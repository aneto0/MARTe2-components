// ============================================================================
//
// NAME:    powerdna.h
//
// DESCRIPTION:
//
//      Autocreated DAQBIOS firmware functions, prototypes and
//      constant definitions.
//
// ----------------------------------------------------------------------------
//
//      Copyright (C) 1997 - 2022 United Electronic Industries, Inc.
//      All rights reserved.
//      United Electronic Industries Confidential Information.
//
//=============================================================================

#ifndef POWERDNA_H
#define POWERDNA_H

#pragma pack(1)

#define DQ_EEMAXSIZE                (2048)      // max EEPROM size
#define EEMAXSIZE                   (2048)      // max EEPROM size
#define DQ_MAXCHAN                  (64)        // max. number of channels in the CL
#define MAXCHAN                     (64)        // max. number of channels in the CL
#define DQ_CHANMASK                 (0x3f)      // mask to mask out channel modifier bits

#define DQ_ONEVOLTINNV              (1000000000)

#define DQ_MAXDEVN                  (0x20)      // 32 devices on the bus maximum
#define DQ_MASKDEVN                 (0x1F)      // device mask to isolate device number
#define DQ_MAXDEVPHYS               (0x10)      // sixteen physical devices on the bus maximum
#define DQ_MAXSS                    (8)         // maximum number of subsystems (four input and four output)
#define DQ_MASKSS                   (0x7)       // subsystem mask to isolate subsystem number
#define DQ_SS0IN                    (0)         // Subsystem 0 input (main and often only device SS)
#define DQ_SS0OUT                   (1)         // Subsystem 0 output (main and often only device SS)
#define DQ_SS1IN                    (2)         // Subsystem 1 input
#define DQ_SS1OUT                   (3)         // Subsystem 1 output
#define DQ_SS2IN                    (4)         // Subsystem 2 input
#define DQ_SS2OUT                   (5)         // Subsystem 2 output
#define DQ_SS3IN                    (6)         // Subsystem 3 input
#define DQ_SS3OUT                   (7)         // Subsystem 3 output

#define DQ_DIR_MASK                 (1)         // 1 == output

// CPU Types
#define DQ_IS_CPU_COLDFIRE(MODEL)   (0x1000==((MODEL)&0xF000))
#define DQ_IS_CPU_MPC5200(MODEL)    (0x2000==((MODEL)&0xF000))
#define DQ_IS_CPU_MPC8347(MODEL)    (0x3000==((MODEL)&0xF000))
#define DQ_IS_CPU_IMX6SX(MODEL)     (0x4000==((MODEL)&0xF000))
#define DQ_IS_CPU_ZYNQ(MODEL)       (0x5000==((MODEL)&0xF000))
#define DQ_IS_CPU_CUBE(MODEL)       ((0x5==((MODEL)&0xFF))||(0x8==((MODEL)&0xFF))||(0x9==((MODEL)&0xFF)))
#define DQ_IS_CPU_RACK(MODEL)       ((0x4==((MODEL)&0xFF))||(0x6==((MODEL)&0xFF))||(0x12==((MODEL)&0xFF)))


#define DQ_ENABLE                   (TRUE)      //
#define DQ_DISABLE                  (FALSE)

#define DQ_LN_DATASZ8               (1L)        // returns/accepts 1 byte
#define DQ_LN_DATASZ16              (2L)        // returns/accepts 2 byte
#define DQ_LN_DATASZ24              (3L)        // returns/accepts 3 byte
#define DQ_LN_DATASZ32              (4L)        // returns/accepts 4 byte

// this is an interface to change default parameters that
// are hard-coded into the firmware. you cannot save these
// parameters between sessions
#define DQ_IOMODE_NAMEDPRM          (0x20)      // set named parameters

#define DQ_IOMODE_MODEMASK          (0x3f)      // modes but not DQ_IOMODE_STORE flag
#define DQ_IOMODE_STORE             (0x80)      // store mode data into EEPROM
#define DQ_IOMODE_GETPRM            (0x40)      // retrieve parameters instead of storing them

#define DQ_IOMODE_INIT              (1L)        // device is being initialized
#define DQ_IOMODE_CFG               (2L)        // device in configuration mode
#define DQ_IOMODE_OPS               (4L)        // device in operation mode
#define DQ_IOMODE_SD                (8L)        // put device in shutdown mode. to exit shutdown, set mode to
                                                // DQ_IOMODE_INIT and then to DQ_IOMODE_CFG
#define DQ_IOMODE_MASK              (0x3fff)    // 14 layers (0xE is PPC)

#define DQ_IOMODE_SLEEP             (0x3)       // sleep mode
#define DQ_IOMODE_PWRDN             (0x9)       // power down device
#define DQ_IOMODE_PWRUP             (0xA)       // switch device power on

#define DQ_IOMODE_EEVER             (0x7)       // pseudo-mode to access EEPROM stucture version and crc
#define DQ_IOMODE_NAMES             (0xB)       // pseudo-mode to access channel names
#define DQ_IOMODE_EECMNDEVS         (0xC)       // pseudo-mode to access manufacturing information
#define DQ_IOMODE_EEFLAGS           (0xD)       // pseudo-mode to access flags
#define DQ_IOMODE_WHEEPROM          (0xE)       // pseudo-mode to whole EEPROM

// Separate defines to get/read parameters
#define DQ_IOM_ACCESS_GETPRM        (DQ_IOMODE_GETPRM)
#define DQ_IOM_ACCESS_MODEMASK      (DQ_IOMODE_MODEMASK)

#define DQ_IOM_ACCESS_INIT          (DQ_IOMODE_INIT)
#define DQ_IOM_ACCESS_CALIBR        (DQ_IOMODE_CFG)
#define DQ_IOM_ACCESS_OPERS         (DQ_IOMODE_OPS)
#define DQ_IOM_ACCESS_SHUTDOWN      (DQ_IOMODE_SD)
#define DQ_IOM_ACCESS_NAMEDPRM      (DQ_IOMODE_NAMEDPRM)
#define DQ_IOM_ACCESS_EEVER         (DQ_IOMODE_EEVER)
#define DQ_IOM_ACCESS_NAMES         (DQ_IOMODE_NAMES)
#define DQ_IOM_ACCESS_EECMNDEVS     (DQ_IOMODE_EECMNDEVS)
#define DQ_IOM_ACCESS_EEFLAGS       (DQ_IOMODE_EEFLAGS)
#define DQ_IOM_ACCESS_ALLEEPROM     (DQ_IOMODE_ALLEEPROM)

// bits set upon change of parameters
#define DQ_IOPRM_INIT               (0x1)
#define DQ_IOPRM_CFG                (0x2)
#define DQ_IOPRM_OPS                (0x4)
#define DQ_IOPRM_SD                 (0x8)
#define DQ_IOPRM_SLEEP              (0x10)      // unused
#define DQ_IOPRM_PWRDN              (0x20)      // unused
#define DQ_IOPRM_PWRUP              (0x40)      // unused
#define DQ_IOPRM_NAMES              (0x80)
#define DQ_IOPRM_EECMNDEVS          (0x800)     // EEPROM common structure
#define DQ_IOPRM_EEFLAGS            (0x2000)    // EEPROM Flags
#define DQ_IOPRM_EEVER              (0x4000)    // EEPROM structure version and crc

// defines to specify which named parameter (NAMEDPRM) is set by call to (*set_prm_io) aka DqCmdSetParameters()
#define DQ_IOPRM_NBUFS              (0x100)     // number of buffers changed
#define DQ_IOPRM_CLPERINT           (0x200)     // controls how often we process interrupts and send packets
#define DQ_IOPRM_RESERVED0          (0x300)     // reserved for future use
#define DQ_IOPRM_ADDLDELAY          (0x400)     // additional delay control
#define DQ_IOPRM_RQID               (0x1000)    // Request id - for streaming RDFIFO
#define DQ_IOPRM_MIDPOS0            (0x1100)    // watermark control for midposion interrupt (logger)

// Watchdog control
#define DQ_WD_CLEAR_DISABLED        (0)
#define DQ_WD_CLEAR_ON_CONSOLE      (1L<<0)
#define DQ_WD_CLEAR_ON_RECEIVE      (1L<<1)
#define DQ_WD_CLEAR_ON_TRANSMIT     (1L<<2)
#define DQ_WD_CLEAR_ON_OSTASK       (1L<<3)
#define DQ_WD_GOTO_SHUTDOWN         (1L<<13)    // go into shutdown mode instead of resetting IOM

// request masks
#define DQ_WD_CLEAR_RESET           (1L<<14)    // reset the countdown counter
#define DQ_WD_CLEAR_STATUS          (1L<<15)    // return the status, do not reset watchdog


// Size of the FIFO - default number of buffer in the ring
#define DQ_FIFO_NBUFS_MIN           (64)        // minimum number of buffers

#define DQ_FIFO_NBUFS               (1024)      // default
#define DQ_FIFO_NBUFS_SLOW          (512)       // standard NBUFS for slow devices
#define DQ_FIFO_NBUFS_MED           (1024)      // standard NBUFS for medium-speed devices
#define DQ_FIFO_NBUFS_FAST          (2048)      // standard NBUFS for fast devices
#define DQ_FIFO_NBUFS_MSG           (1024)      // standard NBUFS for messaging devices

#define DQ_FIFO_REDUCE_SLOW         (64)        // standard buffer reduction for slow devices
#define DQ_FIFO_REDUCE_MED          (128)       // standard buffer reduction for medium-speed devices
#define DQ_FIFO_REDUCE_FAST         (64)        // standard buffer reduction for fast devices
#define DQ_FIFO_REDUCE_MSG          (128)       // standard buffer reduction for messaging devices

#define DQ_FIFO_CLPERINT            (0)         // autoselect

#define DQ_FIFO_BUF_SEC             (5)         // Desirable number of seconds of data in the buffer
#define DQ_FIFO_BUF_MAX             (4096)      // Maximum number of buffers per layer
#define DQ_FIFO_ALLOC_AT_ONCE       (1)         // allocate from the "whole" memory, not a residual part

#define DQ_MAX_ETH_SIZE_100         (1518)      // 100-Base-T
#define DQ_MAX_UDP_SIZE_100         (1472)      // 100-Base-T

#define DQ_MAX_ETH_SIZE             (576)
#define ETH_HDR_SIZE                (14)
#define IP_HDR_SIZE                 (20)
#define UDP_HDR_SIZE                (8)
#define UDP_HDR_OFFSET              (ETH_HDR_SIZE + IP_HDR_SIZE)

#define DQ_MAX_INFO_SIZE            (4096)      // maximum size of getcaps info structure
#define DQ_MAX_INFO_ITEMS           (300)       // maximum number of separate items in the info structure
#define DQ_DQRDCFG_SIZE             (2048)

// FIFO read commands
#define DQ_FIFO_GET_DATA            (0x10)      // default get data ss= DQ_SS0IN
#define DQ_FIFO_GET_DATA1           (DQ_FIFO_GET_DATA | DQ_SS1IN)   // 0x12
#define DQ_FIFO_GET_DATA2           (DQ_FIFO_GET_DATA | DQ_SS2IN)   // 0x14
#define DQ_FIFO_GET_DATA3           (DQ_FIFO_GET_DATA | DQ_SS3IN)   // 0x16
#define DQ_FIFO_GET_CAL             (0x20)
#define DQ_FIFO_GET_CUSTOM          (0x30)

// FIFO write commands
#define DQ_FIFO_SET_DATA            (0x10)
#define DQ_FIFO_PUT_COEFF           (0x20)
#define DQ_FIFO_PUT_CUSTOM          (0x30)


// Reserved Timer IDs (for periodic calls)
#define DQTID_PUSH_DATA             (0x80000001)// push data into output FIFO upon packet arrival

// Note 101 driver uses IOCTLs in range 0x2XNN where X is 0-5 or 7-8
// Refer to drv_101.h to avoid conflict when creating a new IOCTL in that range

// DQCMD_IOCTL commands
#define DQIOCTL_CVTCHNL             (1)         // convert channel
#define DQIOCTL_CVTCHNL_A           (0x1401)    // alternate convert channel
#define DQIOCTL_SETPARAM            (2)         // set arbitrary parameter defined in arg[]
#define DQIOCTL_GETPARAM            (3)         // get arbitrary parameter defined in arg[]
#define DQIOCTL_SETFILTER           (4)         // force filter to set new values
#define DQIOCTL_SIGROUTING          (5)         // set NIS<->IS and SYNCx routing and dio
#define DQIOCTL_GET_IN_CL           (0x1501)    // gets last read channel list ( for PDNA Explorer use)
#define DQIOCTL_EXT_DEVICE          (0x2601)    // control external device attached to layer dio

// DQCMD_IOCTL return codes (from mod_ioctl)
#define DQIOCTL_RTCD_MASK           (0xffff0000)// mask for extra information to return in DQIOCTL.cmd
#define DQIOCTL_RTCD_CMDMASK        (0xffff)    // mask for command
#define DQIOCTL_RTCD_NOTREADY       (0x80000000)// layer not ready

// common DQIOCTL_SETPARAM subcommands
#define DQ_SETPARAM_SETPLL          (0x80)      // set on-layer pll parameters
#define DQ_SETPARAM_SET_SW_TIMEOUT  (0x200)     // set sync switching timeout
#define DQ_SETPARAM_SET_GROUP_DELAY (0x201)     // set group delay compensation
#define DQ_SETPARAM_SET_SCAN_SKIP   (0x202)     // set the number of scans to skip at the beginning
#define DQ_SETPARAM_POWERUP_INIT    (0x203)     // used instead of iomode_init for CPU layers
#define DQ_ADV_GRP_DELAY_SET        (0x11)      // associated high level action parameter for DqAdvGroupDelay()

// common DQIOCTL_GETPARAM subcommands
#define DQ_GETPARAM_TRIG_TS         (0x81)      // get timestamp of last trigger
#define DQ_GETPARAM_GET_GROUP_DELAY (0x201)     // get group delay compensation
#define DQ_GETPARAM_GET_SCAN_SKIP   (0x202)     // get the number of scans to skip at the beginning
#define DQ_ADV_GRP_DELAY_GET        (0x10)      // associated high level action parameter for DqAdvGroupDelay()

// DQCMD_IOCTL commands for data logger
#define DQIOCTL_DLTRIGGER           (0x11)      // issue master start/stop trigger
#define DQIOCTL_DLCFG               (0x12)      // tell the cube that configuration has changed
#define DQIOCTL_SD_CTRL             (0x13)      // SD-card control routines
#define DQIOCTL_PROGRESS            (0x14)      // get progress
#define DQIOCTL_GET_DATA            (0x15)      // get data
#define DQIOCTL_DL_CTRL             (0x16)      // reset the cube or cancel ongoing opeations

#define DQIOCTL_DL_GETMAXRATE       (0x17)      // return maximum rate to write to the card
#define DQIOCTL_DL_TESTMAXRATE      (0x18)      // perform max rate test
#define DQIOCTL_DL_GETBUFFERSIZE    (0x19)      // report size of write buffer to logger app

#define DQIOCTL_DLOGGER             (0x10)      // mask
#define DQIOCTL_DLOGGER_DIO_BIT_0   (0x1200)    // dio control for alarms
#define DQIOCTL_DLOGGER_DIO_BIT_1   (0x1201)    // dio control for alarms
#define DQIOCTL_DLOGGER_DATA_SZ     (0x1202)    // give logger control of sample size (218)

#define DQIOCTL_DIO_READ_LAST_WRITE (0x1300)    // dio output state readback for PowerDNA Explorer
#define DQIOCTL_RLW_DIO_GET1        (0x1)       // used by DQIOCTL_DIO_READ_LAST_WRITE
#define DQIOCTL_RLW_DIO_GET2        (0x2)       // used by DQIOCTL_DIO_READ_LAST_WRITE

#define DQIOCTL_DIO_RD_W_TIMESTAMP  (0x1301)    // read dio with timestamp

// flags for DQIOCTL_DIO_RD_W_TIMESTAMP    ( DqAdv40xReadTs )
#define DQIOCTL_DIO_RST_TIMESTAMP   (1L<<31)    // reset timstamp before


// DQCMD_IOCTL commands for hardware tests
#define DQIOCTL_HW_CPUTEST          (0x40)      // CPU layer tests mask
#define DQIOCTL_HW_CPUTEST_START    (0x41)      // start CPU layer test
#define DQIOCTL_HW_CPUTEST_ABORT    (0x42)      // abort CPU layer test
#define DQIOCTL_HW_CPUTEST_GET_STATUS (0x43)    // get   CPU layer test status
#define DQIOCTL_HW_CPUTEST_GET_RESULT (0x44)    // get   CPU layer test result
#define DQIOCTL_HW_NWTEST           (0x45)      // perform desired network performance test
#define DQIOCTL_HW_IOMTEST          (0x80)      // I/O layer tests mask

// DQCMD_IOCTL command for logic updating
#define DQIOCTL_MAX10_LOGIC         (0x100)      // send logic data to MAX 10 FPGA
#define DQIOCTL_LOGIC_UPDATE        (0x101)
#define DQIOCTL_LOGIC_RESEND        (0x102)

// DQCMD_IOCTL commands for Uboot environment variables
#define DQIOCTL_UBOOT               (0x20)      // UBOOT environment mask
#define DQIOCTL_UBOOT_GETENV        (0x21)      // retrieve environment variable
#define DQIOCTL_UBOOT_SETENV        (0x22)      // modify or add environment variable
#define DQIOCTL_UBOOT_SAVEENV       (0x23)      // save all environment variables to flash

// Type of I/O layer hardware tests. Following commands correspond to DQIOCTL_HW_IOMTEST
#define HW_IOMTEST_BUS              (0x1)       // I/O layer bus test

// Standard part (lower 16 bits) of layer status word
#define DQ_LN_INTSRC                (1<<0)      // layer is a source of interrupts

// DQCMD_SETPASS modes of operation
#define DQ_SETPASS_SUPASS           (1L << 0)   // Confirm SU password
#define DQ_SETPASS_USRPASS          (1L << 1)   // Confirm user password
#define DQ_SETPASS_SETSU            (1L << 2)   // Set SU password
#define DQ_SETPASS_SETUSR           (1L << 3)   // Set user password
#define DQ_SETPASS_CLEAR            (1L << 4)   // Clear passwords for current session

#define DQ_SETPASS_EN_DQCMD0        (1L << 5)   // Open access to the protected commands on NIC1
#define DQ_SETPASS_EN_DQCMD1        (1L << 6)   // Open access to the protected commands on NIC2

// DQCMD_SETLOCK modes of operation
#define DQSETLOCK_LOCK              (0)         // Lock IOM to host
#define DQSETLOCK_UNLOCK            (1)         // Unlock IOM
#define DQSETLOCK_CHECK             (2)         // Get locking host IP
#define DQSETLOCK_CHECKDIAG         (3)         // Check whether the layer is in diagnostics mode
#define DQSETLOCK_DIAG              (4)         // Switch into diagnostics mode

// Standard part (lower 16 bits) of layer configuration word
// Please notice that for multiple-subsystem layers one should pass
// multiple configuration uint32s in config_io()
//
#define DQ_LN_NO_TIMESTAMP_RESET    (1L<<21)    // disable timestamp reset to all layers
#define DQ_LN_VMAPPED               (1L<<20)    // Use in VMap mode
#define DQ_LN_BURST                 (1L<<19)    // For RDFIFO devices, burst
#define DQ_LN_RAW32                 (1L<<18)    // 32-bit raw values
#define DQ_LN_ALT_RES               (1L<<18)    // use alternate resolution for improved speed or resolution

#define DQ_FIFO_MODESCAN            (0L<<16)    // single scan update mode
#define DQ_FIFO_MODEFIFO            (2L<<16)    // continuous acquisition with FIFO
#define DQ_FIFO_MODECONT            (3L<<16)    // continuous

#define DQ_LN_MAPPED                (1L<<15)    // For WRRD (DQDMAP) devices
#define DQ_LN_STREAMING             (1L<<14)    // For RDFIFO devices - stream the FIFO data automatically
                                                // For WRFIFO - do NOT send reply to WRFIFO unless needed
#define DQ_LN_RECYCLE               (1L<<13)    // if there is no data taken/available overwrite/reuse data
#define DQ_LN_GETRAW                (1L<<12)    // force layer to return raw unconverted data
#define DQ_LN_TMREN                 (1L<<11)    // enable layer periodic timer
#define DQ_LN_IRQEN                 (1L<<10)    // enable layer irqs
#define DQ_LN_PTRIGEDGE1            (1L<<9)     // stop trigger edge MSB
#define DQ_LN_PTRIGEDGE0            (1L<<8)     // stop trigger edge:  0 - software, 01 - external

// DQ_LN_STRIGEDGE0 selects between software triggering and external triggering.
// When DQ_LN_STRIGEDGE0 is selected (external trigger), then DQ_LN_STRIGEDGE1 selects the edge of the external trigger
// Rising edge trigger is selected when DQ_LN_STRIGEDGE1 is present.
#define DQ_LN_STRIGEDGE1            (1L<<7)     // start trigger edge: MSB
#define DQ_LN_STRIGEDGE0            (1L<<6)     // start trigger edge: 0 - software, 01 - external
#define DQ_LN_CVCKSRC1              (1L<<5)     // CV clock source MSB
#define DQ_LN_CVCKSRC0              (1L<<4)     // CV clock source 0 - SW, 01 - internal, 10 - external
#define DQ_LN_CLCKSRC1              (1L<<3)     // CL clock source MSB
#define DQ_LN_CLCKSRC0              (1L<<2)     // CL clock source 0 - SW, 01 - internal, 10 - external
#define DQ_LN_ACTIVE                (1L<<1)     // "ACT" LED status
#define DQ_LN_ENABLED               (1L<<0)     // enable operations

#define SS_DIR_MASK                 (0x1)
#define DQ_DIR_INPUT                (0)
#define DQ_DIR_OUTPUT               (1)

// DMap flags
#define DQ_DMAP_RESET_TRL           (1L<<31)    // reset transfer list
#define DQ_DMAP_CHECK_LOCK          (1L<<30)    // check whether this DmapID exists and mark it as locked upon clearing
                                                // an attempt of another process to check and lock this dmapid will return an error
#define DQ_VMAP_FIFO_STATUS         (1L<<0)     // return "remainder" from the FIFO after read/write is completed
#define DQ_VMAP_SPEC_CHANNEL        (1L<<1)     // VMap channels are not defined until the data is placed in the buffer
#define DQ_VMAP_FIFO_RQSIZE         (1L<<2)     // return "remainder" from the FIFO even if a zero size requested for input or output
#define DQ_VMAP_FIFO_CLR_ON_OVF     (1L<<3)     // clear device FIFO on overflow

// Dedicated DMap IDs
#define DQ_DMAP_LASTID_IN           (0x0FF0L)
#define DQ_DMAP_LASTID_OUT          (0x0FF1L)

#define DQ_DMAP_IDMASK              (0xfff)     // DMap/VMap ID
#define DQ_DMAP_MODEMASK            (0xf000)    // Mode selection

#define DQ_DMAP_DMAP                (0x0000)    // DMap mode: mod
#define DQ_DMAP_VMAP                (0x1000)    // VMap mode
#define DQ_DMAP_STICKY_MAP          (0x2000)    // DMap/VMap is sticky and should not be removed
#define DQ_DMAP_SYNC_DMAP_CONV      (0x4000)    // DMap/VMap is sticky and should not be removed

// VMap FIFO modes:
// Input channel list overflow recovery - added to the logics 01021428+.
// Channel list overflow is a critical event that accomplished by the data loss
// However some applications can allow temporary data loss and can re-synchronize data stream based on the timestamps.
// If the following flag is set overflow in the logics 01021428+:
// when channel list overflow is detected internal state machine will stop placing data into the FIFO, but will still
// process all commands in the channel list script.
// When firmware detect this situation it:
// 1. Returns DQ_VMAP_FIFO_RESTARTED_SZ as the result of operation
// 2. Clears content of the channel list by resetting it
// 3. Input channel list state machine will resume writes to the FIFO upon receiving next channel list clock after
// FIFO becomes empty
#define DQ_VMAP_CLEAR_FIFO_RESTART  (1L<<0)     // In VMap mode clear FIFO and then restart operations

#define DQ_VMAP_FIFO_RESTARTED_SZ   0xffff0000  // When FIFO overflowed available - lots, read zero


// Channel list entries definition - lower 16 bits are reserved for channel number
// gain and special, module-specific settings
#define DQ_LNCL_LAST                (0)         // last entry in the channel list
#define DQ_LNCL_NEXT                (1UL<<31)   // channel list has next entry
#define DQ_LNCL_INOUT               (1UL<<30)   // (reserved for future use)
#define DQ_LNCL_SS1                 (1UL<<29)   // (reserved for future use)
#define DQ_LNCL_SS0                 (1UL<<28)   // (reserved for future use)
#define DQ_LNCL_IRQ                 (1UL<<27)   // (reserved for future use)
#define DQ_LNCL_NOWAIT              (1UL<<26)   // (reserved for future use)
#define DQ_LNCL_SKIP                (1UL<<25)   // (reserved for future use)
#define DQ_LNCL_CLK                 (1UL<<24)   // Software clock channel list (for DMap instead of internal clock source)
#define DQ_LNCL_CTR                 (1UL<<23)   // (reserved for future use)
#define DQ_LNCL_WRITE               (1UL<<22)   // write to the channel but not update
#define DQ_LNCL_UPDALL              (1UL<<21)   // update all written channels
#define DQ_LNCL_TSRQ                (1UL<<20)   // timestamp requested
#define DQ_LNCL_SLOW                (1UL<<19)   // slow down operation
#define DQ_LNCL_DIO                 (1UL<<18)   // write/read DIO
#define DQ_LNCL_RSVD1               (1UL<<17)   // (reserved for future use)
#define DQ_LNCL_RSVD0               (1UL<<16)   // (reserved for future use)

#define DQ_LNCL_DIFF                (1UL<<15)   // differential mode
#define DQ_LNCL_GAIN(G)             (((G) & 0xf)<<8) // set gain     4 bits
#define DQ_LNCL_CHANGAIN(C,G)       ((C)|DQ_LNCL_GAIN(G))
#define DQ_LNCL_RANGE(G)            (((G) & 0x3f)<<8) // set range   6 bits
#define DQ_LNCL_CHANRANGE(C,G)      ((C)|DQ_LNCL_RANGE(G))
#define DQ_LNCL_TIMESTAMP           (0xff)      // timestamp entry (when used as a channel #)
#define DQ_LNCL_CHANMASK            (0xff)      // isolate channel #
                                                // could be confused with DQ_CHANMASK (0x3f)

#define DQ_LNCL_READSTATUS          (0xfe)      // read status entry (when used as a channel #) AO-308, 388
#define DQ_LNCL_EXPLSTATUS          (0xfd)      // read pdnaexplorer status (when used as a channel #) AO-308, 388

#define DQ_LNCL_GETRANGE(E)         (((E) & 0x3f00)>>8) // pull out range , 6 bits  (extended gain)
#define DQ_LNCL_GETGAIN(E)          (((E) & 0xf00 )>>8) // pull out gain  , 4 bits
                                                // please note that some models have their own model specific 'GETGAIN' macro.
                                                // ex. DQ_AI212_GETGAIN, DQ_AI248_GETGAIN

#define DQ_LNCL_GETCHAN(E)          ((E) & DQ_LNCL_CHANMASK)// pull out 8-bit channel number.
                                                // please note that some models have their own model specific 'GETCHAN' macro.
                                                // ex. DQ_AI212_GETCHAN, DQ_AI224_GETCHAN

#define DQ_EXTRACT_SS(flags)        (((flags) & (DQ_LNCL_SS1 | DQ_LNCL_SS0)) >> 28)
#define DQ_EXTRACT_DIR(flags)       (((flags) & DQ_LNCL_INOUT) >> 30)
#define DQ_SS_DIR(ss, dir)          (((ss) << 1) | (dir))


// Clock identificators for set_clock_io()
#define DQ_LN_CLKID_DUTY1           (1L<<7)     // Duty cycle of TMR1 (0 is a single pulse)
#define DQ_LN_CLKID_DUTY0           (1L<<6)     // Duty cycle of TMR0 (0 is a single pulse)
#define DQ_LN_CLKID_TMR1            (1L<<5)     // TMR1 (burst clock)
#define DQ_LN_CLKID_TMR0            (1L<<4)     // TMR0 (conversion base clock)
#define DQ_LN_CLKID_CVIN            (1L<<3)     // CV Input SS clock
#define DQ_LN_CLKID_CVOUT           (1L<<2)     // CV Output SS clock
#define DQ_LN_CLKID_CLIN            (1L<<1)     // CL Input SS clock
#define DQ_LN_CLKID_CLOUT           (1L<<0)     // CL Output SS clock

// What to calibrate
#define DQ_LN_CALGAIN               (1L<<1)     // calibrate gain
#define DQ_LN_CALOFFS               (1L<<2)     // calibrate offset


// Timestamps (66MHz divider)
// resolution parameter for DqCmdResetTimestamp() function
#define DQ_LN_01us_TIMESTAMP        (6-1)       // 0.090909us
#define DQ_LN_1us_TIMESTAMP         (66-1)      // 1us
#define DQ_LN_10us_TIMESTAMP        (660-1)     // 10us - default value for most AI layers
#define DQ_LN_100us_TIMESTAMP       (6600-1)    // 100us
#define DQ_LN_1ms_TIMESTAMP         (66000-1)   // 1ms
#define DQ_LN_10ms_TIMESTAMP        (660000-1)  // 10ms
#define DQ_LN_100ms_TIMESTAMP       (6600000-1) // 100ms
#define DQ_LN_1s_TIMESTAMP          (66000000-1)// 1s

#define DQ_LN_MASK_TIMESTAMP        (0x7ffffff) // the timestamp resolution cannot be larger than 2 seconds

// following bits are defined for all FPGA-based layers
// LCR (0x0) control register
#define DQ_FPGAC_PRGEN              (1L<<15)    // enable FPGA image programming
#define DQ_FPGAC_NCFG               (1L<<14)    // value of nConfig pin
#define DQ_FPGAC_MSEL1              (1L<<13)    // Boot mode
#define DQ_FPGAC_MSEL0              (1L<<12)    //
#define DQ_FPGAC_DOE1               (1L<<11)    // dev_oe pin (00=Z, 10=0, 11=1)
#define DQ_FPGAC_DOE0               (1L<<10)    //
#define DQ_FPGAC_DCLR1              (1L<< 9)    // dev_clr pin (00=Z, 10=0, 11=1)
#define DQ_FPGAC_DCLR0              (1L<< 8)    //
#define DQ_FPGAC_ED                 (1L<< 7)    // select master device (1=Mach)
#define DQ_FPGAC_ASPGEN             (1L<< 6)    // enable programming of EPCS device
#define DQ_FPGAC_ASDO               (1L<< 5)    // value of ASDO pin
#define DQ_FPGAC_NCEO               (1L<< 4)    // value of NCEO pin
#define DQ_FPGAC_NCSO               (1L<< 3)    // value of NCSO pin
#define DQ_FPGAC_RESERVED2          (1L<< 2)    //
#define DQ_FPGAC_RESERVED1          (1L<< 1)    //
#define DQ_FPGAC_RESERVED0          (1L<< 0)    //

// LSR (0x0) status register
#define DQ_FPGAS_RDY                (1L<<12)    // Receiver ready status bit
#define DQ_FPGAS_NCFG               (1L<<11)    // current state of nConfig pin
#define DQ_FPGAS_NSTAT              (1L<<10)    // current state of nStatus pin
#define DQ_FPGAS_CONFDONE           (1L<< 9)    // current state of ConfDone pin
#define DQ_FPGAS_DCLK               (1L<< 8)    // current state of dclk pin
#define DQ_FPGAS_DATA0              (1L<< 7)    // current state of data0 pin
#define DQ_FPGAS_MSEL1              (1L<< 6)    // current state of msel1 pin
#define DQ_FPGAS_MSEL0              (1L<< 5)    // current state of msel0 pin
#define DQ_FPGAS_ASDO               (1L<< 4)    // current state of asdo pin
#define DQ_FPGAS_NCEO               (1L<< 3)    // current state of nCEO pin
#define DQ_FPGAS_NCSO               (1L<< 2)    // current state of nCSO pin
#define DQ_FPGAS_DOE                (1L<< 1)    // current state of dev_oe pin
#define DQ_FPGAS_DCLR               (1L<< 0)    // current state of dev_clr pin

// Definitions for triggering and synchronization interface (DqCmdSetTrigger - mode)
#define DQ_TRIGGER_SET_OR           (1L<< 5)    // set alternative condition (OR trigger)
#define DQ_TRIGGER_SET              (1L<< 4)    // set trigger (or add additional AND condition)
#define DQ_TRIGGER_ONCE             (1L<< 3)    // trigger only once
#define DQ_TRIGGER_TS_CL            (0x7)       // synchronize trigger timestamp to first CL clock data
#define DQ_TRIGGER_TS_CV            (0x6)       // synchronize trigger timestamp to first CV clock data
#define DQ_TRIGGER_TS_NO            (0x5)       // normal operation, no timestamp sync
#define DQ_TRIGGER_RESET            (1L<< 2)    // reset trigger to default
#define DQ_TRIGGER_STOP             (1L<< 1)    // issue stop trigger
#define DQ_TRIGGER_START            (1L<< 0)    // issue start trigger

// Sources for CL and CV clock ( used with DQ_LN_CLKID_... constants
// with DqAdvSetClockSource() parameter'uint32 source' )
#define DQ_EXT_CLKIN                (0x30)      // selected DIO line
#define DQ_EXT_TRIGIN               (0x31)      // external trigger
#define DQ_EXT_BURST                (0x32)      // burst source - TMR1
#define DQ_EXT_CLOCK                (0x33)      // main clock - TMR0
#define DQ_EXT_TMR0                 (DQ_EXT_CLOCK)     // readable alias for main clock - TMR0
#define DQ_EXT_EXT0                 (0x34)      // ISO_EXT0 line
#define DQ_EXT_EXT1                 (0x35)      // ISO_EXT1 line
#define DQ_EXT_CLKIN_J3_10          (DQ_EXT_EXT0) // clock in connection on 1GB Power layer
#define DQ_EXT_TRIGIN_J3_6          (DQ_EXT_EXT1) // trigger in connection on 1GB Power layer
#define DQ_EXT_INTER0               (0x36)      // internal source (edge for 40x)

// SYNCx interface lines
#define DQ_EXT_SYNC0                (0x10)      // SYNC0 line
#define DQ_EXT_SYNC1                (0x11)      // SYNC1 line
#define DQ_EXT_SYNC2                (0x12)      // SYNC2 line
#define DQ_EXT_SYNC3                (0x13)      // SYNC3 line

#define DQ_EXT_RELEASE              (0)         // DAQLib command to release the DqAdvRoute... sync connections

#define DQ_EXT_IMMEDIATE            (0x80)      // additional flag bit to force PLL connection to happen immediately

// Signals external DIO can be mapped into
// as well SYNCx line can be mapped
// only one of the lines can be selected as DIO or SYNCx source
// SGNLS.diosrc or SGNLS.isosrc
#define DQ_EXT_GLOBAL_TRIG          (0x20)      // global trigger event
#define DQ_EXT_STOP_TRIG            (0x21)      // stop trigger event
#define DQ_EXT_CLIN                 (0x22)      // CL clock in
#define DQ_EXT_CLOUT                (0x23)      // CL clock out
#define DQ_EXT_CVIN                 (0x24)      // CV clock in
#define DQ_EXT_CVOUT                (0x25)      // CV clock out
#define DQ_EXT_GPIO_LOGIC0          (0x26)      // Set external line to 0
#define DQ_EXT_GPIO_LOGIC1          (0x27)      // Set external line to 1
#define DQ_EXT_INT0                 (0x28)      // Feed DIO In into interrupt 0
#define DQ_EXT_INT1                 (0x29)      // Feed DIO In into interrupt 1
#define DQ_EXT_CLKOUT_J3_8          (DQ_EXT_INT0)   // clock out connection on 1GB Power layer
#define DQ_EXT_TRIGOUT_J3_4         (DQ_EXT_INT1)   // trigger out connection on 1GB Power layer
#define DQ_EXT_DIO0                 (0x2A)      // DIO0 is input or output of SYNCx
#define DQ_EXT_DIO1                 (0x2B)      // DIO1 is input or output of SYNCx
#define DQ_EXT_ADCCVT               (0x2C)      // conversion clock
#define DQ_EXT_TSTD                 (0x2D)      // timestamp generator
#define DQ_EXT_PUSH_BUTTON          (0x2E)      // push button on 1GB Power layer
#define DQ_INTERNAL_ISO_INT         (0x2E)      // connection from internal iso_int
#define DQ_EXT_ADCBS                (0x2F)      // conversion clock busy
// Edges
#define DQ_EDGE_RISING              (0)         // rising edge
#define DQ_EDGE_FALLING             (1)         // falling edge

// DIO directions for SGNLS.diodir
#define DQ_EXT_DIO_DEFAULT          (0x0)       // select default DIO behavior
#define DQ_EXT_DIO_INPUT            (0x1)       // select DIO as an input
#define DQ_EXT_DIO_OUTPUT           (0x2)       // select DIO as an output
#define DQ_EXT_DIO_INVERTED         (0x10)      // I/O signal is inverted

// maximum number of SYNCx and DIOx lines
#define DQ_LN_MAX_SYNCX             (4)         // maximum number of SYNCx lines
#define DQ_LN_MAX_DIOX              (4)         // maximum number of DIOx lines
#define DQ_LN_MAX_CLOCKS            (4)         // clocks (CV and CL, in and out)
#define DQ_LN_MAX_TRIGS             (4)         // triggers (start and stop, in and out)

// The following structure is used to inform FW about external clock
// selection choices
typedef struct _SIGS {
    uint8 clocksrc[DQ_LN_MAX_CLOCKS];           // source of external clock
    uint8 clockedge[DQ_LN_MAX_CLOCKS];          // source of external clock
    uint8 trigsrc[DQ_LN_MAX_TRIGS];             // source of external trigger
    uint8 trigedge[DQ_LN_MAX_TRIGS];            // source of external trigger
    uint8 diosrc[DQ_LN_MAX_DIOX];               // source for DIO lines
    uint8 diodir[DQ_LN_MAX_DIOX];               // direction of DIO lines
    uint8 isosrc[DQ_LN_MAX_SYNCX];              // isosrc[0] and [1] source of ISO_INT[0] and [1]
    uint8 syncxsrc[DQ_LN_MAX_SYNCX];            // source for synclines
    uint32 cmd;                                 // command word, use dio subset
} SGNLS, *pSGNLS;

// data for SGNLS.cmd
// commands for use by set_signal_routing_nnn() ioctl
#define DQ_EXT_SIG_CMD_DEF          (0)         // default SGNLS behavior
#define DQ_EXT_SIG_CMD_DIO_RW       (1)         // set dio state, read dio
#define DQ_EXT_SIG_CMD_DIO_R        (2)         // read dio only
#define DQ_EXT_SIG_CMD_SET_SYS      (0x20)      // set the signals connections on the cpu and sync layers

//   defines for DqAdvLayerAccessDio
#define DQ_ACCESS_DIO_DIO0_ENB      (0x1)
#define DQ_ACCESS_DIO_DIO1_ENB      (0x2)
#define DQ_ACCESS_DIO_DIO2_ENB      (0x4)
#define DQ_ACCESS_DIO_DIO3_ENB      (0x8)
#define DQ_ACCESS_DIO_DIO0_OUT      (0x10)
#define DQ_ACCESS_DIO_DIO0_IN       (0)
#define DQ_ACCESS_DIO_DIO1_OUT      (0x20)
#define DQ_ACCESS_DIO_DIO1_IN       (0)
#define DQ_ACCESS_DIO_DIO2_OUT      (0x40)
#define DQ_ACCESS_DIO_DIO2_IN       (0)
#define DQ_ACCESS_DIO_DIO3_OUT      (0x80)
#define DQ_ACCESS_DIO_DIO3_IN       (0)

// offsets for clocksrc, clockedge vars
#define DQ_EXT_CLIN_OFS             (0)
#define DQ_EXT_CLOUT_OFS            (1)
#define DQ_EXT_CVIN_OFS             (2)
#define DQ_EXT_CVOUT_OFS            (3)
#define DQ_EXT_BOTH_CV_CL_FLAG      (0x10)      // flag to put clocksrc, clockedge into both DQ_EXT_CLIN_OFS and DQ_EXT_CVIN_OFS

#define DQ_EXT_START_TRIG_OFS       (0)
#define DQ_EXT_STOP_TRIG_OFS        (1)

#define DQ_EXT_SYNC0_OFS            (0)
#define DQ_EXT_SYNC1_OFS            (1)
#define DQ_EXT_SYNC2_OFS            (2)
#define DQ_EXT_SYNC3_OFS            (3)

// External DIO lines
#define DQ_EXT_DIO0_OFFS            (0)
#define DQ_EXT_DIO1_OFFS            (1)
#define DQ_EXT_DIO2_OFFS            (2)
#define DQ_EXT_DIO3_OFFS            (3)


// Simplified signal routing structure
//
typedef struct _SYNCPAL {
    // PLL
    float   pll_frq;                // actual
    uint16  pll_Pt;                 // P-value
    uint16  pll_Qt;                 // Q-value
    uint32  pll_Div;                // PLL divider
    uint32  log_Div;                // after-divider in FPGA
} SYNCPLL, *pSYNCPLL;

typedef struct _SYNCRT {
    // Sync lines interconnect
    //5200:
    // Device 0xE is a CPU layer; it has 1 Sync-In, 1 Sync-Out and PLL
    //8347:
    // Device 0xE is a CPU layer; it has PLL
    // Device 0xD is 1gb power layer, it has 2 Sync-In, 2 Sync-Out
    //8347 MIL:
    // Device 0xE is a CPU layer; it has PLL and 2 Sync-In, 2 Sync-Out
    // Device 0xD is backplane, it has 2 Sync-In, 2 Sync-Out
    // All other layers may have up to DQ_LN_MAX_CLOCKS input and output clocks
    // 0 means non-connected, 1 - connected, 2 - external used
    uint8   sync_x[DQ_LN_MAX_CLOCKS][DQ_LN_MAX_SYNCX];   // input interconnect
} SYNCRT, *pSYNCRT;

// CPU layer devn
#define DQ_PWR_DEVN                 (0xC)       // DNR-POWER-DC where DC/DC are located
#define DQ_SYNC_DEVN                (0xD)       // DNx-POWER-1G where SYNC is located
#define DQ_CPU_DEVN                 (0xE)       // device number to access CPU layer logic
#define DQ_BROADCAST_DEVN           (0xF)       // device number to access broadcast

// connection definition  -  contents of sync_x
#define DQ_SYNC_NOT_CONN            (0)         // line is not connected
#define DQ_SYNC_INPUT               (1)         // line is connected as an input, sync bus drives layer or connector
#define DQ_SYNC_DRIVER              (2)         // line is connected as an output, layer drives SYNCx line
#define DQ_SYNC_EXTERNAL            (4)         // lines is not connected and signal is taken from the external line instead

// connection definition  -  add'l contents of sync_x for Gig-e sync layer only
#define DQ_SYNC_0                   (8)         // drive sync with a 0
#define DQ_SYNC_1                   (16)        // drive sync with a 1
#define DQ_SYNC_BUTTON              (32)        // drive sync with button

// layers line designation,        e.g. sync_x[DQ_SYNC_CLOCK][DQ_EXT_SYNC0_OFS]
#define DQ_SYNC_CLOCK               (0)         // Clock-In and Clock-Out (Layers)
#define DQ_SYNC_TRIGGER             (1)         // Trigger-In and Trigger-Out (Layers)

// cpu and sync line designation   e.g. sync_x[DQ_SYNC_PPC][DQ_EXT_SYNC0_OFS]
#define DQ_SYNC_PPC                 (0)         // (PPC)  Sync-In and Sync-Out (iso_int0 and iso_ext0) uses DQ_CPU_DEVN
                                                // (8347) sync connector Clock-In and Clock-Out (iso_int0 and iso_ext0) uses DQ_SYNC_DEVN
#define DQ_SYNC_PLL                 (1)         // (PPC + 8347) PLL-Out  iso_ext1  uses  DQ_CPU_DEVN
#define DQ_SYNC_PPC2                (2)         // (8347) sync connector Trigger-In and Trigger-Out (iso_int1 and iso_ext1) uses DQ_SYNC_DEVN
#define DQ_SYNC_PLL_IMMEDIATE       (3)         // (PPC + 8347) PLL-Out  iso_ext1  uses  DQ_CPU_DEVN programs pll without waiting

// CY22150 used
#define CY22150_MINP                (8)
#define CY22150_MINQ                (5)
#define CY22150_MAXP                (800)
#define CY22150_MAXQ                (129)
#define CY22150_MIN_VCO             (100000000.0)
#define CY22150_MAX_VCO             (365000000.0)  // theoretical limit 400000000, lower limit helps reliability
#define CY22150_BASE                (66000000)

// Cyclone III PLL constants
#define DQ_C3PLL_MIN_N              (2)         // n = q
#define DQ_C3PLL_MAX_N              (510)
#define DQ_C3PLL_MIN_M              (2)         // m = p
#define DQ_C3PLL_MAX_M              (510)
#define DQ_C3PLL_MIN_VCO            (600000000.0)
#define DQ_C3PLL_MAX_VCO            (1300000000.0)
#define DQ_C3PLL_MAX_VCO_60X        (1220000000.0) // theoretical limit 1300000000, lower limit for 60x base
#define DQ_C3PLL_BASE               (66000000)

// Debug flags - common for layers
#define DEBUG_INFO_ISR_OVERRUN      (1L<<0)     // ISR overrun

#define DQL_SYNC_LINES      (4)     // four SYNCx lines available
//----------------------------------------------------------------------------
// TMR0/TMR1 configuration register DQL_CLI_TMRCFG (0x00B0 RD/WR)
// Counter description:
// NOTE : all configuration values are registered are stored inside "simple timer"
// Simple counter is a count-up counter which is running from the "clock" source
// If enabled (EN=1 in configuration word), it increases by 1 every clock if
// "enable" input = 1. If enable input is synchronized with clock, it may be used
// to clock the timer.
// Internal registers:
// st_cnt - counter register
// st_cmp - compare register, used only in in PWM mode, counter output = 0 when it
//          <= st_cmp register
// st_div - divider register, maximum value of the count-up counting. When counter
//           reaches this number, it reset itself to 0
// st_cfg - configuration register, see bit description below

//  +---------------+---------------+---------------+-------+-------+
//  | TSTAMP CLK SRC| TMR 1 CLK SRC | TMR 0 CLK SRC |TSTTRM | TRRDIS|
//  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//  | 31| 30| 29| 28| 27| 26| 25| 24| 23| 22| 21| 20| 19| 18| 17| 16|
//  |   TS3 - TS0   |   1S3 - 1S0   |   0S3 - 0S0   | M1  M0| T1  T0|
//  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//
//  +-------+-----------------------+---------------+---------------+
//  |TSTRST | TRCLK |   unused      |     TMR 1     |     TMR 0     |
//  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//  | 15| 14| 13| 12| 11| 10| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
//  | M1  M0|TR1 TR0|               |EN |INV|  MODE |EN |INV|  MODE |
//  +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
//
//  MODE - select simple timer counting/output mode :
//         00 - pulse output (single-clock pulse at the end of counting)
//         01 - PWM output (output=0 st_cnt<=st_cmp)
//         1x - reserved
//  INV  - If=1, invert "clock_out" output
//  EN   - If=1, enable counter operation

// NOTE: starting from logic rev. 0x010210D6 timestamp source selector is added
// to the CLI_TMRCFG
#define DQL_TMRCFG_TSTS3            (1L<<31)
#define DQL_TMRCFG_TSTS0            (1L<<28)
#define DQL_TMRCFG_TSTS(N)          ((N)<<28)   // N= one of the DQL_TMRCFG_TSTS_XXXX constants


// NOTE: starting from logic rev. 0x0102111B timer clock source selector is added
// to the CLI_TMRCFG. A timer may not clock itself!
#define DQL_TMRCFG_TMR1S3           (1L<<27)
#define DQL_TMRCFG_TMR1S0           (1L<<24)
#define DQL_TMRCFG_TMR1S(N)         (((N)& 0xf)<<24)   // N= any of the DQL_TMRCFG_TSTS_xxxx constants except 'TMR1
#define DQL_TMRCFG_TMR0S3           (1L<<23)
#define DQL_TMRCFG_TMR0S0           (1L<<20)
#define DQL_TMRCFG_TMR0S(N)         (((N)& 0xf)<<20)   // N= any of the DQL_TMRCFG_TSTS_xxxx constants except 'TMR0

// NOTE: starting from logic rev. 0x0102111A timestamp register loaded by trigger
#define DQL_TMRCFG_TSTTRM1          (1L<<19)    // Select trigger capture mode for the timestamp counter.
#define DQL_TMRCFG_TSTTRM0          (1L<<18)    // 00 - no capture, 01 - CLI CV, 10 - CLI CL
#define DQL_TMRCFG_TSTTRM(N)        ((N)<<18)
#define DQL_TMRCFG_TSTTRM_NO        (0x0)       // for high-level API define see DQ_TRIGGER_TS_NO
#define DQL_TMRCFG_TSTTRM_CLICV     (0x1)       // for high-level API define see DQ_TRIGGER_TS_CV
#define DQL_TMRCFG_TSTTRM_CLICL     (0x2)       // for high-level API define see DQ_TRIGGER_TS_CL
// NOTE: starting from logic rev. 0x010211C0 disable reset of timer by start trigger
#define DQL_TMRCFG_TRRDIS1          (1L<<17)    // Control to disable the Timer reset by start trigger
#define DQL_TMRCFG_TRRDIS0          (1L<<16)    // 00 - no reset, 01 - do not reset TMR0,
#define DQL_TMRCFG_TRRDIS(N)        ((N)<<16)
// NOTE: starting from logic rev. 0x01021228 select timestamp reset mode for the timestamp counter
#define DQL_TMRCFG_TSTRSTM1         (1L<<15)    // Select timestamp reset mode for the timestamp counter
#define DQL_TMRCFG_TSTRSTM0         (1L<<14)    // 00 - no reset, 01 - reset by start trigger, 10 reset on PPS
#define DQL_TMRCFG_TSTRSTM(N)       ((N)<<14)
#define DQL_TMRCFG_TSTRSTM_NO       (0x0)       // Normal operation
#define DQL_TMRCFG_TSTRSTM_TRG      (0x1)       // Reset timestamp counter by start trigger
#define DQL_TMRCFG_TSTRSTM_PPS      (0x2)       // Reset timestamp by 1PPS from ADPLL. (switched to 0 on reset)
// NOTE: starting from logic rev. 0x01021258 issure first clock after source after start trigger
#define DQL_TMRCFG_TRCLK1           (1L<<13)    // TMR1 issues pulse on first clock after the trigger.
#define DQL_TMRCFG_TRCLK0           (1L<<12)    // TMR0 issues pulse on first clock after the trigger.
#define DQL_TMRCFG_TRCLK(N)         ((N)<<12)
#define DQL_TMRCFG_TRCLK_NO         (0x0)       // Normal operation
#define DQL_TMRCFG_TRCLK_TMR0       (0x1)       // Issue pulse ASAP after the trigger on TRM0
#define DQL_TMRCFG_TRCLK_TMR1       (0x2)       // Issue pulse ASAP after the trigger on TRM1

// SOURCE - timestamp source selector (same constants also used internally by timer clock source)
#define DQL_TMRCFG_TSTS_66M         (0)         // 0    0000 - 66MHz (default)
#define DQL_TMRCFG_TSTS_TMR0        (1)         // 1    0001 - TMR0 (pulse)
#define DQL_TMRCFG_TSTS_TMR1        (3)         // 3    0011 - TMR1 (pulse)
#define DQL_TMRCFG_TSTS_IEXT0       (4)         // 4    0100 - iso_ext0
#define DQL_TMRCFG_TSTS_IEXT1       (5)         // 5    0101 - iso_ext1
#define DQL_TMRCFG_TSTS_IINT0       (8)         // 8    1000 - "Internal" source 0
#define DQL_TMRCFG_TSTS_IINT1       (9)         // 9    1001 - "Internal" source 1
#define DQL_TMRCFG_TSTS_SYNC0       (12)        // 12   1100 - SYNC line 0
#define DQL_TMRCFG_TSTS_SYNC1       (13)        // 13   1101 - SYNC line 1
#define DQL_TMRCFG_TSTS_SYNC2       (14)        // 14   1110 - SYNC line 2
#define DQL_TMRCFG_TSTS_SYNC3       (15)        // 15   1111 - SYNC line 3

#define DQL_TMRCFG_TMR1_ENABLE      (1UL<<7)
#define DQL_TMRCFG_TMR1_INV         (1UL<<6)
#define DQL_TMRCFG_TMR1_MODE1       (1UL<<5)
#define DQL_TMRCFG_TMR1_MODE0       (1UL<<4)
#define DQL_TMRCFG_TMR0_ENABLE      (1UL<<3)
#define DQL_TMRCFG_TMR0_INV         (1UL<<2)
#define DQL_TMRCFG_TMR0_MODE1       (1UL<<1)
#define DQL_TMRCFG_TMR0_MODE0       (1UL<<0)
#define DQL_TMRCFG_MODE_CNT         (0)         // Pulse output mode
#define DQL_TMRCFG_MODE_PWM         (1)         // PWM output mode

#define DQL_TMRCFG_TS_SRC_MASK      (0xF0000000)
#define DQL_TMRCFG_TMR1_CLK_MASK    (0x0F000000)
#define DQL_TMRCFG_TMR0_CLK_MASK    (0x00F00000)
#define DQL_TMRCFG_TS_TRIG_MASK     (0x000C0000)

// TIMER clock source constants for DAQLib function DqCmdSetClock()
// clocksel parameter
#define DQ_LN_CLKID_SRC_TMR0_66M    (0x50)      // 0    0000 - 66MHz (default)
#define DQ_LN_CLKID_SRC_TMR0_TMR1   (0x53)      // 3    0011 - TMR1 (pulse)
#define DQ_LN_CLKID_SRC_TMR0_IEXT0  (0x54)      // 4    0100 - iso_ext0
#define DQ_LN_CLKID_SRC_TMR0_IEXT1  (0x55)      // 5    0101 - iso_ext1
#define DQ_LN_CLKID_SRC_TMR0_IINT0  (0x58)      // 8    1000 - "Internal" source 0
#define DQ_LN_CLKID_SRC_TMR0_IINT1  (0x59)      // 9    1001 - "Internal" source 1
#define DQ_LN_CLKID_SRC_TMR0_SYNC0  (0x5C)      // 12   1100 - SYNC line 0
#define DQ_LN_CLKID_SRC_TMR0_SYNC1  (0x5D)      // 13   1101 - SYNC line 1
#define DQ_LN_CLKID_SRC_TMR0_SYNC2  (0x5E)      // 14   1110 - SYNC line 2
#define DQ_LN_CLKID_SRC_TMR0_SYNC3  (0x5F)      // 15   1111 - SYNC line 3
#define DQ_LN_CLKID_SRC_TMR1_66M    (0x60)      // 0    0000 - 66MHz (default)
#define DQ_LN_CLKID_SRC_TMR1_TMR0   (0x61)      // 1    0001 - TMR0 (pulse)
#define DQ_LN_CLKID_SRC_TMR1_IEXT0  (0x64)      // 4    0100 - iso_ext0
#define DQ_LN_CLKID_SRC_TMR1_IEXT1  (0x65)      // 5    0101 - iso_ext1
#define DQ_LN_CLKID_SRC_TMR1_IINT0  (0x68)      // 8    1000 - "Internal" source 0
#define DQ_LN_CLKID_SRC_TMR1_IINT1  (0x69)      // 9    1001 - "Internal" source 1
#define DQ_LN_CLKID_SRC_TMR1_SYNC0  (0x6C)      // 12   1100 - SYNC line 0
#define DQ_LN_CLKID_SRC_TMR1_SYNC1  (0x6D)      // 13   1101 - SYNC line 1
#define DQ_LN_CLKID_SRC_TMR1_SYNC2  (0x6E)      // 14   1110 - SYNC line 2
#define DQ_LN_CLKID_SRC_TMR1_SYNC3  (0x6F)      // 15   1111 - SYNC line 3

// default PLL loop filter values
#define DQ_C3PLL_CFG_24MHZ_VCO_POST (0)
#define DQ_C3PLL_CFG_24MHZ_R        (19)
#define DQ_C3PLL_CFG_24MHZ_C        (0)
#define DQ_C3PLL_CFG_24MHZ_I        (1)


#define DQ_PROLOG                   0xBABAFACA /* DqTS id */
#define DQ_PLGVT1                   0xBABAFACB /* DqVT first or not last packet id */
#define DQ_PLGVTL                   0xBABAFACC /* DqVT last or only packet id */

#define DQPROLOGVER                 0xBABAFAC2 /* request supported DQ version */

/* Masks to extract DQERR_... from command code */
#define DQERR_MASK                  (0xFFFF0000)
#define DQNOERR_MASK                (0x0000FFFF)

/* The first nibble indicates how the next three nybbles should be interpreted */
#define DQERR_NIBMASK               (0xF0000000)/* general error/status mask */
#define DQERR_MULTFAIL              (0x80000000)/* high bit - multiple bits indicate error/status */
#define DQERR_SINGFAIL              (0x90000000)/* low bit in first nybble - single error/status */

#define DQERR_BITS                  (0x0FFF0000)/* error/status bits or value extracted from here */

/* multiple errors - inclusive or-ed with dqCommand -- high bit set */
#define DQERR_GENFAIL               (0xF0000000)/* general error/status mask */
#define DQERR_OVRFLW                (0x80010000)/* Data extraction too slow - data overflow */
#define DQERR_STARTED               (0x80020000)/* Start trigger is received */
#define DQERR_STOPPED               (0x80040000)/* Stop trigger is received */

/* single errors/status - not inclusive or-ed bit 0x10000000 set */
#define DQERR_EXEC                  (0x90010000)/* exception on command execution */
#define DQERR_NOMORE                (0x90020000)/* no more data is available */
#define DQERR_MOREDATA              (0x90030000)/* more data is available */
#define DQERR_TOOOLD                (0x90040000)/* request is too old (RDFIFO) */
#define DQERR_INVREQ                (0x90050000)/* Invalid request number (RDFIFO) */
#define DQERR_NIMP                  (0x90060000)/* DQ not implemented or unknown command */
#define DQERR_ACCESS                (0x90070000)/* password is not cleared - access denied */
#define DQERR_LOCKED                (0x90080000)/* cube is locked */
#define DQERR_NOTALLOWED            (0x90090000)/* Command not allowed to be executed */
#define DQERR_WRONGID               (0x900A0000)/* Wrong VMap or DMap ID */
#define DQERR_DEVBUSY               (0x900B0000)/* Device could not be accessed */
#define DQERR_CRC_FAILED            (0x900C0000)/* Command CRC check failed */
#define DQERR_DATA_FAILED           (0x900D0000)/* Command data check failed */


/*
** The following is reuse of the previous code
** in the different direction: host->IOM
** It means that there was no reply to one
** of the previous packets of the same type
** Made especially for RDALL, WRRD and RDFIFO
** commands.
*/
#define DQERR_OPS                   (0x90070000)/* IOM is in operation state */
#define DQERR_PARAM                 (0x90080000)/* Device cannot complete request with specified parameters */

/* network errors */
#define DQERR_RCV                   (0x90090000)/* packet receive error */
#define DQERR_SND                   (0x900A0000)/* packet send error */

/* packet conditions (internal use only) */
#define DQERR_NOSEND                (0xA1000000)/* do not return packet */
#define DQERR_PENDING               (0xA2000000)/* do not return packet, do not free buffer */
#define DQERR_KEEP_PKT              (0xA4000000)/* keep reply packet */

#if defined(__UEIPAC__) || defined(__POWERPC8347__)
#define DQERR_CLEAR_REPLY_MASK      (0xffff)    /* only packet length */
#endif

/* Transfer list maximum size */
#define TRLISTSZ                    (256)
#define TRLISTMAXSZ                 (8*TRLISTSZ)
// Maximum number of DMAPs on one IOM
#define MAXDMAPS                    (DQ_MAXDEVN * DQ_MAXSS)

/* Channel list maximum size */
#define CHLISTSZ                    (128)


#define DQ_REPLY                    (0x1000)    // this is a reply
#define DQ_NOREPLY                  (0x2000)    // reply to this command is not required
#define DQ_REREQ                    (0x4000)    // packet re-request

#define DQCMD_FIRST                 (0x100)
/*
// DaqBIOS commands -----------
//                      ID
*/
#define DQCMD_ECHB          0x100
#define DQCMD_HRTBEAT       0x101
#define DQCMD_ECHO          0x104
#define DQCMD_ECHOPNP       0x108
#define DQCMD_EFR           0x10C
#define DQCMD_RST           0x110
#define DQCMD_RSTTS         0x111
#define DQCMD_RSTTSB        0x112
#define DQCMD_GETNVR        0x113
#define DQCMD_WRVAL         0x114
#define DQCMD_WRRD32        0x115
#define DQCMD_RDVAL         0x118
#define DQCMD_WRVALM        0x11C
#define DQCMD_RDVALM        0x120
#define DQCMD_SETCFG        0x124
#define DQCMD_RDSTS         0x128
#define DQCMD_GETCFG        0x129
#define DQCMD_READD         0x12A
#define DQCMD_WRITED        0x12B
#define DQCMD_WRCHNL        0x12C
#define DQCMD_RDCHNL        0x130
#define DQCMD_SETCLK        0x134
#define DQCMD_START         0x138
#define DQCMD_STARTB        0x139
#define DQCMD_SETCL         0x13C
#define DQCMD_SETTRL        0x140
#define DQCMD_CRTTRL        0x141
#define DQCMD_FINISH        0x144
#define DQCMD_MAP_CLEAR     0x145
#define DQCMD_WRALL         0x148
#define DQCMD_WRRD          0x14C
#define DQCMD_WRFIFO        0x150
#define DQCMD_RDFIFO        0x154
#define DQCMD_WRRDFIFO      0x158
#define DQCMD_WRFLASH       0x15C
#define DQCMD_UPDFLASH      0x160
#define DQCMD_SETSYNCRT     0x162
#define DQCMD_SETCOMM       0x164
#define DQCMD_SETNAME       0x168
#define DQCMD_RDNAME        0x16C
#define DQCMD_SETPRM        0x170
#define DQCMD_GETPRM        0x171
#define DQCMD_WDSET         0x172
#define DQCMD_SETCAL        0x174
#define DQCMD_SAVEPRM       0x178
#define DQCMD_SETMD         0x17C
#define DQCMD_SETRPLMAX     0x180
#define DQCMD_SETPASS       0x184
#define DQCMD_GETCRC        0x188
#define DQCMD_GETCAPS       0x190
#define DQCMD_INITIOM       0x194
#define DQCMD_IOCTL         0x198
#define DQCMD_IOCTLR        0x199
#define DQCMD_IOCTLD        0x19A
#define DQCMD_SETTRIG       0x1A0
#define DQCMD_BURST         0x1A1
#define DQCMD_EVENT         0x1B4
#define DQCMD_EMIT_EVENT    0x1B5
#define DQCMD_SETLOCK       0x1C0
#define DQCMD_RBFCPUWR      0x1C4
#define DQCMD_RBFPAGEWR     0x1C6
#define DQCMD_RBFPAGERD     0x1C7
#define DQCMD_RBFDEVLIST    0x1C8
#define DQCMD_SETAXMAP      0x1CA
#define DQCMD_SETAXWRT      0x1CB
#define DQCMD_SYNCCPU       0x1CC
#define DQCMD_SYNCCPUB      0x1CD
#define DQCMD_CLEARMEM      0x1FC

#define DQCMD_JTAGACCESS            (0x1FD)
#define DQCMD_LOGIC_UPDATE          (0x1FF)
#define DQCMD_UPDATE_STATIC_BUFFERS (0x1F0)


/* following code are not in the current implementation */
#define DQCMD_SETVEC                (0x1A4)
#define DQCMD_RUNVEC                (0x1A8)
#define DQCMD_RSTWCHDG              (0x1AC)
#define DQCMD_FLSHFIFO              (0x1B0)
#define DQCMD_ALLOC                 (0x1B8)
#define DQCMD_FREE                  (0x1BC)

/* Close the comment before this section to activate it */

// If Diagnostics flag is set, command is checked for DQ_EXE_DIAG_OK bit
// If layer is in op mode, command is checked for DQ_EXE_DIAG_OK bit
#define DQ_EXE_LIMITED              (0x0)       // command can be executed at any time, except following

#define DQ_EXE_OPMD_OK              (0x1)       // command cannot be executed in op mode when IOM in it without this bit
#define DQ_EXE_DIAG_OK              (0x2)       // if port is in diagnostics mode this bit allows to execute command
#define DQ_EXE_OP_DIAG              (0x3)       // combination of both

#define DQ_EXE_SHUT_OK              (0x4)       // OK to call when IOM is in shutdown mode
#define DQ_EXE_OP_D_SD              (0x7)       // OK in op mode, diag mode and shutdown mode


/* Parameters for DQCMD_INITIOM command
*/
#define LNPRM_MODID                 (0x101)     // IOM model ID (DQPARAM)
#define LNPRM_MODOPT                (0x102)     // IOM model option (DQPARAM)
#define LNPRM_IOMSN                 (0x103)     // IOM serial number (DQPARAM)
#define LNPRM_IOMMFG                (0x104)     // 0xddmmyyyy    IOM manufacturing date (DQPARAM)
#define LNPRM_IOMFRQ                (0x105)     // Base frequency, Hz (DQPARAM)
#define LNPRM_TICK                  (0x106)     // OS Tick size (may be ignored by OS)
#define LNPRM_PERIOD                (0x107)     // Periodic tick size (may be ignored by OS)
#define LNPRM_WDDLY                 (0x108)     // Watchdog timer reset delay, ms; 0 = disabled
#define LNPRM_TIME                  (0x109)     // Current layer time, seconds from 1/1/2000
#define LNPRM_OPTIONS               (0x10A)     // Firmware options
#define LNPRM_COMDLY                (0x110)     // Delay before entering shutdown mode after communication is lost; 0 = disabled
#define LNPRM_FWCT                  (0x111)     // Type of the IOM firmware: 2: slave, 0x10: data logger, 0x20 UEIPAC
#define LNPRM_LNID                  (0x201)     // Layer ID
#define LNPRM_LNOPT                 (0x202)     // Layer option
#define LNPRM_LNSN                  (0x203)     // Layer serial number
#define LNPRM_TOTAL                 (0x204)     // Total EEPROM size
#define LNPRM_LNMFG                 (0x205)     // 0xddmmyyyy    Layer manufacturing date
#define LNPRM_LNCAL                 (0x206)     // 0xddmmyyyy    Layer calibration date
#define LNPRM_LNEXP                 (0x207)     // 0xddmmyyyy    Layer calibration expiration date
#define LNPRM_DQREV                 (0x208)     // DaqBIOS revision supported
#define LNPRM_FWREV                 (0x209)     // Firmware revision supported

#define LNPRM_NOCHANGE              (0xF0000000)// Do not apply changes, test only (OR with param_id)
#define LNPRM_BYOFFS                (0xF0100000)// Write data by offset to the layer EEPROM. The data should be specified as follows: u16 offs, u16 size, u8[] data (or with param_id)
#define LNPRM_RDONLY                (0xF0000000)// Read only (OR with param_id)

#define LNPRM_DEVIOM                (0xFE)      // IOM "layer ID"
#define LNPRM_DEVALL                (0xFF)      // "layer ID" - all devices

#define BUS_FREQUENCY               (66000000U)


#define DQ_DEVNAME_SIZE             (40)
#define DQ_CLSZ                     (0x40)
#define DQ_CFG_RECORD_SIZE          (0x2000)    /* our parameters can be as big as 8kB */

#define DQ_MAX_FRAGMENTS            (8)         // maximum number of fragments for RT VMAP/DMAP = 11832 bytes UDP payload
#define DQ_MAX_PAYLOAD_FRAG         (DQ_MAX_UDP_SIZE_100*DQ_MAX_FRAGMENTS)
#define DQ_MIN_PAYLOAD_FRAG         (2*sizeof(uint16))  // just two control words



#define DQ_FLEX_ARRAY /* empty */
#if defined(__GNUC__)
# if (__GNUC__ < 3)
#  define DQ_FLEX_ARRAY 0 /* older GNU extension */
# endif
#endif

/*
 *DaqBIOS frame
 */
#define DQMAXUDP                    (530 - DQHSZ) // maximum size of dqData over UDP

#define DQHSZ                       sizeof (DQPKT) // size of the DaqBIOS packet header

/* PPC lwip will calculate packet space
#ifdef __POWERPC__
    #define ETH_HDR_SIZE 0
    #define IP_HDR_SIZE 0
    #define UDP_HDR_SIZE 0
    #define UDP_HDR_OFFSET 0
#endif
*/

#define DQ_ACB_HEADERSZ             (ETH_HDR_SIZE + IP_HDR_SIZE + UDP_HDR_SIZE + DQHSZ + DQFIFOHSZ + sizeof(uint32))

#define DQ_DQPKT_OFFS               (ETH_HDR_SIZE + IP_HDR_SIZE + UDP_HDR_SIZE)

#define DQ_READCOMM                 (1)         // read parameters
#define DQ_WRITECOMM                (2)         // write parameters
#define DQ_READCOMM2                (3)         // read ip2 parameters
#define DQ_WRITECOMM2               (4)         // write ip2 parameters
#define DQ_WRITECOMMSRV             (5)         // write parameters, make srv = ip
#define DQ_WRITECOMM2SRV            (6)         // write ip2 parameters, make srv = ip

typedef struct DQPKT{
    uint32 dqProlog;                /* const 0xBABAFACA */
    uint16 dqTStamp;                /* 16-bit timestamp */
    uint16 dqCounter;               /* Retry counter + bitfields */
    uint32 dqCommand;               /* DaqBIOS command */
    /*uint16 SN;*/                  /* Sequence number - make rqId 16-bit field and then use SN for redundancy */
    uint32 rqId;                    /* Request ID - sent from host, mirrored */
    uint8  dqData[DQ_FLEX_ARRAY];   /* Data - bytes variable size */
} DQPKT, * pDQPKT;

typedef struct {
    uint32 dqProlog;                /* const 0xBABAFACA */
    uint16 dqTStamp;                /* 32-bit timestamp */
    uint16 dqCounter;               /* Retry counter + bitfields */
    uint32 dqCommand;               /* DaqBIOS command */
    uint32 rqId;                    /* Request ID - sent from host, mirrored */
    uint16  dqData[DQ_FLEX_ARRAY];  /* Data - words variable size */
} wDQPKT, * pwDQPKT;

typedef struct {
    uint32 dqProlog;                /* const 0xBABAFACA */
    uint16 dqTStamp;                /* 32-bit timestamp */
    uint16 dqCounter;               /* Retry counter + bitfields */
    uint32 dqCommand;               /* DaqBIOS command */
    uint32 rqId;                    /* Request ID - sent from host, mirrored */
    uint32  dqData[DQ_FLEX_ARRAY];  /* Data - dwords variable size */
} dwDQPKT, * pdwDQPKT;

/* ---------------- typedefs for DaqBIOS commands ----------------- */
/* device configuration data */
typedef struct {
    uint32 model;                   /* device model */
    uint32 ipaddr;                  /* ip address */
    uint32 sernum;                  /* serial number */
    uint32 caldate;                 /* calibration date */
    uint32 mfgdate;                 /* manufacturing date */
    uint16 devmod[DQ_MAXDEVN];      /* up to 32 installed devices */
    uint16 option[DQ_MAXDEVN];      /* and their option parameters */

    // ioctls response counters per device
    uint32 tx_n[DQ_MAXDEVN];
    uint32 rx_n[DQ_MAXDEVN];
} DQRDCFG, *pDQRDCFG;

/* DQCMD_WRVALM structure */
typedef struct {
    uint32  addr;
    int16   increment;
    uint8   size;
    uint8   count;
    uint8   data[DQ_FLEX_ARRAY];    /* 28 BYTEs in DQ-TS */
} DQWRVALM, *pDQWRVALM;

/* DQCMD_RDVALM structure */
typedef struct {
    uint32  addr;
    int16   increment;
    uint8   size;
    uint8   count;
} wDQRDVALM, *pwDQRDVALM;

/* DQCMD_WRVALM structure */
typedef struct {
    uint32  addr;
    int16   increment;
    uint8   size;
    uint8   count;
    uint16  data[DQ_FLEX_ARRAY];    /* 14 WORDs in DQ-TS */
} wDQWRVALM, *pwDQWRVALM;

/* DQCMD_WRVALM structure */
typedef struct {
    uint32  addr;
    int16   increment;
    uint8   size;
    uint8   count;
    uint8   data[DQ_FLEX_ARRAY];    /* 7 DWORDs in DQ-TS */
} dwDQWRVALM, *pdwDQWRVALM;

/* DQCMD_SETCFG */
typedef struct {
    uint8 dev;  // device
    uint8 ss;   // subsystems
    uint32 cfg;
} DQSETCFG, *pDQSETCFG;

/* DQCMD_EVENT structure - should be aligned by 32 bit boundary */
typedef struct {
    uint8   dev;                    // device
    uint8   ss;                     // subsystem
    uint16  size;                   // data size
    uint32  event;                  // event type or command and additional flags
    uint8   data[DQ_FLEX_ARRAY];    // data
} DQEVENT, *pDQEVENT;

/* DQCMD_AXMAP structure */
typedef struct {
    uint8   dev;                    // device
    uint8   ss;                     // subsystem
    uint16  size;                   // data size
    uint32  mode;                   // event type or command and additional flags
    uint8   data[DQ_FLEX_ARRAY];    // data
} DQAXMAP, *pDQAXMAP;

/* DQCMD_GETCFG - reply */
typedef struct {
    uint8 dev;                      // device
    uint8 ss;                       // subsystem
    uint32 chan;                    // channel if channels can be configured separately
    uint32 cfg;                     // configuration
    uint32 cldiv;                   // CL clock divider
    uint32 cvdiv;                   // CV clock divider
    uint32 clsize;                  // channel list size
    uint32 cl[DQ_FLEX_ARRAY];       // channel list - variable
} DQGETCFG, *pDQGETCFG;

/* DQCMD_GETCFG - request */
typedef struct {
    uint8 dev;                      // device
    uint8 ss;                       // subsystem
    uint32 chan;                    // channel if channels can be configured separately
} DQGETCFG_RQ, *pDQGETCFG_RQ;

/* DQCMD_WRCHNL */
typedef struct {
    uint8 dev;
    uint8 ss;
    uint8 chnl;
    uint32 data;
} DQWRCHNL, *pDQWRCHNL;

/* DQCMD_WRCHNL */
typedef struct {
    uint8 dev;
    uint8 ss;
    uint8 chnl;
} DQCHNL, *pDQCHNL;

// write 32-bit channel data
typedef struct {
    DQCHNL    devch;
    uint32    data;
} DQWRCHNL32;

/* DQCMD_RDCHNL */
typedef struct {
    uint8 dev;
    uint8 ss;
    uint8 chnl;
} DQRDCHNL, *pDQRDCHNL;

/* DQCMD_SETCLK */
typedef struct {
    uint8 dev;                      // device number
    uint8 ss;                       // channel/subsystem/CVCL
    uint8 clocksel;                 // select clock settings
    float frq;                      // desired frequency, Hz
} DQSETCLK, *pDQSETCLK;

/* DQCMD_SETCL */
typedef struct {
    uint8 dev;                      // device number
    uint8 ss;                       // subsystem
    uint32 entry;                   // channel list entry
} DQSETCL, *pDQSETCL;


/* DQCMD_SETTRL */
typedef struct {
    uint16 dmapid;                  // DQDMAP id
    uint8  dev;                     // device
    uint8  ss;                      // subsystem (input/output and #)
    uint32 ch;                      // channel (channel list entry)
    uint32 flags;                   // control flags, including channel information
    uint16 samples;                 // number of samples from this channel / size in bytes for VMap
} DQSETTRL, *pDQSETTRL;

/* DQCMD_SETTRIG */
typedef struct {
    uint8 dev;                      // device
    uint8 ss;                       // subsystem
    uint8 ch;                       // channel
    uint8 mode;                     // trigger mode (AND or OR)

    // Start trigger
    uint32 trigtypeS;               // trigger type (enable, edge or mask)
    union {
        float levelS;               // level
        uint32 maskS;
    } uS;

    // stoP trigger
    uint32 trigtypeP;               // trigger type (enable, edge or mask)
    union {
        float levelP;               // level
        uint32 maskP;
    } uP;

    float hyster;                   // hysteresis for both triggers
    int prescans;                   // pre-trigger scans
    int postscans;                  // post-trigger scans, -1 = continue operations
} DQSETTRIG, *pDQSETTRIG;

/* DQCMD_WRRD */
typedef struct {
    uint32 dmapid;
    uint32 size;
    uint8 data[DQ_FLEX_ARRAY];
} DQWRRD, *pDQWRRD;

/* DQCMD_WRRD32 */
#define DQWRRD32_DONOT_INC          (1L<<1)     // do not increment address, useful to read FIFOs
#define DQWRRD32_READ_1ST           (1L<<0)     // first read than write, default is the opposite

typedef struct {
    uint16 dev;                     // device DEVN to access
    uint16 read_1st;                // read before write if TRUE
    uint16 addr_w;                  // address to write
    uint16 size_w;                  // size to write (in uint32s)
    uint16 addr_r;                  // address to read
    uint16 size_r;                  // size to read (in uint32s)
    uint32 data[DQ_FLEX_ARRAY];                  // data
} DQWRRD32, *pDQWRRD32;

/* DQCMD_WRFIFO and DQCMD_RDFIFO */
typedef struct {
    uint8 dev;
    uint8 ss;
    uint16 size;
    uint8 data[DQ_FLEX_ARRAY];
} DQFIFO, *pDQFIFO;

#define DQFIFOHSZ (4)

/* DQCMD_RDFIFO32 */
typedef struct {
    uint8 dev;
    uint8 ss;
    uint16 size;
    uint32 data[DQ_FLEX_ARRAY];
} DQFIFO32, *pDQFIFO32;

/* DQCMD_WRRDFIFO */
typedef struct {
    uint8 dev;                      // device
    uint8 sswr;                     // subsystem to write to
    uint8 ssrd;                     // subsystem to read from
    uint8 chwr;                     // channel to write
    uint8 chrd;                     // channel to read
    uint16 sizewr;                  // size to write (out)/written (in)
    uint16 sizerd;                  // requested (out)/received (in)
    uint16 avlwr;                   // how many additinal samples could have been written
    uint16 avlrd;                   // how many samples remained in the fifo
    uint8 data[DQ_FLEX_ARRAY];
} DQWRRDFIFO, *pDQWRRDFIFO;

/* DQCMD_UPDFLASH */
typedef struct {
    uint16 Sector;
    uint32 Address;
    uint32 Size;
} DQFLASHDATA;

/* DQCMD_RBFPAGEWR */
typedef struct {
    uint32 BaseAddr;
    uint16 Page;
    uint32 Size;
    uint8  CrcVerification;
} DQFPGADATA;

/* DQCMD_JTAGACCESS */
typedef struct {
    uint32 baseAddr;                // layer base address
    uint32 size;                    // total size of words in buffer
    uint32 err;                     // error code
    uint16 size_last;               // number of valid bits in last word
    uint8  config;                  // open/close JTAG, direct access to tms/tdi/tck pins
    uint8  tms_tdi_tck;             // tms (#2), tdi(#1), tck(#0) pins state (for initialization)
    uint8  buffer[DQ_FLEX_ARRAY];   // array with data
} DQJTAGDATA, *pDQJTAGDATA;

/*DQCMD_UPDATE_STATIC_BUFFERS */
typedef struct {
    uint32 size;                    // total size of words in buffer
    uint32 err;                     // error code
    uint32 index;                   // index for dynamically allocated buffer within variables buffer
    uint8 buffer_enable;            // flags used to indicate to which buffer the data should be written to
    uint8 buffer[DQ_FLEX_ARRAY];    // array with data
}DQUPDATE_LOGIC_STATIC_BUFFERS, *pDQUPDATE_LOGIC_STATIC_BUFFERS;

/*DQCMD_LOGIC_UPDATE */
typedef struct
{
    uint32 baseAddr;                 // layer base address
    uint32 size;                     // total size of words in buffer
    uint32 next_pc;                  // jam file offset for next instruction set
    uint32 next_long_temp;           // jam file offset for next temp data set
    uint32 symbol_count;             // number of symbold counted by the user-level app
    uint32 err;                      // error code
    uint8 code_data_requested;       // flag to signal code_data_buffer needs more data
    uint8 long_temp_data_requested;   // flag to signal long_temp_data buffer needs more data
    uint8 print_message_request;     // flag to signal user-app to print message sent from IOM
    uint8 buffers_filled;            // flag to signal when to start logic updating
    uint8 buffer[DQ_FLEX_ARRAY];     // array with data
} DQLOGIC_UPDATE, *pDQLOGIC_UPDATE;

/* DQCMD_GETCRC */
typedef struct {
     uint32 fwcrc;                  // CRC of firmware code
     uint32 fwver;                  // FW version
     uint32 paramcrc;               // CRC of parameter table
     uint32 initcrc;                // Init mode CRC
     uint32 opercrc;                // Operation mode CRC
     uint32 sdcrc;                  // Shutdown CRC
     uint32 build;                  // Build
} DQCRCINFO, *pDQCRCINFO;

/* DQCMD_SETCOMM */
typedef struct {
    uint8  todo;
    uint8  MAC[6];
    uint32 netip;
    uint32 gateway;
    uint32 netmask;
    uint32 startup;
    uint32 baudrate;
    uint16 udpport;
    uint8  signature[28];
} DQSETCOMM, *pDQSETCOMM;

/* DQCMD_SETPRM, DQCMD_GETPRM */
typedef struct {
    uint8 dev;                      // device
    uint8 ss;                       // subsystem
    uint8 mode;                     // parameter mode
    uint8 value[DQ_FLEX_ARRAY];                  // array of values
} DQSETPRM, *pDQSETPRM, DQGETPRM, *pDQGETPRM;

/* DQCMD_SETCAL */
typedef struct {
    uint8 dev;                      // device
    uint8 ss;                       // subsystem
    uint8 channel;                  // channel
    uint8 dac;                      // parameter mode
    uint32 value;                   // DAC value to write
} DQSETCAL, *pDQSETCAL;

/* DQCMD_IOCTL */
typedef struct {
    uint8  dev;                     // device number
    uint8  ss;                      // subsystem
    uint32 cmd;                     // ioctl command
    uint8  arg[DQ_FLEX_ARRAY];      // arguments (var size)
} DQIOCTL, *pDQIOCTL;

/* DQCMD_BURST */
typedef struct {
    uint8 dev;                      // device
    uint8 ss;                       // sub system
    uint32 pre;                     // number of pre-trigger scans
    uint32 post;                    // number of post-trigger scans
    uint32 trigger;                 // trigger flags
} DQBURST, *pDQBURST;

/* DQCMD_CLEARMEM */
typedef struct {
    uint32 devmask;                 // device mask
    uint32 cmd;                     // command to perform
    uint32 mode;                    // cleaning mode
    int32  status;                  // result status
} DQCLRMEM, *pDQCLRMEM;

/* DQCMD_RBFPAGEWR */
typedef struct {
    uint32 err;                     // error code
    uint32 processed_bytes;         // number of processed bytes
    uint32 crc;                     // crc of transfered page
} DQRBF, *pDQRBF;

/* DQCMD_RBFDEVLIST */
typedef struct {
    int  status;
    uint8  system_type_dnr;
    uint8  logic_programmed[DQ_MAXDEVN/2];
    uint8  msp_present[DQ_MAXDEVN/2];
    uint16 layer_model[DQ_MAXDEVN/2];
    uint16 base_addr[DQ_MAXDEVN/2];
    uint32 logic_ver[DQ_MAXDEVN/2];
    uint32 error[DQ_MAXDEVN/2];
    uint8  msp_fw_ver[DQ_MAXDEVN/2];
    uint32 scd_silicon_id[DQ_MAXDEVN/2]; // Serial Configuration Device (SCD) silicon ID. See DEV_IND() macros / MAX10 part number
    uint8  fpga_type[DQ_MAXDEVN/2];      // FPGA type (Cyclone/MAX10)
} DQRBFDEV, *pDQRBFDEV;

#ifdef __UEIPAC__
typedef struct{} NBUFSTR, *pNBUFSTR;
#else
typedef struct {
    struct pbuf *plNbuf;            // pointer to the last packet allocated to send
    struct udp_pcb *pcb;            // the process control block which made us

    DQPKT *pDq;                     // allocated packet
    DQPKT *pDqRq;                   // incoming packet
    struct pbuf *pRq;

    uint32  pDataSize;
    uint32  pRqDataSize;
    uint32  port_num;               // 0 - main, 1 - diagnostics
    uint32  noreply;                // 1 is reply is not requested

} NBUFSTR, *pNBUFSTR;
#endif


#define SYNCCFG_RESERVED1           (1)         // reserved
#define SYNCCFG_DEF_SOURCES         (2)         // for DqSyncDefineSources()
#define SYNCCFG_DEF_CLOCKS          (3)         // for DqSyncDefineLayerClock()
#define SYNCCFG_DEF_TRIGS           (4)         // for DqSyncDefineLayerTrigger()
#define SYNCCFG_DEF_TSTAMPS         (5)         // for DqSyncDefineLayerTimestamp()
#define SYNCCFG_RESYNC_TSTAMPS      (6)         // for DqSyncResyncTimestamp()
#define SYNCCFG_DEF_STARTSTOP       (7)         // for DqSyncDefineStartStop()
#define SYNCCFG_GET_SYNCSTAT        (8)         // for DqSyncGetSyncStatus()
#define SYNCCFG_RESERVED9           (9)         // reserved
#define SYNCCFG_DEF_NTP             (10)        // for DqSyncDefineNTPServer()
#define SYNCCFG_DEF_PTP             (11)        // for DqSyncDefinePTPServer()
#define SYNCCFG_SET_EVENT           (12)        // for DqSyncSetEvent()
#define SYNCCFG_TRIG_NEXTPPS        (13)        // for DqSyncTrigOnNextPPS()
#define SYNCCFG_TRIG_NEXTPPSB       (14)        // for DqSyncTrigOnNextPPSBrCast()
#define SYNCCFG_SETUP_SYNC_IRQ      (15)        // for setting up a periodic task.
#define SYNCCFG_TSTRST_NEXTPPS      (16)        // for DqSyncSetEvent()
#define SYNCCFG_TSTRST_NEXTPPSB     (17)        // for DqSyncSetEvent()
#define SYNCCFG_CLEAR_SOURCES       (18)        // for DqSyncClearSources()
#define SYNCCFG_RESERVED19          (19)        // reserved
#define SYNCCFG_RESERVED20          (20)        // reserved
#define SYNCCFG_GET_TIME            (21)        // for DqSyncGetUTCTimeFromPTP()
#define SYNCCFG_GET_PTPSTS          (22)        // for DqSyncGetPTPStatus()
#define SYNCCFG_SET_SYNCDEBOUNCER   (23)        // for DqSyncSetSyncInDebouncer()

#define DQL_CPU_PLL_MAX     2   // maximum 2 PLLs on CPU layer, 8347/5200 "classic" have only one


// =============================================================================================
// for DqSyncDefineSources()
typedef struct {
    // ==== section A ==========================================================================
    // synchronization: tell IOM where what to use as synchronization source
    uint32 sync_device;             // device that performs synchronization
    uint32 sync_source;             // where to get nPPS clock to synchronize system
    uint32 sync_line;               // where to route sync clock
    uint32 sync_mode;               // mode of synchronization
    uint32 nPPS;                    // N - number of pulses per second for input nPPS clock
    uint32 nPPS_us;                 // Expected accuracy of the nPPS clock in us, clocks outside of the range will be ignored, 0=default

    // ==== section B ==========================================================================
    // synchronization output: tell IOM to become NTP/PTP or trigger server (over Ethernet)
    uint32 sync_server;             // type of the server on the network to become (additionally to for nPPS)
    uint32 srv_param;               // server parameters
    uint32 trig_server;             // tell the IOM that it needs to start the rest of the cubes on the network

    // ==== section C ==========================================================================
    // clocks: select clock source for each SYNC line (0 thru 3)
    uint32 clock_src[DQL_SYNC_LINES];           // clock source for each SYNC line
    uint32 clock_tmr[DQL_SYNC_LINES];           // PLL and external clock can be divided on TMR0 or TMR1
    uint32 clock_frq[DQL_SYNC_LINES];           // clock frequency (for PLL/EM)
    uint32 clock_div[DQL_SYNC_LINES];           // clock divider for EMx (0 == divide by 1, 2 by two, 3 by three etc.)

    // ==== section D ==========================================================================
    // trigger: tell IOM where to get (or generate) and route trigger signal
    uint32 trig_source;             // where to take trigger to start acquisition
    uint32 trig_line;               // <reserved>
    uint32 trig_start;              // start trigger mode selection
    uint32 trig_delay;              // offset of the trigger pulse from nPPS clock (microseconds)
    uint32 trig_period_ms;          // period in ms to issue start trigger
    uint32 trig_stop;               // source for the stop trigger
    uint32 trig_stop_src;           // stop source for stop trigger upon N-count
    uint32 trig_duration;           // milliseconds before issuing stop trigger or N-count

    // ==== section E ==========================================================================
    // destination to route signals: from SYNC lines or to the outside SyncOut0/1
    uint32 clclk_dest[DQL_SYNC_LINES];  // where to feed CL clock
    uint32 pps_dest;                    // where to feed 1PPS clock to
    uint32 trig_dest;                   // where to feed start/stop trigger

} DQ_SYNC_SCHEME, *pDQ_SYNC_SCHEME;

// This structure is hidden from users and passed into the firmware after DQ_SYNC_SCHEME in DqSyncDefineSources()
// It contains calculated values and tables which is done automatically in the library
typedef struct {
    SYNCPLL   syncpll;  // CY22150 PLL settings

} DQ_SYNC_SCHEME_AUX, *pDQ_SYNC_SCHEME_AUX;

// Error code definitions for processing

// For <sync_device> - which device takes care of synchronization ------------------------------
#define DQ_SYNC_8347                (1)         // standard 8347 CPU
#define DQ_SYNC_8347S               (2)         // 8347 CPU equipped with 1588 support
#define DQ_SYNC_5200                (3)         // standard 5200 CPU
#define DQ_SYNC_5200S               (4)         // 5200 CPU equipped with 1588 support
#define DQ_SYNC_RESERVED            (5)         // Reserved
#define DQ_SYNC_IRIG650             (6)         // layer with IRIG support (supported both on DNA and DNR)
#define DQ_SYNC_IMX6SX              (7)         // standard IMX6SX CPU
#define DQ_SYNC_ZYNQMP              (8)         // standard Zynq CPU

// ==== SECTION A ==============================================================================
// For <sync_source> - where to get clock source -----------------------------------------------
// ===== For DQ_SYNC_8347 =====
//

// Possible combinations
// DQ_SYNCCLK_SYNCINx with DQ_SYNCCLK_SYNCx causes POWER-1GB layer to route input clock to one of the
// SYNC lines. Once routed it can be used to clock specific layer from this line (for example IRIG-650
// or SYNC-588 or used with GIG-E CPU layer to synthesize other clocks
//
// <sync_source>
#define DQ_SYNCCLK_SYNCIN0          (1L)        // SyncIn0 delivers nPPS clock
#define DQ_SYNCCLK_SYNCIN1          (2L)        // SyncIn1 delivers nPPS clock

// <sync_line>
#define DQ_SYNCCLK_SYNC0            (1L)        // Sync0 delivers nPPS clock
#define DQ_SYNCCLK_SYNC1            (2L)        // Sync1 delivers nPPS clock
#define DQ_SYNCCLK_SYNC2            (3L)        // Sync2 delivers nPPS clock
#define DQ_SYNCCLK_SYNC3            (4L)        // Sync3 delivers nPPS clock

// <sync_mode>
#define DQ_SYNCCLK_SYNC             (1L)        // Use SYNC clock (set source above)
#define DQ_SYNCCLK_NTP              (2L)        // NTP delivers 1PPS clock
#define DQ_SYNCCLK_SWPTP            (3L)        // PTP in software (1588) delivers 1PPS clock

// ===== For DQ_SYNC_8347S =====
//
// same as previous plus
#define DQ_SYNCCLK_1588             (4L)        // from built-in 1588 chip

// ===== For DQ_SYNC_5200 =====
//
// Since SYNCIN0/SYNCOUT0 connector is located on the layer itself
// DQ_SYNCCLK_SYNCIN0 can be used alone without the need to connect to the SYNC line
#define DQ_SYNCCLK5_SYNCIN0         DQ_SYNCCLK_SYNCIN0      // SyncIn0 delivers nPPS clock
#define DQ_SYNCCLK5_NTP             DQ_SYNCCLK_NTP
#define DQ_SYNCCLK5_SWPTP           DQ_SYNCCLK_SWPTP

// ===== For DQ_SYNC_5200S =====
// same as for 5200 plus
#define DQ_SYNCCLK5_1588            DQ_SYNCCLK_1588

// <sync_mode> - Ethernet port to use
#define DQ_SYNCCLK_ETH0             (0L<<12)    // default: use ETH0 interface for providing synchronization sources
#define DQ_SYNCCLK_ETH1             (8L<<12)    // use ETH1 interface for providing synchronization sources

#define DQ_SYNCCLK_MODE_MSK         (0xF)       // mask for DQ_SYNCCLK_*

// The following constants are used in clock server, clock and trigger selection to assign
// clock or trigger signal to one of the SYNCx lines
#define DQ_USE_SYNC0                (1L<<8)     // Feed clock from SYNC0
#define DQ_USE_SYNC1                (2L<<8)     // Feed clock from SYNC1
#define DQ_USE_SYNC2                (3L<<8)     // Feed clock from SYNC2
#define DQ_USE_SYNC3                (4L<<8)     // Feed clock from SYNC3
#define DQ_USE_SYNC_MASK            (0xf00)

// ==== SECTION B ==============================================================================
// For <sync_server> - if and how to provide clock source -----------------------------------------------
// A rack can become a source of the synchronization signal if a time server is not available
// Note a separate function call DqSyncDefineNTPServer() or DqSyncDefinePTPServer() needs to be made
// before enabling operations in DqSyncDefineSources()
//
// ==== For all types ====
#define DQ_SYNCSRV_1PPS             (1L)        // Locally generated 1PPS (based on TMR0)
#define DQ_SYNCSRV_NTP              (2L)        // NTP delivers 1PPS clock
#define DQ_SYNCSRV_SWPTP            (3L)        // PTP in software (1588) delivers 1PPS clock

// if <sync_server == DQ_SYNCSRV_1PPS> then <srv_param> contains output line assignment
#define DQ_SYNCSRV_SYNCOUT0         (1L)        // SyncOut0 delivers nPPS clock
#define DQ_SYNCSRV_SYNCOUT1         (2L)        // SyncOut1 delivers nPPS clock

// Also, if 1PPS clock is a sync server it needs to be fed into ADPLL of the server rack as well
// to do it <srv_param> should also contain


// ===== For DQ_SYNC_8347S DQ_SYNC_5200S =====
//
// same as previous plus
#define DQ_SYNCSRV_1588             (4L)        // from built-in 1588 chip

// bit [15..12]
#define DQ_SYNCSRV_ETH0             (0L<<12)    // default: use ETH1 interface for providing synchronization sources
#define DQ_SYNCSRV_ETH1             (8L<<12)    // use ETH1 interface for providing synchronization sources

// For <trig_server> - one cube could be dedicated to broadcast "start acquisition" packet right
// after 1PPS to start the whole setup upon the next PPS pulse
#define DQ_TRIGSRV_START_PPS        (1L<<0)     // broadcast "start" upon next 1PPS clock
#define DQ_TRIGSRV_GLOB_START       (1L<<1)     // broadcast "start" upon next start trigger
#define DQ_TRIGSRV_GLOB_STOP        (1L<<2)     // broadcast "stop" to all devices upon global stop trigger

// ==== SECTION C ==============================================================================
//
// Clocks <clock_src[i]>
//
// ==== For DQ_SYNC_8347 and DQ_SYNC_8347S ====
//
// 8347 and 5200 can:
//  1. Take external clock on POWER-1G (CPU for 5200) and route it into SYNCx line via dividers
//  2. Take clock from PLLx and route it into SYNCx line
//  3. Take clock from EMx  and route it into SYNCx line
//  All of these clocks can be divided:
//
//  Clock source can be selected for each SYNCx line
//  There are multiple sources and dividers for the clock which can be selected
//
// Each of the clock_src[i] has to use DQ_USE_SYNCx line to tell which SYNC line to
// to assign CL clock to

//
// For 8347 external clocks can be taken from SYNCIN0/1 on POWER-1G layer
// NB: 8347 SYNCINx clock needs to be routed to SYNCx (see DQ_CLKDEST_...)
// <clock_src>
// use DQ_USE_SYNCx line to assign where to route clock
#define DQ_CLOCKSRC_UNUSED          (0L)        //
#define DQ_CLOCKSRC_PLL0            (1L)        // PLL0 on CPU layer
#define DQ_CLOCKSRC_ADPLL           (2L)        // ADPLL on CPU layer
#define DQ_CLOCKSRC_SYNCIN0         (3L)        // SYNCIN0 on POWER-1GB layer
#define DQ_CLOCKSRC_SYNCIN1         (4L)        // SYNCIN1 on POWER-1GB layer
#define DQ_CLOCKSRC_EM0             (5L)        // Event module synthesizes clock
#define DQ_CLOCKSRC_EM1             (6L)        // Event module divider (needs to be set) (used EM divider C)
#define DQ_CLOCKSRC_EM2             (7L)        // Event module divider (needs to be set, 0=default) (used EM divider D)
#define DQ_CLOCKSRC_PLL0TMR0        (8L)        // PLL0 on CPU layer divided by TMR0
#define DQ_CLOCKSRC_PLL0TMR1        (9L)        // PLL0 on CPU layer divided by TMR1
#define DQ_CLOCKSRC_MASK            (0xff)

// PLLx and SYNCINx clocks can be a source of TMRx to divide them
// <clock_tmr>
// Note: PLL clock can be connected to the timer
//       SYNCINx clock may be used without a timer connecting directly to the SYNC

// ==== For DQ_SYNC_5200 and DQ_SYNC_5200S ====
#define DQ_CLOCKSRC5_PLL0           DQ_CLOCKSRC_PLL0      // PLL0 on CPU layer
#define DQ_CLOCKSRC5_SYNCIN0        DQ_CLOCKSRC_SYNCIN0   // PLL on CPU layer


// ==== SECTION D ==============================================================================
// For <trig_source> - where to get trigger source
// ===== For DQ_SYNC_8347, DQ_SYNC_8347S =====
//
// For 8347 trigger must be delivered from POWER-1GB layer to one of the SYNC lines before use
// for the synchronization in even modules. Trigger can be also used alone as routed by each layer
//
// <trig_source>
// use DQ_USE_SYNCx line to assign where to route clock
#define DQ_TRIGSTART_SYNCIN0        (1L)        // SyncIn0 delivers trigger
#define DQ_TRIGSTART_SYNCIN1        (2L)        // SyncIn1 delivers trigger

// <trig_start>
#define DQ_TRIGSTART_SYNC           (1L)        // Derive start trigger from the SYNC line
#define DQ_TRIGSTART_NPPS           (2L)        // Issue start trigger on the next PPS (plus <trig_delay>)
#define DQ_TRIGSTART_RETRIG         (3L)        // Automatically re-trigger at <trig_freq>

// ===== For DQ_SYNC_5200 and DQ_SYNC_5200S =====
#define DQ_TRIGSTART5_SYNCIN0       DQ_TRIGSTART_SYNCIN0    // SyncIn0 delivers trigger
#define DQ_TRIGSTART5_NEXTPPS       DQ_TRIGSTART_NPPS      // Issue start trigger on the next PPS (plus trig_offset)
#define DQ_TRIGSTART5_RETRIG        DQ_TRIGSTART_RETRIG    // Automatically re-trigger after a certain interval in ms

#define DQ_TRIGSTART_DEFAULT        (0)         // Leave it to each individual card


// For <trig_stop> - where to get trigger source and how to propagate it ------------------------
//
// <trig_stop>
#define DQ_TRIGSTOP_SYNC            (1L)        // Derive stop trigger from the SYNC line
#define DQ_TRIGSTOP_DURATION        (2L)        // Issue stop trigger upon expiring on N ms
#define DQ_TRIGSTOP_NCLOCKS         (3L)        // Stops after a certain number of scans acquired (specify which clock)

// ===== For DQ_SYNC_5200 and DQ_SYNC_5200S =====
#define DQ_TRIGSTOP5_SYNCIN0       DQ_TRIGSTOP5_SYNCIN0  // SyncIn0 delivers trigger
#define DQ_TRIGSTOP5_SCANS         DQ_TRIGSTOP5_SCANS    // Stops after a certain number of scans acquired

// ==== For DQ_SYNC_IRIG650 ====
#define DQ_TRIGSTOP650_TIME         (4L)        // issue start trigger upon a specific time

#define DQ_TRIGSTOP_DEFAULT         (0)         // Leave it to each individual card

// <trig_stop_src>
// use DQ_USE_SYNCx line to assign stop trigger line

// ==== SECTION E ==============================================================================
//
// For all destination signals: there is no direct output for 8347 CPUs, user needs to feed signal to one
// of the SYNC lines and then route it to the output
// For 5200 only one DQ_nPPSDEST_SYNCOUT0 and DQ_nPPSDEST_SYNCIN0 exist
//

// Each of the output assignment should you DQ_USE_SYNCx constant to tell what SYNCx line
// to take the clock from
//
// For <pps_dest> - where to feed nPPS clock (i.e. into outside world)
// use DQ_USE_SYNCx to define SYNC line
#define DQ_nPPSDEST_SYNCOUT0        (1L<<0)     // Feed the clock to SYNCOUT0
#define DQ_nPPSDEST_SYNCOUT1        (2L<<0)     // Feed the clock to SYNCOUT1

// For <trig_dest> - where to feed trigger (i.e. into outside world)
// use DQ_USE_SYNCx to define SYNC line
#define DQ_TRGDEST_SYNCOUT0         (1L<<0)     // Feed the trigger to SYNCOUT0
#define DQ_TRGDEST_SYNCOUT1         (2L<<0)     // Feed the trigger to SYNCOUT1

// For <clclk_dest[]> - where to feed each CL clock (i.e. into outside world)
// Note: up to three clocks can be created on the SYNC lines (i.e. from EM0 and two dividers)
// use DQ_USE_SYNCx to define SYNC line
#define DQ_CLKDEST_SYNCOUT0         (1L<<0)     // Feed the clock to SYNCOUT0
#define DQ_CLKDEST_SYNCOUT1         (2L<<0)     // Feed the clock to SYNCOUT1


// =============================================================================================
// for DqSyncGetSyncStatus()

typedef struct {
    uint32 status;  // ADPLL status register
    uint32 min_per; // Minimum period length for the input clock
    uint32 avg_per; // Averaged detected length of the VALIDATED input period
    uint32 max_per; // Maximum period length for the input clock
    uint32 lst_per; // Measured length of the last input period
    uint32 acc_err; // Accumulated pulse position error in system clocks

} DQ_SYNC_ADPLL_STAT, *pDQ_SYNC_ADPLL_STAT;


typedef struct {
    DQ_SYNC_ADPLL_STAT adpll_sts;       // ADPLL status
    uint32 pll_stat[DQL_CPU_PLL_MAX];   // whether PLLs are locked (8347/5200 "classic" have only one PLL)
    uint32 pps_status;                  // status of nPPS signal
    uint32 gps_irig;                    // combined status of GPS/IRIG receiver
    uint32 evm_stat;                    // event module status
    uint32 sync_snap;                   // snapshot of the SYNC lines
    uint32 sync_conn;                   // snapshot of the SyncIn/SyncOut lines
    uint32 reserved[4];                 // reserved
    uint32 time_since_pps;              // how long since the last PPS
} DQ_SYNC_STATUS, *pDQ_SYNC_STATUS;

// =============================================================================================
// for DqSyncDefineNTPServer()
typedef struct {
    uint32 strata;
    uint32 resolution;
} DQ_SYNC_DEFNTP, *pDQ_SYNC_DEFNTP;

// =============================================================================================
// for DqSyncDefinePTPServer()
#define DQ_PTP_USE_STATIC_MASTER  (1L<<0)
#define DQ_PTP_NO_OPS_TS_RESET    (1L<<1)

typedef struct {
    uint32 cfg;                         // bitmask for PTP configuration

    uint8 subdomain;                    // PTP subdomain number
    uint8 priority1;                    // priority of the device
    uint8 priority2;
    int8  logSyncInterval;              // log2(period of sync messages)

    int8  logMinDelayRequestInterval;   // log2(minimum space between delay requests)
    int8  logAnnounceInterval;          // log2(period of announce messages)
    uint8 announceTimeout;
    uint8 utcOffset;                    // number of leap seconds between TIA and UTC
                                        // (37 as of 2017/11/1) last known value set
                                        // use this to handle additional leap seconds
                                        // since compile.

    uint32 reserved[5];

    // nonstandard extensions
    uint32 static_master_ip;

} DQ_SYNC_DEFPTP, *pDQ_SYNC_DEFPTP;


// =============================================================================================
// for DqSyncGetPTPStatus()

// defines for port state
#define DQ_PTP_PORT_STATE_INIT         (1)
#define DQ_PTP_PORT_STATE_FAULTY       (2)
#define DQ_PTP_PORT_STATE_DISABLED     (3)
#define DQ_PTP_PORT_STATE_LISTENING    (4)
#define DQ_PTP_PORT_STATE_PRE_MASTER   (5)
#define DQ_PTP_PORT_STATE_MASTER       (6)
#define DQ_PTP_PORT_STATE_PASSIVE      (7)
#define DQ_PTP_PORT_STATE_UNCALIBRATED (8)
#define DQ_PTP_PORT_STATE_SLAVE        (9)

typedef struct {
    uint32 reserved;

    uint32 state;              // Current PTP state

    uint64 grandMasterClockID; // PTP clock ID of the grand master of the system.
    uint64 masterClockID;      // PTP clock ID of the current master.

    uint32 stepsFromGrandMaster;  // The value of the PTP data set stepsRemoved.
    uint32 grandMasterClockClass; // The PTP grand master clock class taken from the master's announce messages.

    uint32 reserved0[2];
    int32 meanPathDelay;       // Current calculated mean path delay.
    int32 lastMeasuredOffset;  // Last calculated time offset from master
    int32 maxMeasuredOffset;   // Maximum calculated time offset from master.
    int32 minMeasuredOffset;   // Minimum calculated time offset from master.
    int32 avgMeasuredOffset;   // Average calculated time offset from master.
    uint32 reserved1[8];

    // packet statistics
    uint32 totalPkts;          // Total PTP packets received on the domain.
    uint32 announceRcvd;       // the following parameters are counters of packets sent or accepted by type.
    uint32 announceSnt;         // The following counters won't increment if a message is rejected
    uint32 syncRcvd;           // because the IOM is in the wrong stated.
    uint32 syncSnt;
    uint32 followUpRcvd;
    uint32 followUpSnt;
    uint32 delyReqRcvd;
    uint32 delyReqSnt;
    uint32 delyRspRcvd;
    uint32 delyRspSnt;
    uint32 signalingRcvd;
    uint32 signalingSnt;
} DQ_SYNC_PTP_STAT, *pDQ_SYNC_PTP_STAT;

// =============================================================================================
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 evtmask;                 // subtype of reported events (mask)
    uint32 status;                  // event status register
    uint32 tstamp;                  // timestamp of event taken from layer TS generator
    uint32 size;                    // size of the following data in bytes
    uint32 avail;                   // number of bytes available
    uint32 data[DQ_FLEX_ARRAY];     // data to follow (byte pointer - ntohx() and convert properly)
} EVSYNC_ID, *pEVSYNC_ID;

// Types of event
typedef enum {
    EVSYNC_CLEAR = 0x1000,        // clear all events

    // sync events
    EVSYNC_1PPS  = 0x101,  // 1PPS clock from ADPLL event
    EVSYNC_ADPLL_LOST,     // ADPLL lost input clock for more than two periods
    EVSYNC_NTP_LOST,       // NTP server connection lost for more than a defined period
    EVSYNC_PTP_LOST,       // PTP server connection lost for more than a defined period
    EVSYNC_GLOB_START,     // Global start trigger occurred. Returns timestamp upon global trigger
    EVSYNC_GLOB_STOP       // Global stop trigger occurred
} evsync_t;

// =============================================================================================
// This is for
// DqSyncDefineLayerClock(..., clock_line, ...)

typedef struct {
    int clk_line;   // clock line to use
    int divider;    // 0=original clock, 1..n = divide clock by (n+1)
    int grp_delay;  // group delay in samples, -1 = auto define
    uint32 flags;   // flags to change mode of operation
} DQ_SYNC_DEF_CLOCKS, *pDQ_SYNC_DEF_CLOCKS;


#define DQ_SYNCCLLK_SYNC0    1   // SYNC0
#define DQ_SYNCCLLK_SYNC1    2   // SYNC1
#define DQ_SYNCCLLK_SYNC2    3   // SYNC2
#define DQ_SYNCCLLK_SYNC3    4   // SYNC3
#define DQ_SYNCCLLK_SYNCIN0  5   // SYNCIN0
#define DQ_SYNCCLLK_SYNCIN1  6   // SYNCIN1
#define DQ_SYNCCLLK_DEFAULT  0   // layer decides (used to disable)


// Flags for DqSyncDefineLayerClock
#define DQ_SYNCLCLK_CLOCK_PER_SCAN    (1L<<28)  // Force layer to use clock per scan mode
#define DQ_SYNCLCLK_ISSUE_IMMEDIATE   (1L<< 0)  // Set clock divider to issue clock next clock after trigger.
// =============================================================================================
// This is for
// DqSyncDefineLayerTrigger
#define DQ_SYNCTRG_SYNC0    1   // SYNC0
#define DQ_SYNCTRG_SYNC1    2   // SYNC1
#define DQ_SYNCTRG_SYNC2    3   // SYNC2
#define DQ_SYNCTRG_SYNC3    4   // SYNC3
#define DQ_SYNCTRG_SYNCIN0  5   // SYNCIN0
#define DQ_SYNCTRG_SYNCIN1  6   // SYNCIN1
#define DQ_SYNCTRG_SOFT     7   // software trigger
#define DQ_SYNCTRG_DEFAULT  0   // layer decides (used to disable)

#define DQ_SYNCTRG_MODE_INV           (1L<<0) // Use falling edge as start trigger, use rising edge is stop trigger
#define DQ_SYNCTRG_MODE_NOSTOP        (1L<<1) // Do not configure a stop trigger

// =============================================================================================
// This is for
// DqSyncDefineLayerTimestamp
#define DQ_SYNCTST_SYNC0    1   // SYNC0
#define DQ_SYNCTST_SYNC1    2   // SYNC1
#define DQ_SYNCTST_SYNC2    3   // SYNC2
#define DQ_SYNCTST_SYNC3    4   // SYNC3
#define DQ_SYNCTST_SYNCIN0  5   // SYNCIN0
#define DQ_SYNCTST_SYNCIN1  6   // SYNCIN1
#define DQ_SYNCTST_DEFAULT  0   // layer decides (used to disable)

// =============================================================================================
// This is for
// DqSyncDefineStartStop

// =============================================================================================
// This is for
// DqSyncGetUTCTimeFromPTP
typedef struct {
    uint32 reserved;   // reserved
    uint32 sec;        // PTP time in seconds
    uint32 nsec;       // PTP time nanoseconds
    uint32 timestamp;  // timestamp from the CPU layer to the time above
    uint32 flags;      // status flags relating the returned time.
} DQ_SYNC_UTC_TIME, *pDQ_SYNC_UTC_TIME;

#define DQ_SYNC_UTCTM_OFFSINVLAID     (1L<<0)  // UTC Offset is invalid
#define DQ_SYNC_UTCTM_ARB_PTPTSCALE   (1L<<1)  // PTP master is using an arbitrary timescale
#define DQ_SYNC_UTCTM_TIMEVALID       (1L<<31) // Time is known.  Either we are master or PTP slave.

#define DQ_IMX_ADC_CHANS_PER_ADC    (4)         // number of i.MX6 ADC channels on each ADC
#define DQ_IMX_ADC_NUM_ADCS         (2)         // number of i.MX6 ADC's
#define DQ_IMX_ADC_CHANS            (DQ_IMX_ADC_CHANS_PER_ADC * DQ_IMX_ADC_NUM_ADCS)   // =8, number of total ADC channels
#define DQ_IMX_ADC_VREF_X_1K        (3300)      // reference voltage times 1000
#define DQ_IMX_ADC_STEPS_12         (4095)      // steps in a 12-bit conversion
#define DQ_IMX_V_DIVIDER            (2)         // conversion ratio for all ADC inputs < 24V
#define DQ_IMX_V_DIVIDER_24V        (11)        // conversion ratio for solox 24V
#define DQ_IMX_V_DIVIDER_21         (21)        // Vin,24V integer conversion ratio for 1010
#define DQ_IMX_V_DIVIDER_21_D       (21.04)     // Vin,24V double conversion ratio for 1010


typedef struct {
    uint32 fcal;        // current CPU frequency calibration value
    uint32 fcal_date;   // last cal date
    uint32 model;       // solox model (hex)
    uint32 bom;         // major bom rev, same as pcb rev
    uint32 logic;       // cpu layer logic version
    uint32 today_date;  // return today's date
    uint32 ts;
    uint32 cpu_temp;
    uint32 resv;
} DQ_FCALDATA_10, *pDQ_FCALDATA_10;
#define DQ_CPU10_FREQ_SETCAL        (0)         // DQSETCAL.channel
#define DQ_CPU10_FREQ_SETCALDATE    (1)         // default is IOM date
#define DQ_CPU10_FREQ_SETCALFLWR    (2)         // FLash WRite, save

//  DqAdvDnxCpuRead() 'sel' parameter,  SoloX only
#define DQ_CPU10_READ_VOLTS         (0)         // read diagnostic voltages
#define DQ_CPU10_READ_HRDEGC        (1)         // read hours meter and cpu die temperature
#define DQ_CPU10_READ_CLK_FREQ      (2)         // read clock freq when pps is on sync[0], for calibration use only
#define DQ_CPU10_READ_CLK_FREQ_EXT  (3)         // read clock w/pps on TR-In & IGnd, PIO-1010 calibration use only
#define DQ_CPU10_READ_CLK_FREQ_SYNC (4)         // read clock w/pps connected to sync conn on power layer, uses sync[0]


// MAX 10 JTAG port definitions
#define MAX10_JTAG_OPEN             (1<<0)     // Enable access
#define MAX10_JTAG_CLOSE            (1<<1)     // Disable access
#define MAX10_JTAG_TMSTDITCK        (1<<2)     // Direct access to tms/tdi/tck pins
#define MAX10_JTAG_FWVER            (1<<3)     // on-board MSP430 microcontroller firmware version

// Error codes for MAX 10 IC reprogramming
#define JPERR_OK                                    (1)     // successful call
#define JPERR_MEMALOC                               (-105)  // unable to allocate memory
#define JPERR_SUPASS                                (-109)  // bad SU password

// Logic Reprogramming static buffers for MAX10
#define UNKNOWN_BUFFER               (0x0)
#define _STRING_TABLE                (0x1)
#define _PROC_TABLE                  (0x2)
#define _VARIABLES                   (0x3)   // variables buffer is a 2-d array
#define _VARIABLE_SIZE               (0x4)
#define _ATTRIBUTES                  (0x5)
#define _PROC_ATTRIBUTES             (0x6)
#define _NESTED_BUF                  (0x7)


// Definitions for DNx NIS logic programming

//Cyclone Raw Binary File (.rbf) Sizes (Bytes)
#define EP1C3_FILE_SIZE             (78422)     // EP1C3
#define EP1C4_FILE_SIZE             (115564)    // EP1C4
#define EP1C6_FILE_SIZE             (145902)    // EP1C6
#define EP1C12_FILE_SIZE            (209405)    // EP1C12
#define EP1C20_FILE_SIZE            (444951)    // EP1C20
//Cyclone II Raw Binary File (.rbf) Sizes (Bytes)
#define EP2C5_FILE_SIZE             (152998)    // EP2C5
#define EP2C8_FILE_SIZE             (247974)    // EP2C8
#define EP2C15_FILE_SIZE            (486562)    // EP2C15
#define EP2C20_FILE_SIZE            (486562)    // EP2C20
#define EP2C35_FILE_SIZE            (857332)    // EP2C35
#define EP2C50_FILE_SIZE            (1245424)   // EP2C50
#define EP2C70_FILE_SIZE            (1789902)   // EP2C70
//Cyclone V E Raw Binary File (.rbf) Sizes (Bytes)
#define EP5CEA2_FILE_SIZE           (2632660)   // 5CEA2
#define EP5CEA4_FILE_SIZE           (2632660)   // 5CEA4
#define EP5CEA5_FILE_SIZE           (4244820)   // 5CEA5
#define EP5CEA7_FILE_SIZE           (7020944)   // 5CEA7
#define EP5CEA9_FILE_SIZE           (12858972)  // 5CEA9
#define FPGA_IMAGE_MAX_SIZE         (EP5CEA9_FILE_SIZE)

#define LPROG_WR_DONE_MAX           166000000
#define LPROG_RD_DONE_MAX           166000000
#define LPROG_BUSY_MAX              166000000
#define LPROG_WAIT_FLAG_MAX         166000000


// Devices list size for logic reprogramming
#define LOGIC_PROG_DEV_LIST_SZ      (DQ_MAXDEVN/2) // 16

// Error codes for FPGA load IC reprogramming
#define LPERR_OK                                    (1)     // successful call
#define LPERR_BUSY                  /*0xFFFFFF9C*/  (-100)  // CS4 module is busy
#define LPERR_CMDRD                 /*0xFFFFFF9B*/  (-101)  // read command in progress
#define LPERR_CMDWR                 /*0xFFFFFF9A*/  (-102)  // write command in progress
#define LPERR_ADDROUTRANGE          /*0xFFFFFF99*/  (-103)  // device address out of range EXT_DEV_ADDRESS2...EXT_DEV_ADDRESS3
#define LPERR_UNABLECOMMSP          /*0xFFFFFF98*/  (-104)  // unable to communicate with on-layer MSP microcontroller
#define LPERR_MEMALOC               /*0xFFFFFF97*/  (-105)  // unable to allocate memory
#define LPERR_EPCSOVERFULL          /*0xFFFFFF96*/  (-106)  // FPGA load IC is overfull
#define LPERR_BADCRC                /*0xFFFFFF95*/  (-107)  // bad CRC
#define LPERR_IMGVERSIZE            /*0xFFFFFF94*/  (-108)  // Image size exceeds FPGA load IC size
#define LPERR_SUPASS                /*0xFFFFFF93*/  (-109)  // bad SU password
#define LPERR_IO2_EMPTY_NOREPROG    /*0xFFFFFF92*/  (-110)  // DNR I/O 2 slot empty or layer does not support logic updating
#define LPERR_IO3_NOT_EMPTY         /*0xFFFFFF91*/  (-111)  // DNR I/O 3 slot not empty
#define LPERR_WRONG_CPU_MODEL       /*0xFFFFFF90*/  (-112)  // CPU layer does not support logic updating
#define LPERR_NOREPROG              /*0xFFFFFF8F*/  (-113)  // logic reprogramming is not supported by layer
#define LPERR_IO_NOT_EMPTY          /*0xFFFFFF8E*/  (-114)  // DNR I/O x slot not empty
#define LPERR_IO1_12_NOT_EMPTY      /*0xFFFFFF8D*/  (-115)  // DNR slots (I/O 1,3-12) are not empty
#define LPERR_IO3_4_NOT_EMPTY       /*0xFFFFFF8E*/  (-116)  // DNF slots (I/O 3,4) are not empty
#define LPERR_IO1_EMPTY_NOREPROG    /*0xFFFFFF8F*/  (-117)  // DNR I/O 1 slot empty or layer does not support logic updating

// Total number of Serial Configuration Device (EPCS1, EPCS4, EPCS16, EPCS64, EPCQ16, EPCQ32, EPCQ64 and N/A )
#define EPCSx_TOTAL_DEV              8

// Firmware or high level application can control the DNR backplane limitation
#define DNR_BP_LIMITATION_FW         0x0
#define DNR_BP_LIMITATION_APP        0x2
// Check MAX10 FPGA config instead of EPCS/EPCQ/EPCQA (Cyclone Serial Configuration Device)
#define LRFW_MAX10                   0x4

// FPGA type (Cyclone/MAX10)
#define FPGA_TYPE_NA                 0x10
#define FPGA_TYPE_CYCLONE            0x20
#define FPGA_TYPE_MAX10              0x40

// Serial Configuration Device EPCS/EPCQ/EPCQA Page Size (Bytes)
#define EPCSx_PAGESIZE               256

// FPGA type (Cyclone/MAX10)
#define FPGA_TYPE_NA                 0x10
#define FPGA_TYPE_CYCLONE            0x20
#define FPGA_TYPE_MAX10              0x40

// Serial Configuration Device Memory Size (Bytes)
// EPCS Series
#define EPCS1_SIZE_BYTES        131072        //   1 Mbits (  1,048,576 bits)
#define EPCS4_SIZE_BYTES        524288        //   4 Mbits (  4,194,304 bits)
#define EPCS16_SIZE_BYTES      2097152        //  16 Mbits ( 16,777,216 bits)
#define EPCS64_SIZE_BYTES      8388608        //  64 Mbits ( 67,108,864 bits)
// EPCQ/EPCQA Series
#define EPCQ16_SIZE_BYTES      2097152        //  16 Mbits ( 16,777,216 bits)
#define EPCQ32_SIZE_BYTES      4194304        //  32 Mbits ( 33,554,432 bits)
#define EPCQ64_SIZE_BYTES      8388608        //  64 Mbits ( 67,108,864 bits)
#define EPCQ128_SIZE_BYTES    16777216        // 128 Mbits (134,217,728 bits)
#define EPCQ256_SIZE_BYTES    33554432        // 256 Mbits (268,435,456 bits)
#define EPCQ512_A_SIZE_BYTES  67108864        // 512 Mbits (536,870,912 bits)

// Serial Configuration Device total number of pages = EPCSx_SIZE_BYTES / EPCSx_PAGESIZE
#define EPCS1_PAGES                512
#define EPCS4_PAGES               2048
#define EPCS16_PAGES              8192
#define EPCS64_PAGES             32768
#define EPCQ16_PAGES              8192
#define EPCQ32_PAGES             16384
#define EPCQ64_PAGES             32768

// Serial configuration devices list (EPCSx: C51014-5.1.pdf Table 14; EPCQx: CF5212.pdf Table 29)
#define MSPSDC_EPCSx           0x00                 // EPCSx series mask
#define MSPSDC_EPCQx           0x80                 // EPCQx series mask
#define MSPSDC_EPCS1           (MSPSDC_EPCSx|0x10)  // EPCS1   ID=0x10
#define MSPSDC_EPCS4           (MSPSDC_EPCSx|0x12)  // EPCS4   ID=0x12
#define MSPSDC_EPCS16          (MSPSDC_EPCSx|0x14)  // EPCS16  ID=0x14
#define MSPSDC_EPCS64          (MSPSDC_EPCSx|0x16)  // EPCS64  ID=0x16
#define MSPSDC_EPCQ16          (MSPSDC_EPCQx|0x15)  // EPCQ16  ID=0x95
#define MSPSDC_EPCQ32          (MSPSDC_EPCQx|0x16)  // EPCQ32  ID=0x96 (EPCQ32 or EPCQ32A)
#define MSPSDC_EPCQ64          (MSPSDC_EPCQx|0x17)  // EPCQ64  ID=0x97 (EPCQ64A)

// macros for getting Serial Configuration Devices ID
#define MSPDEV_IDX_0           0
#define MSPDEV_IDX_1           1
#define MSPDEV_IDX_2           2
#define MSPDEV_IDX_3           3
#define MSPDEV_IDX_4           4
#define MSPDEV_IDX_5           5
#define MSPDEV_IDX_6           6
#define MSPDEV_IDX_UD          7
#define DEV_IND(v)             ((v==MSPSDC_EPCS1) ?MSPDEV_IDX_0:\
                                (v==MSPSDC_EPCS4) ?MSPDEV_IDX_1:\
                                (v==MSPSDC_EPCS16)?MSPDEV_IDX_2:\
                                (v==MSPSDC_EPCS64)?MSPDEV_IDX_3:\
                                (v==MSPSDC_EPCQ16)?MSPDEV_IDX_4:\
                                (v==MSPSDC_EPCQ32)?MSPDEV_IDX_5:\
                                (v==MSPSDC_EPCQ64)?MSPDEV_IDX_6:MSPDEV_IDX_UD\
                               )

typedef struct {
   int tm_sec;                      /* seconds after the minute - [0,59] */
   int tm_min;                      /* minutes after the hour - [0,59] */
   int tm_hour;                     /* hours since midnight - [0,23] */
   int tm_mday;                     /* day of the month - [1,31] */
   int tm_mon;                      /* months since January - [0,11] */
   int tm_year;                     /* years since 1900 */
   int tm_wday;                     /* days since Sunday - [0,6] */
   int tm_yday;                     /* days since January 1 - [0,365] */
   int tm_isdst;                    /* daylight savings time flag */
} ANSI_TIME, *pANSI_TIME;

#define DNx_ADDR_BUS_TEST_MASK      (0x0000FFFC)// Only 14 address bits (A15-A2) are involved into the bus testing

#pragma pack(1)
/* structure for hardware tests data */
typedef struct
{
    uint32  cpu_memtest_enable;     // enable/disable memory test loop
    uint32  error;                  // total errors
    uint32  dnx_data_bus_staus;     // DNx data lines (D31-D0) test status. 0-passed/1-failed
    uint32  dnx_addr_bus_staus;     // DNx address lines test status. 0-passed/1-failed.
                                    // NOTE: Only 14 address bits (A15-A2) are involved into the bus testing
    char    str[80];                // output buffer
} HW_TEST_DATA, *pHW_TEST_DATA;
#pragma pack()

// Keep last four nibbles zero
//
#define LNERR_NOTIMP                (0xFFFFFFFF) // function is not implemented
#define LNERR_OK                    (0x1)        // successful call
#define LNERR_DISABLED              (0x81000000) // layer or subsystem is disabled

#define LNERR_NOEEPROM              (0x85010000) // layer doesn't have EEPROM
#define LNERR_EEREAD                (0x85020000) // EEPROM read fails; xxxx - offset
#define LNERR_EEWRITE               (0x85030000) // EEPROM write fails; xxxx - offset
#define LNERR_EECRC                 (0x85040000) // EEPROM CRC doesn't match

#define LNERR_NOMEM                 (0x80010000) // not enough memory to allocate structures
#define LNERR_BUSY                  (0x80020000) // memory is busy

#define LNERR_CVINPROGRESS          (0x83010000) // WARNING: conversion in progress data may not be valid
#define LNERR_CURVALUE              (0x83020000) // WARNING: currend data is returned data may not be valid
#define LNERR_CLMODE                (0x83030000) // WARNING: device in CL mode
#define LNERR_NOTREADY              (0x83040000) // WARNING: device is busy output previous write to the isolated side
#define LNERR_BADPARAM              (0x83050000) // incorrect parameters
#define LNERR_BADQUEUE              (0x83060000) // requested queue doesn't exist
#define LNERR_NODATA                (0x83070000) // cnt is bigger than data available
#define LNERR_NOCL                  (0x83080000) // device doesn't support channel list
#define LNERR_INTPARAM              (0x83090000) // internal error
#define LNERR_BADCL                 (0x830A0000) // error in the channel list (lower 16 bit is erroneous entry)
#define LNERR_TOOFAST               (0x830B0000) // channel list cannot be acquired at desirable rate
#define LNERR_IOERROR               (0x830C0000) // I/O error
#define LNERR_NOTSUPP               (0x830D0000) // command not supported
#define LNERR_EXECERR               (0x830E0000) // command execution error

// Interrupt routine returns
#define LNERR_BOGUSINT              (0x86010000) // layer wasn't the source of int
#define LNERR_OVRFLOW               (0x86020000) // overflow event has happened

#define LNERR_MAX_ERROR             (0x8FFFFFFF) // maximum error number for layer driver


// DNx CPU layer type
#define TYPE_DNA_CPU_CM1          (1)
#define TYPE_DNA_PPC_CPU          (2)       // 2005  2008
#define TYPE_DNR_PPC_CPU          (3)
#define TYPE_DNA_PPC_1GB          (4)       // 3005  3008
#define TYPE_DNR_PPC_1GB          (5)       // 3004  3006  3012
#define TYPE_DNA_MIL_PPC_1GB      (6)       // DNA MIL cpu id 3204
#define TYPE_DNR_MIL_PPC_1GB      (7)       // DNR MIL cpu id 3212

/* SoloX DNx CPU layer type */
#define TYPE_DNA_SOLOX_1GB        (0x10)    // 4003 4005 4008 4009
#define TYPE_DNR_SOLOX_1GB        (0x11)    // 4006 4012
#define TYPE_DNA_MIL_SOLOX_1GB    (0x14)    // 4206
#define TYPE_DNR_MIL_SOLOX_1GB    (0x15)    // 4212
#define TYPE_DNA_SOLOX_PIO1010    (0x1010)  // 1010

// Format definition to create capabilities text
#define _CAPS_DEVNAME_F     "DevName=%s%x\n"
#define _CAPS_DEVNAME_CPU_F "DevName=%s%x-%x\n"
#define _CAPS_OPTION_F      "Option=%x\n"
#define _CAPS_OPTION_3F     "Option=%03x\n"
#define _CAPS_SERIAL_F      "Serial=%07d\n"
#define _CAPS_CALDATE_F     "CalDate=%02x-%02x-%02x\n"
#define _CAPS_CALEXP_F      "CalExp=%02x-%02x-%02x\n"
#define _CAPS_MFGDATE_F     "MfgDate=%02x-%02x-%02x\n"
#define _CAPS_FWREV_F       "FwRev=%x\n"
#define _CAPS_FWBUILD_F     "FwBuild=%x\n"
#define _CAPS_FWINFOSTR_F   "FwInfoStr=%s\n"
#define _CAPS_LOGICREV_F    "LogicRev=%02x.%02x.%02x\n"
#define _CAPS_FIFO_SZ_F     "FifoSizes=%d,%d\n"
#define _CAPS_ADDR_F        "BaseAddr=0x%x\n"
#define _CAPS_IRQ_F         "Irq=%x\n"
#define _CAPS_MAXPKT_SZ_F   "MaxPkt=%d\n"
#define _CAPS_ACBPKT_SZ_F   "AcbPkt=%d\n"
#define _CAPS_FWCT_F        "FWCT=%d.%d.%d.%d\n"
#define _CAPS_LAYERS_F      "Layers=%d\n"
#define _CAPS_DEVSINFO_F    "L%d=(%x-%x,%d,%x)\n"
#define _CAPS_IOMIP_F       "IP%s=%d.%d.%d.%d\n"
#define _CAPS_IOMMAC_F      "MAC%s=%02x:%02x:%02x:%02x:%02x:%02x\n"
#define _CAPS_SD_F          "SdType=%c\n"
#define _CAPS_SDRAMSZ_F     "RAMSz=%d\n"
#define _CAPS_FLASHSZ_F     "FlashSz=%d\n"
#define _CAPS_UBOOT_F       "UBoot=%s\n"


#pragma pack(1)
// This structure is located in the EEPROM of every device
typedef struct {
    /* header is standard for all devices */
                                    /* superuser access */
    uint16  model;                  /* device model to verify EEPROM identity */
    uint16  option;                 /* device option */
    uint16  total;                  /* total EEPROM size - EEPROM read is expensive */
                                    /* if this field <32 or >2048 read all2048 bytes */
    uint32  sernum;                 /* serial number - pad to %07d when printing */
    uint32  mfgdate;                /* manufacturing date:  0xmmddyyyy */
                                    /* user access */
    uint32  caldate;                /* calibration date:    0xmmddyyyy */
    uint32  calexpd;                /* calibration expired: 0xmmddyyyy */

    /* header is followed by device-specific data structures */

    /* total 5.5 u32s = 22 bytes */
} DQEECMNDEVS, *pDQEECMNDEVS;

/* Located on layers designed 2015+ (s/n 148000+) */
typedef struct {
    uint16  ee_ver;     // version of eeprom structure
    uint32  crc;        // located on every layer
} DQEEPROMTAIL, *pDQEEPROMTAIL;

#define DQPRMFLAGS_RESERVED_SIZE    (62)

// Common "flags" structure
typedef struct {
    uint32  flag_ver;   // reserved for (hardware) revision
    uint32  dcard_sn;   // daughter card serial number
    uint32  card_info;  // additional card information
    uint32  val[DQPRMFLAGS_RESERVED_SIZE];    // reserved

} DQPRMFLAGS, *pDQPRMFLAGS;

// Common "flags" structure for layers which use almost all EEPROM
typedef struct {
    uint32  flag_ver;   // reserved for (hardware) revision
    uint32  dcard_sn;   // daughter card serial number
    uint32  card_info;  // additional card information
} DQPRMFLAGSA, *pDQPRMFLAGSA;

#pragma pack()


/* status offsets into devobj.status array */
#define STS_NUMBER_WORDS            (4)         // number of status words per layer
#define STS_STATE                   (0)         // current status including "alive" counter
#define STS_POST                    (1)         // post status
#define STS_FW                      (2)         // firmware status
#define STS_LOGIC                   (3)         // logic status

/* state flags */
#define STS_STATE_TS_SH             (8)
#define STS_STATE_TS_INS(S,TS,MD)   ((S & 0xffff00f0)|((TS<<8) & 0xff00)|(MD&0xf))
// bits 3..0 of the state flags show the last reported operating mode of the layer, elsewhere defined as:
//#define DQ_IOMODE_INIT            (1L)        // device is being initialized
//#define DQ_IOMODE_CFG             (2L)        // device in configuration mode
//#define DQ_IOMODE_OPS             (4L)        // device in operation mode
//#define DQ_IOMODE_SD              (8L)        // device in shutdown mode

#define STS_STATE_STICKY            (0)

/* Behavior in parenthesis */
/* (B) - boot up */
/* (C) - continuously monitored */
/* (F) - upon executing functions */

/* logic status flags (offset 3) */
#define STS_LOGIC_DC_OOR            (1UL<<0)    // (C) DC/DC out of range (IOM also)
#define STS_LOGIC_DC_FAILED         (1UL<<1)    // (C) DC/DC failed (IOM also)
#define STS_LOGIC_TRIG_START        (1UL<<2)    // (C) Trigger event started (IOM also)
#define STS_LOGIC_TRIG_STOP         (1UL<<3)    // (C) Trigger event stopped (IOM also)
#define STS_LOGIC_CLO_NOT_RUNNING   (1UL<<4)    // (C) Output channel list not running
#define STS_LOGIC_CLI_NOT_RUNNING   (1UL<<5)    // (C) Input channel list not running
#define STS_LOGIC_CVCLK_CLO_ERR     (1UL<<6)    // (C) CV clock error for CLO
#define STS_LOGIC_CVCLK_CLI_ERR     (1UL<<7)    // (C) CV clock error for CLI
#define STS_LOGIC_CLCLK_CLO_ERR     (1UL<<8)    // (C) CL clock error for CLO
#define STS_LOGIC_CLCLK_CLI_ERR     (1UL<<9)    // (C) CL clock error for CLI

// CPU Layer only = current status of the connection - from 4.9 tree
// 00 = no connection or no information on connection
// 01 = 1000-Base-T
// 10 = 100-Base-T
// 11 = Error state
#define STS_LOGIC_NIC1_1000         (1L<<14)    // (C) NIC1 is connected to Gig-E network
#define STS_LOGIC_NIC1_100          (1L<<15)    // (C) NIC1 is connected to 100-Base-T network
#define STS_LOGIC_NIC2_1000         (1L<<16)    // (C) NIC2 is connected to Gig-E netwerk
#define STS_LOGIC_NIC2_100          (1L<<17)    // (C) NIC2 is connected to 100-Base-T network


#define STS_LOGIC_CALIBRATING       (1UL<<30)   //
#define STS_LOGIC_NO_REPORTING      (1UL<<31)   // installed logic doesn't support error reporting

#define STS_LOGIC_STICKY            (STS_LOGIC_NO_REPORTING|STS_LOGIC_CALIBRATING)

/* fw status flags (offset 2) */
/* Note: Some flags may apply to a certain types of layers thus the meaning of the bits can be */
/* different for different layer types */

#define STS_FW_CLK_OOR              (1UL<<0)    // (F) Clock out of range (IOM also)
#define STS_FW_SYNC_ERR             (1UL<<1)    // (C) Synchronization interface error (IOM also)
#define STS_FW_CHNL_ERR             (1UL<<2)    // (F) Channel list is incorrect
#define STS_FW_BUF_SCANS_PER_INT    (1UL<<3)    // (F) Too few samples per interrupt - interrupt rate is too high
#define STS_FW_BUF_SAMPS_PER_PKT    (1UL<<4)    // (F) Buf setting error: samples/packet
#define STS_FW_BUF_RING_SZ          (1UL<<5)    // (F) Buf setting error: FW buffer ring size
#define STS_FW_BUF_PREBUF_SZ        (1UL<<6)    // (F) Buf setting error: Pre-buffering size
#define STS_FW_BAD_CONFIG           (1UL<<7)    // (F) Layer cannot operate in current config
#define STS_FW_BUF_OVER             (1UL<<8)    // (C) Firmware buffer overrun
#define STS_FW_BUF_UNDER            (1UL<<9)    // (C) Firmware buffer underrun
#define STS_FW_LYR_FIFO_OVER        (1UL<<10)   // (C) Layer FIFO overrun
#define STS_FW_LYR_FIFO_UNDER       (1UL<<11)   // (C) Layer FIFO underrun warning
#define STS_FW_EEPROM_FAIL          (1UL<<12)   // (BF) Layer EEPROM failed
#define STS_FW_GENERAL_FAIL         (1UL<<13)   // (C) Layer general failure
#define STS_FW_ISO_TIMEOUT          (1UL<<14)   // (C) Isolated part reply timeout
#define STS_FW_FIR_GAIN_ERR         (1UL<<15)   // (F) Sum of fir coeffs is not correct
#define STS_FW_OUT_FAIL             (1UL<<16)   // (C) Output CB tripped or over-current
#define STS_FW_IO_FAIL              (1UL<<17)   // (C) Messaging I/O failed (5xx layers)
#define STS_FW_NO_MEMORY            (1UL<<18)   // (C) Error with memory allocation
#define STS_FW_BAD_OPER             (1UL<<19)   // (F) Operation wasn't performed properly
#define STS_FW_LAYER_ERR            (1UL<<20)   // (F) Layer returned unexpected value
#define STS_FW_OVERLOAD             (1UL<<21)   // (C) CPU or Ethernet is starved out of time or told to free the wire

#define STS_FW_RES22                (1UL<<22)   // () Reserved 22
#define STS_FW_RES23                (1UL<<23)   // () Reserved 23
#define STS_FW_RES24                (1UL<<24)   // () Reserved 24
#define STS_FW_RES25                (1UL<<25)   // () Reserved 25
#define STS_FW_RES26                (1UL<<26)   // () Reserved 26
#define STS_FW_RES27                (1UL<<27)   // () Reserved 27
#define STS_FW_RES28                (1UL<<28)   // () Reserved 28

#define STS_FW_SD_CARD_BUSY         (1UL<<29)   // (C) SD card subsystem is busy(e.g. format,speed test)
#define STS_FW_CONFIG_DONE          (1UL<<30)   // (F) Configuration is completed (not an error)
#define STS_FW_OPER_MODE            (1UL<<31)   // (F) Layer entered operation mode successfully

// (C) CPU layer only
#define STS_FW_DIAG_0               (1UL<<3)    // (F) Port 0 is in diagnostics mode (CPU only)
#define STS_FW_DIAG_1               (1UL<<4)    // (F) Port 1 is in diagnostics mode (CPU only)

/* POST status flags (offset 1) */
#define STS_POST_MEM_FAIL           (1L<<0)    // (B) Memory test failed
#define STS_POST_EEPROM_FAIL        (1L<<1)    // (B) E2PROM read failed
#define STS_POST_LAYER_FAILED       (1L<<2)    // (C) Layer failure
#define STS_POST_FLASH_FAILED       (1L<<3)    // (B) Flash checksum error
#define STS_POST_SDCARD_FAILED      (1L<<4)    // (C) SD Card is not present
#define STS_POST_DC24               (1L<<5)    // (C) DC->24 layer failed
#define STS_POST_DCCORE             (1L<<6)    // (C) Core voltages problem
#define STS_POST_BUSTEST_FAILED     (1L<<7)    // (B) bus test failed (hw_test.c)
#define STS_POST_BUSFAIL_DATA       (1L<<8)    // (B) Bus test failed on data test
#define STS_POST_BUSFAIL_ADDR       (1L<<9)    // (B) Bus test failed on address test
#define STS_POST_OVERHEAT           (1L<<10)   // (C) Overheat detected
#define STS_POST_OVERCURRENT        (1L<<11)   // (C) Layer DC/DC reported overcurrent
#define STS_POST_RESET_FAILED       (1L<<12)   // (B) Uint hasn't been properly reset
#define STS_POST_UNRECOG_LAYER      (1L<<13)   // (B) Layer or backplane cannot be recognized by the firmware

#define STS_POST_STICKY             (STS_POST_MEM_FAIL|STS_POST_BUSTEST_FAILED|STS_POST_BUSFAIL_DATA|STS_POST_BUSFAIL_ADDR)

/* STS_STATE status flags (offset 0) */
#define STS_STATE_MODE(N)           (((N)&0xf))     // lower 4 bits are dedicated for mode
#define STS_STATE_TSTAMP(N)         (((N)&0xff00))  // second byte is dedicated for the lower part of the timestamp

#define STS_POST_STICKY (STS_POST_MEM_FAIL|STS_POST_BUSTEST_FAILED|STS_POST_BUSFAIL_DATA|STS_POST_BUSFAIL_ADDR)

/* status helper macros/defines */
#define STS_FW_STICKY (STS_FW_EEPROM_FAIL | STS_FW_GENERAL_FAIL)
#define STS_FW_BAD_CONFIG_MASK (STS_FW_CLK_OOR | STS_FW_BUF_SCANS_PER_INT | STS_FW_BUF_SAMPS_PER_PKT | STS_FW_BUF_RING_SZ | STS_FW_BUF_PREBUF_SZ)
#define STS_LOGIC_BAD_MASK (STS_LOGIC_DC_OOR | STS_LOGIC_DC_FAILED | STS_LOGIC_CVCLK_CLO_ERR | STS_LOGIC_CVCLK_CLI_ERR | STS_LOGIC_CLCLK_CLO_ERR | STS_LOGIC_CLCLK_CLI_ERR)

#define SET_STS_FLAG(DEV, SS, FG, FLAG)     (((pDEVOBJ)(DEV))->status[(SS)&7][FG] |= FLAG)
#define SET_STS_FLAGp(DEV, SS, FG, FLAG)    {(((pDEVOBJ)(DEV))->status[(SS)&7][FG] |= FLAG); _printf("line=%d ss=%d sts=%x\n", __LINE__, SS,((pDEVOBJ)(DEV))->status[SS][FG]);}
#define CLR_STS_FLAG(DEV, SS, FG, FLAG)     (((pDEVOBJ)(DEV))->status[(SS)&7][FG] &= (~FLAG))
#define IF_STS_FLAG(DEV, SS, FG, FLAG)      (((pDEVOBJ)(DEV))->status[(SS)&7][FG] & (FLAG))
#define GET_STS_FLAGS(DEV, SS, FG)          (((pDEVOBJ)(DEV))->status[(SS)&7][FG])

/* event number cannot exceed 0xff - 0x100 is the start of event enumerator */
/* Layer DQEVENTs should be above 0x1000 */
#define DQEVENT_SETUP         1   // set event parameters
#define DQEVENT_DISPATCH      2   // dispatch packet to the device driver
#define DQEVENT_ENABLE        3   // enable/disable events
#define DQEVENT_INTERNAL      4   // set internal processing of events
#ifdef __UEIPAC__
#define DQEVENT_WAIT          5
#endif

#define DQEVENT_MASK_ENABLE_ADDITIVE  (1L<<31)   // a bit to control selected layers only
#define DQEVENT_MASK_DISABLE_ADDITIVE (1L<<30)   // a bit to control selected layers only

#define DQEVENT_NOREPLY       (1L<<31)  // do not reply to this event
#define DQEVENT_ONCE          (1L<<30)  // fire event only once
#define DQEVENT_NOSTORE       (1L<<29)  // do not store UDP port to generate events
#define DQEVENT_LAYER         0x1000    // block of layer events specific to the layer

/* Commands to set asynchronous Dmap/Vmap */
#define DQAXMAP_CLEAR               (1)     // clear all settings
#define DQAXMAP_TEST                (2)     // test required time
#define DQAXMAP_SET_TIMING          (3)     // and timing parameters
#define DQAXMAP_SET_SLOT            (4)     // set asynchronous slot
#define DQAXMAP_ENABLE              (5)     // enable/disable aDMap/aVMap operations
#define DQAXMAP_SET_WATERMARK       (6)     // set the watermark level (vmap only)
#define DQAXMAP_SET_EXT_CLK_SRC     (7)     // set external clock source to pace refersh

// Flags for VMap/Dmap operations - passed as a flag (first uint16) in VMap/Dmap packet
#define DQ_VMAP_REREQUEST       (1L<<0)     // re-request VMap packet over again (also sent back from the cube on output re-request)
#define DQ_VMAP_ALT_PROC        (1L<<1)     // IN: use alternative processing function to process all VMap by the layer as one block
#define DQ_VMAP_RESENT          (1L<<1)     // missed packet is re-sent
#define DQ_VMAP_NOACK           (1L<<2)     // only output packet without acknowledge
#define DQ_VMAP_OUTACK          (1L<<3)     // acknowledge if the output packet
#define DQ_VMAP_CONTROL         (1L<<4)     // do not output, control aVmap input sizes
#define DQ_VMAP_SET_OUT_CTR     (1L<<5)     // set output counter to the packet counter
#define DQ_VMAP_SET_IN_CTR      (1L<<6)     // set input counter to the packet counter

#define DQ_VMAP_FLAG_MASK       (0x7f)      // mask flags

/* Limits for Firmware and Logic Buffer Writes */
#define DQ_FLSHBUF_PKT_MAX      (512)

// These layers have non-standard (not 2K) EEPROM size and/or different memory access mechanism than others
#define DQ_WHEEPROM_VALID(layer) ( (layer==0x440) ? 0:\
                                   (layer==0x470) ? 0:\
                                   (layer==0x358) ? 0:\
                                   (layer==0x910) ? 0:\
                                   (layer==0x911) ? 0:\
                                   (layer==0x912) ? 0:\
                                   (layer==0x913) ? 0:\
                                   (layer==0x921) ? 0:\
                                   (layer==0x923) ? 0:\
                                   (layer==0x925) ? 0:\
                                   (layer==0x926) ? 0: 1)

#define DQ_MX6SX_FLASH_FIRMWARE_OFFSET  (0x00200000)
#define DQ_MX6SX_FLASH_FIRMWARE_SIZE    (0x00800000)

#define DQ_PPC_FLASH_ADDRESS        (0xFFC00000)
#define DQ_PPC_FLASH_SIZE           (0x00400000)
#define DQ_PPC_FLASH_FIRMWARE_OFFSET (0x00010000)

#define DQ_FIRMWARE_ENTRY_ROM       (0xFFC10000)
#define DQ_UBOOT_ENTRY_ROM          (0xFFF00100)
#define DQ_UBOOT_DATA_SEG           (0xFFF20000)
#define DQ_UBOOT_DATA_SEG_SZ        (0x20000)


#define DQ_FLASH_ADDRESS            (DQ_PPC_FLASH_ADDRESS)
#define DQ_FLASH_SIZE               (DQ_PPC_FLASH_SIZE)
#define DQ_FLASH_FIRMWARE_OFFSET    (DQ_PPC_FLASH_FIRMWARE_OFFSET)

#define SDRAM_ADDRESS               (0x00000000)
#define SDRAM_SIZE                  (0x08000000)

#define EXT_DEV_ADDRESS2            (0xA0000000)
#define IOM_BASE_ADDRESS            (0xA00E0000)
#define IOM_BCAST_ADDRESS           (0xA00F0000)
#define EXT_DEV_ADDRESS3            (0xA0100000)
#define EXT_DEV_ADDRESS4            (0xA0200000)
#define EXT_DEV_ADDRESS5            (0xA0300000)
#define IOM_BASE_IRQ                (2)

#define EXT_DEV_SIZE                (0x01000000)


#define DQ_PPC8347_FLASH_ADDRESS_32             (0xFE000000)
#define DQ_PPC8347_FLASH_SIZE_32                (0x02000000)
#define DQ_PPC8347_FLASH_FIRMWARE_OFFSET_32     (0x01800000)
#define PARAM_SEC_32                            (252)           /* start param sector */
#define PARAM_ADDR_32                           (0x01f80000)    /* param sector addr offset */
#define UBOOTENV_SEC_32                         (253)            /* sector where uboot environment is stored */
#define UBOOTENV_ADDR_32                        (0x01fA0000)    /* uboot environment address offset */

#define DQ_PPC8347_UPUSER_SEC_32                (192)       /* start of user sector on MPC8347 */
#define DQ_PPC8347_UEIPACKERNEL_SEC_32          (0)         /* start of UEIPAC kernel sector on MPC8347 */
#define DQ_PPC8347_UEIPACRAMDISK_SEC_32         (16)        /* start of UEIPAC ramdisk sector on MPC8347 */


#define DQ_PPC8347_FLASH_ADDRESS_128            (0xF8000000)
#define DQ_PPC8347_FLASH_SIZE_128               (0x08000000)
#define DQ_PPC8347_FLASH_FIRMWARE_OFFSET_128    (0x07800000)
#define PARAM_SEC_128                           (1020)          /* start param sector */
#define PARAM_ADDR_128                          (0x07f80000)    /* param sector addr */
#define UBOOTENV_SEC_128                        (1021)          /* sector where uboot environment is stored */
#define UBOOTENV_ADDR_128                       (0x07fA0000)    /* uboot environment address offset */

#define DQ_PPC8347_UPUSER_SEC_128               (960)       /* start of user sector on MPC8347 */
#define DQ_PPC8347_UEIPACKERNEL_SEC_128         (768)       /* start of UEIPAC kernel sector on MPC8347 0xfe000000 */
#define DQ_PPC8347_UEIPACRAMDISK_SEC_128        (184)        /* start of UEIPAC ramdisk sector on MPC8347 + 16 */

// These depricated constants are preserved for compatibility with the older code which doesn't report size in caps
#define DQ_PPC8347_MAXFWSIZE                    0x700000        /* Maximum size of the firmware code */
#define DQ_PPC8347_FLASH_SIZE                   (0x02000000)
#define DQ_PPC8347_FLASH_FIRMWARE_OFFSET        (0x01800000)
// 

#define INT_DNR_POWER_ADDRESS       (0xA00C0000)
#define INT_GIGE_POWER_ADDRESS      (0xA00D0000)
#define INT_GIGE_LOGIC_ADDRESS      (0xA00E0000)
#define INT_CM2_LOGIC_ADDRESS       (0xA00E0000)


#define DQ_CF_UPUSER_SEC            (4)         /* start of user sector on CF5272*/
#define DQ_PPC_UPUSER_SEC           (8)         /* start of user sector on MPC5200 */
#define DQ_PPC_UEIPACKERNEL_SEC     (21)        /* start of UEIPAC kernel sector on MPC5200 */

//#define DQ_PPC8347_UPUSER_SEC       (192)       /* start of user sector on MPC8347 */
//#define DQ_PPC8347_UEIPACKERNEL_SEC (0)         /* start of UEIPAC kernel sector on MPC8347 */
//#define DQ_PPC8347_UEIPACRAMDISK_SEC (16)        /* start of UEIPAC ramdisk sector on MPC8347 */


#define MODID_CPU_MASK  0xF000    // access only the CPU type
// i.MX6SX CPU
#define MODID6_DNF4    0x4004    // flat rack
#define MODID6_DNR6    0x4006    // half-rack
#define MODID6_DNR12   0x4012    // full rack
#define MODID6_DNM12   0x4212    // DNR-MIL rack id = 7
#define MODID6_DNM4    0x4204    // DNA-MIL cube
#define MODID6_BRK4    0x4304    // BRICK-4
#define MODID6_DNM6    0x4206    // DNR-MIL6 rack
#define MODID6_PIO1    0x4401    // PIO unit
#define MODID6_DNA3    0x4003    // 3-layer cube, 'Net'
#define MODID6_DNA5    0x4005    // 5-layer cube
#define MODID6_DNA8    0x4008    // 8-layer cube
#define MODID6_DNA9    0x4009    // 9-layer cube
#define MODID6_UNKNOWN 0x4000    // unknown layer type

// PPC-8347ea CPUs
#define MODID_DNF4    0x3004    // flat rack
#define MODID_DNR6    0x3006    // half-rack
#define MODID_DNR12   0x3012    // full rack
#define MODID_DNM12   0x3212    // DNR-MIL rack id = 7
#define MODID_DNM4    0x3204    // DNA-MIL cube
#define MODID_BRK4    0x3304    // BRICK-4
#define MODID_DNM6    0x3206    // DNR-MIL6 rack
#define MODID_DNA3    0x3003    // 3-layer cube, 'Net'
#define MODID_DNA5    0x3005    // 5-layer cube
#define MODID_DNA8    0x3008    // 8-layer cube
#define MODID_DNA9    0x3009    // 9-layer cube
#define MODID_UNKNOWN 0x3000    // unknown layer type

// PPC-5200 CPUs
#define MODID5_DNA3    0x2003    // 3-layer cube, 'Net'
#define MODID5_DNA5    0x2005    // 5-layer cube
#define MODID5_DNA8    0x2008    // 8-layer cube
#define MODID5_UNKNOWN 0x2000    // unknown layer type

#define CPUMOD_5200_DNA         2
#define CPUMOD_5200_DNR         3
#define CPUMOD_8347_DNA         4
#define CPUMOD_8347_DNR         5
#define CPUMOD_8347_DNAMIL      6
#define CPUMOD_8347_DNRMIL      7

#ifndef __UEIPAC__
// CPU identification register and ID
#define SPRIDR              0xE0000108  // CPU and revision ID register
#define CPUMODE_8347A       0x8035  // 8347A in TBGA package
#define CPUMODE_8347EA      0x8034  // 8347EA in TBGA package
#endif

// MF-101

#define DQ_MF101_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_MF101_BASE               (BUS_FREQUENCY)     // 66MHz base frequency

#define DQ_MF101_SS_AI          (DQ_SS0IN)
#define DQ_MF101_SS_AO          (DQ_SS0OUT)
#define DQ_MF101_SS_DI          (DQ_SS1IN)
#define DQ_MF101_SS_DO          (DQ_SS1OUT)
#define DQ_MF101_SS_GUARDIAN    (DQ_SS2IN)
#define DQ_MF101_SS_CT          (DQ_SS2OUT)
#define DQ_MF101_SS_I2C         (DQ_SS3IN)
#define DQ_MF101_SS_SERIAL      (DQ_SS3OUT)

// Define for DQCMD_SETCLK to set individual subsystem clock
#define DQ_MF101_CLKID_SS           (0) // clocksel/clkid for subsystem clock

// Additional CL defines
#define DQ_MF101_MAX_CLI_FREQ       (32000.0)   // Max rate = Max AI rate = 2kHz * 16 channels
#define DQ_MF101_MAX_CLO_FREQ       (100000.0)  // Max rate = Max AO rate = 50kHz * 2 channels
#define DQ_MF101_CLI_SS(RAW)        (((RAW) >> 28) & 0x7)   // Extract subsystem from CL data

// Channel list subsystem defines
#define DQ_MF101_CLI_SS_AIN     (0)        // AIn
#define DQ_MF101_CLI_SS_DINF    (1)        // Digital FET, reserved
#define DQ_MF101_CLI_SS_DINA    (2)        // Digital ADC
#define DQ_MF101_CLI_SS_DINT    (3)        // Digital TTL, reserved
#define DQ_MF101_CLI_SS_RS      (4)        // Serial RS-232/485, reserved
#define DQ_MF101_CLI_SS_I2C     (5)        // I2C, reserved
#define DQ_MF101_CLI_TIMESTAMP  (1L << 31) // Indicates data is timestamp

#define DQ_MF101_CLI_AI_CHAN(RAW)   (((RAW) >> 20) & 0x3f)  // Extract channel from CL AI data
#define DQ_MF101_CLI_AI_DATA(RAW)   ((RAW) & 0x3ffff)       // Extract data from CL AI data
#define DQ_MF101_CLI_DI_CHAN(RAW)   (((RAW) >> 20) & 0xf)   // Extract channel from CL DI data
#define DQ_MF101_CLI_DI_TYPE(RAW)   (((RAW) >> 16) & 0x7)   // Extract type from CL DI data
#define DQ_MF101_CLI_DI_DATA(RAW)   (((RAW) >> 0) & 0xffff) // Extract data from CL DI data

#define DQ_MF101_CLI_DI_TYPE_IMM        (0) // Immediate ADC data
#define DQ_MF101_CLI_DI_TYPE_AVG        (1) // Averaged ADC data
#define DQ_MF101_CLI_DI_TYPE_COS_L_TO_H (2) // Change of state, low to high
#define DQ_MF101_CLI_DI_TYPE_COS_H_TO_L (3) // Change of state, high to low
#define DQ_MF101_CLI_DI_TYPE_STATE      (4) // State

#define DQ_MF101_CLO_AO_CHAN(CH)        (((CH) == 0) ? 0 : (1L << 23)) // bit 23 controls AO channel

// Special subsystem defines for VMap
#define DQ_MF101_VMAP_SS_CHAN_IN    (DQ_SS3IN)  // Use DQ_MF101_VMAP_CHAN_IN_ defines
#define DQ_MF101_VMAP_SS_CHAN_OUT   (DQ_SS3OUT) // Use DQ_MF101_VMAP_CHAN_OUT_ defines

// SS=DQ_MF101_VMAP_SS_CHAN_IN
#define DQ_MF101_VMAP_CHAN_IN_SERIAL    (0xff00)    // Input serial data

// SS=DQ_MF101_VMAP_SS_CHAN_OUT
#define DQ_MF101_VMAP_CHAN_OUT_SERIAL   (0xff01)    // Output serial data

// special channels for use with DMap
// SS=DQ_MF101_SS_DI
#define DQ_MF101_DMAP_DI_FET_STATE      (0x0)   // Get current state of FET lines
#define DQ_MF101_DMAP_DI_FET_DEB        (0x1)   // Get debounced state of FET lines
#define DQ_MF101_DMAP_DI_TTL            (0x2)   // Get current state of TTL lines
#define DQ_MF101_DMAP_DI_CT_0           (0x3)   // Read from CT 0, OR with DQ_MF101_CT_CHNLTYPE_ defines
#define DQ_MF101_DMAP_DI_CT_1           (0x4)   // Read from CT 1, OR with DQ_MF101_CT_CHNLTYPE_ defines
                                                // For CT DMAP channels DQ_MF101_CT_CHNLTYPE_SHADOW should not be used.

// SS=DQ_MF101_SS_DO
#define DQ_MF101_DMAP_DO_FET            (0x0)  // Set state of FET lines
#define DQ_MF101_DMAP_DO_TTL            (0x1)  // Set state of TTL (+TRIG_OUT) lines
#define DQ_MF101_DMAP_DO_CT_0           (0x2)  // Read from CT , OR with DQ_MF101_CT_CHNLTYPE_ defines (CR0 or CR1)
#define DQ_MF101_DMAP_DO_CT_1           (0x3)  // Read from CT , OR with DQ_MF101_CT_CHNLTYPE_ defines (CR0 or CR1)
#define DQ_MF101_DMAP_DIO_MASK          (0xf)  // Channel mask for DIO DMAP channels, only bottom 4 bits
                                               // are available due to CT channels needing DQ_MF101_CT_CHNLTYPE_
// SS=DQ_MF101_SS_GUARDIAN
#define DQ_MF101_DMAP_GUARD_DI_ADC_CHAN (DQ_MF101_DIADC_ADC_CHAN) // Logical OR with FET channel number

// extracts TTL status from raw TTL data
#define DQ_MF101_DMAP_DI_TTL_DATA(RAW)  (((RAW) & DQ_MF101_TTL_STS_MASK) >> DQ_MF101_TTL_STS_SHIFT)

// create write data for low-side and high-side FET control
#define DQ_MF101_DMAP_DO_FET_DATA(LOW, HIGH)    ((((LOW) & 0xffff)) | (((HIGH) & 0xffff) << 16))

// TTL DMap control
#define DQ_MF101_DMAP_DO_TTL_3_2_EN         (1L << 21) // enable TTL 3 and 2 as outputs, otherwise use as input
#define DQ_MF101_DMAP_DO_TTL_1_0_EN         (1L << 20) // enable TTL 1 and 0 as outputs, otherwise use as input
#define DQ_MF101_DMAP_DO_TTL_0(ST)          (((ST) & 0x1) << 0)  // set TTL 0 state, 0=low 1=high
#define DQ_MF101_DMAP_DO_TTL_1(ST)          (((ST) & 0x1) << 4)  // set TTL 1 state, 0=low 1=high
#define DQ_MF101_DMAP_DO_TTL_2(ST)          (((ST) & 0x1) << 8)  // set TTL 2 state, 0=low 1=high
#define DQ_MF101_DMAP_DO_TTL_3(ST)          (((ST) & 0x1) << 12) // set TTL 3 state, 0=low 1=high
#define DQ_MF101_DMAP_DO_TTL_TRIG_OUT(ST)   (((ST) & 0x1) << 16) // set TRIG_OUT state, 0=low 1=high

// Guardian
#define DQ_MF101_GUARDIAN_AO    (0)
#define DQ_MF101_GUARDIAN_DI    (1)

// DIO FET + DI ADC
#define DQ_MF101_DIO_CHAN         (16)

#define DQ_MF101_DIADC_CHAN_MASK  (0xf)
#define DQ_MF101_DIADC_DFLT_DIV   (0xA5) // 400kHz
#define DQ_MF101_DIADC_MAX_RATE   (400000.0) // Max ADC rate 400kHz
#define DQ_MF101_DIADC_STARTDELAY (5000)    // microseconds
#define DQ_MF101_DIADC_MAX        (0xffff)
#define DQ_MF101_DIADC_DATA_READY (1L << 31) // 1=data was updated after last read
#define DQ_MF101_DIADC_DATA_MASK  (0xffff)
#define DQ_MF101_DIADC_CL_SIZE    (16)
#define DQ_MF101_DIADC_SPAN       (10.0)
#define DQ_MF101_DIADC_STEP       (DQ_MF101_DIADC_SPAN / DQ_MF101_DIADC_MAX)
#define DQ_MF101_DIADC_OFFSET     (5.0)
#define DQ_MF101_DIADC_DIV_R1     (1000000.0)
#define DQ_MF101_DIADC_DIV_R2     (68000.0)
#define DQ_MF101_DIADC_DIV_VAL    (DQ_MF101_DIADC_DIV_R2 / (DQ_MF101_DIADC_DIV_R2 + DQ_MF101_DIADC_DIV_R1)) // 0.06367041198501872
#define DQ_MF101_DIADC_FLOAT_MAX  (((DQ_MF101_DIADC_MAX * DQ_MF101_DIADC_STEP) - DQ_MF101_DIADC_OFFSET) / DQ_MF101_DIADC_DIV_VAL) // ~78.53
#define DQ_MF101_DIADC_LEVEL_MAX  (55.0)    // max voltage for low and high levels

// Use with DqAdvRawToScale to get DIn ADC conversion, OR with actual ADC channel number
#define DQ_MF101_DIADC_ADC_CHAN         (0x20)

// For use with DQL_IOCTL101_CFG_MAV_DI
#define DQ_MF101_DI_MAV_MAX         (8)     // max moving average value

// DO FET
// Default break-before-make clocks
#define DQ_MF101_DO_BBM_DEF         (132)   // 2us

// for use with <DQMF101DOPWM.pwm_mode>
#define DQ_MF101_DO_PWM_DISABLED    (0)     // PWM and soft start disabled
#define DQ_MF101_DO_PWM_SOFTSTART   (1)     // use PWM to soft-start (when output changes from 0 to 1)
#define DQ_MF101_DO_PWM_SOFTSTOP    (2)     // use PWM to soft-stop (when output changes from 1 to 0)
#define DQ_MF101_DO_PWM_SOFTBOTH    (3)     // use PWM to soft-start and soft-stop
#define DQ_MF101_DO_PWM_MODE        (4)     // use output in PWM mode
#define DQ_MF101_DO_PWM_MODE_GATED  (5)     // use output in gated PWM mode

// for use with <DQMF101DOPWM.output_mode>
#define DQ_MF101_DO_PWM_OFF         (0)     // No PWM applied to high or low side FETs
#define DQ_MF101_DO_PWM_PULL        (1)     // only low-side FET is switching, high-side is OFF
#define DQ_MF101_DO_PWM_PUSH        (2)     // only high-side FET is switching, low-side is OFF
#define DQ_MF101_DO_PWM_PUSH_PULL   (3)     // both high side and low side FET are switching

#define DQ_MF101_DO_PWM_PERIOD_US_MAX   (254200) // Max PWM period

#pragma pack(1)
typedef struct {
    uint8 channel;        // channel to configure PWM
    uint8 pwm_mode;       // soft start/stop or base PWM mode
    uint8 output_mode;    // push, pull, or push-pull output mode
    uint32 period_us;     // PWM period in us
    float duty_cycle;     // percent duty_cycle. ex duty_cycle=0.5 results in 50% duty cycle
    uint32 soft_stop_us;  // soft stop duration in us. unused in PWM_MODE and PWM_MODE_GATED
    uint32 soft_start_us; // soft start duration in us. unued in PWM_MODE and PWM_MODE_GATED
} MF101DOPWM, *pMF101DOPWM;



#pragma pack()

// For use with DQL_IOCTL101_CFG_TERM_DO
#define DQ_MF101_DO_TERM_PU(CH)   (1L << (((CH) * 2) + 1))  // enable pull-up on channel
#define DQ_MF101_DO_TERM_PD(CH)   (1L << ((CH) * 2))        // enable pull-down on channel

// AIN
#define DQ_MF101_AI_DFLT_DIV     (0xA121F) // 100Hz
#define DQ_MF101_AI_MAX_RATE     (2000.0)  // 2kHz
#define DQ_MF101_AI_CHAN         (16)      // 16 single-ended channels
#define DQ_MF101_AI_CHAN_DIFF    (8)       // 8 differential channels
#define DQ_MF101_AI_GAINS        (4)       // 4 available user gains
#define DQ_MF101_AI_RANGES       (2)       // low/high voltage range
#define DQ_MF101_AI_STARTDELAY   (5000)    // microseconds
#define DQ_MF101_AI_DIV_R1       (140000.0)
#define DQ_MF101_AI_DIV_R2       (1000000.0)
#define DQ_MF101_AI_DIV_VAL      (0.122807017543859649)
#define DQ_MF101_AI_FIFO_SZ      (4096)
#define DQ_MF101_AI_DEF_GAIN     (0x20000)
#define DQ_MF101_AI_DEF_OFFS     (0x0)
#define DQ_MF101_AI_MUX_DELAY_CUTOFF_HZ (1500) // slower clock rates than this use longer mux delay for
                                            // higher accuracy. faster rates lose some accuracy.
                                            // refer to MF101_AI_OFFS_DLY_DFLT_FAST/SLOW

#define DQ_MF101_AI_CL_SIZE      (32)
#define DQ_MF101_AI_CL_AVG_EN    (1L << 20) // override auto avg setting
#define DQ_MF101_AI_CL_AVG_LSB   (16)
#define DQ_MF101_AI_CL_AVG_MSB   (19)
#define DQ_MF101_AI_CL_GND       (0x30)     // special read channel, will pass AGDN to ADC
                                            // for reading. Requires 5-6 second settling time

#define DQ_MF101_AI_DATA_READY   (1L << 31) // 1=data was updated after last read
#define DQ_MF101_AI_DATA_PGA_EF  (1L << 30) // 1=PGA error flag is set
#define DQ_MF101_AI_DATA_MASK    (0x3FFFF)
#define DQ_MF101_AI_MAX          (0x3FFFF)
#define DQ_MF101_AI_SPAN_1       (20.0)
#define DQ_MF101_AI_STEP_1       (DQ_MF101_AI_SPAN_1 / DQ_MF101_AI_MAX)
#define DQ_MF101_AI_OFFSET_1     (10.0)
#define DQ_MF101_AI_SPAN_4       (5.0)
#define DQ_MF101_AI_STEP_4       (DQ_MF101_AI_SPAN_4 / DQ_MF101_AI_MAX)
#define DQ_MF101_AI_OFFSET_4     (2.5)
#define DQ_MF101_AI_SPAN_16      (1.25)
#define DQ_MF101_AI_STEP_16      (DQ_MF101_AI_SPAN_16 / DQ_MF101_AI_MAX)
#define DQ_MF101_AI_OFFSET_16    (0.625)
#define DQ_MF101_AI_SPAN_64      (0.3125)
#define DQ_MF101_AI_STEP_64      (DQ_MF101_AI_SPAN_64 / DQ_MF101_AI_MAX)
#define DQ_MF101_AI_OFFSET_64    (0.15625)

// bits 8-11 for use with DQ_LNCL_GAIN    (  low      / high ) low=divider disabled, high=divider enabled
#define DQ_MF101_AI_GAIN_1      (0)    // (+-10V      / +-80V)
#define DQ_MF101_AI_GAIN_4      (1)    // (+-2.5V     / +-20V)
#define DQ_MF101_AI_GAIN_16     (2)    // (+-0.625V   / +-5V)
#define DQ_MF101_AI_GAIN_64     (3)    // (+-0.15625V / +-1.25)

// For use with MF101CFG_AI struct moving_average field
#define DQ_MF101_AI_MAV_1        (0)
#define DQ_MF101_AI_MAV_2        (1)
#define DQ_MF101_AI_MAV_4        (2)
#define DQ_MF101_AI_MAV_8        (3)
#define DQ_MF101_AI_MAV_16       (4)
#define DQ_MF101_AI_MAV_32       (5)
#define DQ_MF101_AI_MAV_64       (6)
#define DQ_MF101_AI_MAV_128      (7)
#define DQ_MF101_AI_MAV_256      (8)

// AOUT
#define DQ_MF101_AO_CHAN             (2)
#define DQ_MF101_AO_CHAN_MASK        (0x1)  // Mask of channel in AO channel list entries
#define DQ_MF101_AO_CL_SIZE          (32)
#define DQ_MF101_AO_DAC_MAX_TRIES    (600)
#define DQ_MF101_AO_WR_DATA_SHIFT    (4)
#define DQ_MF101_AO_WR_DATA_MASK     (0xffff)
#define DQ_MF101_AO_STARTDELAY       (5000)
#define DQ_MF101_AO_FIFO_SZ          (4096)
#define DQ_MF101_AO_FIFO_DIV_DFLT    (0x527)   // 50kHz
#define DQ_MF101_AO_FIFO_MAX_RATE    (50000.0)
#define DQ_MF101_AO_DAC_RD_DIV_DFLT  (0xA121F) // 66MHz / 660000 = 100Hz
#define DQ_MF101_AO_DAC_MAX_RATE     (1000.0)  // Max DAC read rate 1kHz
#define DQ_MF101_AO_DAC_WR_DATA_MASK (0xffff)
#define DQ_MF101_AO_DAC_RD_DATA_MASK (0xfff)

// for use with DqAdv101AOReadAdc
// bitwise OR with AO channel number to select which AO DAC
#define DQ_MF101_AO_ADC_CHAN          (4)    // Number of available AO ADC channels
#define DQ_MF101_AO_ADC_CHAN_TEMP     (0x10) // DAC main die temperature (degrees C)
#define DQ_MF101_AO_ADC_CHAN_VSENSE_P (0x14) // DAC voltage on Vsense+ (volts)
#define DQ_MF101_AO_ADC_CHAN_VSENSE_N (0x18) // DAC voltage on Vsense- (volts)
#define DQ_MF101_AO_ADC_CHAN_VDPC_P   (0x1C) // DAC voltage on Vdpc+ (volts)
#define DQ_MF101_AO_ADC_DISABLE       (0xffffffff) // Disable ADC readback
#define DQ_MF101_AO_ADC_CHAN_MASK     (0x1C) // bitmask for ADC channel
#define DQ_MF101_AO_ADC_GETCHAN(C)    (C & DQ_MF101_AO_CHAN_MASK)   // Extract AO channel number
#define DQ_MF101_AO_ADC_GETTYPE(C)    (C & DQ_MF101_AO_ADC_CHAN_MASK)   // Extract ADC channel type, one of DQ_MF101_AO_ADC_CHAN_

// for use with DQL_IOCTL101_CFG_AO
#define DQ_MF101_AO_RANGES           (7)  // includes 2 "special" ranges, OFF and EN_PD
#define DQ_MF101_AO_RANGE_PN_5V      (0)  // +-5V
#define DQ_MF101_AO_RANGE_PN_10V     (1)  // +-10V
#define DQ_MF101_AO_RANGE_0_20MA     (2)  // 0 to 20mA
#define DQ_MF101_AO_RANGE_4_20MA     (3)  // 4 to 20mA
#define DQ_MF101_AO_RANGE_N_1_P_22MA (4)  // -1 to +22mA
#define DQ_MF101_AO_RANGE_OFF        (5)  // disable DAC DC/DC
#define DQ_MF101_AO_RANGE_EN_PD      (6)  // enable 30kOhm pulldown resistor to ground on output
#define DQ_MF101_AO_RANGE_OVERRANGE_EN (1L << 4) // OR with selected range to enable 20% overrange
                                                 // on voltage ranges
                                                 // note overrange is uncalibrated and should
                                                 // only be used for diagnostics
                                                 // +-5V  -> +-6V
                                                 // +-10V -> +-12V
#define DQ_MF101_AO_RANGE_MASK       (0xf)

#define DQ_MF101_AO_OVERRANGE_SCALE   (1.2)
#define DQ_MF101_AO_SPAN_PN_5V        (10.0)
#define DQ_MF101_AO_OFFSET_PN_5V      (5.0)
#define DQ_MF101_AO_STEP_PN_5V        (DQ_MF101_AO_SPAN_PN_5V / 65535.0)
#define DQ_MF101_AO_SPAN_PN_10V       (20.0)
#define DQ_MF101_AO_OFFSET_PN_10V     (10.0)
#define DQ_MF101_AO_STEP_PN_10V       (DQ_MF101_AO_SPAN_PN_10V / 65535.0)
#define DQ_MF101_AO_SPAN_0_20MA       (20.0)
#define DQ_MF101_AO_OFFSET_0_20MA     (0.0)
#define DQ_MF101_AO_STEP_0_20MA       (DQ_MF101_AO_SPAN_0_20MA / 65535.0)
#define DQ_MF101_AO_SPAN_4_20MA       (16.0)
#define DQ_MF101_AO_OFFSET_4_20MA     (-4.0)
#define DQ_MF101_AO_STEP_4_20MA       (DQ_MF101_AO_SPAN_4_20MA / 65535.0)
#define DQ_MF101_AO_SPAN_N_1_P_22MA   (23.0)
#define DQ_MF101_AO_OFFSET_N_1_P_22MA (1.0)
#define DQ_MF101_AO_STEP_N_1_P_22MA   (DQ_MF101_AO_SPAN_N_1_P_22MA / 65535.0)
/*
#define DQ_MF101_AO_SPAN_PN_24MA      (48.0)
#define DQ_MF101_AO_OFFSET_PN_24MA    (24.0)
#define DQ_MF101_AO_STEP_PN_24MA      (DQ_MF101_AO_SPAN_PN_24MA / 65535.0)
*/

// for use with MF101_AO_CFG
#define DQ_MF101_AO_MODES            (3)
#define DQ_MF101_AO_MODE_DPC_I       (1)  // DPC current mode
#define DQ_MF101_AO_MODE_DPC_V       (2)  // DPC voltage mode
#define DQ_MF101_AO_MODE_PPC_I       (3)  // PPC current mode

// for use with DQL_IOCTL101_CTRL_WFORM_AO
#define DQ_MF101_AO_WFORM_ENABLE    (0x0) // control enable/disable
#define DQ_MF101_AO_WFORM_FLUSH     (0x1) // flush all data in fifo (clear waveform)

// DQ_MF101_AO_WFORM_ENABLE
#define DQ_MF101_AO_WFORM_CH_MASK   (0x3)
#define DQ_MF101_AO_WFORM_RELOAD    (1L << 2) // enable continuous reload of waveform

// DIO TTL
#define DQ_MF101_TTL_CHAN           (5)     // 4 + TRIG IN/OUT
#define DQ_MF101_TTL_BASE_CHAN      (4)     // Channels not including TRIG IN/OUT
#define DQ_MF101_TTL_STS_MASK       (0x1f0) // TTL data mask from MF101_STS
#define DQ_MF101_TTL_STS_SHIFT      (4)     // TTL data shift from MF101_STS

// for use with DQL_IOCTL101_WR_TTL and DQL_IOCTL101_RD_TTL
#define DQ_MF101_TTL_WRRD_TRIGOUT     (1L << 4)         // TRIGOUT high
#define DQ_MF101_TTL_WRRD_TTL3        (1L << 3)         // TTL3 high
#define DQ_MF101_TTL_WRRD_TTL2        (1L << 2)         // TTL2 high
#define DQ_MF101_TTL_WRRD_TTL1        (1L << 1)         // TTL1 high
#define DQ_MF101_TTL_WRRD_TTL0        (1L << 0)         // TTL0 high
#define DQ_MF101_TTL_WRRD_TTL(LINE)   (1L << (LINE))

// Serial
#define DQ_MF101_SERIAL_CHAN         (1)
#define DQ_MF101_SERIAL_MFIFO_1M     (1000000) // 1MHz major FIFO clock
#define DQ_MF101_SERIAL_FIFO_SZ      (2048)
#define DQ_MF101_SERIAL_MAJORSZ      (1024)
#define DQ_MF101_SERIAL_MAX_TERM_LEN (128) // max length for termination string

// additional flags within serial data, will be included with data read using DqAdv101SerialReadRxFIFOEx
#define DQ_MF101_SERIAL_DATA_TS      (1L << 15) // data is timestamp. add_ts_on_idle must be enabled for this
#define DQ_MF101_SERIAL_DATA_FAE     (1L << 11) // FIFO almost empty, this data is the last remaining in FIFO
#define DQ_MF101_SERIAL_DATA_PE      (1L << 10) // parity error detected with this data
#define DQ_MF101_SERIAL_DATA_FE      (1L << 9)  // frame error detected with this data
#define DQ_MF101_SERIAL_DATA_BI      (1L << 8)  // break indicator for current data

#pragma pack(1)

// for use with DQL_IOCTL101_CFG_SERIAL
typedef struct {
    uint32 flags;

    // baud rate
    uint32 baud_rate;

    // general channel config
    uint32 mode;
    uint32 loopback; // =1 enable
    uint32 stop_bits;
    uint32 parity;
    uint32 width;
    uint32 error_en; // reserved
    uint32 break_en; // =1 enable
    uint32 term_fs_tx_rx; // 485 terminators

    // char delay cfg
    uint32 char_delay_src;
    float char_delay_us;            // delay in us if using internal source, otherwise number of clocks

    // frame delay cfg
    uint32 frame_delay_mode;
    uint32 frame_delay_length;      // string length if FRAMEDELAY_FIXEDLEN selected
    uint32 frame_delay_src;
    float frame_delay_us;           // delay in us if using internal source, otherwise number of clocks
    float frame_delay_repeat_us;    // delay in us if using internal source, otherwise number of clocks

    //timeout
    uint32 timeout;                 // number of clocks (based on timeout_clock) without receiving data before timeout
    uint32 timeout_clock;

    // watermark
    uint32 tx_watermark;
    uint32 rx_watermark;

    // ext cfg
    uint32 suppress_hd_echo; // 1= suppress echo in half-duplex mode
    uint32 add_ts_on_idle;   // 1= add 11-bit timestamp before data if timeout period ended, timestamp is ignored in DqAdv101SerialReadRxFIFO

    // term
    uint32 term_length; // length of <term_buf>
    char* term_buf;     // termination string
} MF101SERIALCFG, *pMF101SERIALCFG;

#pragma pack()

#define DQ_MF101_SERIAL_CFG_BAUD_DFLT   (57600) // default baud rate

// <flags> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_CLEAR       (1L << 31)  // reset all settings to default
#define DQ_MF101_SERIAL_CFG_BAUD        (1L << 30)  // configure <baud_rate>
#define DQ_MF101_SERIAL_CFG_CHAN        (1L << 29)  // configure <mode>, <loopback>, <stop_bits>, <parity>, <width>
#define DQ_MF101_SERIAL_CFG_CHAR_DELAY  (1L << 28)  // configure <char_delay_src> and <char_delay_us>
#define DQ_MF101_SERIAL_CFG_FRAME_DELAY (1L << 27)  // configure <frame_delay_mode>, <frame_delay_length>, <frame_delay_src>, <frame_delay_us>, <frame_delay_repeat_us>
#define DQ_MF101_SERIAL_CFG_TERM_STRING (1L << 26)  // configure <term_length> and <term_buf>
#define DQ_MF101_SERIAL_CFG_TIMEOUT     (1L << 25)  // configure <timeout> and <timeout_clock>
#define DQ_MF101_SERIAL_CFG_TX_WM       (1L << 24)  // configure <tx_watermark>
#define DQ_MF101_SERIAL_CFG_RX_WM       (1L << 23)  // configure <rx_watermark>
#define DQ_MF101_SERIAL_CFG_EXT         (1L << 22)  // configure <suppress_hd_echo> and <add_ts_on_idle>

// <mode> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_MODE_232    (DQ_SL501_MODE_232)
#define DQ_MF101_SERIAL_CFG_MODE_485F   (DQ_SL501_MODE_485F)
#define DQ_MF101_SERIAL_CFG_MODE_485H   (DQ_SL501_MODE_485H)

// <stop_bits> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_STOP_1      (DQ_SL501_STOP_1)
#define DQ_MF101_SERIAL_CFG_STOP_1_5    (DQ_SL501_STOP_1_5)
#define DQ_MF101_SERIAL_CFG_STOP_2      (DQ_SL501_STOP_2)

// <parity> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_PARITY_NONE  (DQ_SL501_PARITY_NONE)
#define DQ_MF101_SERIAL_CFG_PARITY_EVEN  (DQ_SL501_PARITY_EVEN)
#define DQ_MF101_SERIAL_CFG_PARITY_ODD   (DQ_SL501_PARITY_ODD)
#define DQ_MF101_SERIAL_CFG_PARITY_SPACE (DQ_SL501_PARITY_SPACE)
#define DQ_MF101_SERIAL_CFG_PARITY_MARK  (DQ_SL501_PARITY_MARK)

// <width> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_WIDTH_8     (DQ_SL501_WIDTH_8)
#define DQ_MF101_SERIAL_CFG_WIDTH_7     (DQ_SL501_WIDTH_7)
#define DQ_MF101_SERIAL_CFG_WIDTH_6     (DQ_SL501_WIDTH_6)
#define DQ_MF101_SERIAL_CFG_WIDTH_5     (DQ_SL501_WIDTH_5)

// <term_fs_tx_rx> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_TERM_FS     (1L << 0)
#define DQ_MF101_SERIAL_CFG_TERM_TX     (1L << 1)
#define DQ_MF101_SERIAL_CFG_TERM_RX     (1L << 2)

// <char_delay_src> and <frame_delay_src> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_DELAY_DISABLED  (DQ_SL501_DELAYMODE_DISABLED) // disabled
#define DQ_MF101_SERIAL_CFG_DELAY_INTERNAL  (DQ_SL501_DELAYMODE_INTERNAL) // internal per channel clock

// <frame_delay_mode> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_FRAMEDELAY_DISABLED     (DQ_SL501_FRAMEDELAY_DISABLED)  // disabled
#define DQ_MF101_SERIAL_CFG_FRAMEDELAY_FIXEDLEN     (DQ_SL501_FRAMEDELAY_FIXEDLEN)  // fixed length
#define DQ_MF101_SERIAL_CFG_FRAMEDELAY_VMAP_LEN     (DQ_SL501_FRAMEDELAY_VMAP_LEN)  // frame size is determined by the amount of provided FIFO data
#define DQ_MF101_SERIAL_CFG_FRAMEDELAY_ZERO_CHAR    (DQ_SL501_FRAMEDELAY_ZERO_CHAR) // frame ends upon zero character (ASCIIZ string)
#define DQ_MF101_SERIAL_CFG_FRAMEDELAY_VARLEN       (DQ_SL501_FRAMEDELAY_VARLEN)    // the data structure is [size][B1]..[Bsize][size][B1]..[Bsize]...
                                                                                    // Frame delay bit is added at the beginning of each frame.
#define DQ_MF101_SERIAL_CFG_FRAMEDELAY_REPEAT       (DQ_SL501_FRAMEDELAY_REPEAT)    // "repeat" mode - repeat last placed frame if not updated on time

// <timeout_clock> definitions for MF101SERIALCFG
#define DQ_MF101_SERIAL_CFG_TIMEOUT_1MS     (0)     // 1ms clock
#define DQ_MF101_SERIAL_CFG_TIMEOUT_100US   (1)     // 100us clock
#define DQ_MF101_SERIAL_CFG_TIMEOUT_10US    (2)     // 10us clock
#define DQ_MF101_SERIAL_CFG_TIMEOUT_1US     (3)     // 1us clock

// <action> for use with DQL_IOCTL101_CLEAR_FIFO_SERIAL
#define DQ_MF101_SERIAL_CLEAR_FIN       (1L << 0)   // clear input FIFO
#define DQ_MF101_SERIAL_CLEAR_FOUT      (1L << 1)   // clear output FIFO
#define DQ_MF101_SERIAL_CLEAR_FINFOUT   (DQ_MF101_SERIAL_CLEAR_FIN | DQ_MF101_SERIAL_CLEAR_FOUT) // clear input and output FIFO

// <cts_cfg> for use with DQL_IOCTL101_FLOW_CONTROL_SERIAL
#define DQ_MF101_SERIAL_CTS_NO_CHANGE  (DQL_IOCTL501_CTS_NO_CHANGE)  // make no change to the flow control setting, most usefull when reading the cts inputs
#define DQ_MF101_SERIAL_CTS_IGNORE     (DQL_IOCTL501_CTS_IGNORE)     // default setting, the cts input is ignored by the transmitter, transmitter always transmits
#define DQ_MF101_SERIAL_CTS_AUTOFLOW   (DQL_IOCTL501_CTS_AUTOFLOW)   // turns transmit flow control ON, transmitter is controlled by the CTS input

// <rts_cfg> for use with DQL_IOCTL101_FLOW_CONTROL_SERIAL
#define DQ_MF101_SERIAL_RTS_NO_CHANGE  (DQL_IOCTL501_RTS_NO_CHANGE)       // make no change to the flow control setting, most usefull when reading the cts inputs
#define DQ_MF101_SERIAL_RTS_PIN_LOW    (DQL_IOCTL501_RTS_PIN_LOW)         // set RTS pin low, may be used to disable other RS-232 devices
#define DQ_MF101_SERIAL_RTS_PIN_HIGH   (DQL_IOCTL501_RTS_PIN_HIGH)        // default setting, provides a high level normally used to enable other RS-232 devices
#define DQ_MF101_SERIAL_RTS_AUTOFLOW_NORMAL_TIMING (DQL_IOCTL501_RTS_AUTOFLOW_NORMAL_TIMING) // flow control enabled with normal timing, provides a high level that goes low when watermark reached
#define DQ_MF101_SERIAL_RTS_AUTOFLOW_GATED_TIMING  (DQL_IOCTL501_RTS_AUTOFLOW_GATED_TIMING)  // same flow control action as normal timing except that timing is changed for use with gated transmitters

// I2C
#define DQ_MF101_I2C_CHAN       (1)

#define DQ_MF101_I2C_CH_FIFOSZ_MRX       (1024)      // master Rx
#define DQ_MF101_I2C_CH_FIFOSZ_SRX       (512)       // slave Rx
#define DQ_MF101_I2C_CH_FIFOSZ_MTX       (1024)      // master Tx
#define DQ_MF101_I2C_CH_FIFOSZ_STX       (512)       // slave Tx

// Define I2C master command on the bus
#define DQ_MF101_I2C_CMD_A_BIT      (DQ_L534_CMD_A_BIT)   // Address mode bit: 0 == 7-bit/1 == 10-bit
#define DQ_MF101_I2C_CMD_N_BIT      (DQ_L534_CMD_N_BIT)   // Address ignore NACK bit. 1 == ignore /ACK (I2C violation)
#define DQ_MF101_I2C_CMD_P_BIT      (DQ_L534_CMD_P_BIT)   // NO-STOP (do not issue STOP); next valid command with START must follow; ignored for I2C_CMD_STP command
#define DQ_MF101_I2C_CMD_B_BIT_MASK (DQ_L534_CMD_B_BIT_MASK)

#define DQ_MF101_I2C_CMD_TDELAY     (DQ_L534_CMD_TDELAY)    // Insert NOP command for delay sequence
#define DQ_MF101_I2C_CMD_STOP       (DQ_L534_CMD_STOP)      // STOP - issue a stop condition once bus is available
#define DQ_MF101_I2C_CMD_ST_WRITE   (DQ_L534_CMD_ST_WRITE)  // START+WRITE (including write multiple)
#define DQ_MF101_I2C_CMD_ST_READ    (DQ_L534_CMD_ST_READ)   // START+READ (including read multiple)
#define DQ_MF101_I2C_CMD_ST_WRRD    (DQ_L534_CMD_ST_WRRD)   // START+WRITE+RESTART+READ (including read multiple)
// Note: For the next two command, there is always one byte written after the first address byte
#define DQ_MF101_I2C_CMD_XDCP_READ  (DQ_L534_CMD_XDCP_READ)  // START+WRITE+READ (for Renesas XDCP protocol - ex. X9119)
#define DQ_MF101_I2C_CMD_XDCP_WRITE (DQ_L534_CMD_XDCP_WRITE) // START+WRITE+WRITE (for Renesas XDCP protocol - ex. X9259)

#define DQ_MF101_I2C_CMD_ADDR7(N)        (DQ_L534_CMD_ADDR7(N))      // 7 bit address
#define DQ_MF101_I2C_CMD_ADDR10(N)       (DQ_L534_CMD_ADDR10(N))     // 10 bit address

#pragma pack(1)
// for use with DQL_IOCTL101_CFG_I2C
typedef struct {    // all members must be of uint32 size
    uint32 flags;       // select active parameters to set/change
    uint32 clock;       // clock frequency, 100k, 400k and 1Mbit are supported; 0 = custom parameters
    uint32 tx_lines;    // enable loopback

    // Master configuration
    uint32 master_cfg;              // master configuration bitset
    uint32 master_idle_delay;       // delay in MM mode before acquiring bus in 15ns increments
    uint32 master_byte_delay;       // delay between bytes sent by master in 1us resolution
    uint32 master_max_sync_delay;   // maximum delay in uS slave could delay clock
    uint32 master_datasz_unfifo;    // <reserved>
    uint32 master_to_cfg;           // Maximum timeout delay in uS before releasing bus (0 == default)
    uint32 master_wait_bm_fifo_ms;  // Maximum wait for BM FIFO to receive all expected words, ms
    uint32 master_xdcp_device_type; // XDCP protocol device type - select upper 4 bits <reserved>

    // Slave configuration
    uint32 slave_cfg;               // slave configuration bitset
    uint32 slave_addr;              // select 7/10 slave address
    uint32 slave_data;              // data to reply when slave Tx FIFO is empty
    uint32 slave_sync_dly;          // length of ACK in 15.15ns clocks (acknowledge cycle stretch)
    uint32 slave_ack_dly;           // 12-bit how long we wait for master ACK (in clocks)
    uint32 slave_max_ack;           // Slave RX max count register (# of words per /ACK)
    uint32 slave_tx_reg_size;       // in unFIFO mode the size of bytes to transmit to master, 1..4
} MF101I2CCFG, *pMF101I2CCFG;

#pragma pack()

// <flags> definitions for channel
#define DQ_MF101_I2C_CFG_CLOCK          (DQ_L534CFG_CLOCK)        // select clock, default is 400kHz
#define DQ_MF101_I2C_CFG_MASTER_VALID   (DQ_L534CFG_MASTER_VALID) // master configuration is valid
#define DQ_MF101_I2C_CFG_SLAVE_VALID    (DQ_L534CFG_SLAVE_VALID)  // slave configuration is valid
#define DQ_MF101_I2C_CFG_TERM_LOOP      (DQ_L534CFG_TERM_LOOP)    // set termination and loopback
#define DQ_MF101_I2C_CFG_SDATA_ADDR     (DQ_L534CFG_SDATA_ADDR)   // set slave address and register-based data
#define DQ_MF101_I2C_CFG_CLEAR          (DQ_L534CFG_CLEAR)        // clear configurations stored from the previous calls

// <clock>
#define DQ_MF101_I2C_CFG_CLOCK_CUST     (DQ_L534CFG_CLOCK_CUST)   // custom clock rate 2kHz..100kHz
#define DQ_MF101_I2C_CFG_CLOCK_100k     (DQ_L534CFG_CLOCK_100k)   // 100kbaud
#define DQ_MF101_I2C_CFG_CLOCK_400k     (DQ_L534CFG_CLOCK_400k)   // 400kbaud
#define DQ_MF101_I2C_CFG_CLOCK_1M       (DQ_L534CFG_CLOCK_1M)     // 1Mbaud

// <tx_lines>

// <master_cfg>
#define DQ_MF101_I2C_MCFG_MMASTER           (DQ_L534MCFG_MMASTER)         // enable multi-master mode
#define DQ_MF101_I2C_MCFG_CLK_SYNC          (DQ_L534MCFG_CLK_SYNC)        // allow clock synchronization (stretching) by slave
#define DQ_MF101_I2C_MCFG_BYTE_DELAY        (DQ_L534MCFG_BYTE_DELAY)      // enable byte to byte delay (extra delay after ACK)
#define DQ_MF101_I2C_MCFG_LONG_IDLE_DLY     (DQ_L534MCFG_LONG_IDLE_DLY)   // allow to wait programmed time until taking over the bus in multi-master mode
#define DQ_MF101_I2C_MCFG_XDCP              (DQ_L534MCFG_XDCP)            // set XDCP device ID <reserved>
#define DQ_MF101_I2C_MCFG_RAWMODE           (DQ_L534MCFG_RAWMODE)         // select Master into raw mode operation

// <slave_cfg>
#define DQ_MF101_I2C_SCFG_ENABLE_BM     (DQ_L534SCFG_ENABLE_BM)       // set slave into BM mode
#define DQ_MF101_I2C_SCFG_SCKSYN_AD     (DQ_L534SCFG_SCKSYN_AD)       // =1 allows clock stretching during address ACK cycle (12-bit # of clocks in slave_sync_dly)
#define DQ_MF101_I2C_SCFG_SCKSYN_TX     (DQ_L534SCFG_SCKSYN_TX)       // =1 allows clock stretching during data TX ACK cycle (12-bit # of clocks in slave_sync_dly)
#define DQ_MF101_I2C_SCFG_SCKSYN_RX     (DQ_L534SCFG_SCKSYN_RX)       // =1 allows clock stretching during data RX ACK cycle (12-bit # of clocks in slave_sync_dly)
#define DQ_MF101_I2C_SCFG_ACKLEN        (DQ_L534SCFG_ACKLEN)          // =1 set 12-bit master ACK length (12-bit # of clocks in slave_ack_dly)
#define DQ_MF101_I2C_SCFG_ACK_BM        (DQ_L534SCFG_ACK_BM)          // allow acknowledge generation in BM mode
#define DQ_MF101_I2C_SCFG_10BIT         (DQ_L534SCFG_10BIT)           // slave address is 10 bit
#define DQ_MF101_I2C_SCFG_MAXACK        (DQ_L534SCFG_MAXACK)          // enable <slave_max_ack> # of words per /ACK
#define DQ_MF101_I2C_SCFG_SLAVE_UNFIFO  (DQ_L534SCFG_SLAVE_UNFIFO)    // do not use FIFO mode for slave
#define DQ_MF101_I2C_SCFG_FIFO_SRXDO    (DQ_L534SCFG_FIFO_SRXDO)      // suppress bus conditions in RX FIFO, preserve data only

// for use with DQL_IOCTL101_STATUS_I2C
typedef struct {    // all members must be of uint32 size
    uint32 hw_stat;     // HW status as reported by the hardware, refer to DQ_I2C_STS_HW defines
    uint32 pin_stat;    // HW pin status, refer to DQ_I2C_STS_PIN defines
    uint32 drv_stat;    // reserved
} MF101I2CSTS, *pMF101I2CSTS;

// <hw_stat>
// Sticky bits 31..16. Clear using DQL_IOCTL101_STATUS_CLR flag
#define DQ_MF101_I2C_STS_HW_ACKERR (1L<<30)   // =1 - master ack error has occurred
#define DQ_MF101_I2C_STS_HWPIERR   (1L<<29)   // =1 - PHY idle wait timeout error
#define DQ_MF101_I2C_STS_HWPTOERR  (1L<<28)   // =1 - PHY command wait while bus is active timeout error
#define DQ_MF101_I2C_STS_HWCSERR   (1L<<27)   // =1 - slave clock synchronization error
#define DQ_MF101_I2C_STS_HWMDONE   (1L<<26)   // =1 - master completes execution of the last command
#define DQ_MF101_I2C_STS_HWMSCH    (1L<<25)   // =1 - master command or data sequence received
#define DQ_MF101_I2C_STS_HWMCRCERR (1L<<24)   // reserved
#define DQ_MF101_I2C_STS_HWMCLOERR (1L<<23)   // =1 - error in CLO-->master sequence
#define DQ_MF101_I2C_STS_HWMMERR   (1L<<22)   // =1 - multi-master arbitration was lost
#define DQ_MF101_I2C_STS_HWSTXDONE (1L<<21)   // =1 - slave TX data sent (non-continuous mode)
#define DQ_MF101_I2C_STS_HWSRXDTR  (1L<<20)   // =1 - slave RX data ready (non-continuous mode)
#define DQ_MF101_I2C_STS_HWSRXFFS  (1L<<19)   // =1 - slave RX FIFO was full
#define DQ_MF101_I2C_STS_HWSTXFES  (1L<<18)   // =1 - slave TX FIFO was empty
#define DQ_MF101_I2C_STS_HWRXFFS   (1L<<17)   // =1 - master RX FIFO was full
#define DQ_MF101_I2C_STS_HWTXFES   (1L<<16)   // =1 - master TX FIFO was empty
// Static bits 15..0
#define DQ_MF101_I2C_STS_HW_BBSY    (1L<<15)   // =1 when bus is busy
#define DQ_MF101_I2C_STS_HW_CSWAIT  (1L<<14)   // =1 indicates that master waits for the slave to release SCL
#define DQ_MF101_I2C_STS_HW_MCLORDY (1L<<13)   // =1 when channel can accept writes
#define DQ_MF101_I2C_STS_HW_MWAIT   (1L<<12)   // =1 - master waiting for command/data release
#define DQ_MF101_I2C_STS_HW_CLOMWT  (1L<<11)   // =1 when output channel list SM waits for the master to become available
#define DQ_MF101_I2C_STS_HW_SRXFHF  (1L<<10)   // =1 - slave RX FIFO is above watermark
#define DQ_MF101_I2C_STS_HW_SRXFF   (1L<<9)    // =1 - slave RX FIFO is full
#define DQ_MF101_I2C_STS_HW_STXFHF  (1L<<8)    // =1 - slave TX FIFO is below watermark
#define DQ_MF101_I2C_STS_HW_STXFE   (1L<<7)    // =1 - slave TX FIFO is empty
#define DQ_MF101_I2C_STS_HW_SBSY    (1L<<6)    // =1 when slave state machine is busy
#define DQ_MF101_I2C_STS_HW_EMAS    (1L<<5)    // =1 when external master owns the bus
#define DQ_MF101_I2C_STS_HW_MBSY    (1L<<4)    // =1 when master state machine is busy
#define DQ_MF101_I2C_STS_HW_RXFHF   (1L<<3)    // =1 - master RX FIFO is above watermark
#define DQ_MF101_I2C_STS_HW_RXFF    (1L<<2)    // =1 - master RX FIFO is full
#define DQ_MF101_I2C_STS_HW_TXFHF   (1L<<1)    // =1 - master TX FIFO is below watermark
#define DQ_MF101_I2C_STS_HW_TXFE    (1L<<0)    // =1 - master TX FIFO is empty

// <pin_stat>
#define DQ_MF101_I2C_STS_PIN_SDAM (1L<<3)    // Master SDA current value
#define DQ_MF101_I2C_STS_PIN_SCLM (1L<<2)    // Master SCL current value
#define DQ_MF101_I2C_STS_PIN_SDAS (1L<<1)    // Slave SDA current value
#define DQ_MF101_I2C_STS_PIN_SCLS (1L<<0)    // Slave SCL current value

// for use with DQL_IOCTL_STATUS_I2C <flags> parameter
#define DQL_IOCTL101_STATUS_CLR         (1L << 30)   // clear "sticky" status bits

// for use with DQL_IOCTL101_xWRFRAME_I2C
#define DQL_IOCTL101_WRFRAME_DIRECT_I2C     (0xB6)   // Write master command (and data) directly into CLOWR
#define DQL_IOCTL101_WRFRAME_FIFO_I2C       (0x75)   // Write master command into TX FDR

// for use with DQL_IOCTL101_xRDFRAME_I2C
#define DQL_IOCTL101_RDFRAME_FIFO_I2C       (0xad)   // Read data from master or slave RX FDR

// for use with DQL_IOCTL101_FLUSH_I2C
#define DQL_IOCTL101_FLUSH_SRX_I2C      (DQL_IOCTL534_FLUSH_SRX)     // =1 - Flush slave RX FIFO
#define DQL_IOCTL101_FLUSH_STX_I2C      (DQL_IOCTL534_FLUSH_STX)     // =1 - Flush slave TX FIFO
#define DQL_IOCTL101_FLUSH_MRX_I2C      (DQL_IOCTL534_FLUSH_MRX)     // =1 - Flush master RX FIFO
#define DQL_IOCTL101_FLUSH_MTX_I2C      (DQL_IOCTL534_FLUSH_MTX)     // =1 - Flush master TX FIFO
#define DQL_IOCTL101_FLUSH_MRST_I2C     (DQL_IOCTL534_FLUSH_MRST)    // Reset master module
#define DQL_IOCTL101_FLUSH_SRST_I2C     (DQL_IOCTL534_FLUSH_SRST)    // Reset slave module

// CT
#define DQ_MF101_CT_CHAN        (2)
#define DQ_MF101_CT_CHAN_MASK   (0x03)
#define DQ_MF101_CT_MODE_MASK   (0xf0)

// for use with DQL_IOCTL101_CFG_SOURCE_CT
#define DQ_MF101_CT_SOURCE_FET15    (31) // FET-based DIn/DOuts
#define DQ_MF101_CT_SOURCE_FET14    (30) //
#define DQ_MF101_CT_SOURCE_FET13    (29) //
#define DQ_MF101_CT_SOURCE_FET12    (28) //
#define DQ_MF101_CT_SOURCE_FET11    (27) //
#define DQ_MF101_CT_SOURCE_FET10    (26) //
#define DQ_MF101_CT_SOURCE_FET9     (25) //
#define DQ_MF101_CT_SOURCE_FET8     (24) //
#define DQ_MF101_CT_SOURCE_FET7     (23) //
#define DQ_MF101_CT_SOURCE_FET6     (22) //
#define DQ_MF101_CT_SOURCE_FET5     (21) //
#define DQ_MF101_CT_SOURCE_FET4     (20) //
#define DQ_MF101_CT_SOURCE_FET3     (19) //
#define DQ_MF101_CT_SOURCE_FET2     (18) //
#define DQ_MF101_CT_SOURCE_FET1     (17) //
#define DQ_MF101_CT_SOURCE_FET0     (16) //
#define DQ_MF101_CT_SOURCE_SYNC3    (11) // SYNC pins (input only)
#define DQ_MF101_CT_SOURCE_SYNC2    (10) //
#define DQ_MF101_CT_SOURCE_SYNC1    (9)  //
#define DQ_MF101_CT_SOURCE_SYNC0    (8)  //
#define DQ_MF101_CT_SOURCE_LTRIGGER (6)  // Layer trigger state (0-STOPPED/1-STARTED)
#define DQ_MF101_CT_SOURCE_TRIGOUT  (5)  // TTL TRIGOUT pin
#define DQ_MF101_CT_SOURCE_TRIGIN   (4)  // TTL TRIGIN pin
#define DQ_MF101_CT_SOURCE_TTL3     (3)  // TTL DIN/DOUT pins
#define DQ_MF101_CT_SOURCE_TTL2     (2)  //
#define DQ_MF101_CT_SOURCE_TTL1     (1)  //
#define DQ_MF101_CT_SOURCE_TTL0     (0)  //

// for use with DQL_IOCTL101_CFG_OUTPUT_CT
#define DQ_MF101_CT_OUTPUT_FET15    (1L << (DQ_MF101_CT_SOURCE_FET15))      // FET-based DIn/DOuts
#define DQ_MF101_CT_OUTPUT_FET14    (1L << (DQ_MF101_CT_SOURCE_FET14))      //
#define DQ_MF101_CT_OUTPUT_FET13    (1L << (DQ_MF101_CT_SOURCE_FET13))      //
#define DQ_MF101_CT_OUTPUT_FET12    (1L << (DQ_MF101_CT_SOURCE_FET12))      //
#define DQ_MF101_CT_OUTPUT_FET11    (1L << (DQ_MF101_CT_SOURCE_FET11))      //
#define DQ_MF101_CT_OUTPUT_FET10    (1L << (DQ_MF101_CT_SOURCE_FET10))      //
#define DQ_MF101_CT_OUTPUT_FET9     (1L << (DQ_MF101_CT_SOURCE_FET9))       //
#define DQ_MF101_CT_OUTPUT_FET8     (1L << (DQ_MF101_CT_SOURCE_FET8))       //
#define DQ_MF101_CT_OUTPUT_FET7     (1L << (DQ_MF101_CT_SOURCE_FET7))       //
#define DQ_MF101_CT_OUTPUT_FET6     (1L << (DQ_MF101_CT_SOURCE_FET6))       //
#define DQ_MF101_CT_OUTPUT_FET5     (1L << (DQ_MF101_CT_SOURCE_FET5))       //
#define DQ_MF101_CT_OUTPUT_FET4     (1L << (DQ_MF101_CT_SOURCE_FET4))       //
#define DQ_MF101_CT_OUTPUT_FET3     (1L << (DQ_MF101_CT_SOURCE_FET3))       //
#define DQ_MF101_CT_OUTPUT_FET2     (1L << (DQ_MF101_CT_SOURCE_FET2))       //
#define DQ_MF101_CT_OUTPUT_FET1     (1L << (DQ_MF101_CT_SOURCE_FET1))       //
#define DQ_MF101_CT_OUTPUT_FET0     (1L << (DQ_MF101_CT_SOURCE_FET0))       //
#define DQ_MF101_CT_OUTPUT_TRIGOUT  (1L << (DQ_MF101_CT_SOURCE_TRIGOUT))    // TTL TRIGOUT pin
#define DQ_MF101_CT_OUTPUT_TTL3     (1L << (DQ_MF101_CT_SOURCE_TTL3))       // TTL DIN/DOUT pins
#define DQ_MF101_CT_OUTPUT_TTL2     (1L << (DQ_MF101_CT_SOURCE_TTL2))       //
#define DQ_MF101_CT_OUTPUT_TTL1     (1L << (DQ_MF101_CT_SOURCE_TTL1))       //
#define DQ_MF101_CT_OUTPUT_TTL0     (1L << (DQ_MF101_CT_SOURCE_TTL0))       //

#define DQ_MF101_CT_OUTPUT_FET(N)   ((1L << ((N) & 0xf)) << DQ_MF101_CT_SOURCE_FET0)    // select DOUT FET N as output
#define DQ_MF101_CT_OUTPUT_TTL(N)   ((1L << ((N) & 0x3)) << DQ_MF101_CT_SOURCE_TTL0)    // select DOUT TTL N as output

// for use with DQL_IOCTL101_CFG_CHAN_CT
typedef struct {
    uint32  startmode;              // trigger mode
    uint32  sampwidth;              // reserved, expected sample width

    uint32  ps;                     // prescaler
    uint32  pc;                     // period counter
    uint32  cr0;
    uint32  cr1;                    // compare 0/1
    uint32  tbr;                    // time base
    uint32  dbg;
    uint32  dbc;                    // debounce
    uint32  ctr;                    // ctr - input, gate, output inversion
    uint32  ccr;                    // configuration
    uint32  lr;                     // load
    uint32  ier;
    int     b_has_config;           // true when a configuration has been provided
} MF101CTCFG, *pMF101CTCFG;

// <startmode>
#define DQ_MF101_CT_SMAUTO             (0L)        // counter starts immediately
#define DQ_MF101_CT_SMHARD             (1L)        // reserved
#define DQ_MF101_CT_SMSOFT             (2L)        // counter starts on software trigger

// <sampwidth> (PWM only)
#define DQ_MF101_CT_SW8                (1L)
#define DQ_MF101_CT_SW16               (2L)
#define DQ_MF101_CT_SW32               (4L)

// special channels used to specify that we wish to read/write other
// registers than default capture/compare register
#define DQ_MF101_CT_CHNLTYPE_STATUS    (DQ_PL601_CHNLTYPE_STATUS)    // Reads channel STR register instead of CR
#define DQ_MF101_CT_CHNLTYPE_CRH       (DQ_PL601_CHNLTYPE_CRH)       // Reads channel CRH register
#define DQ_MF101_CT_CHNLTYPE_CRL       (DQ_PL601_CHNLTYPE_CRL)       // Reads channel CRL register
#define DQ_MF101_CT_CHNLTYPE_CR0       (DQ_PL601_CHNLTYPE_CR0)       // Writes channel CR0 register
#define DQ_MF101_CT_CHNLTYPE_CR1       (DQ_PL601_CHNLTYPE_CR1)       // Writes channel CR1 register
#define DQ_MF101_CT_CHNLTYPE_SHADOW    (DQ_PL601_CHNLTYPE_SHADOW)    // Reads shadow CR/CRL/CRH/timestamp registers
#define DQ_MF101_CT_CHNLTYPE_TSTAMP    (DQ_PL601_CHNLTYPE_TSTAMP)    // Request timestamp for this channel into the FIFO
#define DQ_MF101_CT_CHNLTYPE_SDRH      (DQ_PL601_CHNLTYPE_SDRH)      // Request channel shadow CRH register
#define DQ_MF101_CT_CHNLTYPE_SDRL      (DQ_PL601_CHNLTYPE_SDRL)      // Request channel shadow CRL register
#define DQ_MF101_CT_CHNLTYPE_SDRT      (DQ_PL601_CHNLTYPE_SDRT)      // Request channel shadow timestamp

// IOCTL
// 0x2X0N X=0 AI, =1 AO, =2 TTL, =3 DI, =4 DO, =5 Serial. =7 I2C, =8 CT
#define DQL_IOCTL101_CFG_AI        (0x2000)

#define DQL_IOCTL101_CFG_AO        (0x2100)
#define DQL_IOCTL101_CTRL_WFORM_AO (0x2101)
#define DQL_IOCTL101_WR_WFORM_AO   (0x2102)

#define DQL_IOCTL101_CFG_TTL       (0x2200)
#define DQL_IOCTL101_WR_TTL        (0x2201)
#define DQL_IOCTL101_RD_TTL        (0x2202)

#define DQL_IOCTL101_CFG_LVL_DI    (0x2300)
#define DQL_IOCTL101_CFG_DEB_DI    (0x2301)
#define DQL_IOCTL101_RD_DI         (0x2302)
#define DQL_IOCTL101_CFG_MAV_DI    (0x2303)

#define DQL_IOCTL101_CFG_TERM_DO   (0x2400)
#define DQL_IOCTL101_WR_DO         (0x2401)
#define DQL_IOCTL101_CFG_PWM_DO    (0x2402)
#define DQL_IOCTL101_RD_DO         (0x2404)

#define DQL_IOCTL101_CFG_SERIAL    (0x2500)
#define DQL_IOCTL101_START_SERIAL  (0x2501)
#define DQL_IOCTL101_STOP_SERIAL   (0x2502)
#define DQL_IOCTL101_WRITE_FIFO_SERIAL    (0x2503)
#define DQL_IOCTL101_READ_FIFO_SERIAL     (0x2504)
#define DQL_IOCTL101_CLEAR_FIFO_SERIAL    (0x2505)
#define DQL_IOCTL101_FLOW_CONTROL_SERIAL  (0x2506)
#define DQL_IOCTL101_SEND_BREAK_SERIAL    (0x2507)

// Note I2C is 0x270N to avoid conflict with DQIOCTL_EXT_DEVICE
#define DQL_IOCTL101_CFG_I2C       (0x2700)
#define DQL_IOCTL101_ENABLE_I2C    (0x2701)
#define DQL_IOCTL101_MWRFRAME_I2C  (0x2702)
#define DQL_IOCTL101_MRDFRAME_I2C  (0x2703)
#define DQL_IOCTL101_SWRFRAME_I2C  (0x2704)
#define DQL_IOCTL101_SRDFRAME_I2C  (0x2705)
#define DQL_IOCTL101_STATUS_I2C    (0x2706)
#define DQL_IOCTL101_FLUSH_I2C     (0x2707)

#define DQL_IOCTL101_CFG_SOURCE_CT (0x2800)
#define DQL_IOCTL101_CFG_CHAN_CT   (0x2801)
#define DQL_IOCTL101_START_CHAN_CT (0x2802)
#define DQL_IOCTL101_READ_CHAN_CT  (0x2803)
#define DQL_IOCTL101_CLEAR_CT      (0x2804)
#define DQL_IOCTL101_CFG_OUTPUT_CT (0x2805)
#define DQL_IOCTL101_WRITE_CT      (0x2806)

// Errors for DQL_IOCTL101_CFG_AO
#define DQL_IOCTL101_CFG_AO_ERR_BUSY    (-1)    // AO is unable to update configuration (ie in waveform/fifo mode)

// Subcommands for DQL_IOCTL101_READ_FIFO_SERIAL
#define DQL_IOCTL101_READ_FIFO_SERIAL_DATA_ONLY     (0)     // Reads data as uint8, ignores upper status bits
#define DQL_IOCTL101_READ_FIFO_SERIAL_DATA_AND_STS  (1)     // Reads data as uint16, includes upper status bits

// Caldac constants
// <DQSETCAL.dac>, bottom 3 bits SS, remaining are SS specific
#define DQ_MF101_CALDAC_DAC_SS_MASK     (0x7)     // Use DQ_MF101_SSx constants
#define DQ_MF101_CALDAC_DAC_GAIN        (1L << 4) // AI/AO/DIO gain
#define DQ_MF101_CALDAC_DAC_OFFSET      (1L << 5) // AI/AO/DIO offset
#define DQ_MF101_CALDAC_DAC(SS, CAL)    (((SS) & DQ_MF101_CALDAC_DAC_SS_MASK) | CAL) // SS is one of DQ_MF101_SSx
                                                                                     // CAL is one of DQ_MF101_CALDAC_DAC_x constants

// DqCmdGet/SetParameters ss constants for use with DQ_IOM_ACCESS_CALIBR mode
#define DQ_MF101_CALIB_SS_AI_GAIN       (0)     // AI gain
#define DQ_MF101_CALIB_SS_AI_OFFSET     (1)     // AI offset
#define DQ_MF101_CALIB_SS_AO            (2)     // AO gain and offset
#define DQ_MF101_CALIB_SS_DIO           (3)     // DIO gain and offset


typedef struct {
    uint32 chan;
    uint32 evtype;
    uint32 tstamp;
    uint32 size;
    uint32 data[DQ_FLEX_ARRAY];
} EV101_ID, *pEV101_ID;

typedef enum {
    EV101_CLEAR         = 0x1000,
    EV101_PERIODIC      = 0x101,
    EV101_DI_CHANGE     = 0x102
} event101_t;

#define DqAdv101ConfigEvents_PARAMSZ (2)        // maximum number of uint32 parameters after pEV101_ID

// EV101_PERIODIC param[1] for building mask of status to return on this periodic event
#define DQ_MF101_PERIODIC_DI_STS    (1L << 0) // will add all data returned from EV101_DI_CHANGE

#define DQ_MF101_EVENT_PER_RESET    (1L << 0) // event will reset periodic timer

typedef struct {
    uint32 divider_mask;    // bitmask to enable 8x voltage divider on each channel (0=disable 1=enable)
    uint32 moving_average;  // number of averages for every channel as a power of 2 (0-8)
} MF101CFG_AI, *pMF101CFG_AI;

typedef struct {
    uint32 mode;  // refer to DQ_MF101_AO_MODE_ defines
    uint32 range; // refer to DQ_MF101_AO_RANGE_ defines
} MF101CFG_AO, *pMF101CFG_AO;


#pragma pack(1)
typedef struct {
    uint32 gain[DQ_MF101_AI_RANGES][DQ_MF101_AI_CHAN + DQ_MF101_AI_CHAN_DIFF][DQ_MF101_AI_GAINS];
    uint32 offset[DQ_MF101_AI_RANGES][DQ_MF101_AI_CHAN + DQ_MF101_AI_CHAN_DIFF][DQ_MF101_AI_GAINS];
} DQCALSET_101_AI, *pDQCALSET_101_AI;

typedef struct {
    uint16 gain[DQ_MF101_AO_CHAN][DQ_MF101_AO_RANGES];
    uint16 offset[DQ_MF101_AO_CHAN][DQ_MF101_AO_RANGES];
} DQCALSET_101_AO, *pDQCALSET_101_AO;

typedef struct {
    uint16 gain[DQ_MF101_DIO_CHAN];
    uint16 offset[DQ_MF101_DIO_CHAN];
} DQCALSET_101_DIO, *pDQCALSET_101_DIO;

typedef struct {
    // AO
    uint32 ao_cfg[DQ_MF101_AO_CHAN]; // range
    uint32 ao_val[DQ_MF101_AO_CHAN]; // raw value in lower 16-bits, upper bits reserved
    // TTL
    uint32 ttl_cfg;   // MF101_CFG defines
                      //   bit 21 enables TTL 3 and 2 as output
                      //   bit 20 enables TTL 1 and 0 as output
                      //   bits 0,4,8,12,16 set TTL 0..3 and TRIGOUT high or low
    // FET
    uint32 fet_term;  // use DQ_MF101_DO_TERM_PD and DQ_MF101_DO_TERM_PU macros
    uint32 fet_state; // High 16 bits set high-side FETs, low 16 bits set low-side FETs
} DQINITPRM_101, *pDQINITPRM_101;

typedef struct {
    // AO
    uint32 ao_cfg[DQ_MF101_AO_CHAN]; // range
    uint32 ao_val[DQ_MF101_AO_CHAN]; // raw value in lower 16-bits, upper bits reserved
    // TTL
    uint32 ttl_cfg;   // MF101_CFG defines
                      //   bit 21 enables TTL 3 and 2 as output
                      //   bit 20 enables TTL 1 and 0 as output
                      //   bits 0,4,8,12,16 set TTL 0..3 and TRIGOUT high or low
    // FET
    uint32 fet_term;  // use DQ_MF101_DO_TERM_PD and DQ_MF101_DO_TERM_PU macros
    uint32 fet_state; // High 16 bits set high-side FETs, low 16 bits set low-side FETs
} DQSDOWNPRM_101, *pDQSDOWNPRM_101;

#define DQ_MF101_NAMELEN    (6)

typedef struct {
    char ai_cname[DQ_MF101_AI_CHAN][DQ_MF101_NAMELEN];          // 16*6=96
    char ao_cname[DQ_MF101_AO_CHAN][DQ_MF101_NAMELEN];          // 2*6=12
    char fet_cname[DQ_MF101_DIO_CHAN][DQ_MF101_NAMELEN];        // 16*6=96
    char ttl_cname[DQ_MF101_TTL_CHAN][DQ_MF101_NAMELEN];        // 5*6=30
} DQCNAMES_101, *pDQCNAMES_101;                                 // =234

#define DQ_SX6_MAX_HRS_CEL          (8)         // number of cells to store hours

#define DQ_MF101_PASSWORD_MAX_LENGTH    (12)    // max length for password used in PIO-1010

typedef struct {
    DQEECMNDEVS         ee;
    DQPRMFLAGSA         eeflags;
    DQCALSET_101_AI     calset_ai;
    DQCALSET_101_AO     calset_ao;
    DQCALSET_101_DIO    calset_dio;
    DQINITPRM_101       initprm;
    DQSDOWNPRM_101      sdownprm;
    DQCNAMES_101        cname;
    char                u_pass[DQ_MF101_PASSWORD_MAX_LENGTH];   // only used by PIO-1010
    char                su_pass[DQ_MF101_PASSWORD_MAX_LENGTH];  // only used by PIO-1010
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQPRMFLAGSA)
                           - sizeof(DQCALSET_101_AI)
                           - sizeof(DQCALSET_101_AO)
                           - sizeof(DQCALSET_101_DIO)
                           - sizeof(DQINITPRM_101)
                           - sizeof(DQSDOWNPRM_101)
                           - sizeof(DQCNAMES_101)
                           - sizeof(char) * DQ_MF101_PASSWORD_MAX_LENGTH
                           - sizeof(char) * DQ_MF101_PASSWORD_MAX_LENGTH
                           - DQ_SX6_MAX_HRS_CEL * sizeof(uint32)
                           - sizeof(DQEEPROMTAIL)];
    uint32 hours[DQ_SX6_MAX_HRS_CEL];  // [8] 1010 hours counter - round robbin
    DQEEPROMTAIL        eever_crc;
} DEVEEPROM_101, *pDEVEEPROM_101;

#pragma pack()

#define DQ_PC104_CHAN               (2)
#define DQ_PC104_CALDACS            (2)
#define DQ_PC104_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)

#define DQ_PC104_INFOSZ             (DQ_MAX_INFO_SIZE)      // maximum size of information structure
#define DQ_PC104_BASE               (66000000)  // 66MHz base frequency
#define DQ_PC104_MAXCLFRQ           (2000)
#define DQ_PC104_MAXCVFRQ           (2000)
#define DQ_PC104_MAXWAIT            (20)        // max delay on the bus for read/write = 2us per read/write

// Special bits in LCR register (0x0)
#define DQ_PC104_LCR_DPEN           (1L<<2)     // Enable (1)/Disable(0) direct access to the dual-port block memory
                                                // has to be zero to program CLO/CDO for interrupt handling
#define DQ_PC104_LCR_LED            (1L<<1)     // Enable/disable LED driver

// Special interrupt settings for (IER/IMR/ISR/ICR) (DQL_CLI_IER (0x1c/20/24/28)
#define DQ_PC104_IER_AE             (1L<<9)     // Address generation error
#define DQ_PC104_IER_TO             (1L<<8)     // Timeout is detected on the bus
#define DQ_PC104_IER_WBD            (1L<<7)     // Write block completed
#define DQ_PC104_IER_RBD            (1L<<6)     // Read block completed
#define DQ_PC104_IER_WIOD           (1L<<5)     // Write to I/O completed
#define DQ_PC104_IER_RIOD           (1L<<4)     // Read from I/O completed
#define DQ_PC104_IER_WMD            (1L<<3)     // Write to memory completed
#define DQ_PC104_IER_RMD            (1L<<2)     // Read from memory completed
#define DQ_PC104_IER_IRQB           (1L<<1)     // Combined IRQB sources
#define DQ_PC104_IER_IRQA           (1L<<0)     // Combined IRQA sources

// DC/DC control mask (DQL_CLI_CFGDCDC (0x0038))
#define DQ_PC104_DC12N_2            (1L<<7)     // -12V DC/DC
#define DQ_PC104_DC12N_1            (1L<<4)     // -12V DC/DC
#define DQ_PC104_DC12_5             (1L<<6)     // +12V DC/DC
#define DQ_PC104_DC12_4             (1L<<5)     // +12V DC/DC
#define DQ_PC104_DC12_3             (1L<<3)     // +12V DC/DC
#define DQ_PC104_DC12_2             (1L<<2)     // +12V DC/DC
#define DQ_PC104_DC12_1             (1L<<1)     // +12V DC/DC
#define DQ_PC104_DC5N               (1L<<0)     // -5V DC/DC


#define DQ_PC104_CFG                (0x2000)    // configuration register
#define DQ_PC104_STS                (0x2004)    // status register
#define DQ_PC104_BA0                (0x2008)    // base address and bus setup for device 0
#define DQ_PC104_BA1                (0x200C)    // base address and bus setup for device 1
#define DQ_PC104_IRQA               (0x2010)    // IRQ A assignment
#define DQ_PC104_IRQB               (0x2014)    // IRQ B assignment
#define DQ_PC104_LNEN               (0x2018)    // direct control over PC-104 bus lines
#define DQ_PC104_IRQPINS            (0x201C)    // current status of IRQ lines
#define DQ_PC104_MEMRD              (0x2020)    // Async read from PC-104 bus memory space (R)/address (W)
#define DQ_PC104_MRADDR             (0x2020)    //
#define DQ_PC104_IORD               (0x2024)    // Async read from PC-104 bus I/O space (R)/port I/O (W)
#define DQ_PC104_IORADDR            (0x2024)    //
#define DQ_PC104_MWADDR             (0x2028)    // Memory write address
#define DQ_PC104_MEMWR              (0x202C)    // Memory write
#define DQ_PC104_IOWADDR            (0x2030)    // I/O write address
#define DQ_PC104_IOWR               (0x2034)    // Power I/O write
#define DQ_PC104_BCMD0              (0x2038)    // Block I/O command word 0
#define DQ_PC104_BCMD1              (0x203C)    // Block I/O command word 0

#define DQ_PC104_DP0                (0x8000)    // beginning of 32-bit dual-port FPGA memory

// General configuration register (0x2000 W)
#define DQ_PC104_DBGxEN(N)          (((N)&0xff)<<8)     // DBGxEN
#define DQ_PC104_EN_MC              (1L<<7)     // take IVP out of reset
#define DQ_PC104_IRQP               (0L<<6)     // positive interrupt polarity
#define DQ_PC104_IRQN               (1L<<6)     // negative interrupt polarity
#define DQ_PC104_BUSCLOCK_5_5MHz    (1L<<4)     // bus clock 5.5MHz
#define DQ_PC104_BUSCLOCK_6_6MHz    (2L<<4)     // bus clock 6.6MHz
#define DQ_PC104_BUSCLOCK_8MHz      (3L<<4)     // bus clock 8MHz
#define DQ_PC104_OSC_14MHz          (1L<<3)     // 14.08MHz oscillator enabled
#define DQ_PC104_BE                 (1L<<2)     // block access enabled
#define DQ_PC104_WE                 (1L<<1)     // bus enabled
#define DQ_PC104_ASSERT_RESET       (1L<<0)     // assert reset line on the bus
#define DQ_PC104_BUSCLOCK_0         (0)         // no bus clock

// General status register (0x2004 R)
#define DQ_PC104_STS_BTB            (1L<<31)    // block transfer in progress, block access is busy
#define DQ_PC104_STS_IOCHK          (1L<<30)    // I/O Check state (high is OK)

#define DQ_PC104_STS_STAE           (1L<<19)    // Address error - BA0/BA1 programmed incorrectly
#define DQ_PC104_STS_STTO           (1L<<18)    // Timeout in ISA state machine - logic error
#define DQ_PC104_STS_IO16TO         (1L<<17)    // Timeout during 16-bit I/O access
#define DQ_PC104_STS_M16TO          (1L<<16)    // Timeout during 16-bit memory access
#define DQ_PC104_STS_MIO8TO         (1L<<15)    // Timeout during 8-bit memory or IO access
#define DQ_PC104_STS_IRQ14_15S      (1L<<14)    // IRQs 14 and 15
#define DQ_PC104_STS_IRQ12S         (1L<<13)    // IRQs 12
#define DQ_PC104_STS_IRQ11S         (1L<<12)    // IRQs 11
#define DQ_PC104_STS_IRQ10S         (1L<<11)    // IRQs 10
#define DQ_PC104_STS_IRQ7_9S        (1L<<10)    // IRQs 7 and 9
#define DQ_PC104_STS_IRQ6S          (1L<<9)     // IRQs 6
#define DQ_PC104_STS_IRQ5S          (1L<<8)     // IRQs 5
#define DQ_PC104_STS_IRQ4S          (1L<<7)     // IRQs 4
#define DQ_PC104_STS_IRQ3S          (1L<<6)     // IRQs 3

#define DQ_PC104_STS_BWD            (1L<<5)     // block write completed
#define DQ_PC104_STS_BRD            (1L<<4)     // block read completed
#define DQ_PC104_STS_IOWD           (1L<<3)     // I/O write completed
#define DQ_PC104_STS_IORD           (1L<<2)     // I/O read completed
#define DQ_PC104_STS_MWD            (1L<<1)     // memory write completed
#define DQ_PC104_STS_MRD            (1L<<0)     // memory read completed

#define DQ_PC104_STS_IRQ3S_SH       (6)         // shift relatively to ISR configuration register

// Device Base Address register (0x2008 first/0x200C second device)
#define DQ_PC104_BA_SELECT          (1L<<31)    // bit needs to be set to reprogram mode
#define DQ_PC104_BA_IOSPACE         (0L<<30)    // 0 = I/O space, 1 = memory space <- software only
#define DQ_PC104_BA_MEMIO           (1L<<30)    // 0 = I/O space, 1 = memory space <- software only
#define DQ_PC104_BA_IOCHKRDY        (1L<<29)    // use IOCHKRDY line for access
#define DQ_PC104_BA_IOCS16          (1L<<28)    // use IOCS16# line for access
#define DQ_PC104_BA_MEMCS16         (1L<<27)    // use MEMCS16# line for access
#define DQ_PC104_BA_AEN_A17         (1L<<26)    // AEN line needs to be driven together with A17
#define DQ_PC104_BA_ACCESS_16       (1L<<25)    // device supports 16-bit access

#define DQ_PC104_BA_ALL             (0xff000000)// all control bits

#define DQ_PC104_BAN(N)             (((N)&0x1f)<<20)    // number of bits used in BA field
#define DQ_PC104_BA(N)              ((N)&0xfffff)       // base address

// Interrupt selection register (0x2010/0x2014 W/R)
#define DQ_PC104_IRQ14_15S          (1L<<8)     // IRQs 14 and 15
#define DQ_PC104_IRQ12S             (1L<<7)     // IRQs 12
#define DQ_PC104_IRQ11S             (1L<<6)     // IRQs 11
#define DQ_PC104_IRQ10S             (1L<<5)     // IRQs 10
#define DQ_PC104_IRQ7_9S            (1L<<4)     // IRQs 7 and 9
#define DQ_PC104_IRQ6S              (1L<<3)     // IRQs 6
#define DQ_PC104_IRQ5S              (1L<<2)     // IRQs 5
#define DQ_PC104_IRQ4S              (1L<<1)     // IRQs 4
#define DQ_PC104_IRQ3S              (1L<<0)     // IRQs 3

#define DQ_PC104_ASSIGN_IRQA(N)     ((N)&0x1ff)
#define DQ_PC104_ASSIGN_IRQB(N)     (((N)&0x1ff)<<16)

// Bus pin enable register (0x2018 W)
#define DQ_PC104_DACK               (1L<<13)    // enable DACK# output
#define DQ_PC104_SHBE               (1L<<12)    // enable SHBE# output

#define DQ_PC104_BALE               (1L<<11)    // enable BALE# output
#define DQ_PC104_AEN                (1L<<10)    // enable AEN# output
#define DQ_PC104_BCLK               (1L<<9)     // enable BCLK# output
#define DQ_PC104_OSC                (1L<<8)     // enable OSC# output

#define DQ_PC104_TC                 (1L<<7)     // enable TC# output
#define DQ_PC104_REFRESH            (1L<<6)     // enable REFRESH# output
#define DQ_PC104_IOW                (1L<<5)     // enable IOW# output
#define DQ_PC104_IOR                (1L<<4)     // enable IOR# output

#define DQ_PC104_SMEMW              (1L<<3)     // enable SMEMW# output
#define DQ_PC104_SMEMR              (1L<<2)     // enable SMEMR# output
#define DQ_PC104_MEMW               (1L<<1)     // enable MEMW# output
#define DQ_PC104_MEMR               (1L<<0)     // enable MEMR# output

// For DqAdv104WriteScript() - and output channel list commands
#define DQ_PC104_CDO_ENDIRQ         (1L<<28)    // call WBD/RBD interrupt upon completion of the block transfer
#define DQ_PC104_CDO_ACC16BIT       (0L<<27)    // perform 16-bit access
#define DQ_PC104_CDO_ACC8BIT        (1L<<27)    // perform 8-bit access
#define DQ_PC104_CDO_IMMDATA        (1L<<26)    // write immediate word (from the second entry)
#define DQ_PC104_CDO_DIR            (1L<<25)    // direction of the block access (0=Read, 1=Write)
#define DQ_PC104_CDO_READ           (0L<<25)    // direction of the block access - read
#define DQ_PC104_CDO_WRITE          (1L<<25)    // direction of the block access write
#define DQ_PC104_CDO_IOSPCSEL       (0L<<24)    // select what to access 0=I/O space, 1=memory space
#define DQ_PC104_CDO_MEMSPCSEL      (1L<<24)    // select what to access 0=I/O space, 1=memory space
#define DQ_PC104_CDO_ADDRESS(N)     ((N)&0xffffff) // 24-bit PC-104 address

#define DQ_PC104_CDO_TRANSIZE(N)    ((((N)-1)&0xfff)<<16)   // number of PC-104 transactions to perform; if IMMDATA flag is set this field is used for the data
#define DQ_PC104_CDO_DNAADDRi(N)    ((((N)-0x8000)>>2)&0x1fff)  // Data index within DNA-PC-104 layer exchange memory (index of zero is 0x8000 in the 32-bit memory address space)
#define DQ_PC104_CDO_DNAADDR(N)     ((N)&0xffff)    // Data address within DNA-PC-104 layer exchange memory (index of zero is 0x8000 in the 32-bit memory address space)

#define DQ_PC104_CL_CLK             (1L<<29)    // wait for CL clock - software only

#define DQ_PC104_SPACESIZE_MASK     (DQ_PC104_CDO_ACC8BIT|DQ_PC104_CDO_MEMSPCSEL)    // access and space only
#define DQ_PC104_SCRIPT_MASK        (0xfffffff) // CDO entries but not software flags - first word
#define DQ_PC104_SCRIPTDATA_MASK    (0xffff0fff)// CDO entries - second word

// For DqAdv104SetClock
#define DQ_PC104_CL_SW              (0)         // Software clock
#define DQ_PC104_CL_TIMER           (1)         // use timer as a CL clock
#define DQ_PC104_CL_IRQA            (2)         // use IRQA as a CL clock
#define DQ_PC104_CL_IRQB            (3)         // use IRQB as a CL clock
#define DQ_PC104_CL_IRQEN           (1L<<3)     // internal IRQ processing enabled

// IOCTLs for PC-104 layer
#define DQL_IOCTL104_SETCFG         (0x8)       // set configuration, return status
#define DQL_IOCTL104_SETDCDC        (0x9)       // control DC/DC
#define DQL_IOCTL104_MEMIOWRRD      (0xA)       // write or read memory or I/O word
#define DQL_IOCTL104_START          (0xB)       // enable serving CLO script
#define DQL_IOCTL104_BLOCKWRRD      (0xC)       // read or write memory or I/O block
#define DQL_IOCTL104_MEMORYWRRD     (0xD)       // read or write FPGA dual-port memory
#define DQL_IOCTL104_CUSTOMPROC     (0xE)       // Set custom proc

#define DQ_PC104_READBUS            (1)         // read bus
#define DQ_PC104_WRITEBUS           (2)         // write bus
#define DQ_PC104_READMEM            (3)         // read memory
#define DQ_PC104_WRITEMEM           (4)         // write memory
#define DQ_PC104_WRITESCRIPT        (5)         // write script
#define DQ_PC104_READSTATUS         (6)         // read status
#define DQ_PC104_CONFIGURE_BUS      (7)         // configure bus
#define DQ_PC104_CONFIGURE_INTCLK   (8)         // configure interrupt and clock settings

#define DQ_PC104_SET_CUSTOM_PROC    (1)         // Set the type of the custom procedure
#define DQ_PC104_SET_CUSTOM_PARAM   (2)         // Edit parameters of this procedure

#define DQ_PC104_ISR_DEFAULT        (0)         // default ISR
#define DQ_PC104_ISR_SIMA_ICB       (1)         // SIMA ICB card
#define DQ_PC104_ISR_SIMA_RSB       (2)         // SIMA RSB card
#define DQ_PC104_ISR_SIMA_ASCBA     (4)         // SIMA ASCB-A card
#define DQ_PC104_ISR_SIMA_ASCBB     (5)         // SIMA ASCB-B card
#define DQ_PC104_ISR_SIMA_ASCBC     (6)         // SIMA ASCB-C card
#define DQ_PC104_ISR_IVP            (16)        // ISR serviced by IVP

// SIMA card addresses
#define DQ_PC104_SIMA_FRAME         (0x440)     // frame for ASCB, reserved for ICB and RSB
#define DQ_PC104_SIMA_MSLOT         (0x442)     // message slot
#define DQ_PC104_SIMA_BCM           (0x444)     // bus control mode
#define DQ_PC104_SIMA_DCNT          (0x446)     // data counter
#define DQ_PC104_SIMA_ECNT          (0x448)     // error counter
#define DQ_PC104_SIMA_ERRVLD        (0x450)     // error/valid cumulative counter
#define DQ_PC104_SIMA_ACK           (0x7ffe)    // read to acknowledge an interrupt

#define DQ_PC104_SIMA_MCTRL         (0x900)     // location the message control/status data
#define DQ_PC104_SIMA_MCTRL_STAT    (0x90E)     // status area

#define DQ_PC104_SIMA_CLO_ENTRIES   (32)        // number of entries for interrupt processing

#pragma pack(1)

/**************************************************************/
/* Message control/status data                                */
/* BP_MSG_DATA must be located at (RAM start + 0x900)         */
/**************************************************************/
typedef struct {
   uint16 addr: 8;                  /* message Rx address            */
   uint16 datacnt_mode: 8;          /* data count mode               */
                                    /* 0x00 no data count            */
                                    /* 0x01 - 0-1 data count         */
                                    /* 0x03 - 0-3 data count         */
                                    /* 0x07 - 0-7 data count         */
                                    /* 0x0f - 0-15 data count        */
                                    /* 0x10 - control data count     */
                                    /* 0x20 - multiplexed data count */
} SIMA_ADCT_BITS;

typedef struct {
   uint16 type: 4;                  /* message type                      */
                                    /* 0 - none                          */
                                    /* 1 - start                         */
                                    /* 2 - control                       */
                                    /* 3 - request                       */
                                    /* 4 - data                          */
   uint16 mode: 4;                  /* message mode                      */
                                    /* 0 - NOP                           */
                                    /* 1 - rx    (data messages only )   */
                                    /* 2 - tx    (data messages only )   */
                                    /* 3 - tx/rx (control messages only) */
   uint16 crc: 4;                   /* crc                               */
                                    /* 0 - error                         */
                                    /* 1 - valid                         */
   uint16 check: 4;                 /* error check                       */
                                    /* 0 - none                          */
                                    /* 1 - valid checksum                */
                                    /* 2 - valid CRC                     */
} SIMA_CTRL_BITS;

typedef struct {
   uint16 trigger: 2;               /* trigger selection */
                                    /* 0 - none          */
                                    /* 1 - output 1      */
                                    /* 2 - output 2      */
                                    /* 3 - both outputs  */
   uint16 rxbus: 2;                 /* Rx Bus selection  */
                                    /* 0 - bus 1         */
                                    /* 1 - bus 2         */
                                    /* 2 - bus 3         */
                                    /* 3 - bus 4         */
   uint16 txbus: 4;                 /* tx enable bits    */
                                    /* 0 - disable       */
                                    /* 1 - disable       */
   uint16 rsvd: 8;                  /* reserved bits     */
} SIMA_TBUS_BITS;

typedef struct {
   uint16 add:1;
   uint16 crc:1;
   uint16 chk:1;
   uint16 cnt:1;
   uint16 frm:1;
   uint16 chr:1;
   uint16 res:10;
} SIMA_STAT_BITS;

typedef union {
   SIMA_ADCT_BITS bits;
   uint16 whole;
} SIMA_ADCT;

typedef union {
   SIMA_CTRL_BITS bits;
   uint16 whole;
} SIMA_CTRL;

typedef union {
   SIMA_TBUS_BITS bits;
   uint16 whole;
} SIMA_TBUS;

typedef union {
   SIMA_STAT_BITS bits;
   uint16 whole;
} SIMA_STAT;

typedef struct {
   SIMA_ADCT adct;                  // message address/data count
   SIMA_CTRL ctrl;                  // message 0 control word
   uint16 leng;                     // message length in bytes (including CRC and check)
                                    // minimum control message length is 3 and
                                    // minimum data message length is 6
   SIMA_TBUS tbus;                  // message trigger and bus enables
   uint16 offs;                     // message data offset (hex)
   uint16 segm;                     // message data segment (hex)
   uint16 time;                     // message rx/tx offset time
   SIMA_STAT stat;                  // message receive status
} SIMA_MSG_CTRL_STATUS, *pSIMA_MSG_CTRL_STATUS;



#define SIMA_ADCT_OF                (0)         // message address/data count
#define SIMA_CTRL_OF                (2)         // message 0 control word
#define SIMA_LENG_OF                (4)         // message length in bytes (including CRC and check)
                                                // minimum control message length is 3 and
                                                // minimum data message length is 6
#define SIMA_TBUS_OF                (6)         // message trigger and bus enables
#define SIMA_OFFS_OF                (8)         // message data offset (hex)
#define SIMA_SEGM_OF                (10)        // message data segment (hex)
#define SIMA_TIME_OF                (12)        // message rx/tx offset time
#define SIMA_STAT_OF                (14)        // message receive status

#define SIMA_OF_SIZE                (0x10)      // size of the structure

//
#define DQ_PC104_CHNUM              (0x1)
#define DQ_PC104_CHTYPE             (0xE)

// blocks of memory for ICB/RSB mapping
#define DQ_SIMA_RDBLK0              (0x8000)    // read block 0
#define DQ_SIMA_RDBLK1              (0x9000)    // read block 1
#define DQ_SIMA_WRBLK0              (0xA000)    // write block 0
#define DQ_SIMA_WRBLK1              (0xB000)    // write block 1

// data exchange area
#define DQ_SIMA_RX_BUFSEL           (0)
#define DQ_SIMA_TX_BUFSEL           (1)

#define DQ_SIMA_WRRDBLK(N,W)        ((((N)>0)?0x8000:0x9000)+(((W)>0)?0x2000:0))
#define DQ_SIMA_WRRDBLKi(N,W)       (((DQ_SIMA_WRRDBLK((N),(W))-0x8000)>>2)&0x1fff)

#define DQ_SIMA_RDBLK0i             (DQ_SIMA_RDBLK0>>2)  // ditto but uint32 indices
#define DQ_SIMA_RDBLK1i             (DQ_SIMA_RDBLK1>>2)
#define DQ_SIMA_WRBLK0i             (DQ_SIMA_WRBLK0>>2)
#define DQ_SIMA_WRBLK1i             (DQ_SIMA_WRBLK1>>2)

// blocks of memory for block operations
#define DQ_PC104_BLKMEM0            (0xF000)    // read area (2kB)
#define DQ_PC104_BLKMEM1            (0xF800)    // write area (2kB)
#define DQ_PC104_BLKSCRATCH         (0xFFC0)    // scratchpad area (64B)

// same but 32-bit indices in exchange areas
#define DQ_PC104_BLKMEM0i           ((DQ_PC104_BLKMEM0-0x8000)>>2)      // read area (2kB)
#define DQ_PC104_BLKMEM1i           ((DQ_PC104_BLKMEM1-0x8000)>>2)      // write area (2kB)
#define DQ_PC104_BLKSCRATCHi        ((DQ_PC104_BLKSCRATCH-0x8000)>>2)   // scratchpad area (64B)

// VMap channels for ICB/RSB boards
#define DQ_PC104_VMAP_SIMA_CTRL     (0x0)       // control
#define DQ_PC104_VMAP_SIMA_STS      (0x0)       // status
#define DQ_PC104_VMAP_SIMA_SLOT(BRD,SLOT)   ((((BRD)&1)<<15)|(((SLOT)&0xFF)+0x10))
#define DQ_PC104_VMAP_SIMA_R90E     (0x40)      // modifyer to request register 0x90E (status) along with the data
#define DQ_PC104_VMAP_SIMA_GET_BRD(N)   (((N)&0x8000)>>15)

#define DQ_PC104_VMAP_SIMA_BUFF(CHAN)   (((CHAN)&0xff) - 0x10)
#define DQ_PC104_VMAP_SIMA_CARD(CHAN)   ((CHAN)>>15)

#define DQ_PC104_MAXWAIT_BUF        (5)         // max delay us if buffer is locked

// ICB/RSB parameters
#define DQ_PC104_SIMA_FRMSZ_RD      (1)         // size of the frame for read
#define DQ_PC104_SIMA_FRMSZ_WR      (2)         // ditto write

/* channel names */
typedef struct {
    char cname[DQ_PC104_CHAN][DQ_PC104_NAMELEN];
} DQCNAMES_104, *pDQCNAMES_104;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_PC104_CALDACS];    /* four calibration DAQs */
} DQCALSET_104, *pDQCALSET_104;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_PC104_CHAN*2];  // channel list - full
    int clperint;                   // <reserved>
} DQOPMODEPRM_104, *pDQOPMODEPRM_104;

// this is custom device structure to support SIMA ICB/RSB cards
#define PC104_SIMA_ICB_BUFS         (4)         // number of RSB buffers
#define PC104_SIMA_ICB_BUFSZ        (768)       // size in bytes, max (XXX: largest buffer is 394*2B=788B)

#define PC104_SIMA_RSB_BUFS         (24)        // number of RSB buffers
#define PC104_SIMA_RSB_BUFSZ        (64)        // size in bytes, max
#define PC104_SIMA_BUFSIZE          (16384)     // 16kB per buffer

#define DQ_PC105_CHAN               (1)
#define DQ_PC105_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)

#define DQ_PC105_INFOSZ             (DQ_MAX_INFO_SIZE)      // maximum size of information structure
#define DQ_PC105_BASE               (66000000)  // 66MHz base frequency
#define DQ_PC105_MAXCLFRQ           (2000)
#define DQ_PC105_MAXCVFRQ           (2000)
#define DQ_PC105_MAXWAIT            (20)        // max delay on the bus for read/write = 2us per read/write
#define DQ_PC105_MAXCLSIZE          (65536)     // maximum amount of EC memory accessible by the EC host

#define DQ_PC105_CALDACS            (4)

#define DQL_PC105_SYNCD            DQL_LCR_SYNCD   // debug mode on
#define DQL_PC105_LED              (1L<<1)         // switch LED on

#define EC105_PERIODIC_us          (100*1000)          // 10ms

#define EC105_UPDATE_RATE          (1000)     // 1k Hertz
#define EC105_STARTRATE_DIV        (DQ_PC105_BASE/EC105_UPDATE_RATE-1)     // divider for EC105_UPDATE_RATE

// ------------- Registers ----------------------------------------------------------
#define DQ_PC105_CFG            0x2000  // R/W  General configuration register
#define DQ_PC105_STS            0x2004  // R        Current status of the RIN32 access module
#define DQ_PC105_RDWR           0x2008  // R/W  Direct read/write access to RIN32 MC,
#define DQ_PC105_DATARD         0x200C  // R        RIN32 data from the read transaction

//            PC105_CFG                 16'h2000,             // R/W  General configuration register
// General configuration register is used to enable/disable RIN32 access module and set address
// for the next R/W transaction, address auto-increment mode is available
#define DQ_PC105_CFG_EN     (1L<<31)    // Enable RIN32 access
                // 30..28
#define DQ_PC105_WCLK_E     (1L<<27)    // # of 66MHz clock for the RIN32 access, actual access cycle
#define DQ_PC105_WCLK_S     (1L<<24)    // is N+4 clocks, 0 -  use default value (10)
#define DQ_PC105_WCLK(N)    ((N)<<24)   //
#define DQ_PC105_CFG_R41    (1L<<23)    // Value for Reserved 41 pin on the RIN32 connector
                // 22
#define DQ_PC105_CFG_AAI    (1L<<21)    // Auto-increment address by 2 after each read/write transaction
#define DQ_PC105_CFG_A20    (1L<<20)    // Configure address for the next access, please note that only bits
#define DQ_PC105_CFG_A0     (1L<<0)     // A20, A16:A0 are connected to the RIN32 microcontroller, bits A19:A17 are pulled up
#define DQ_PC105_CFG_ADDR(N)   (((N)&0x1ffffe)<<0)

//            PC105_STS                 16'h2004,             // R        Current status of the RIN32 access module
#define DQ_PC105_STS_WBUSY  (1L<<2)     // =1 - Write state machine is busy
#define DQ_PC105_STS_RBUSY  (1L<<1)     // =1 - Read state machine is busy
#define DQ_PC105_STS_BUSY_N (1L<<0)     // =0 - RIN32 is busy

//            PC105_RDWR                    =             16'h2008,             // R/W  Direct read/write access to RIN32 MC
//  Write initiate write transaction - 16LSBs of data will be written to the RIN32
//  Read initiates read transaction, data will be available after PC105_STS_RBUSY will go back to zero
//  Also standard IRQ/IRQ status can be used for the read/write completion
//    Read - use IR105IDR - RIN32 data ready interrupt request
//    Write - use IR105IWR - RIN32 write complete interrupt request

//            PC105_DATARD                =             16'h200C,             // R        RIN32 data from the read transaction
// Read  returns data from the previous read transaction initiated via PC105_RDWR


#pragma pack(1)


//-----------------------------------------------------------------------------
// EtherCAT register - as a structure
//-----------------------------------------------------------------------------
#define RINECAT_OFFS        (0xE0000)       // offset of ECAT area from PDNA
#define RINECAT_PTR         (0xE0F80)       // offset of the pointer into RAM structure

#define RINRAM_BASE         (0x180000)
#define RINRAM_OFFS         (0x1f0000)      // offset for RAM as seen from PDNA (notice, PDNA can access 0x1f0000 range only)
#define RINRAM_SIZE         (0xffff)
#define RINRAM_RIN32OFFS    (0x20000000)    // offset for RAM as seen from RIN32 device



#define EC105_ACC_NSLEEP    1000     // in nS
#define EC105_ACC_MAXTIME   1000     // in EC105_ACC_NSLEEP

// ------ FMMU ------
typedef struct
{
    uint32   L_START_ADR;                //!< 0x0000 : Logical Start Address
    uint16   LEN;                        //!< 0x0004 : Length
    uint8    L_START_BIT;                //!< 0x0006 : Logical Start bit
    uint8    L_STOP_BIT;                    //!< 0x0007 : Logical Stop bit
    uint16   P_START_ADR;                //!< 0x0008 : Physical Start Address
    uint8    P_START_BIT;                //!< 0x000A : Physical Start bit
    uint8    TYPE;                        //!< 0x000B : Type
    uint8    ACT;                        //!< 0x000C : Activate
    uint8    RESERVED0[0x10 - 0x0D];        //!< 0x000D - 0x000F : Reserved
} ECAT_FMMU_TypeDef, *pECAT_FMMU_TypeDef;

// ------ SyncManager ------
typedef struct
{
    uint16   P_START_ADR;                //!< 0x0000 : Physical Start Address
    uint16   LEN;                        //!< 0x0002 : Length
    uint8    CONTROL;                    //!< 0x0004 : Control Register
    uint8    STATUS;                        //!< 0x0005 : Status Register
    uint8    ACT;                        //!< 0x0006 : Activate
    uint8    PDI_CONT;                    //!< 0x0007 : PDI Control
} ECAT_SM_TypeDef, *pECAT_SM_TypeDef;

// ------ EtherCAT registers -----
typedef struct
{
    // ------ ESC Information ------
    uint8    TYPE;                        //!< 0x0000 : Type
    uint8    REVISION;                    //!< 0x0001 : Revision
    uint16   BUILD;                        //!< 0x0002 : Build
    uint8    FMMU_NUM;                    //!< 0x0004 : FMMUs supported
    uint8    SYNC_MANAGER;                //!< 0x0005 : SyncManagers supported
    uint8    RAM_SIZE;                    //!< 0x0006 : RAM Size
    uint8    PORT_DESC;                    //!< 0x0007 : Port Descriptor
    uint16   FEATURE;                     //!< 0x0008 : ESC Features supported
    uint8    RESERVED0[0x10 - 0x0A];        //!< 0x000A - 0x000F : Reserved

    // ------ Station Address ------
    uint16   STATION_ADR;                //!< 0x0010 : Configured Station Address
    uint16   STATION_ALIAS;                //!< 0x0012 : Configured Station Alias
    uint8    RESERVED1[0x20 - 0x14];        //!< 0x0014 - 0x001F : Reserved

    // ------ Write Protection ------
    uint8    WR_REG_ENABLE;                //!< 0x0020 : Write Register Enable
    uint8    WR_REG_PROTECT;                //!< 0x0021 : Write Register Protection
    uint8    RESERVED2[0x30 - 0x22];        //!< 0x0022 - 0x002F : Reserved
    uint8    ESC_WR_ENABLE;                //!< 0x0030 : ESC Write Enable
    uint8    ESC_WR_PROTECT;                //!< 0x0031 : ESC Write Protection
    uint8    RESERVED3[0x40 - 0x32];        //!< 0x0032 - 0x003F : Reserved

    // ------ Data Link Layer ------
    uint8    ESC_RESET_ECAT;                //!< 0x0040 : ESC Reset ECAT
    uint8    ESC_RESET_PDI;                //!< 0x0041 : ESC Reset PDI
    uint8    RESERVED4[0x100 - 0x42];    //!< 0x0042 - 0x00FF : Reserved
    uint32   ESC_DL_CONTROL;                //!< 0x0100 : ESC DL Control
    uint8    RESERVED5[0x108 - 0x104];    //!< 0x0104 - 0x0107 : Reserved
    uint16   PHYSICAL_RW_OFFSET;            //!< 0x0108 : Physical Read/Write Offset
    uint8    RESERVED6[0x110 - 0x10a];    //!< 0x010A - 0x010F : Reserved
    uint16   ESC_DL_STATUS;                //!< 0x0110 : ESC DL Status
    uint8    RESERVED7[0x120 - 0x112];    //!< 0x0112 - 0x011F : Reserved

    // ------ Application Layer ------
    uint16   AL_CONTROL;                    //!< 0x0120 : AL Control
    uint8    RESERVED8[0x130 - 0x122];    //!< 0x0122 - 0x012F : Reserved
    uint16   AL_STATUS;                    //!< 0x0130 : AL Status
    uint16   RESERVED9;                    //!< 0x0132 - 0x0133 : Reserved
    uint16   AL_STATUS_CODE;                //!< 0x0134 : AL Status Code
    uint16   RESERVEDA;                    //!< 0x0136 - 0x0137 : Reserved
    uint8    RUN_LED;                    //!< 0x0138 : RUN LED Override
    uint8    ERR_LED;                    //!< 0x0139 : ERR LED Override
    uint8    RESERVEDB[0x140 - 0x13A];    //!< 0x013A - 0x013F : Reserved

    // ------ PDI ------
    uint8    PDI_CONTROL;                //!< 0x0140 : PDI Control
    uint8    ESC_CONFIG;                    //!< 0x0141 : ESC Configuration
    uint8    RESERVEDC[0x150 - 0x142];    //!< 0x0142 - 0x014F : Reserved
    uint8    PDI_CONFIG;                    //!< 0x0150 : PDI Configuration
    uint8    SYNC_LATCH_CONFIG;            //!< 0x0151 : SYNC/LATCH PDI Configuration
    uint16   EXT_PDI_CONFIG;                //!< 0x0152 : 4 Extended PDI Configuration
    uint8    RESERVEDD[0x200 - 0x154];    //!< 0x0154 - 0x01FF : Reserved

    // ------ Interrupts ------
    uint16   ECAT_EVENT_MASK;            //!< 0x0200 : ECAT Event Mask
    uint16   RESERVEDE;                    //!< 0x0202 - 0x0203 : Reserved
    uint32   AL_EVENT_MASK;                //!< 0x0204 : AL Event Mask
    uint8    RESERVEDF[0x210 - 0x208];    //!< 0x0208 - 0x020F : Reserved
    uint16   ECAT_EVENT_REQ;                //!< 0x0210 : ECAT Event Request
    uint8    RESERVEDG[0x220 - 0x212];    //!< 0x0212 - 0x021F : Reserved
    uint32   AL_EVENT_REQ;                //!< 0x0220 : AL Event Request
    uint8    RESERVEDH[0x300 - 0x224];    //!< 0x0224 - 0x02FF : Reserved

    // ------ Error Counters ------
    uint16   RX_ERR_COUNT[2];            //!< 0x0300 : Rx Error Counter [port]
    uint16   RESERVEDI[2];                //!< 0x0304 - 0x0307 : Reserved
    uint8    FWD_RX_ERR_COUNT[2];        //!< 0x0308 : Forwarded Rx Error counter [port]
    uint8    RESERVEDJ[2];                //!< 0x030A - 0x030B : Reserved
    uint8    ECAT_PROC_ERR_COUNT;        //!< 0x030C : ECAT Processing Unit Error Counter
    uint8    PDI_ERR_COUNT;                //!< 0x030D : PDI Error Counter
    uint8    PDI_ERR_CODE;                //!< 0x030E : PDI Error Code
    uint8    RESERVEDK;                    //!< 0x030F : Reserved
    uint8    LOST_LINK_COUNT[2];            //!< 0x0310 : Lost Link Counter [port]
    uint8    RESERVEDL[2];                //!< 0x0312 - 0x0313 : Reserved
    uint8    RESERVEDM[0x400 - 0x314];    //!< 0x0314 - 0x03FF : Reserved

    // ------ Watchdogs ------
    uint16   WD_DIVIDE;                    //!< 0x0400 : Watchdog Divider
    uint8    RESERVEDN[0x410 - 0x402];    //!< 0x0402 - 0x040F : Reserved
    uint16   WDT_PDI;                    //!< 0x0410 : Watchdog Time PDI
    uint8    RESERVEDO[0x420 - 0x412];    //!< 0x0412 - 0x041F : Reserved
    uint16   WDT_DATA;                    //!< 0x0420 : Watchdog Time Process Data
    uint8    RESERVEDP[0x440 - 0x422];    //!< 0x0422 - 0x043F : Reserved
    uint16   WDS_DATA;                    //!< 0x0440 : Watchdog Status Process Data
    uint8    WDC_DATA;                    //!< 0x0442 : Watchdog Counter Process Data
    uint8    WDC_PDI;                    //!< 0x0443 : Watchdog Counter PDI
    uint8    RESERVEDQ[0x500 - 0x444];    //!< 0x0444 - 0x04FF : Reserved

    // ------ SII EEPROM Interface ------
    uint8    EEP_CONF;                    //!< 0x0500 : EEPROM Configuration
    uint8    EEP_STATE;                    //!< 0x0501 : EEPROM PDI Access State
    uint16   EEP_CONT_STAT;                //!< 0x0502 : EEPROM Control/Status
    uint32   EEP_ADR;                    //!< 0x0504 : EEPROM Address
    uint32   EEP_DATA;                    //!< 0x0508 : EEPROM Data
    uint32   RESERVEDR;                    //!< 0x050C : Reserved

    // ------ MII Management Interface ------
    uint16   MII_CONT_STAT;                //!< 0x0510 : MII Management Control/Status
    uint8    PHY_ADR;                    //!< 0x0512 : PHY Address
    uint8    PHY_REG_ADR;                //!< 0x0513 : PHY Register Address
    uint16   PHY_DATA;                    //!< 0x0514 : PHY Data
    uint8    MII_ECAT_ACS_STAT;            //!< 0x0516 : MII Management ECAT Access State
    uint8    MII_PDI_ACS_STAT;            //!< 0x0517 : MII Management PDI Access State
    uint8    PHY_STATUS[2];                //!< 0x0518 : PHY Port Status
    uint8    RESERVEDS[0x600 - 0x51a];    //!< 0x052A - 0x05FF : Reserved

    // ------ FMMU ------
    ECAT_FMMU_TypeDef    FMMU[8];                //!< 0x0600 - 0x067F FMMU
    uint8    RESERVEDT[0x800 - 0x680];    //!< 0x067C - 0x07FF : Reserved

    // ------ SyncManager ------
    ECAT_SM_TypeDef        SM[8];                    //!< 0x0800 - 0x083F SyncManager
    uint8    RESERVEDU[0x900 - 0x840];    //!< 0x0840 - 0x08FF : Reserved

    // ====== Distributed Clocks (DC) ======
    // ------ DC - Receive Times ------
    uint32   DC_RCVIME_PORT[4];        //!< 0x0900 : Receive Time Port n

    // ------ DC - Time Loop Control Unit ------
    uint64   DC_SYSIME;                //!< 0x0910 : 4/8 System Time
    uint64   DC_RCVIME_UNIT;            //!< 0x0918 : 4/8 Receive Time ECAT Processing Unit
    uint64   DC_SYSIME_OFFSET;            //!< 0x0920 : 4/8 System Time Offset
    uint32   DC_SYSIME_DELAY;            //!< 0x0928 : System Time Delay
    uint32   DC_SYSIME_DIFF;            //!< 0x092C : System Time Difference
    uint16   DC_SPEED_COUNT_START;        //!< 0x0930 : Speed Counter Start
    uint16   DC_SPEED_COUNT_DIFF;        //!< 0x0932 : Speed Counter Diff
    uint8    DC_SYSIME_FIL_DEPTH;        //!< 0x0934 : System Time Difference Filter Depth
    uint8    DC_SPEED_COUNT_FIL_DEPTH;    //!< 0x0935 : Speed Counter Filter Depth
    uint8    RESERVEDV[0x980 - 0x936];    //!< 0x0936 - 0x097F : Reserved

    // ------ DC - Cyclic Unit Control ------
    uint8    DC_CYC_CONT;                //!< 0x0980 : Cyclic Unit Control

    // ------ DC - SYNC Out Unit ------
    uint8    DC_ACT;                        //!< 0x0981 : Activation
    uint16   DC_PULSE_LEN;                //!< 0x0982 : Pulse Length of SyncSignals
    uint8    DC_ACT_STAT;                //!< 0x0984 : Activation Status
    uint8    RESERVEDW[0x98E - 0x985];    //!< 0x0985 - 0x098D : Reserved
    uint8    DC_SYNC_STAT[2];            //!< 0x098E : SYNC n Status
    uint64   DC_CYC_STARTIME;            //!< 0x0990 : 4/8 Start Time Cyclic Operation/Next SYNC0 Pulse
    uint64   DC_NEXT_SYNC1_PULSE;        //!< 0x0998 : 4/8 Next SYNC1 Pulse
    uint32   DC_SYNC_CYCIME[2];        //!< 0x09A0 : SYNC n Cycle Time

    // ------ DC - Latch In Unit ------
    uint8    DC_LATCH_CONT[2];            //!< 0x09A8 : Latch n Control
    uint8    RESERVEDX[0x9AE - 0x9AA];    //!< 0x09AA - 0x09AD : Reserved
    uint8    DC_LATCH_STAT[2];            //!< 0x09AE : Latch n Status
    uint64   DC_LATCH0IME_POS;            //!< 0x09B0 : 4/8 Latch0 Time Positive Edge
    uint64   DC_LATCH0IME_NEG;            //!< 0x09B8 : 4/8 Latch0 Time Negative Edge
    uint64   DC_LATCH1IME_POS;            //!< 0x09C0 : 4/8 Latch1 Time Positive Edge
    uint64   DC_LATCH1IME_NEG;            //!< 0x09C8 : 4/8 Latch1 Time Negative Edge
    uint8    RESERVEDY[0x9F0-0x9D0];        //!< 0x09D0 - 0x09EF : Reserved

    // ------ DC - SyncManager Event Times ------
    uint32   DC_ECAT_CNG_EVIME;        //!< 0x09F0 : EtherCAT Buffer Change Event Time
    uint32   RESERVEDZ;                    //!< 0x09F4 - 0x09F7 : Reserved
    uint32   DC_PDI_START_EVIME;        //!< 0x09F8 : PDI Buffer Start Event Time
    uint32   DC_PDI_CNG_EVIME;            //!< 0x09FC : PDI Buffer Change Event Time
    uint8    RESERVED10[0xE00 - 0xA00];    //!< 0x0A00 - 0x0DFF : Reserved

    // ------ ESC specific ------
//    uint64    PRODUCT_ID;                    //!< 0x0E00 : Product ID
    uint32   PRODUCT_ID[2];                //!< 0x0E00 : Product ID
    uint32   VENDOR_ID;                    //!< 0x0E08 : Vendor ID
    uint8    RESERVED11[0xF10 - 0xE0C];    //!< 0x0E0C - 0x0F0F : Reserved

    // ------ General Purpose ------
    uint32   GPOUT[2];                    //!< 0x0F10 : General Purpose Outputs
    uint32   GPIN[2];                    //!< 0x0F18 : General Purpose Inputs
    uint8    RESERVED12[0xF80 - 0xF20];    //!< 0x0F20 - 0x0F7F : Reserved

    // ------ User RAM/Extended ESC features ------
    uint32   USER_RAM[0x20];                //!< 0x0F80 - 0x0FFF User RAM/Extended ESC features

    // ------ Process Data RAM ------
    uint32   DATA_RAM[8192/4];            //!< 0x1000 - 0x11FF Process Data RAM (8K byte)
} RIN_ECAT_TypeDef, *pRIN_ECAT_TypeDef;



/* channel names */
typedef struct {
    char cname[DQ_PC105_CHAN][DQ_PC105_NAMELEN];
} DQCNAMES_105, *pDQCNAMES_105;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_PC105_CALDACS];    /* four calibration DAQs */
} DQCALSET_105, *pDQCALSET_105;


/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_PC105_CHAN*2];  // channel list - full
    int clperint;                   // <reserved>
} DQOPMODEPRM_105, *pDQOPMODEPRM_105;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_105, *pDQINITPRM_105;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_105, *pDQSDOWNPRM_105;

// this is custom device structure to support SIMA ICB/RSB cards
#define PC105_SIMA_ICB_BUFS         (4)         // number of RSB buffers
#define PC105_SIMA_ICB_BUFSZ        (768)       // size in bytes, max (XXX: largest buffer is 394*2B=788B)

#define PC105_SIMA_RSB_BUFS         (24)        // number of RSB buffers
#define PC105_SIMA_RSB_BUFSZ        (64)        // size in bytes, max
#define PC105_SIMA_BUFSIZE          (16384)     // 16kB per buffer


#define DNR_PWR                     (0x20)      // model number of DNR power (left-most slot), model #'s below this are CPUs
#define DNR_PWR_1G                  (0x40)      // model number of DNR power for Gig-E processor (next to CPU)
#define DNA_PWR_1G                  (0x41)      // model number of DNA power for Gig-E processor (next to CPU)
#define DNF_PWR_1G                  (0x46)      // model number of DNF power for Gig-E processor (next to CPU)
#define MIL_PWR_1G                  (0x47)      // model number of MIL power for Gig-E processor (on backplane)
#define DNR_PWR_1G_MIL6             (0x48)      // model number of MIL power for Gig-E processor (DNR-MIL-6 next to CPU)
#define DQ_DNF_I_MEASURE_LOGIC_VER  (0x10a8)    // logic revision of rev1 PCB where input current measurement appears

// PowerDNx diagnostic layer
#define DNR_LB                      (0x42)      // model number of DNR load board
#define DNR_QTB                     (0x43)      // model number of DNR quick test board
#define DNA_LB                      (0x44)      // model number of DNR load board
#define DNA_QTB                     (0x45)      // model number of DNR quick test board

#define DQ_L2_CHAN                  (16)        // total possible channels
#define DQ_L2_CHAN_MESR             (13)        // measurement channels
#define DQ_L2_CHAN_MAX              (64)        // write/read channels (including special)
#define DQ_L2_INFOSZ                (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_L2_BASE                  (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_L2_MAXCLFRQ              (10)
#define DQ_L2_MAXCVFRQ              (10)

#define DQ_L2_DNRP_OL_CH            (0x10)      // over-limit channel 0
#define DQ_L2_DNRP_UL_CH            (0x20)      // under-limit channel 0
#define DQ_L2_DNRP_LED_CH           (0x30)      // direct R/W to LED register
#define DQ_L2_DNRP_FAN_CH           (0x31)      // direct R/W to STS/CFG register
#define DQ_L2_DNRP_LED_MNGD         (0x32)      // managed R/W to LED register
#define DQ_L2_DNRP_FAN_MNGD         (0x33)      // managed R/W to CFG register
#define DQ_L2_DNRP_SCRATCH_PAD      (0x34)      // read/write to a scratchpad register
#define DQ_L2_DNRP_LAYER_STATUS     (0x35)      // read layer status register
#define DQ_L4_DNRP_HOURS            (0x36)      // return number of hours unit is operational
#define DQ_L4_DNRP_GETSPEED1        (0x37)      // return current speed/duplex on NIC1
#define DQ_L4_DNRP_GETSPEED2        (0x38)      // return current speed/duplex on NIC2

// DQIOCTL_SETPARAM
#define DQ_L2_SET_CONFIG            (1)         // set FAN configurations
#define DQ_L2_SET_LED               (2)         // set LED configurations
#define DQ_L2_SET_LIMITS            (4)         // program limits
#define DQ_L2_SET_SYNC_SW_TIMEOUT   (8)         // program limits
#define DQ_L2_SET_HR_MTR            (16)        // set hour meter configuration

#define DQ_L4_SET_CONFIG            (DQ_L2_SET_CONFIG)    // set FAN configurations
#define DQ_L4_SET_LED               (DQ_L2_SET_LED)       // set LED configurations
#define DQ_L4_SET_LIMITS            (DQ_L2_SET_LIMITS)    // program limits
#define DQ_L4_SET_HR_MTR            (DQ_L2_SET_HR_MTR)    // set hour meter configuration

// ADC allocation 0x20
#define DQ_L2_ADC_TEMP2             (12)        // Temperature 2 (Code-0x800000)*149nV)/0.00295K
#define DQ_L2_ADC_TEMP1             (11)        // Temperature 1 (Code-0x800000)*149nV)/0.00295K
#define DQ_L2_ADC_I_IN              (10)        // Input current (Code-0x800000)*1.788uA
#define DQ_L2_ADC_V_FAN             (9)         // Fan voltage (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_1_2             (8)         // 1.2V source (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_1_5             (7)         // 1.5V source (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_IN              (6)         // Input voltage (Code-0x800000)*149nV*45.3V
#define DQ_L2_ADC_V_24NIC           (5)         // 24V NIC (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_24DNR           (4)         // 24V DNR (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_3_3NIC          (3)         // 3.3V NIC (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_3_3DNR          (2)         // 3.3V DNR (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_2_5NIC          (1)         // 2.5V NIC (Code-0x800000)*149nV*23.1V
#define DQ_L2_ADC_V_2_5DNR          (0)         // 2.5V DNR (Code-0x800000)*149nV*23.1V

// ADC allocation 0x40
#define DQ_L4_ADC_TEMP2             (15)        // Temperature Code/644 [(Code-0x800000)*149nV)/0.00295K]
#define DQ_L4_ADC_I_1_5             (14)        // 1.5V output current (Code-0x800000)*7.45uA
#define DQ_L4_ADC_TEMP1             (13)        // Temperature Code/644 [(Code-0x800000)*149nV)/0.00295K]
#define DQ_L4_ADC_I_3_3             (12)        // 3.3V output current (Code-0x800000)*7.45uA
#define DQ_L4_ADC_GND_3             (11)        // internal reference ground
#define DQ_L4_ADC_I_IN              (10)        // Input current (Code-0x800000)*1.788uA
#define DQ_L4_ADC_V_FAN             (9)         // Fan voltage (Code-0x800000)*149nV*23.1V
#define DQ_L4_ADC_V_1_2             (8)         // 1.2V source (Code-0x800000)*149nV*23.1V
#define DQ_L4_ADC_V_1_5             (7)         // 1.5V source (Code-0x800000)*149nV*23.1V
#define DQ_L4_ADC_V_IN              (6)         // Input voltage (Code-0x800000)*149nV*45.3V
#define DQ_L4_ADC_GND_2             (5)         // internal reference ground
#define DQ_L4_ADC_V_24DNR           (4)         // 24V DNR (Code-0x800000)*149nV*23.1V
#define DQ_L4_ADC_V_CAP             (3)         // V capacitor
#define DQ_L4_ADC_V_3_3DNR          (2)         // 3.3V DNR (Code-0x800000)*149nV*23.1V
#define DQ_L4_ADC_GND               (1)         // internal reference ground
#define DQ_L4_ADC_V_2_5DNR          (0)         // 2.5V DNR (Code-0x800000)*149nV*23.1V

// ADC allocation (0x46) DNF  L4F
//#define DQ_L4_ADC_TEMP2           (15)        // Temperature Code/644 [(Code-0x800000)*149nV)/0.00295K]
//#define DQ_L4_ADC_I_1_5           (14)        // 1.5V output current (Code-0x800000)*7.45uA
//#define DQ_L4_ADC_TEMP1           (13)        // Temperature Code/644 [(Code-0x800000)*149nV)/0.00295K]
//#define DQ_L4_ADC_I_3_3           (12)        // 3.3V output current (Code-0x800000)*7.45uA
#define DQ_L4F_ADC_GND_3            (11)        // internal reference ground
#define DQ_L4F_ADC_I_IN             (10)        // Input current (Code-0x800000)*1.788uA
#define DQ_L4F_ADC_V_FAN            (9)         // Fan voltage (Code-0x800000)*149nV*23.1V
#define DQ_L4F_ADC_V_1_2            (8)         // 1.2V source (Code-0x800000)*149nV*23.1V
#define DQ_L4F_ADC_V_1_5            (7)         // 1.5V source (Code-0x800000)*149nV*23.1V
#define DQ_L4F_ADC_V_IN             (6)         // Input voltage (Code-0x800000)*149nV*45.3V
//gnd                               (5)
//#define DQ_L4_ADC_V_24DNR         (4)         // 24V DNR (Code-0x800000)*149nV*23.1V
//#define (reserved fan current)    (3)         //
//#define DQ_L4F_ADC_I_FAN          (2)         // Fan current
#define DQ_L4F_ADC_V_3_3DNR         (1)         // 3.3V DNR (DNF)(Code-0x800000)*149nV*23.1V
//#define DQ_L4_ADC_V_2_5DNR        (0)         // 2.5V DNR (Code-0x800000)*149nV*23.1V


// ADC allocation (0x47) L4M - MIL
//#define DQ_L4_ADC_TEMP2           (15)        // Temperature Code/644 [(Code-0x800000)*149nV)/0.00295K]
#define DQ_L4M_ADC_I_1_2            (14)        // 1.2V current  (Code-0x800000)*149nV*(1.0/shunt)
//#define DQ_L4_ADC_TEMP1           (13)        // Temperature Code/644 [(Code-0x800000)*149nV)/0.00295K]
#define DQ_L4M_ADC_I_1_5            (12)        // 1.5V current  (Code-0x800000)*149nV*(1.0/shunt)
//#define (unused)                  (11)        // channel 11 readings should be ignored
#define DQ_L4M_ADC_I_3_3            (10)        // 3.3V current  (Code-0x800000)*149nV*(1.0/shunt)
#define DQ_L4M_ADC_GND              (9)         // internal reference ground (Code-0x800000)*149nV
#define DQ_L4M_ADC_I_IN             (8)         // Input current (Code-0x800000-232000)*1.788uA
#define DQ_L4M_ADC_I_24             (7)         // 24V  current  (Code-0x800000)*1.49uA
#define DQ_L4M_ADC_V_1_2            (6)         // 1.2V source   (Code-0x800000)*149nV*23.1V
#define DQ_L4M_ADC_V_1_5            (5)         // 1.5V source   (Code-0x800000)*149nV*23.1V
#define DQ_L4M_ADC_V_IN             (4)         // Input voltage (Code-0x800000)*149nV*47.5V
#define DQ_L4M_ADC_V_24DNR          (3)         // 24V DNR       (Code-0x800000)*149nV*23.1V
#define DQ_L4M_ADC_V_HOLD           (2)         // VHOLD         (Code-0x800000)*149nV*47.5V
#define DQ_L4M_ADC_V_3_3DNR         (1)         // 3.3V DNR (DNF)(Code-0x800000)*149nV*23.1V
#define DQ_L4M_ADC_V_2_5DNR         (0)         // 2.5V DNR      (Code-0x800000)*149nV*23.1V

#define DQ_LT2448_GETVAL(V)         ((((V)>>5)&0xffffff)^0x800000)    // return 24-bit value

// Diagnostic layer ADC allocation (0x42/43/44/45)
#define DQ_LDIAG_ADC_TEMP2          (15)        // Temperature Code/644
#define DQ_LDIAG_ADC_GND_8          (14)        // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_TEMP1          (13)        // Temperature Code/644
#define DQ_LDIAG_ADC_GND_7          (12)        // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_GND_6          (11)        // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_GND_5          (10)        // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_GND_4          (9)         // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_V_1_2          (8)         // +1.2V / 2 (0.6V). Vin = (CODE-0x800000)* 149nV*1.1V
#define DQ_LDIAG_ADC_V_1_5          (7)         // +1.5V / 2 (0.75V).Vin = (CODE-0x800000)* 149nV*1.1V
#define DQ_LDIAG_ADC_V_IN           (6)         // Input voltale (9-36V). Vin = (CODE-0x800000)* 149nV*23.1V
#define DQ_LDIAG_ADC_GND_3          (5)         // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_V_24           (4)         // +24V / 3 (8V). Vin = (CODE-0x800000)* 149nV*11V
#define DQ_LDIAG_ADC_GND_2          (3)         // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_V_3_3          (2)         // +3.3V / 2 (1.667V). Vin = (CODE-0x800000)* 149nV*11V
#define DQ_LDIAG_ADC_GND            (1)         // Internal ground reference. Vin = (CODE-0x800000)* 149nV
#define DQ_LDIAG_ADC_V_2_5          (0)         // +2.5V / 2 (1.25V). Vin = (CODE-0x800000)* 149nV*11V

// Conversion macros (0x42/43/44/45)
#define DQ_LDIAG_CVT_TEMP2(N)       (((float)(N)-0x800000)/644)
#define DQ_LDIAG_CVT_TEMP1(N)       (((float)(N)-0x800000)/644)
#define DQ_LDIAG_CVT_V_1_2(N)       ((((float)(N)-0x800000)*0.000000149)*11)
#define DQ_LDIAG_CVT_V_1_5(N)       ((((float)(N)-0x800000)*0.000000149)*11)
#define DQ_LDIAG_CVT_V_IN(N)        ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_LDIAG_CVT_V_24(N)        ((((float)(N)-0x800000)*0.000000149)*11)
#define DQ_LDIAG_CVT_V_3_3(N)       ((((float)(N)-0x800000)*0.000000149)*11)
#define DQ_LDIAG_CVT_GND(N)         (((float)(N)-0x800000)*0.000000149)
#define DQ_LDIAG_CVT_V_2_5(N)       ((((float)(N)-0x800000)*0.000000149)*11)

// Conversion macros
#define DQ_L2_CVT_TEMP2(N)          ((((float)(N)-0x800000)*0.000000149)*339)
#define DQ_L2_CVT_TEMP1(N)          ((((float)(N)-0x800000)*0.000000149)*339)
#define DQ_L2_CVT_I_IN(N)           (((((float)(N)-0x800000)*0.000000149)*12)- 0.39)
#define DQ_L2_CVT_V_FAN(N)          ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_1_2(N)          ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_1_5(N)          ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_IN(N)           ((((float)(N)-0x800000)*0.000000149)*45.3)   //22.1K ~ 475
#define DQ_L2_CVT_V_24NIC(N)        ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_24DNR(N)        ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_3_3NIC(N)       ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_3_3DNR(N)       ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_2_5NIC(N)       ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L2_CVT_V_2_5DNR(N)       ((((float)(N)-0x800000)*0.000000149)*23.1)

#define LM6p                        (0.943)     // Limit minus 6%
#define LP6p                        (1.06)      // Limit plus 6%
#define LM10p                       (0.909)     // Limit minus 10%
#define LP10p                       (1.1)       // Limit plus 10%

// Define limits
#define DQ_L2_LIM_TEMP2(N)          (((N)>(273-40))&&((N)<(273+90)))
#define DQ_L2_LIM_TEMP1(N)          (((N)>(273-40))&&((N)<(273+90)))
#define DQ_L2_LIM_I_IN(N)           (((N)>0.1)&&((N)<4.5))
#define DQ_L2_BLIM_I_IN(N)          (((N)>0.01)&&((N)<7.0))
#define DQ_L2_LIM_V_FAN(N)          (((N)>7.5)&&((N)<10.0))

// Ideal values - +/-6%
#define DQ_L2_LIM_V_1_2(N)          (((N)>(1.271*LM6p))&&((N)<(1.271*LP6p)))
#define DQ_L2_LIM_V_1_5(N)          (((N)>(1.576*LM6p))&&((N)<(1.576*LP6p)))
#define DQ_L2_LIM_V_IN(N)           (((N)>11)&&((N)<30))
#define DQ_L2_LIM_V_24NIC(N)        (((N)>22.5)&&((N)<26.0))
#define DQ_L2_LIM_V_24DNR(N)        (((N)>22.5)&&((N)<26.0))
#define DQ_L2_LIM_V_3_3NIC(N)       (((N)>(3.3*LM6p))&&((N)<(3.3*LP6p)))
#define DQ_L2_LIM_V_3_3DNR(N)       (((N)>(3.3*LM6p))&&((N)<(3.3*LP6p)))
#define DQ_L2_LIM_V_2_5NIC(N)       (((N)>(2.5*LM6p))&&((N)<(2.5*LP6p)))
#define DQ_L2_LIM_V_2_5DNR(N)       (((N)>(2.5*LM6p))&&((N)<(2.5*LP6p)))

// Still workable +/-10%, but blink LEDs
#define DQ_L2_BLIM_V_1_2(N)         (((N)>(1.271*LM10p))&&((N)<(1.271*LP10p)))
#define DQ_L2_BLIM_V_1_5(N)         (((N)>(1.576*LM10p))&&((N)<(1.576*LP10p)))
#define DQ_L2_BLIM_V_IN(N)          (((N)>9)&&((N)<36))
#define DQ_L2_BLIM_V_24NIC(N)       (((N)>21.6)&&((N)<27.0))
#define DQ_L2_BLIM_V_24DNR(N)       (((N)>21.6)&&((N)<27.0))
#define DQ_L2_BLIM_V_3_3NIC(N)      (((N)>(3.3*LM10p))&&((N)<(3.3*LP10p)))
#define DQ_L2_BLIM_V_3_3DNR(N)      (((N)>(3.3*LM10p))&&((N)<(3.3*LP10p)))
#define DQ_L2_BLIM_V_2_5NIC(N)      (((N)>(2.5*LM10p))&&((N)<(2.5*LP10p)))
#define DQ_L2_BLIM_V_2_5DNR(N)      (((N)>(2.5*LM10p))&&((N)<(2.5*LP10p)))


#define DQ_L2_SAFE_TEMP_HIGH        (273+40)
#define DQ_L2_SAFE_TEMP_LOW         (273+35)
#define DQ_L2_SAFE_TEMP_REDUCTION   (10)        // safe temp reduction if AO-364 or AI-256 is installed

#define DQ_C4_SAFE_TEMP_HIGH        (273+50)
#define DQ_C4_SAFE_TEMP_LOW         (273+47)    // small difference since thermal inertia in DNx-MIL is huge compared to a regular layer

// Conversion macros
#define DQ_L4_CVT_TEMP2(N)          (((float)(N)-0x800000)*2.5/1570) //(((float)(N)-0x800000)/644)
#define DQ_L4_CVT_I_IN_1_5(N)       ((((float)(N)-0x800000)*0.00000745))
#define DQ_L4_CVT_TEMP1(N)          (((float)(N)-0x800000)*2.5/1570) //(((float)(N)-0x800000)/644)
#define DQ_L4_CVT_I_IN_3_3(N)       ((((float)(N)-0x800000)*0.00000745))
#define DQ_L4_CVT_V_GND3(N)         (((float)(N)>=0x800000)?((((float)(N)-0x800000)*0.000000149)):0)
#define DQ_L4_CVT_I_IN(N)           ((((float)(N)-0x800000)*0.000001788)- 0.48)
#define DQ_L4_CVT_V_FAN(N)          ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L4_CVT_V_1_2(N)          ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L4_CVT_V_1_5(N)          ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L4_CVT_V_IN(N)           ((((float)(N)-0x800000)*0.000000149)*47.526)
#define DQ_L4_CVT_V_GND2(N)         ((((float)(N)-0x800000)*0.000000149))
#define DQ_L4_CVT_V_24DNR(N)        ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L4_CVT_V_U_CAP(N)        ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L4_CVT_V_3_3DNR(N)       ((((float)(N)-0x800000)*0.000000149)*23.1)
#define DQ_L4_CVT_V_GND(N)          ((((float)(N)-0x800000)*0.000000149))
#define DQ_L4_CVT_V_2_5DNR(N)       ((((float)(N)-0x800000)*0.000000149)*23.1)

// DNF only Conversion macros (0x46)
#define DQ_L4_CVT_I_IN_FAN(N)       ((((float)(N)-0x800000)*0.000005962))
#define DQ_L4_CVT_I_IN_DNF(N)       ((((float)(N)-0x800000)*0.000001788)- 3.8)

// MIL only Conversion macros (0x47)
#define DQ_L4_CVT_I_1_2(N)          ((((float)(N)-0x800000)*0.0000149))
#define DQ_L4_CVT_I_3_3(N)          ((((float)(N)-0x800000)*0.0000149))
#define DQ_L4_CVT_I_1_5(N)          ((((float)(N)-0x800000)*0.0000149))
#define DQ_L4_CVT_V_HOLD(N)         ((((float)(N)-0x800000)*0.000000149)*47.526)
#define DQ_L4_CVT_I_IN_M(N)         ((((float)(N)-0x800000-232000)*0.00000178))
//#define DQ_L4_CVT_V_IN(N)         ((((float)(N)-0x800000)*0.000000149)*47.526)   //22.1K ~ 475
#define DQ_L4_CVT_I_24(N)           ((((float)(N)-0x800000-0x1080)*0.000000149)*10.0)    // RP45 DNP
#define DQ_L4_CVT_R_VIN             (0.54) // OHm, DNR MIL Power(0x047) Vin resistance (+VIN-C on JPOWIN1->VIN-EMI->+VIN-HOLD->+VIN),
                                           // see page# 28 (Power conducting) of DNR-MIL-12 backplane schematic
// Define limits
#define DQ_L4_LIM_TEMP2(N)          (((N)>(273-40))&&((N)<(273+90)))
#define DQ_L4_LIM_TEMP1(N)          (((N)>(273-40))&&((N)<(273+90)))
#define DQ_L4_LIM_I_IN(N)           (((N)>0.1)&&((N)<4.0))
#define DQ_L4_LIM_I_IN_HI_ONLY(N)   ((N)<4.0)                // check for over-current only on some models
#define DQ_L4_LIM_I_IN_3_3(N)       (((N)>0.1)&&((N)<3.0))
#define DQ_L4_LIM_I_IN_1_5(N)       (((N)>0.1)&&((N)<3.0))
#define DQ_L4_BLIM_I_IN(N)          (((N)>0.01)&&((N)<5.0))
#define DQ_L4_BLIM_I_IN_3_3(N)      (((N)>0.1)&&((N)<3.0))
#define DQ_L4_BLIM_I_IN_1_5(N)      (((N)>0.1)&&((N)<3.0))
#define DQ_L4_LIM_V_FAN(N)          (((N)>7.5)&&((N)<10.0))
#define DQ_L4_LIM_I_FAN_DNF(N)      (((N)>-0.01)&&((N)<0.18))
#define DQ_L4_BLIM_I_FAN_DNF(N)     (((N)>-0.01)&&((N)<0.2))

// Ideal values - +/-6%
#define DQ_L4_LIM_V_1_2R(N)         (((N)>(1.271*LM6p))&&((N)<(1.271*LP6p)))  // DNR
#define DQ_L4_LIM_V_1_2A(N)         (((N)>(1.21*LM6p))&&((N)<(1.21*LP6p)))    // DNA
#define DQ_L4_LIM_V_1_5(N)          (((N)>(1.576*LM6p))&&((N)<(1.576*LP6p)))
#define DQ_L4_LIM_V_IN(N)           (((N)>11)&&((N)<30))
#define DQ_L4_LIM_V_24NIC(N)        (((N)>22.5)&&((N)<26.0))
#define DQ_L4_LIM_V_24DNR(N)        (((N)>22.5)&&((N)<26.0))
#define DQ_L4_LIM_V_3_3NIC(N)       (((N)>(3.3*LM6p))&&((N)<(3.3*LP6p)))
#define DQ_L4_LIM_V_3_3DNR(N)       (((N)>(3.3*LM6p))&&((N)<(3.3*LP6p)))
#define DQ_L4_LIM_V_2_5NIC(N)       (((N)>(2.5*LM6p))&&((N)<(2.5*LP6p)))
#define DQ_L4_LIM_V_2_5DNR(N)       (((N)>(2.5*LM6p))&&((N)<(2.5*LP6p)))

// Still workable +/-10%, but blink LEDs
#define DQ_L4_BLIM_V_1_2R(N)        (((N)>(1.271*LM10p))&&((N)<(1.271*LP10p)))   // DNR
#define DQ_L4_BLIM_V_1_2A(N)        (((N)>(1.21*LM10p))&&((N)<(1.21*LP10p)))     // DNA
#define DQ_L4_BLIM_V_1_5(N)         (((N)>(1.576*LM10p))&&((N)<(1.576*LP10p)))
#define DQ_L4_BLIM_V_IN(N)          (((N)>9)&&((N)<36))
#define DQ_L4_BLIM_V_24NIC(N)       (((N)>21.6)&&((N)<27.0))
#define DQ_L4_BLIM_V_24DNR(N)       (((N)>21.6)&&((N)<27.0))
#define DQ_L4_BLIM_V_3_3NIC(N)      (((N)>(3.3*LM10p))&&((N)<(3.3*LP10p)))
#define DQ_L4_BLIM_V_3_3DNR(N)      (((N)>(3.3*LM10p))&&((N)<(3.3*LP10p)))
#define DQ_L4_BLIM_V_2_5NIC(N)      (((N)>(2.5*LM10p))&&((N)<(2.5*LP10p)))
#define DQ_L4_BLIM_V_2_5DNR(N)      (((N)>(2.5*LM10p))&&((N)<(2.5*LP10p)))

#define DQ_L4_SAFE_TEMP_HI          (273+40)
#define DQ_L4_SAFE_TEMP_LO          (273+35)

// DNR-MIL
#define DQ_C4_LIM_TEMP2(N)          (((N)>(273-40))&&((N)<(273+90)))
#define DQ_C4_LIM_TEMP1(N)          (((N)>(273-40))&&((N)<(273+90)))


// Common macros
#define DQ_L2_PLIM(V, N, T)         (((V)>((N)-(N)*(T)))&&((V)<((N)+(N)*(T))))

// LED allocation for 0x20
#define DQ_L2_LED_VIN               (1L<<0)     // input voltage (on if exists, blinks - overcurrent, off - failed)
#define DQ_L2_LED_IIN               (1L<<1)     // input current
#define DQ_L2_LED_1_5               (1L<<2)     // 1.5V
#define DQ_L2_LED_FAN               (1L<<3)     // FAN is on
#define DQ_L2_LED_USR               (1L<<4)     // User controlled
#define DQ_L2_LED_IO                (1L<<5)     // I/O (user)
#define DQ_L2_LED_OVRT              (1L<<6)     // Overtemperature (red)
#define DQ_L2_LED_ATT               (1L<<7)     // Attention (red)
#define DQ_L2_LED_24_DNR            (1L<<8)     // DNR side 24V
#define DQ_L2_LED_24_NIC            (1L<<9)     // NIC side 24V
#define DQ_L2_LED_3_3_DNR           (1L<<10)    // DNR side 3.3V
#define DQ_L2_LED_3_3_NIC           (1L<<11)    // NIC side 3.3V
#define DQ_L2_LED_STOP_UPDATE       (1L<<31)    // stop LED updates in periodic routine

#define DQ_L2_LED_USR_              (DQ_L2_LED_USR|DQ_L2_LED_IO|DQ_L2_LED_ATT)
#define DQ_L2_LED_MASK              (DQ_L2_LED_USR_|(DQ_L2_LED_USR_<<16))

#define DQ_L2_LED_BLINK(N)          (((N)<<16)|(N)) // up and blink
#define DQ_L2_OVERHEAT_IGNORE       (10)        // ignore first N readings when calculating overheating

// LED allocation for 0x40
#define DQ_L4_LED_OVRT              (1L<<0)     // Overtemperature (red)
#define DQ_L4_LED_ATT               (1L<<1)     // Attention (red)
#define DQ_L4_LED_RW                (1L<<2)     // Read/write
#define DQ_L4_LED_USR               (1L<<3)     // User controlled
#define DQ_L4_LED_IO                (1L<<4)     // Communication active
#define DQ_L4_LED_3_3_DNR           (1L<<5)     // DNR side 3.3V
#define DQ_L4_LED_PG                (1L<<6)     // Power good
#define DQ_L4_LED_24_DNR            (1L<<7)     // DNR side 24V
#define DQ_L4_LED_STOP_UPDATE       (DQ_L2_LED_STOP_UPDATE)   // stop LED updates in periodic routine


#define DQ_L4_LED_USR_              (DQ_L4_LED_USR|DQ_L4_LED_IO|DQ_L4_LED_ATT)
#define DQ_L4_LED_MASK              (DQ_L4_LED_USR_|(DQ_L4_LED_USR_<<16))

#define DQ_L4_LED_BLINK(N)          (((N)<<16)|(N)) // up and blink

#define DQ_L2_DNRP_CHECK_us         (100*1000)  // how often to check for power level and control LEDs

// Status register (DQL_CLI_LSR)
// For 0x40 DNR_PWR_1G and 0x41 DNA_PWR_1G layers
#define LSR_040_PIRQ                (1L<<6)     // Power down IRQ
#define LSR_040_ADCIRQ              (1L<<5)     // ADC-based IRQ
#define LSR_040_WDIRQ               (1L<<4)     // Watchdog IRQ
#define LSR_040_BTIN                (1L<<3)     // Push button
#define LSR_040_BTOUT               (1L<<2)     // Debounced push button
#define LSR_040_FANON               (1L<<1)     // Fan "ON" status
#define LSR_040_SCAP                (1L<<0)     // Supercapacitor status (reserved)

// For 0x46 DNF_PWR_1G layer
#define LSR_046_ADCIRQ              (1L<<5)     // ADC-based IRQ
#define LSR_046_WDIRQ               (1L<<4)     // Watchdog IRQ
#define LSR_046_BTIN                (1L<<3)     // Push button
#define LSR_046_BTOUT               (1L<<2)     // Debounced push button
#define LSR_046_FANON               (1L<<1)     // Fan "ON" status
#define LSR_046_FPS                 (1L<<0)     // Flash write protect jumper status

// For 0x47 MIL_PWR_1G layer
#define LSR_047_CCRG                (1L<<7)     // Brown-out capacitor charged
#define LSR_047_CDIS                (1L<<6)     // Brown-out capacitor discharged
#define LSR_047_ADCIRQ              (1L<<5)     // ADC-based IRQ
#define LSR_047_WDIRQ               (1L<<4)     // Watchdog IRQ
#define LSR_047_BTIN                (1L<<3)     // Push button
#define LSR_047_BTOUT               (1L<<2)     // Debounced push button
#define LSR_047_PFAIL               (1L<<1)     // Input power supply is below 9V
#define LSR_047_FPS                 (1L<<0)     // Flash write protect jumper status

// Configuration register DQ_L2_DNRP_CFG (0x2000)
#define DQ_L2_CFG_UONLY             (1L<<31)    // do not scan ADC automatically
#define DQ_L2_CFG_24BIT             (1L<<30)    // 1 to return straight 24-bit data
#define DQ_L2_CFG_ADCFE             (1L<<29)    // 1 to convert on the falling edge
#define DQ_L2_CFG_ADCDIV            (1L<<20)    // 8-bit ADC rate divider: 16..255
#define DQ_L2_STS_FAN1STS           (1L<<19)    // Fan 3-4 status (1=on)
#define DQ_L2_STS_FAN0STS           (1L<<18)    // Fan 1-2 status (1=on)
#define DQ_L2_STS_DC24OFF           (1L<<17)    // Shut down 24V DC/DC
#define DQ_L2_STS_FANOFF            (1L<<16)    // Fan off

#define DQ_L2_STS_WDRSTEN           (1L<<15)    // 1= watch dog reset enable

#define DQ_L2_CFG_MASK              (DQ_L2_STS_DC24OFF|DQ_L2_STS_FANOFF|DQ_L2_STS_WDRSTEN)

// LED configuration (0x2004)
#define DQ_L2_LED_BLINK0            (1L<<16)    // Write 1 to blink
#define DQ_L2_LED_LEDON0            (1L<<0)     // write 1 to switch LED on

// Error status (0x2008)
#define DQ_L2_EST_ESTS0             (1L<<16)    // Error status
#define DQ_L2_EST_CURSTS0           (1L<<0)     // Current status

// Special IOCTL
#define DQL_IOCTL2000_GETPASS       (10L)       // get password (0x40 only)
#define DQL_IOCTL2000_SETPASS       (11L)       // set password

// Configuration/status bits (0x2000)
#define DQ_L4_STS_UONLY             (1L<<31)    // Stop autoscanning, user controls conversions
#define DQ_L4_STS_24BIT             (1L<<30)    // 1=straight binary (default), 0=32-bit native
#define DQ_L4_STS_ADCFE             (1L<<29)    // Read data on the falling edge
#define DQ_L4_STS_ASL1BIT           (1L<<28)    // Left-shift conversion result by 1 bit. Debug only
#define DQ_L4_STS_DIV_SH            (20)        // 8-bit divider for ADC, default is 16=4.125MHz
#define DQ_L4_STS_FAN12STS          (1L<<18)    // Fan status (1=ON)
#define DQ_L4_STS_DC24OFF           (1L<<17)    // 1= shut down 24V DC/DC (sleep)
#define DQ_L4_STS_FANOFF            (1L<<16)    // 1= turn fans off, overwrite hardware
#define DQ_L4_STS_WDRSTEN           (1L<<15)    // 1= watch dog reset enable
#define DQ_L4_STS_PBRSTDIS          (1L<<14)    // 1= push button reset disable
#define DQ_L4_STS_WD                (1L<<13)    // 1= watchdog reset is requested
#define DQ_L4_STS_PBRST             (1L<<12)    // 1= push button reset is requested
#define DQ_L4_STS_BUZZDIS           (0L<<10)    // Buzzer configuration - disabled
#define DQ_L4_STS_BUZZ0             (1L<<10)    // Driven 0
#define DQ_L4_STS_BUZZ1             (2L<<10)    // Driven 1
#define DQ_L4_STS_BUZZTMR1          (3L<<10)    // Driven from TMR1
#define DQ_L4_STS_AUTO24OFF         (1L<<9)     // Shut off 24V upon power failure
#define DQ_L4_STS_FLENSTS           (1L<<8)     // For logics 10.C4+ =0 if flash disable jumper is installed, =1 if flash write is enabled

#define DQ_L2_NAMELEN               (20)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_L2_CHAN][DQ_L2_NAMELEN];
} DQCNAMES_2000_, *pDQCNAMES_2000_;

/* specific device structure - calibration values */
typedef struct {                    // Current value (hex) of the calibration shunt from internal monitor:
    uint32 level[DQ_L2_CHAN];       // calibration level
    uint32 gain[DQ_L2_CHAN];        // gain coefficient, nV per count
    uint32 offset[DQ_L2_CHAN];      // offset value from 0x7f0000 to 0x810000
} DQCALSET_2000_, *pDQCALSET_2000_;

#define CM4_LED_CBL_RESET           (1L<<31)    // enable reset on cable
#define CM4_LED_ACD_TST_DIS         (1L<<30)    // disable ACD (air circulating device) test
#define CM4_LED_ACD_DIS             (1L<<29)    // disable auto ACD on mode
#define CM4_LED_IP_CABLE            (1L<<28)    // enable picking up IP address from PWR cable SYNC-C-IN0/1

typedef struct {
    uint32 ovr_lim[DQ_L2_CHAN];     // over current/voltage limit
    uint32 undr_lim[DQ_L2_CHAN];    // under current/voltage limit
    uint32 fan_on;                  // when to power fan
    uint32 fan_off;                 // when to shut fan off
    uint32 led_state;               // initial state of the LEDs and reset
} DQOPMODEPRM_2000_, *pDQOPMODEPRM_2000_;


typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_2000_, *pDQINITPRM_2000_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_2000_, *pDQSDOWNPRM_2000_;

// Tell the stack what to do with IP address
#define DQ_L2_NO_IP                 (1)
#define DQ_L2_PROGRAM_IP            (2)

#define CM4_MAX_CSEL_IP             (4)         // maximum number of cable-select IP addresses
#define CM4_MAX_HRS_CEL             (8)         // number of cells to store hours

#define CM4_MAX_HOURS               20000000    // maximum hour count = 228 years in 1/10 hour counts
#define CM4_UPD_PERIOD              360000      // every 6 minutes (in ms)

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_2000_ calset;
    DQOPMODEPRM_2000_ opmodeprm;
    DQINITPRM_2000_ initprm;
    DQSDOWNPRM_2000_ sdownprm;
    DQCNAMES_2000_ cname;
    DQPRMFLAGS eeflags;
    char u_pass[12];                // user password for 0x40 layer
    char su_pass[12];               // ditto super-user password
    uint32 ipflag;                  // selects behavior of IP address allocation
    uint32 ip1;                     // IP address of the rack if QTB/LTB is in slot 0
    uint32 ip2;                     // ditto IP2

    uint32 ipfec1[CM4_MAX_CSEL_IP]; // cable-select FEC1 IP address
    uint32 ipfec2[CM4_MAX_CSEL_IP]; // cable-select FEC2 IP address
    uint32 hours[CM4_MAX_HRS_CEL];  // hours counter - round robbin
    // crc calculation skips over the hours[]. If sizeof(DEVEEPROM_2000_) changes,
    // then the calculations for size_use in write_e2prom_2000() will need to be updated
} DEVEEPROM_2000_, *pDEVEEPROM_2000_;

#pragma pack()

// Attention LED trigger flags:
#define DQ_PERFAIL_OVRHEATCNT      0    // overheat backplane
#define DQ_PERFAIL_L2_1_2          1    // L2 (POWER-1G) layer 1.2V out of range
#define DQ_PERFAIL_L2_A_1_2        2    // L2 1.2V needs attention
#define DQ_PERFAIL_L2_1_5          3    // L2 1.5V out of range
#define DQ_PERFAIL_L2_3_3          4    // L2 3.3V out of range
#define DQ_PERFAIL_L2_A_3_3        5    // L2 3.3V needs attention
#define DQ_PERFAIL_L2_2_5          6    // L2 2.5V out of range
#define DQ_PERFAIL_LN_3_3          7    // LN (NIC) 3.3V out of range
#define DQ_PERFAIL_LN_A_3_3        8    // LN 3.3V needs attention
#define DQ_PERFAIL_LN_2_5          9    // LN 2.5V out of range
#define DQ_PERFAIL_L2_A_24         10   // L2 24V needs attention
#define DQ_PERFAIL_L2_24           11   // L2 24V out of range
#define DQ_PERFAIL_LN_A_24         12   // LN 24V needs attention
#define DQ_PERFAIL_LN_24           13   // LN 24V out of range
#define DQ_PERFAIL_L2_V_IN         14   // L2 VIn out of range
#define DQ_PERFAIL_L2_V_A_IN       15   // L2 VIn needs attntion
#define DQ_PERFAIL_L2_I_IN         16   // L2 Iin out of range
#define DQ_PERFAIL_L2_I_A_IN       17   // L2 Iin needs attention
#define DQ_PERFAIL_L4_OVRHEATCNT   18   // L4 (POWER-DC) overheat
#define DQ_PERFAIL_L2_OVRHEATCNT   19   // L2 overheat
#define DQ_PERFAIL_L2_1_2R_1_5     20   // L2 MIL 1.2V or 1.5V out of range
#define DQ_PERFAIL_L2_1_2A_1_5     21   // L2 MIL 1.2V or 1.5V needs attntion
#define DQ_PERFAIL_L4_2_5          22   // L4 2.5V out of range
#define DQ_PERFAIL_L4_3_3          23   // L4 3.3V out of range
#define DQ_PERFAIL_L4_A_3_3        24   // L4 3.3V needs attention
#define DQ_PERFAIL_L4_A_24         25   // L4 24V needs attention
#define DQ_PERFAIL_L4_24           26   // L4 24V out of range
#define DQ_PERFAIL_L4_V_IN         27   // L4 Vin out of range
#define DQ_PERFAIL_L4_I_IN         28   // L4 Iin out of range
#define DQ_PERFAIL_L2_V_FAN        29   // L2 V Fan out of range
#define DQ_PERFAIL_L4_V_FAN        30   // L4 V Fan out of range

#define DQ_AI201_CHAN               (24)        // working channels
#define DQ_AI201_CHANSVC            (32)        // total channels including service
#define DQ_AI201_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AI201_BASE               (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_AI201_GAINS              (4)         // number of gains supported

#define DQ_AI201_SPAN               (30.0)
#define DQ_AI201_OFFSET             (15.0)
#define DQ_AI201_STEP               (DQ_AI201_SPAN/0xFFFF)

#define DQ_AI201_STEP_10            (DQ_AI201_STEP/10)
#define DQ_AI201_STEP_100           (DQ_AI201_STEP/100)
#define DQ_AI201_STEP_1000          (DQ_AI201_STEP/1000)
#define DQ_AI201_STEP_2             (DQ_AI201_STEP/2)
#define DQ_AI201_STEP_5             (DQ_AI201_STEP/5)

#define DQ_AI201_OFFSET_10          (DQ_AI201_OFFSET/10)
#define DQ_AI201_OFFSET_100         (DQ_AI201_OFFSET/100)
#define DQ_AI201_OFFSET_1000        (DQ_AI201_OFFSET/1000)
#define DQ_AI201_OFFSET_2           (DQ_AI201_OFFSET/2)
#define DQ_AI201_OFFSET_5           (DQ_AI201_OFFSET/5)

// gain settings for DQ_LNCL_GAIN() and DQ_LNCL_CHANGAIN() macros
#define DQ_AI201_GAIN_1             (0)         //AI-201-16 +/-15V
#define DQ_AI201_GAIN_10            (1)         //AI-201-16 +/-1.5V
#define DQ_AI201_GAIN_100           (2)         //AI-201-16 +/-0.15V
#define DQ_AI201_GAIN_1000          (3)         //AI-201-16 +/-0.015V

#define DQ_AI201_GAIN_1_100         (0)         //AI-201-100 +/-15V
#define DQ_AI201_GAIN_2_100         (1)         //AI-201-100 +/-7.5V
#define DQ_AI201_GAIN_5_100         (2)         //AI-201-100 +/-3V
#define DQ_AI201_GAIN_10_100        (3)         //AI-201-100 +/-1.5V

#define DQ_AI202_GAIN_10            (1)         //AI-202 +/-150mA
#define DQ_AI202_GAIN_100           (2)         //AI-202 +/- 15mA
#define DQ_AI202_GAIN_1000          (3)         //AI-202 +/-1.5mA

#define DQ_AI201_GAINV_0            (1)
#define DQ_AI201_GAINV_1            (10)
#define DQ_AI201_GAINV_2            (100)
#define DQ_AI201_GAINV_3            (1000)

#define DQ_AI201_MAXCLFRQ           (120000)
#define DQ_AI201_MAXCVFRQ           (120000)

#define DQ_AI201_CALDACS            (4)         // number of calibration DACs
#define DQ_AI201_VREFS              (2)         // number of voltage references

//Data conversion 16 2's -> 16 straight
#define DQ_LT1608_GETVALS(V)        (((V)&0xffff)^0x8000) // return straight binary
#define DQ_LT1608_GETVAL(V)         (V)         // return 2s complement
// FIFO-related defs
#define DQ_AI201_CL_TIMES           (2)         // upper and lower part of the buffer
#define DQ_AI201_FIFO_CH            (128)       // entries in the fifo

// Upper part of the configuration word - AI-201 specific
#define DQ_AI201_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI201_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI201_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition


// Output FIFO to read data
#define DQ_AI201_FIFO_GET_DATA      (DQ_FIFO_GET_DATA)

#define DQ_AI201_NAMELEN            (20)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)
/* channel names */
typedef struct {
    char cname[DQ_AI201_CHAN][DQ_AI201_NAMELEN];
} DQCNAMES_201_, *pDQCNAMES_201_;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_AI201_CALDACS];     /* four calibration DAQs */
    uint16 precref[DQ_AI201_VREFS];  /* exact binary code of the built-in voltage ref */
} DQCALSET_201_, *pDQCALSET_201_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AI201_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_201_, *pDQOPMODEPRM_201_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_201_ calset;
    DQOPMODEPRM_201_ opmodeprm;
    DQCNAMES_201_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_201_, *pDEVEEPROM_201_;
#pragma pack()

#define DQ_ONESTEP201               (45776UL)   //30518 //tens of nv
#define DQ_OFFSETD201               (1500000000UL) // offset (in tens of nv)

#define DQ_ONESTEP201_10            (30518UL)   //30518 //tens of nv
#define DQ_OFFSETD201_10            (1000000000UL) // offset (in tens of nv)

// definitions for AI-204 layer CLI part
#define DQ_AI204_CHAN               (24)        // number of current measurement channels
#define DQ_AI204_AUX_CHANS          (7)         // Special AI-204 channels, 24 thru 30, ( #24 and #25 reserved, do not use )
#define DQ_AI204_CHAN_TOTAL         (DQ_AI204_CHAN+DQ_AI204_AUX_CHANS)
#define DQ_AI204_USER_CHANS         (29)        // 24 current reads + 5 Special AI-204 channels, 26 thru 30
#define DQ_AI204_MAX_CL_SIZE        (30)        // USER CHANS+TIMESTAMP
#define DQ_AI204_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AI204_BASE               (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_AI204_MAXRATE            (1000)      // Max samples per second from AI-204
#define DQ_AI204_GAINS              (4)         // number of gains (current ranges) supported, they are 1,2,5,10

// Special AI-204 channels - DQ_AI204_AUX_CHANS
#define DQL_AI204_CH_RESERVED_1     (24)        // (do not use) reserved1 input,
#define DQL_AI204_CH_RESERVED_2     (25)        // (do not use) reserved2 input
#define DQL_AI204_VREF              (26)        // ~1.25V - use for self-test, gain code is internally set to 0 (Gain of 1)
#define DQL_AI204_GND_G1            (27)        // internal use only - 0x1b - autozero gnd reference channels, gain codes are set automatically
#define DQL_AI204_GND_G2            (28)        // internal use only - 0x1c             "
#define DQL_AI204_GND_G5            (29)        // internal use only - 0x1d             "
#define DQL_AI204_GND_G10           (30)        // internal use only - 0x1e             "

// Conversion factors
#define DQ_AI204_SPAN               (5.0)       // calculate and define the conversion factors for all of the current measurement ranges
#define DQ_AI204_OFFSET             (2.5)       //                              "
#define DQ_AI204_STEP               (DQ_AI204_SPAN/(double)0x3ffff)     //      "
#define DQ_AI204_STEP_2             (DQ_AI204_STEP/2.0)     //                  "
#define DQ_AI204_STEP_5             (DQ_AI204_STEP/5.0)     //                  "
#define DQ_AI204_STEP_10            (DQ_AI204_STEP/10.0)    //                  "
#define DQ_AI204_OFFSET_2           (DQ_AI204_OFFSET/2.0)   //                  "
#define DQ_AI204_OFFSET_5           (DQ_AI204_OFFSET/5.0)   //                  "
#define DQ_AI204_OFFSET_10          (DQ_AI204_OFFSET/10.0)  //                  "
#define DQ_AI204_ADC_DATA_MASK      (0x3ffff)

// Gain codes for channel list construction
#define DQ_AI204_GAIN_1             (0)         // code for Gain of 1, +-25.0mA,
#define DQ_AI204_GAIN_2             (1)         // code for Gain of 2, +-12.5mA,
#define DQ_AI204_GAIN_5             (2)         // code for Gain of 5, +- 5.0mA,
#define DQ_AI204_GAIN_10            (3)         // code for Gain of 10,+- 2.5mA,

#define DQ_AI204_R                  (100.0)     // ohms, sense resistor, is in series with circuit breaker switch (9 to 17 ohms)
#define DQ_AI204_MILLIAMPS_AMP      (1000.0)    // milliamps per ampere, constant for a DAQLib calculation

// Defaults
#define DQ_AI204_DEF_OFFS_CAL       (0x00048)   // use this value as default offset calibration before first calibration is performed
#define DQ_AI204_DEF_GAIN_CAL       (0x1FFF8)   // use this value as default  gain  calibration before first calibration is performed
#define DQ_AI204_LIMIT_OFFS         (4096)
#define DQ_AI204_LIMIT_GAIN         (8192)

// Circuit breaker related commands and constants
#define DQ_AI204_SET_CB_LIMITS      (0x10)      // command internal to DqAdv204EnableCB(), set circuit breaker ON/OFF
#define DQ_AI204_SET_CB             (0x11)      // command internal to DqAdv204CBStatus(), do reengage, status
#define DQ_AI204_SEL_ALL_CHAN       (0xFFFFFF)  // bit mask of 24 bits, for the 24 current input channels, (ch_mask parameter)
#define DQ_AI204_GET_CB_STATE       (0x20)      // command for DQIOCTL_GETPARAM, get circuit breaker enable and trip states
#define DQ_AI204_ENABLE_CB_OFF      (0x3FFFF)   // DqAdv204EnableCB(),int onoff, set circuit breaker action OFF, (breaker never breaks, always engaged)
#define DQ_AI204_ENABLE_CB_ON       (0x3FFFE)   // DqAdv204EnableCB(),int onoff, set circuit breaker action ON, breaker breaks for max current > 100mS
#define DQ_AI204_ENABLE_CB_TRIP     (0x20000)   // DqAdv204EnableCB(),int onoff, test mode, force circuit breaker into tripped (disconnected) state.
                                                // use DqCmdSetParameters() to save power-up state of circuit breaker ON/OFF

// moving average commands
#define DQ_AI204_SET_MOV_AVG        (0x12)      // command internal to DqAdv204SetMovAvg(),the library function that sets moving average ON/OFF
#define DQ_AI204_SET_MOV_AVG_OFF    (0x10)      // value for onoff parameter of DqAdv204SetMovAvg, OFF is default setting upon power-up
#define DQ_AI204_SET_MOV_AVG_ON_128 (0x7)       // enable moving average using the last 128 samples on channels 0..23

//  data format (bit positions) for fstatus returned by DqAdv204Read()
#define DQ_AI204IS_SWFAULT          (6)        // =1 if any of the muxes or switches are reporting a fault
#define DQ_AI204IS_CURSW_FF         (5)        // FF output of the current switch (0=fault or switch does not exist for this channel)
#define DQ_AI204IS_CURMUX_SF        (4)        // SF output of the current mux (0=fault)
#define DQ_AI204IS_CURMUX_FF        (3)        // FF output of the current mux (0=fault)
#define DQ_AI204IS_NEXTSW_FF        (2)        // FF output of the next switch (0=fault or switch does not exist in next position(ch+4))
#define DQ_AI204IS_NEXTMUX_SF       (1)        // SF output of the next mux (0=fault)
#define DQ_AI204IS_NEXTMUX_FF       (0)        // FF output of the next mux (0=fault)

//  data format for bData returned by DqAdv204Read()
// All 32 bits of bData are used for timestamp when channel number = DQ_LNCL_TIMESTAMP
#define DQ_AI204IS_NEW_DATA         (1L<<31)    // =1 if bData has been updated since last read
#define DQ_AI204IS_DIO1             (19)        // DIO1 state - read only
#define DQ_AI204IS_DIO0             (18)        // DIO0 state - read only
#define DQ_AI204IS_ADCDATAE         (17)        // 18-bits of ADC data msb
#define DQ_AI204IS_ADCDATAS         (0)         //                     lsb


#define DQIOCTL_DIO_SIGROUTING      (0x0a)
#define DQIOCTL_DIO_READ_DI_ONLY    (0x0b)

// FIFO-related defs
#define DQ_AI204_CL_TIMES           (2)         // upper and lower part of the buffer
#define DQ_AI204_FIFO_CH            (128)       // entries in the fifo
#define DQ_AI204_FIFO_BUFSZ         (16)        // number of FIFOs in allocated buffer

// Upper part of the configuration word - AI-204 specific
#define DQ_AI204_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI204_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI204_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AI204_NAMELEN            (16)        // maximum length of the PowerdnaExplorer channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_AI204_CHAN_TOTAL][DQ_AI204_NAMELEN];
} DQCNAMES_204_, *pDQCNAMES_204_;

/* specific device structure - calibration values */
typedef struct {
    int32 gain[DQL_AI204_GND_G1+1][DQ_AI204_GAINS];  // 28 = 24 channels + 2 aux + vref + ground = 0..27
    int32 offs[DQL_AI204_GND_G1+1][DQ_AI204_GAINS];  // 28 = 24 channels + 2 aux + vref + ground = 0..27
} DQCALSET_204_, *pDQCALSET_204_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32  chlst[DQ_AI204_CHAN_TOTAL];   // channel list - bitmask
    uint32  conf;                   // control word - layer API flags
    uint32  spd;                    // CL clock in speed grades (1..10)
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32  trig;                   // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_204_, *pDQOPMODEPRM_204_;

typedef struct {
    uint32 res;                     // reserved
    uint32 cfg;
    uint32 limit[DQ_AI204_CHAN];    // power-up CB limits
} DQINITPRM_204_, *pDQINITPRM_204_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS      ee;
    DQCALSET_204_    calset;
    DQOPMODEPRM_204_ opmodeprm;
    DQINITPRM_204_   initprm;
    DQCNAMES_204_    cname;
    DQPRMFLAGS       eeflags;
    uint8            res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                                      - sizeof(DQCALSET_204_)
                                      - sizeof(DQOPMODEPRM_204_)
                                      - sizeof(DQINITPRM_204_)
                                      - sizeof(DQCNAMES_204_)
                                      - sizeof(DQPRMFLAGS)
                                      - sizeof(uint32)];   // crc
} DEVEEPROM_204_, *pDEVEEPROM_204_;
#pragma pack()

#define DQ_AI205_CHAN               (4)         // working channels
#define DQ_AI205_CHANSVC            (4)         // total channels including service
#define DQ_AI205_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AI205_BASE               (BUS_FREQUENCY)     // 66MHz base frequency

#define DQ_AI205_FIRNUM             (3)         // Number of FIR stages per channel
#define DQ_AI205_DEFDECR            (5)         // default decimation ration for every stage
#define DQ_AI205_MAXDECR            (32)        // maximum decimation ratio
#define DQ_AI205_MAXTAPS            (128)       // maximum taps per stage
#define DQ_AI205_COEFF_WIDTH        (16)        // bit width of FIR filter coefficients
#define DQ_AI205_FIR_TOTAL          (1<<(DQ_AI205_COEFF_WIDTH-1))  // 32768, expected sum of FIR coeffs

#define DQ_AI205_SPAN               (200.0)
#define DQ_AI205_OFFSET             (100.0)
#define DQ_AI205_STEP               (DQ_AI205_SPAN/0x3FFFF)    // 18 bits
#define DQ_AI205_STEP16             (DQ_AI205_SPAN/0xFFFF)     // 16 bits - to LSB masked to improve transfer rate

#define DQ_AI205_STEP_10            (DQ_AI205_STEP/10)
#define DQ_AI205_STEP_100           (DQ_AI205_STEP/100)
#define DQ_AI205_STEP_1000          (DQ_AI205_STEP/1000)

#define DQ_AI205_OFFSET_10          (DQ_AI205_OFFSET/10)
#define DQ_AI205_OFFSET_100         (DQ_AI205_OFFSET/100)
#define DQ_AI205_OFFSET_1000        (DQ_AI205_OFFSET/1000)

#define DQ_AI205_SPAN_801           (8.192)
#define DQ_AI205_OFFSET_801         (4.096)
#define DQ_AI205_STEP_801           (DQ_AI205_SPAN_801/0x3FFFF)     // 18 bits
#define DQ_AI205_STEP16_801         (DQ_AI205_SPAN_801/0xFFFF)      // 16 bits - to LSB masked to improve transfer rate

#define DQ_AI205_STEP_10_801        (DQ_AI205_STEP_801/10)
#define DQ_AI205_STEP_100_801       (DQ_AI205_STEP_801/100)
#define DQ_AI205_STEP_1000_801      (DQ_AI205_STEP_801/1000)

#define DQ_AI205_OFFSET_10_801      (DQ_AI205_OFFSET_801/10)
#define DQ_AI205_OFFSET_100_801     (DQ_AI205_OFFSET_801/100)
#define DQ_AI205_OFFSET_1000_801    (DQ_AI205_OFFSET_801/1000)

#define DQ_AI205_CALDACS            (8)         // number of calibration DACs

#define AI205_STARTRATE             (DQ_AI205_BASE/100-1)     // 100 Hertz
#define AI205_SHOW_SUM              (0x80)

// FIFO-related defs
#define DQ_AI205_CL_TIMES           (2)         // upper and lower part of the buffer
#define DQ_AI205_FIFO_CH            (128)       // entries in the fifo
#define DQ_AI205_FIFO_BUFSZ         (256)       // number of FIFOs in allocated buffer

//Data conversion 16 2's -> 16 straight
#define DQ_AD7776_GETVALS(V)        ((V)&0x3ffff) // return straight binary 18-bit code
#define DQ_AD7776_GETVAL(V)         (V)         // return 2s complement
#define DQ_AD7776_GETVAL16(V)       ((V)&0x3ffff >> 2)    // return straight binary 16-bit code
#define DQ_AD7776_GETCH(V)          (((V)>>28)&3) // return integrated channel number


// gain settings for DQ_LNCL_GAIN() macros
#define DQ_AI205_GAIN_1             (0)
#define DQ_AI205_GAIN_10            (1)
#define DQ_AI205_GAIN_100           (2)
#define DQ_AI205_GAIN_1000          (3)

#define DQ_AI205_GAINV_0            (1)
#define DQ_AI205_GAINV_1            (10)
#define DQ_AI205_GAINV_2            (100)
#define DQ_AI205_GAINV_3            (1000)


// Upper part of the configuration word - AI-225 specific
#define DQ_AI205_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI205_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI205_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AI205_TSCOPY             (1L << 18)  // Push timestamp into FIFO along with data


// Definition of the I/O FIFOs

// Input FIFO is to write coefficients
#define DQ_AI205_FIFO_COEF          (DQ_FIFO_PUT_COEFF)
#define DQ_AI205_FIFO_DATA          (DQ_FIFO_SET_DATA)
#define DQ_AI205_FIFO_MODE          (DQ_FIFO_PUT_CUSTOM)

// Output FIFO to read data
#define DQ_AI205_FIFO_GET_DATA      (DQ_FIFO_GET_DATA)


// when write to the input coefficient FIFO the following
// sequence is required:
// <uint16 AI205_CFILTxx> <uint16 size> <uint16 decimation ratio>
// <uint16 data[0]> ... <uint16 data[size-1]>
// please notice that all data should be in one packet
// if filter size is equal zero or
#define DQ_AI205_CFILTMINENT        (3)         // 4 entries is minimal to program filter

#define DQ_AI205_CFILT00            (0x00)      // Ch0 Filter0
#define DQ_AI205_CFILT01            (0x01)      // Ch0 Filter1
#define DQ_AI205_CFILT02            (0x02)      // Ch0 Filter2

#define DQ_AI205_CFILT10            (0x10)      // Ch1 Filter0
#define DQ_AI205_CFILT11            (0x11)      // Ch1 Filter1
#define DQ_AI205_CFILT12            (0x12)      // Ch1 Filter2

#define DQ_AI205_CFILT20            (0x20)      // Ch2 Filter0
#define DQ_AI205_CFILT21            (0x21)      // Ch2 Filter1
#define DQ_AI205_CFILT22            (0x22)      // Ch2 Filter2

#define DQ_AI205_CFILT30            (0x30)      // Ch3 Filter0
#define DQ_AI205_CFILT31            (0x31)      // Ch3 Filter1
#define DQ_AI205_CFILT32            (0x32)      // Ch3 Filter2

#define DQ_AI205_CFILT_GETCHAN(D)   (((D) & 0xf0)>>4)     // pull out channel number
#define DQ_AI205_CFILT_GETFILT(D)   ((D) & 0xf)   // pull out filter stage number
#define DQ_AI205_CFILT_CHANFILT(C,F) ((((C)&0x3)<<4)|((F)&0x3))

// Output FIFO is to retrieve data
#define DQ_AI205_DATAFIFO           (1)


// FIR has three modes of operation: disabled, default and programmed
// If you don't program FIR in the application it remains in disabled
// mode
#define AI205_FIR_DISABLED          (0)         // filter disabled
#define AI205_FIR_DEFAULT           (1)         // set default parameters
#define AI205_FIR_DECRAT_ONLY       (2)         // program decimation ratio only
#define AI205_FIR_PROGRAMMED        (6)         // program filter and decimation



// default FIR parameters

#define AI205_DEFTAPS               (128)       // 128 taps in the default filter
#define AI205_DEFDCR                (0)         // default decimation ratio (-1)


#define DQ_AI205_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_AI205_CHAN][DQ_AI205_NAMELEN];
} DQCNAMES_205_, *pDQCNAMES_205_;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_AI205_CALDACS];    /* eight calibration DAQs - two per channel */
} DQCALSET_205_, *pDQCALSET_205_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AI205_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    uint8  firtaps[DQ_AI205_CHAN][DQ_AI205_FIRNUM];  // number of taps for every filter stage, 0 - bypass
    uint8  firdecr[DQ_AI205_CHAN][DQ_AI205_FIRNUM];  // decimation ration for every filter stage
    int clperint;                   // <reserved>
} DQOPMODEPRM_205_, *pDQOPMODEPRM_205_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_205_ calset;
    DQOPMODEPRM_205_ opmodeprm;
    DQCNAMES_205_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_205_, *pDEVEEPROM_205_;

#pragma pack()


#define DQ_ONESTEP205               (7629UL)    //tens of nv, +/-10V range, 18 bits
#define DQ_OFFSETD205               (1000000000UL)  // offset (in tens of nv)


#define DQ_AI208_CHAN               (8)
#define DQ_AI208_INFOSZ             (DQ_MAX_INFO_SIZE)   // maximum size of information structure
#define DQ_AI208_BASE               (BUS_FREQUENCY)      // 66MHz base frequency
#define DQ_AI208_GAINS              (12)        // number of gains supported
#define DQ_AI208_18_BIT_DATA_MASK   (0x3FFFF)

#define DQ_AI248_CHAN               (24)        // does not include CJC, Vref & Gnd. See 'Special AI-248 channels' below
#define DQ_AI248_GAINS              (4)         // number of gains (voltage ranges) supported
#define DQ_AI248_GETGAIN(E)         (((E) & 0x300)>>8) // pull out gain index
#define DQ_AI248_MAXCLFRQ           (7250)
#define DQ_AI248_MAXCVFRQ           (7250)

#define DQ_AI208_MAXCLFRQ           (20000)
#define DQ_AI208_MAXCVFRQ           (20000)

#define DQ_AI207_MAXCLFRQ           (16000)
#define DQ_AI207_MAXCVFRQ           (16000)

#define DQ_AI208_RS                 (4990)
#define DQ_AI208_SHUNT_NOMINAL      (200000)
#define DQ_AI208_SHUNT_STEPS        (256)

#define DQ_AI208_CALDACS            (4)         // number of calibration DACs
#define DQ_AI208_VREFS              (2)         // number of voltage references

#define DQ_AI208_MAX_CH_LIST        (32)        // maximum number of entries in the channel list
#define DQ_AI248_MAX_CH_LIST        (32)        // maximum number of entries in the channel list

#define DQ_AI208_SPAN               (20.0)
#define DQ_AI208_OFFSET             (10.0)
#define DQ_AI208_STEP               (DQ_AI208_SPAN/65535.0)
#define DQ_AI208_STEP18             (DQ_AI208_SPAN/262143.0)

// integer gains used by DqAdv208ReadAutogain()
#define DQ_AI208_GAINV              (1)
#define DQ_AI208_GAINV_2            (DQ_AI208_GAINV*2)
#define DQ_AI208_GAINV_4            (DQ_AI208_GAINV*4)
#define DQ_AI208_GAINV_8            (DQ_AI208_GAINV*8)
#define DQ_AI208_GAINV_10           (DQ_AI208_GAINV*10)
#define DQ_AI208_GAINV_20           (DQ_AI208_GAINV*20)
#define DQ_AI208_GAINV_40           (DQ_AI208_GAINV*40)
#define DQ_AI208_GAINV_80           (DQ_AI208_GAINV*80)
#define DQ_AI208_GAINV_100          (DQ_AI208_GAINV*100)
#define DQ_AI208_GAINV_200          (DQ_AI208_GAINV*200)
#define DQ_AI208_GAINV_400          (DQ_AI208_GAINV*400)
#define DQ_AI208_GAINV_800          (DQ_AI208_GAINV*800)

#define DQ_AI208_STEP_2             (DQ_AI208_STEP/2.0)
#define DQ_AI208_STEP_4             (DQ_AI208_STEP/4.0)
#define DQ_AI208_STEP_8             (DQ_AI208_STEP/8.0)
#define DQ_AI208_STEP_10            (DQ_AI208_STEP/10.0)
#define DQ_AI208_STEP_20            (DQ_AI208_STEP/20.0)
#define DQ_AI208_STEP_40            (DQ_AI208_STEP/40.0)
#define DQ_AI208_STEP_80            (DQ_AI208_STEP/80.0)
#define DQ_AI208_STEP_100           (DQ_AI208_STEP/100.0)
#define DQ_AI208_STEP_200           (DQ_AI208_STEP/200.0)
#define DQ_AI208_STEP_400           (DQ_AI208_STEP/400.0)
#define DQ_AI208_STEP_800           (DQ_AI208_STEP/800.0)

#define DQ_AI208_STEP18_2           (DQ_AI208_STEP18/2.0)
#define DQ_AI208_STEP18_4           (DQ_AI208_STEP18/4.0)
#define DQ_AI208_STEP18_8           (DQ_AI208_STEP18/8.0)
#define DQ_AI208_STEP18_10          (DQ_AI208_STEP18/10.0)
#define DQ_AI208_STEP18_20          (DQ_AI208_STEP18/20.0)
#define DQ_AI208_STEP18_40          (DQ_AI208_STEP18/40.0)
#define DQ_AI208_STEP18_80          (DQ_AI208_STEP18/80.0)
#define DQ_AI208_STEP18_100         (DQ_AI208_STEP18/100.0)
#define DQ_AI208_STEP18_200         (DQ_AI208_STEP18/200.0)
#define DQ_AI208_STEP18_400         (DQ_AI208_STEP18/400.0)
#define DQ_AI208_STEP18_800         (DQ_AI208_STEP18/800.0)

#define DQ_AI208_OFFSET_2           (DQ_AI208_OFFSET/2.0)
#define DQ_AI208_OFFSET_4           (DQ_AI208_OFFSET/4.0)
#define DQ_AI208_OFFSET_8           (DQ_AI208_OFFSET/8.0)
#define DQ_AI208_OFFSET_10          (DQ_AI208_OFFSET/10.0)
#define DQ_AI208_OFFSET_20          (DQ_AI208_OFFSET/20.0)
#define DQ_AI208_OFFSET_40          (DQ_AI208_OFFSET/40.0)
#define DQ_AI208_OFFSET_80          (DQ_AI208_OFFSET/80.0)
#define DQ_AI208_OFFSET_100         (DQ_AI208_OFFSET/100.0)
#define DQ_AI208_OFFSET_200         (DQ_AI208_OFFSET/200.0)
#define DQ_AI208_OFFSET_400         (DQ_AI208_OFFSET/400.0)
#define DQ_AI208_OFFSET_800         (DQ_AI208_OFFSET/800.0)

#define DQ_AI248_SPAN               (36.0)
#define DQ_AI248_OFFSET             (18.0)

#define DQ_AI248_STEP18             (DQ_AI248_SPAN/262143.0)
#define DQ_AI248_STEP18_10          (DQ_AI248_STEP18/10.0)
#define DQ_AI248_STEP18_100         (DQ_AI248_STEP18/100.0)
#define DQ_AI248_STEP18_1000        (DQ_AI248_STEP18/1000.0)

#define DQ_AI248_OFFSET_10          (DQ_AI248_OFFSET/10.0)
#define DQ_AI248_OFFSET_100         (DQ_AI248_OFFSET/100.0)
#define DQ_AI248_OFFSET_1000        (DQ_AI248_OFFSET/1000.0)

#define DQ_AI248_230_SPAN           (64.0)
#define DQ_AI248_230_OFFSET         (32.0)

#define DQ_AI248_230_STEP18         (DQ_AI248_230_SPAN/262143.0)
#define DQ_AI248_230_STEP18_10      (DQ_AI248_230_STEP18/10.0)
#define DQ_AI248_230_STEP18_100     (DQ_AI248_230_STEP18/100.0)
#define DQ_AI248_230_STEP18_1000    (DQ_AI248_230_STEP18/1000.0)

#define DQ_AI248_230_OFFSET_10      (DQ_AI248_230_OFFSET/10.0)
#define DQ_AI248_230_OFFSET_100     (DQ_AI248_230_OFFSET/100.0)
#define DQ_AI248_230_OFFSET_1000    (DQ_AI248_230_OFFSET/1000.0)


// available gains
#define DQ_AI208_GAIN_1             (0)
#define DQ_AI208_GAIN_2             (1)
#define DQ_AI208_GAIN_4             (2)
#define DQ_AI208_GAIN_8             (3)
#define DQ_AI208_GAIN_10            (4)
#define DQ_AI208_GAIN_20            (5)
#define DQ_AI208_GAIN_40            (6)
#define DQ_AI208_GAIN_80            (7)
#define DQ_AI208_GAIN_100           (8)
#define DQ_AI208_GAIN_200           (9)
#define DQ_AI208_GAIN_400           (10)
#define DQ_AI208_GAIN_800           (11)

#define DQ_AI248_GAIN_1             (0)
#define DQ_AI248_GAIN_10            (1)
#define DQ_AI248_GAIN_100           (2)
#define DQ_AI248_GAIN_1000          (3)

#define EXC_V2R(V)                  ((uint16)((V) * (65535.0/10.0))&0xffff)
#define AI208_MINEXCITE             (1.5)
#define AI208_MAXEXCITE             (10.0)


#define DQ_AI248_DEFAULT_OFFS       (0x20000)   // neutral offset and gain for in-library 248 calibration
#define DQ_AI248_DEFAULT_GAIN       (0x3e666)
#define DQ_AI248_LIMIT_OFFS         (4096)
#define DQ_AI248_LIMIT_GAIN         (8192)

#define DQ_AI208_DEFAULT_OFFS       (0x20000)   // neutral offset and gain for in-library 207/248 calibration
#define DQ_AI208_DEFAULT_GAIN       (0x3e666)


// To program muxes apply DQL_ICTR208_MUXES(cdo);
#define DQ_AI207_CHAN               (16)


// Special AI-207 channels include AGND, REF and CJC
#define DQL_FE207_AGND              (32)        // autozero channel, match gain to compensated channel
#define DQL_FE207_CJC               (33)        // CJC channel returns temperature in Kelvin * 0.00295V , use gain = 4
#define DQL_FE207_REF               (34)        // 2.5V reference

// Special AI-248 channels
#define DQL_FE248_CJC               (24)        // CJC channel expects temperature in Kelvins * 0.00295V, use gain of 10 w/STPAI-U
#define DQL_FE248_USER_AGND         (25)
#define DQL_FE248_VREF              (26)        // 2.5V - use for self-test
#define DQL_FE248_NULL_AGND         (27)        // autozero channel, match gain to compensated channel


// Channel designation:
#define DQL_FE208_SPSM              (0x0)       //  0x0..0x7    [from S+ to S-]
#define DQL_FE208_PPG               (0x10)      // 0x10..0x17   [from P+ to AGND]
#define DQL_FE208_PSPG              (0x20)      // 0x20..0x27   [from PS+ to AGND]
#define DQL_FE208_PSSM              (0x30)      // 0x30..0x37   [from PS+ to S-]
#define DQL_FE208_REF_A             (0x3E)      // 0x3E alias for 0x51, use for DMAP
#define DQL_FE208_AGND_A            (0x3F)      // 0x3F alias for 0x50. use for DMAP
#define DQL_FE208_SCUR              (0x40)      // 0x40..0x47   [R5k - shunt current selects A or B shunt automatically]
#define DQL_FE208_AGND              (0x50)      // 0x50         [CAL_AGND] match gain to compensated channel
#define DQL_FE208_REF               (0x51)      // 0x51         [CAL_REF] 2.5V

// ISTR208_CFGWR bits
#define DQL_ISTR208_GEN7            (1L<<15)    // enable excitation voltage on P7+ terminal (FET control)
#define DQL_ISTR208_GEN6            (1L<<14)    // enable excitation voltage on P6+ terminal (FET control)
#define DQL_ISTR208_GEN5            (1L<<13)    // enable excitation voltage on P5+ terminal (FET control)
#define DQL_ISTR208_GEN4            (1L<<12)    // enable excitation voltage on P4+ terminal (FET control)
#define DQL_ISTR208_GEN3            (1L<<11)    // enable excitation voltage on P3+ terminal (FET control)
#define DQL_ISTR208_GEN2            (1L<<10)    // enable excitation voltage on P2+ terminal (FET control)
#define DQL_ISTR208_GEN1            (1L<<9)     // enable excitation voltage on P1+ terminal (FET control)
#define DQL_ISTR208_GEN0            (1L<<8)     // enable excitation voltage on P0+ terminal (FET control)
#define DQL_ISTR208_18BIT           (1L<<5)     // 18-BIT ADC data
#define DQL_ISTR208_PD              (1L<<4)     // Power save mode on ADC
#define DQL_ISTR208_RESET           (1L<<3)     // Reset ADC
#define DQL_ISTR208_LED             (1L<<2)     // LED control
#define DQL_ISTR208_ADCEN           (1L<<1)     // Enable conversions/disable status
#define DQL_ISTR208_RSV0            (1L<<0)     // reserved

// Upper part of the configuration word - AI-208 specific

#define DQ_AI208_ALL_EXCITED        (1L<<19)    // keep all outputs excited

#define DQ_AI208_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI208_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI208_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

// Output FIFO to read data
#define DQ_AI208_FIFO_GET_DATA      (DQ_FIFO_GET_DATA)

#define DQL_IOCTL208_SET_SSPERCHAN  (1)         // set number of reads per channel (continuous max speed samples for averaging)
#define DQL_IOCTL208_SET_EXC_A      (2)         // read PS+ (block of 32 samples)
#define DQL_IOCTL208_SET_EXC_B      (3)         // read PS+ (block of 32 samples)
#define DQL_IOCTL208_SET_EXC_CH     (4)         // read PS+ (block of 32 samples)
#define DQL_IOCTL208_SET_Ra         (5)         // set Ra shunt resistor
#define DQL_IOCTL208_SET_Rb         (6)         // set Rb shunt resistor

// IOCTL for 248 autozero control, used internally by DqAdv248SetAutozero()
#define DQIOCTL_248_AUTOZERO        (0x08)      // autozero control, default is ON

// IOCTL for 208, 'uint32 measurement' parameter for
//  DqAdv208ReadAutogain() and DqAdv208ReadChannel()
//  used partially by DqAdv207ReadChannel()
#define DQL_IOCTL208_READ_SS        (10)        // read S+ (block of 32 samples)
#define DQL_IOCTL208_READ_PP        (11)        // read P+ (block of 32 samples)
#define DQL_IOCTL208_READ_PS        (12)        // read PS+ (block of 32 samples)
#define DQL_IOCTL208_READ_AGND      (13)        // configure and read when PGA is grounded
#define DQL_IOCTL208_READ_REF       (14)        // read reference voltage (2.5V)
#define DQL_IOCTL208_READ_Rs        (15)        // measure switch resistance
#define DQL_IOCTL208_READ_Rx        (16)        // measure multiplexor resistance
#define DQL_IOCTL208_READ_Ra        (17)        // measure Ra resistance
#define DQL_IOCTL208_READ_Rb        (18)        // measure Rb resistance
#define DQL_IOCTL208_READ_5k        (19)        // measure 5k resistance
#define DQL_IOCTL208_READ_PSM       (20)        // measure S+ thru the PS+ line
#define DQL_IOCTL208_READ_5kB       (21)        // measure 5k resistance

#define DQ_AI208_NAMELEN            (20)        // maximum length of the channel name (trailing 0 isn't included)
#define DQ_AI207_NAMELEN            (14)        // ""
#define DQ_AI248_NAMELEN            (14)        // ""

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_AI208_CHAN][DQ_AI208_NAMELEN];
} DQCNAMES_208_, *pDQCNAMES_208_;

/* channel names */
typedef struct {
    char cname[DQ_AI207_CHAN+DQ_AI207_CHAN][DQ_AI207_NAMELEN];
} DQCNAMES_207_, *pDQCNAMES_207_;

/* channel names */
typedef struct {
    char cname[DQ_AI248_CHAN][DQ_AI248_NAMELEN];
} DQCNAMES_248_, *pDQCNAMES_248_;

/* specific device structure - calibration values */
typedef struct {
    uint8  cal[DQ_AI208_CALDACS];        // calibration coeffs to load to DACs
    uint32 offs_gain[DQ_AI208_GAINS];    // offset correction factor (for all gains)
    uint32 gain_gain[DQ_AI208_GAINS];    // gain   correction factor (for all gains)
} DQCALSET_208_, *pDQCALSET_208_;

/* specific device structure - calibration values */
typedef struct {   // 24 channels + CJC
    uint32 offs[DQ_AI248_GAINS];    // offset correction factor (for all gains)
    uint32 gain[DQ_AI248_GAINS];    // gain   correction factor (for all gains)
} DQCALSET_248_, *pDQCALSET_248_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AI208_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_208_, *pDQOPMODEPRM_208_;

typedef struct {
    uint32 chlst[DQ_AI248_CHAN+2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_248_, *pDQOPMODEPRM_248_;

typedef struct {
    uint16 dio_init;                //
    uint16 dio_state;               //
} DQINITPRM_248_, *pDQINITPRM_248_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_208_ calset;
    DQOPMODEPRM_208_ opmodeprm;
    DQCNAMES_207_ cname;            // 207 names are longer than 208 (448 bytes long (32*14))
    DQPRMFLAGS eeflags;
} DEVEEPROM_208_, *pDEVEEPROM_208_;
#pragma pack()

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_248_ calset;
    DQOPMODEPRM_248_ opmodeprm;
    DQINITPRM_248_ initprm;
    DQCNAMES_248_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_248_, *pDEVEEPROM_248_;



#define DQ_AI211_CHAN               (4)         // working channels
#define DQ_AI211_INFOSZ             DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_AI211_BASE               BUS_FREQUENCY  // 66MHz base frequency
#define DQ_AI211_BASE_24MHZ         (24000000)
#define DQ_AI211_BASE_30MHZ         (30720000)

#define DQ_AI211_DEFDECR            (0)         // default decimation ratio
#define DQ_AI211_DEFTAPS            (254)       // number of taps in default FIR
#define DQ_AI211_MAXDECR            (65536)     // maximum decimation ratio, assumed to be power of 2
#define DQ_AI211_MAXTAPS            (256)       // maximum filter taps
#define DQ_AI211_COEFF_WIDTH        (20)        // bit width of FIR filter coefficients
#define DQ_AI211_FIR_TOTAL          (1<<(DQ_AI211_COEFF_WIDTH-1))   // 524288, expected sum of FIR coeffs

#define DQ_AI211_ADC_CLOCK_FACTOR   (8)         // sample rate to clock speed multiplier
#define DQ_AI211_MAX_EXTERNAL_CLOCK (1000000)   // Max 8x clock
#define DQ_AI211_PLL_CLKDIV         (31)        // PLL multiplier used internally by DqCmdSetClock() function

#define DQ_AI211_SPAN_V             (50.0)
#define DQ_AI211_SPAN_H             (0xFFFFFF)
#define DQ_AI211_STEP               (DQ_AI211_SPAN_V/DQ_AI211_SPAN_H)
#define DQ_AI211_HEX_TO_V(HEX)      ((HEX)*DQ_AI211_STEP-DQ_AI211_SPAN_V/2)

#define DQ_AI211_GETCH(V)           (((V)>>28)&3) // return integrated channel number from raw data

#define DQ_AI211_CALDACS            (8)         // number of calibration DACs

// channel select defines for commands DqAdv211SetFIR, DqAdv211SetCfgChannel etc
#define DQ_AI211_SEL_CHAN_0         (0x01)
#define DQ_AI211_SEL_CHAN_1         (0x02)
#define DQ_AI211_SEL_CHAN_2         (0x04)
#define DQ_AI211_SEL_CHAN_3         (0x08)
#define DQ_AI211_SEL_CHAN_ALL       (0x0f)

#define DQ_AI211_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI211_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI211_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

// Action mask defines for DqAdv211SetFIR
#define DQ_AI211_FIR_SET_DEFAULT    (0x8)       // set and enable the default filter i.e. coeffs, taps ,decimation

#define DQ_AI211_FIR_COEFF_LOAD     (0x4)       // load coefficients, number of taps is the length of the coefficient data
#define DQ_AI211_FIR_SET_DECIMATION_RATE    (0x2)  // set decimation rate
#define DQ_AI211_FIR_ENABLE         (0x1)       // enable fir filter
#define DQ_AI211_FIR_DISABLE        (0x0)       // disable fir filter. if both enable and disable are specified, fir will be enabled
                                                // if neither are specified, fir will be disabled
#define DQ_AI211_FIRFIRST_DISABLE   (0x10)
#define DQ_AI211_FIRFIRST_ENABLE    (0)
#define DQ_AI211_FIR_SET_SKIP       (0x20)      // set skip count by user, use tapsize to pass in skip count

// AI-211 channel configuration. Each channel may be configured separately or all at once if they have the same setup.
// Recommended procedure is to do a call to set defaults before changing individual parameters.
typedef struct {
    uint16 channels;    // channel select bits, bit 0 for channel0 etc. you may set multiple channels per call.
    uint16 mask;        // bitwise indicate which of the following struct fields are valid and are to be set.
    uint16 biasdrive;   // set drive current for iepe sensors, range 0-255 approx = 0-8mA
    uint16 biasonoff;   // DQ_211_BIAS_ON  or  DQ_211_BIAS_OFF
    uint16 comphi;      // 12 bit comparison value for open sensor detection,start with values 0xf00 to 0xff0
    uint16 complo;      // 12 bit comparison value for shorted sensor detection,start with values 0x030 to 0x0e0
    uint16 alarmctrl;   // led alarm control, see defines below
    uint16 hpf;         // high pass filters. see defines below
    uint16 offset;      // test mode. with a 1 here and biasonoff=0, input is internally shorted for adjustment purposes.
                        // No sensor connections allowed at this time.
    uint16 anafilt;     // 48kHz analog anti-aliasing filter. DQ_211_ANALOG_FILTER_ON or DQ_211_ANALOG_FILTER_OFF
    uint16 main_enb;    // enable dataflow from main ADC, see defines below
    uint16 sec_enbs;    // secondary enables. 0= sec. off, 1= secondary ON
    uint16 secn;        // determine rate of updates for secondary (led comparison) converter. Value is the
                        // number of main converter reads per secondary converter read. Min =2400, Max = 32767
} DQCFGCH_211, *pDQCFGCH_211;

// mask select bits for DQCFGCH_211.mask.  Or together as many as required except for DQAI211_CFGCH_DEFAULTSET
#define DQAI211_CFGCH_DEFAULTSET    (1L<<11)    // if=1  set all values to default state, all other mask bits and data ignored
#define DQAI211_BIASDRIVESET        (1L<<0)     // =1 if "biasdrive" contains valid data
#define DQAI211_BIASONOFFSET        (1L<<1)     // =1 if "biasonoff" contains valid data
#define DQAI211_COMPHISET           (1L<<2)     // =1 if "comphi" contains valid data
#define DQAI211_COMPLOSET           (1L<<3)     // =1 if "complo" contains valid data
#define DQAI211_ALARMCTRLSET        (1L<<4)     // =1 if "alarmctrl" contains valid data
#define DQAI211_HPFSET              (1L<<5)     // =1 if "hpf" contains valid data
#define DQAI211_OFFSETSET           (1L<<6)     // =1 if "offset" contains valid data
#define DQAI211_ANAFILTSET          (1L<<7)     // =1 if "anafilt" contains valid data
#define DQAI211_MAINENBSET          (1L<<8)     // =1 if "main_enb" contains valid data
#define DQAI211_SECENBSSET          (1L<<9)     // =1 if "secenbs" contains valid data
#define DQAI211_SECNSET             (1L<<10)    // =1 if "secn" contains valid data

// data defines for DQCFGCH_211.biasdrive
#define DQ211_DRIVE_CURRENT(I) (((I)/8.0)*255)  // drive current scaling macro. For example, enter 5 for 5mA.
                                                // Driver accepts values from zero to 255 which map to
                                                // drive currents from zero to 8mA

// data defines for DQCFGCH_211.biasonoff
#define DQ_211_BIAS_ON              (1)         // provide power for IEPE sensors
#define DQ_211_BIAS_OFF             (0)
#define DQ_211_MAX_BIAS             (0xff)      // 0 = 0.0mA, 255 = 8.0mA
#define DQ_211_BIAS_NO_CAL          (0xfe00)    // bypass calibration
#define DQ_211_BIAS_NO_CAL_MAX      (0xfeff)

// data defines for DQCFGCH_211.comphi
#define DQ_211_COMP_HI_STD          (0xfa0)     // standard value for doing comparison
#define DQ_211_COMP_HI_DEFAULT      (0xfff)     // default value also disables comparison

// data defines for DQCFGCH_211.complo
#define DQ_211_COMP_LO_STD          (0x0c0)     // standard value for doing comparison
#define DQ_211_COMP_LO_DEFAULT      (0x0)       // default value also disables comparison

// data defines for DQCFGCH_211.alarmctrl
#define DQ_211_ALARM_ON             (0x3)       // LEDs are controlled by comparison registers and secondary adc only
#define DQ_211_ALARM_OFF            (0)         // LEDs are off
#define DQ_211_ALARM_RED            (0x4)       // LED controlled by user program, red on
#define DQ_211_ALARM_GREEN          (0x8)       // LED controlled by user program, green on
#define DQ_211_ALARM_ORANGE         (0x0c)      // LED controlled by user program, orange on

// data defines for DQCFGCH_211.hpf. select one of the following:
#define DQ_211_HPF_DC               (1L<<0)     // DC coupling
#define DQ_211_HPF_POINT1_HZ        (1L<<1)     // 0.1 Hz cutoff high pass filter, this is the default value
#define DQ_211_HPF_1_HZ             (1L<<2)     // 1.0 Hz cutoff high pass filter
#define DQ_211_HPF_10_HZ            (1L<<3)     //  10 Hz cutoff high pass filter

// data defines for DQCFGCH_211.offset.
#define DQ_211_OFFSET_TEST_ON       (1)         // test mode. The combination of DQ_211_BIAS_OFF and DQ_211_OFFSET_TEST_ON
                                                // internally grounds the sensor input for adjustment purposes.
                                                // No sensor connections are allowed at this time.
#define DQ_211_OFFSET_TEST_OFF      (0)         // default value

// data defines for DQCFGCH_211.anafilt
#define DQ_211_ANALOG_FILTER_ON     (1)         // anti-aliasing filter ON   <-- preferred setting
#define DQ_211_ANALOG_FILTER_OFF    (0)         // anti-aliasing filter OFF

// data defines for DQCFGCH_211.main_enb
#define DQ_211_MAIN_FLOW_OFF        (0)
#define DQ_211_MAIN_FLOW_ON         (1)         // in most cases the main flow is enabled automatically by driver

// data defines for DQCFGCH_211.secenbs
#define DQ_211_SEC_ENB_OFF          (0)         // SECondary converter OFF
#define DQ_211_SEC_ENB_LED          (0x1)       // SEC converter updates LED comparison

// data defines for DQCFGCH_211.secn
#define DQ_211_SEC_N_STD            (6000)      // Recommended number of main reads per SECondary read
#define DQ_211_SEC_N_MIN            (2400)      // smallest allowed value for N

// AI-211 advanced layer configuration. These settings apply to all channels on the layer.
// In the normal case, these configuration settings are set automatically by the DqAcbInitOps()
// function. Use these to override standard behavior.
typedef struct {
    uint16 mask;        // bitwise indicate which of the following struct fields are valid
    uint16 clksrc;      // select clock source for divider. 0= 66MHz,10=24Mhz. use DQ_211_CLK_ defines below
    uint16 clkdiv;      // clock divider. output (1MHz max)  clkdiv=0 passes sync[x] w/o change.
                        // Do not set values less than 65 or 23 when 66MHz or 24MHz selected.
                        // Sample rate is:  clksrc/((clkdiv+1)*8).
    uint16 fmtr;        // reduced precision data format 1= reduced, 0 = normal.
    uint16 avg_factor;  //Set the averaging factor. 0=1, 1=2, 2=4, 3=8, etc. Max value is 15
    uint16 dec_factor;  //Set the decimation factor. 0=1, 1=2, 2=4, 3=8, etc. Max value is 16
} DQCFGLAYER_211, *pDQCFGLAYER_211;

// mask select bits for DQCFGLAYER_211.mask.
#define DQAI211_CFGLAYER_DEFAULTSET (1L<<0)     // if ==1  set all values to default state,
                                                //all other mask bits and data ignored
#define DQAI211_CLKSRCSET           (1L<<1)     // =1 if "clksrc" contains valid data
#define DQAI211_CLKDIVSET           (1L<<2)     // =1 if "clkdiv" contains valid data
#define DQAI211_FMTRSET             (1L<<3)     // =1 if "fmtr" contains valid data
#define DQAI211_AVGFACTORSET        (1L<<4)     // =1 if avg_factor contains valid data
#define DQAI211_DECFACTORSET        (1L<<8)     // =1 if dec_factor contains valid data
#define DQAI211_FIR_BY_DECFACTOR    (1L<<5)     // if 1, and DQAI211_DECFACTORSET and dec_factor are valid,
                                                // the default FIR filter coefficients will be adjusted to follow
                                                // the decimation ratio
#define DQAI211_DC_DC_ON            (1L<<6)     // Disable shutdown DC/DC. NOTE: only for calibration purpose
#define DQAI211_DC_DC_OFF           (1L<<7)     // Shutdown unused DC/DC when it required (default mode). NOTE: only for calibration purpose

// data defines for DQCFGLAYER_211.clksrc
#define DQ_211_CLK_66MHZ            (0)
#define DQ_211_CLK_24MHZ            (0x10)
#define DQ_211_CLK_30_72MHZ         (0x20)      // 30.72 MHz, logic 02.12.40 or greater
#define DQ_211_CLK_SYNC2            (0x18)
#define DQ_211_CLK_SYNC0_BUS        (0x8)
#define DQ_211_CLK_SYNC1_BUS        (0x9)
#define DQ_211_CLK_SYNC2_BUS        (0xa)
#define DQ_211_CLK_SYNC3_BUS        (0xb)

// data defines for DQCFGLAYER_211.clkdiv
#define DQ_211_CLK_DIV_MAX          (0x3ff)

// data defines for DQCFGLAYER_211.fmtr
#define DQ_211_FMTR_NORMAL          (0)
#define DQ_211_FMTR_REDUCED         (1)

#define DQ_AI211_SPAN               (50.0)
#define DQ_AI211_OFFSET             (25.0)
#define DQ_AI211_STEP16             (DQ_AI211_SPAN/0xFFFF)     // 16 bits - to LSB masked to improve transfer rate

#define DQ_AI211_STEP_2             (DQ_AI211_STEP/2.0)
#define DQ_AI211_STEP_5             (DQ_AI211_STEP/5.0)
#define DQ_AI211_STEP_10            (DQ_AI211_STEP/10.0)

#define DQ_AI211_OFFSET_2           (DQ_AI211_OFFSET/2.0)
#define DQ_AI211_OFFSET_5           (DQ_AI211_OFFSET/5.0)
#define DQ_AI211_OFFSET_10          (DQ_AI211_OFFSET/10.0)

// ioctls
#define DQIOCTL_SET211CHANNEL       (0x08)
#define DQIOCTL_SET211LAYER         (0x09)
#define DQIOCTL_GET211_CFGAMG       (0x10)      // 16

//define for DQIOCTL_SETFILTER found in mod_def.h

#define DQ_AI211_MAXAVG             (15)        // maximum average factor 15=32768
#define DQ_AI211_MAXDEC             (16)
#define DQ_AI211_MAXCVFRQ           (125000)    //
#define DQ_AI211_ONE_PER_SCAN_CVFRQ (120000)    //
#define DQ_AI211_MINCVFRQ_AVG       (DQ_AI211_MAXCVFRQ/2)   // minimum frequency when averaging kicks in
#define DQ_AI211_MIN_SAMPLE_RATE    (1.0)
#define DQ_AI211_DMAP_FREQ          (3900.0)    // default single scan frequency



// AI-211 channel list data format when FMTR=0
#define DQ_AI211_CLID_FMTR0_CHN0    (3UL<<28)   // channel numbers
#define DQ_AI211_CLID_FMTR0_INFOO   (1UL<<27)   // Represent state of the over-range alarm (1=alarm)
#define DQ_AI211_CLID_FMTR0_INFOU   (1UL<<26)   // Represent state of the under-range alarm (1=alarm)
#define DQ_AI211_CLID_FMTR0_SMSB0   (3UL<<24)   // The 2 MSB's of the latest secondary converter reading
#define DQ_AI211_CLID_FMTR0_ADCD0   (1UL<<0)    // LSB of 24-bit ADC conversion result

// AI211_ICTR_CFGAMG bits
#define DQ_AI211_CFGAMG_DEFAULT_STATE  (0x020A)
#define DQ_AI211_CFGAMG_FMTR        (1UL<<16)   // IS FMTR control, 1 = data ForMaT Reduced
#define DQ_AI211_CFGAMG_L1COMP      (1UL<<15)   // enable HIgh limit led COMParator
#define DQ_AI211_CFGAMG_L1STATE     (1UL<<14)   // Led1 STATE when comparator disabled
#define DQ_AI211_CFGAMG_L0COMP      (1UL<<13)   // enable LOw limit led COMParator
#define DQ_AI211_CFGAMG_L0STATE     (1UL<<12)   // Led0 STATE when comparator disabled
#define DQ_AI211_CFGAMG_GAIN(G)     (((G)&3UL)<<10) // GAIN settings (bits 10 and 11)
#define DQ_AI211_CFGAMG_GAIN_MASK   (3UL<<10)
#define DQ_AI211_CFGAMG_BW_10HZ     (1UL<<9)    // AC 10Hz  (Select 10Hz high pass filter)
#define DQ_AI211_CFGAMG_BW_1HZ      (1UL<<8)    // AC 1Hz   (Select 1Hz high pass filter
#define DQ_AI211_CFGAMG_BW_0_1HZ    (1UL<<7)    // AC 0.1Hz (Select 0.1Hz high pass filter)
#define DQ_AI211_CFGAMG_BW_DC       (1UL<<6)    // DC mode  (Select DC coupled signal)
#define DQ_AI211_CFGAMG_OFFSET      (1UL<<5)    // enable OFFSET calibration when ICTR211_IDIS = 1
#define DQ_AI211_CFGAMG_FLOFF       (1UL<<4)    // bypass anti-aliasing FiLter
#define DQ_AI211_CFGAMG_IDIS        (1UL<<3)    // DISable bias drive current
#define DQ_AI211_CFGAMG_S_ADCEN     (1UL<<2)    // Secondary ADC ENable
#define DQ_AI211_CFGAMG_M_ADCENFEN  (1UL<<1)    // Main ADC ENable Flow ENable

// gain setings for AI211_CFGAMG_GAIN() macros
#define DQ_AI211_GAINS              (4)         // Total number of gainns
#define DQ_AI211_GAIN_1             (0)         // Gain 1
#define DQ_AI211_GAIN_2             (1)         // Gain 2
#define DQ_AI211_GAIN_5             (2)         // Gain 5
#define DQ_AI211_GAIN_10            (3)         // Gain 10
// 8 sets for store calibration DACs values
#define DQ_AI211_CAL_SETS           (8)         // Total number of calibration sets  (DQ_AI211_CAL_SET_0...7)
#define DQ_AI211_SETS               (4)         // Total number of coefficients sets (DQ_AI211_CAL_SET_0...3)
#define DQ_AI211_SETS1              (4)         // Total number of coefficients sets (DQ_AI211_CAL_SET_4...7)
#define DQ_AI211_CAL_SETS1          (4)         // Total number of sets (DQ_AI211_CAL_SET_5...7)
#define DQ_AI211_CAL_SET_0          (0)         // AC/DC filter = DC,    Analog Filter = ON
#define DQ_AI211_CAL_SET_1          (1)         // AC/DC filter = 0.1Hz, Analog Filter = ON
#define DQ_AI211_CAL_SET_2          (2)         // AC/DC filter =   1Hz, Analog Filter = ON
#define DQ_AI211_CAL_SET_3          (3)         // AC/DC filter =  10Hz, Analog Filter = ON
#define DQ_AI211_CAL_SET_4          (4)         // AC/DC filter = DC,    Analog Filter = OFF
#define DQ_AI211_CAL_SET_5          (5)         // AC/DC filter = 0.1Hz, Analog Filter = OFF
#define DQ_AI211_CAL_SET_6          (6)         // AC/DC filter =   1Hz, Analog Filter = OFF
#define DQ_AI211_CAL_SET_7          (7)         // AC/DC filter =  10Hz, Analog Filter = OFF

#define DQ_AI211_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_AI211_CHAN][DQ_AI211_NAMELEN];
} DQCNAMES_211_, *pDQCNAMES_211_;

// Offset/gain calibration DACs values
typedef struct {
    uint8 cal_dac[DQ_AI211_GAINS][DQ_AI211_CALDACS]; // 4 gains per channel, eight calibration
                                                     // DACs (two per channel: CalGain0, CalOffset0,..., CalGain3, CalOffset3):
} CAL_DAC_SET_211, *pCAL_DAC_SET_211;

/* specific device structure - calibration values */
typedef struct {
    CAL_DAC_SET_211 conf[DQ_AI211_CAL_SETS]; // 8 different configurations (DQ_AI211_CAL_SET_0...7) for store
                                             // calibration DACs gain and offset values
    uint8 i_drive_8ma[DQ_AI211_CHAN];  // current drive scaling value 8mA
    uint8 i_drive_1ma[DQ_AI211_CHAN];  // current drive scaling value 1mA
                                       // These values are used to calibrate and scale user's input.
                                       // User input of 0xff to be 8mA, 0x20 to be 1mA
                                       // 0x0 to be DAC input 0 always
} DQCALSET_211_, *pDQCALSET_211_;

// Digital offset(AI211_FIR_FOFFS)/gain(AI211_FIR_FGAIN) calibration registers values, 24 bits
typedef struct {
    uint32 factor[DQ_AI211_GAINS][DQ_AI211_CALDACS]; // 4 gains per channel, eight calibration
                                                     // DACs (two per channel: DGain0, DOffset0,..., DGain3, DOffset3):
} CAL_DAC_SET_EXT_211, *pCAL_DAC_SET_EXT_211;

/* specific device structure - extented calibration values. Analog filter ON */
typedef struct {
    CAL_DAC_SET_EXT_211 conf[DQ_AI211_SETS]; // 4 sets (DQ_AI211_CAL_SET_0...3) for store
                                                 // digital offset and gain calibration registers values
} DQCALSET_EXT_AFON_211_, *pDQCALSET_EXT_AFON_211_;

/* specific device structure - extented calibration values. Analog filter OFF */
typedef struct {
    CAL_DAC_SET_EXT_211 conf[DQ_AI211_SETS]; // 4 sets (DQ_AI211_CAL_SET_4...7) for store
                                                 // digital offset and gain calibration registers values
} DQCALSET_EXT_AFOFF_211_, *pDQCALSET_EXT_AFOFF_211_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
     uint32 chlst[DQ_AI211_CHAN*2]; // channel list - full
     int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
     uint32 conf;                // control word - layer API flags
     uint32 cvclk;               // CV clock
     uint32 clclk;               // CL clock
     uint32 trig;                // trigger conditions
     uint32 clkcfg;
     uint32 clkdiv;
     uint32 cfgamg[DQ_AI211_CHAN];
     uint32 cfgdpn[DQ_AI211_CHAN];
     uint32 cfgbias[DQ_AI211_CHAN];
     uint32 cfgcomp[DQ_AI211_CHAN];
     uint16 firtaps[DQ_AI211_CHAN];  // number of taps for every channel, 0 - bypass
     uint16 firdecr[DQ_AI211_CHAN];  // decimation ratio for every channel
} DQOPMODEPRM_211_, *pDQOPMODEPRM_211_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_211_ calset;
    DQCALSET_EXT_AFON_211_  calsetext_afon;
    DQCALSET_EXT_AFOFF_211_ calsetext_afoff;
    DQOPMODEPRM_211_ opmodeprm;
    DQCNAMES_211_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_211_, *pDEVEEPROM_211_;

#pragma pack()


#define DQ_AI212_CHAN               (12)        // primary working channels
#define DQ_AI222_CHAN               (12)        // primary working channels
#define DQ_AI222_CL_MAX_SIZE        (DQ_AI222_CHAN+1)   // 12 plus timestamp
#define DQ_AI212_CHANSVC            (32)        // total channels including service
#define DQ_AI212_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AI212_BASE               (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_AI212_GAINS              (7)         // number of gains supported
#define DQ_AI222_GAINS              (4)         // number of gains supported

// max size needed for pt/pt CL w/timestamp and all cjc channels
#define DQ_AI212_CL_SIZE            (DQ_AI212_CHAN+DQ_AI212_I2C_CJC_CHANS+1)

// AI212 and AI222 channel list encoding
//
// 31        23        15         7       0  bit position
//  xxxx xxxx xxxx xxxx dmmm mggg Bbxc cccc
//
//  x unused
//  d differential flag, always inserted by framework, ignored by 212/222 firmware
//  m multiplexer setting,  DQ_AI222_MUX_x_x defines
//  g gain, DQ_AI212_GAIN_n defines
//  B burnout flag
//  b bias flag - use bias flag only when thermocouples have no return path to ground.
//                DNA-STP-AI-212 provides a 100K resistance to ground.
//  c channel number
//

//
//          AI-212 helper macros
//
//    construct channel list
#define DQ_AI212_BIAS_ON_FLAG       (1L<<6)     // bitwise 'or' to channel# in channel list to enable bias voltage on Ain-
#define DQ_AI212_BURNOUT_ON_FLAG    (1L<<7)     // bitwise 'or' to channel# in channel list to enable burnout current source
#define DQ_AI212_GAIN(G)            (((G) & 0x7)<<8)    // set gain
#define DQ_AI212_CHANGAIN(C,G)      ((C)|DQ_AI212_GAIN(G))

//    read channel list
#define DQ_AI212_GETCHAN(N)         ((N)&0x1f)  // (222 too) take channel list entry and strip off the BIAS_ON_FLAG
#define DQ_AI212_CL_GAIN_MASK       (0x700)
#define DQ_AI212_GETGAIN(E)         (((E) & DQ_AI212_CL_GAIN_MASK)>>8)  // pull out gain
#define DQ_AI212_GET_BIAS_FLAG(N)   ((N)&DQ_AI212_BIAS_ON_FLAG)     // extract bias state from channel list entry
#define DQ_AI222_GETBURNOUT_FLAG(N) ((N)&DQ_AI212_BURNOUT_ON_FLAG)

#define DQ_AI212_SEL_CHAN_ALL       (0xFFF)     // chan_mask used by DqAdv212SetBurnoutDetectCurrent()

//
//          AI-222 helper macros
//
//    construct channel list
#define DQ_AI222_MUX(M)             (((((M)==0)? DQ_AI222_MUX_D_B:(M)) & 0xf)<<11)    // zero defaults to 2 wire setting
#define DQ_AI222_CHANMUX(C,M)       ((C)|DQ_AI222_MUX(M))

//    read channel list
#define DQ_AI222_CL_MUX_MASK        (0x7800)
#define DQ_AI222_GETMUX(E)          (((E)&DQ_AI222_CL_MUX_MASK)>>11)  // pull out mux setting


#define DQ_AI212_SPAN               (4.096)
#define DQ_AI212_OFFSET             (2.048)
#define DQ_AI212_STEP               (DQ_AI212_SPAN/0xFFFFFF)

#define DQ_AI212_STEP_64            (DQ_AI212_STEP/64.0)
#define DQ_AI212_STEP_32            (DQ_AI212_STEP/32.0)
#define DQ_AI212_STEP_16            (DQ_AI212_STEP/16.0)
#define DQ_AI212_STEP_8             (DQ_AI212_STEP/8.0)
#define DQ_AI212_STEP_4             (DQ_AI212_STEP/4.0)
#define DQ_AI212_STEP_2             (DQ_AI212_STEP/2.0)

#define DQ_AI212_OFFSET_64          (DQ_AI212_OFFSET/64.0)
#define DQ_AI212_OFFSET_32          (DQ_AI212_OFFSET/32.0)
#define DQ_AI212_OFFSET_16          (DQ_AI212_OFFSET/16.0)
#define DQ_AI212_OFFSET_8           (DQ_AI212_OFFSET/8.0)
#define DQ_AI212_OFFSET_4           (DQ_AI212_OFFSET/4.0)
#define DQ_AI212_OFFSET_2           (DQ_AI212_OFFSET/2.0)

// alternate AIN
#define DQ_AI212_AIN1_OFFSET        (12)        // defines starting channel number of secondary set of 12 inputs (not implemented)

// digital cjc
#define DQ_AI212_I2C_CJC_CHANS      (6)         // max number of digital cjc channels
#define DQ_AI212_DCJC_FIRST         (24)        // channel number of first digital cjc channel
#define DQ_AI212_DCJC_LAST          (DQ_AI212_DCJC_FIRST + DQ_AI212_I2C_CJC_CHANS - 1)  // channel number of last digital cjc channel
#define DQ_AI212_I2CCJC_STEPS_PER_DEGREE        (128.0)         // digital temperature conversion factor
#define DQ_AI212_DCJC_NO_DATA       (-999.0)    // digital cjc sensor data is missing or startup time has not yet elapsed
#define DQ_AI212_DCJC_NO_DATA_HEX   (0xFFFFE0C8)
#define DQ_AI212_STP_U1             (24)        // channel number for sensor U1 on DNA-STP-AI-212 screw terminal panel
#define DQ_AI212_STP_U2             (25)        // channel number for sensor U2 on DNA-STP-AI-212 screw terminal panel
                                                // channels 24..29 are reserved for the ADT-7420 digital cjc temperature sensors
                                                // In the dcjc data returned in *bData by DqAdv212Read(), the 3 lsb's are status data
                                                // and the msb (sign bit) of the temperature data is in bit18.

// gain index settings for DQ_AI212_GAIN() and DQ_AI212_CHANGAIN() macros
#define DQ_AI212_GAIN_1             (0)         // +/-2.048
#define DQ_AI212_GAIN_2             (1)         // +/-1.024
#define DQ_AI212_GAIN_4             (2)         // +/-0.512
#define DQ_AI212_GAIN_8             (3)         // +/-0.256
#define DQ_AI212_GAIN_16            (4)         // +/-0.128
#define DQ_AI212_GAIN_32            (5)         // +/-0.064
#define DQ_AI212_GAIN_64            (6)         // +/-0.032

// gain range settings are automatically set internally by DqAdv222Config() according to resistance range chosen by mode parameter
#define DQ_AI222_GAIN_1             (0)         // +/-2.048    5Kohm and 40Kohm ranges
#define DQ_AI222_GAIN_4             (1)         // +/-0.512    1.25Kohm range
#define DQ_AI222_GAIN_16            (2)         // +/-0.128    312 ohm range
#define DQ_AI222_GAIN_32            (3)         // +/-0.064    156 ohm range

   // translate 0,1,2,3 to 0,2,4,5, used internally by DAQLib
#define DQ_AI222_GAIN_XLAT(G)       (((G)==1)?2: \
                                    ((G)==2)?4: \
                                    ((G)==3)?5: 0)

#define DQ_AI222_GETCHAN(N)         ((N)&0x1f)  // take channel list entry and strip off the BIAS_OFF_FLAG

#define DQ_AI212_FAIL_FLAG          (1L<<24)    // Bit is set in DqAdv212Read() bData word to indicate a failed channel
#define DQ_AI212_FAIL_VALUE         (-999.9)    // value reported by DqAdv212Read() when a failed channel is read.

// Use the following rate if the requested rate is greater than this number.
// For example: the ADC will run at 20Hz if requested rate is greater than 9.9Hz
// and if requested rate is 19.7 or less
#define DQ_AI212_SWITCHTO_10SPS     (4.9)
#define DQ_AI212_SWITCHTO_20SPS     (9.9)
#define DQ_AI212_SWITCHTO_40SPS     (19.7)
#define DQ_AI212_SWITCHTO_80SPS     (39.4)
#define DQ_AI212_SWITCHTO_160SPS    (78.3)
#define DQ_AI212_SWITCHTO_320SPS    (140.1)
#define DQ_AI212_SWITCHTO_640SPS    (302.3)
#define DQ_AI212_SWITCHTO_1000SPS   (578.1)
#define DQ_AI212_SWITCHTO_2000SPS   (860.9)

#define DQ_AI212_MAXCLFRQ           (1800)      // 212 max delivery rate of the output channel list
#define DQ_AI212_MAXCVFRQ           (1800)
#define DQ_AI222_MAXCLFRQ           (150)       // 222 max delivery rate of the output channel list
#define DQ_AI222_MAXCVFRQ           (150)

#define DQ_AI212_CALDACS            (DQ_AI212_CHAN*DQ_AI212_GAINS*2)  // number of calibration DACs
#define DQ_AI212_VREFS              (2)         // number of voltage references/

// setparam_212()
#define DQL_IOCTL212_SET_DCJC_RATE  (0x01L)     // sets a custom DCJC conversion rate
#define DQ_AI212_DCJC_SET_RATE(HZ)  (DQ_AI212_BASE/192.0/(HZ))  // convert DCJC conversion frequency to clock cycle count
#define DQ_AI212_DCJC_GET_RATE(REG) (DQ_AI212_BASE/192.0/(REG)) // convert DCJC clock cycle count to conversion frequency
#define DQ_AI212_DCJC_MIN_RATE      (0.25)      // minimum DCJC conversion frequency (Hz)
#define DQ_AI212_DCJC_DEFAULT_RATE  (4.0)       // default DCJC conversion frequency (Hz)
#define DQ_AI212_DCJC_MAX_RATE      (1500.0)    // maximum DCJC conversion frequency (Hz)

#define DQL_IOCTL212_SET_DCJC_AVERAGE   (0x02L) // command to set number of samples in moving average
#define DQL_IOCTL212_SET_BURNOUT    (0x04L)     // command to set burnout current source settings
#define DQ_AI212_BURNOUT_SRC_OFF    (0x00)      // burnout current source off
#define DQ_AI212_BURNOUT_SRC_HALFUA (0x40)      // burnout current source 0.5uA
#define DQ_AI212_BURNOUT_SRC_2UA    (0x80)      // burnout current source 2.0uA
#define DQ_AI212_BURNOUT_SRC_10UA   (0xC0)      // burnout current source 10uA
#define DQ_AI212_BURNOUT_MASK       (0xC0)      // burnout current source mask

// setparam_222()
#define DQL_IOCTL222_SET_PARAMS     (0x03L)     // command to set excitation and vref

// mux settings to include in AI-222 channel list entries, use with DQ_AI222_CHANMUX()
// These mux settings are internally set by DqAdv222Config()
#define DQ_AI222_MUX_C_D            (1)         // mux setting 0 and 10 will also set DQ_AI222_MUX_C_D
#define DQ_AI222_MUX_B_D            (2)
#define DQ_AI222_MUX_A_D            (3)
#define DQ_AI222_MUX_D_C            (4)
#define DQ_AI222_MUX_B_C            (6)
#define DQ_AI222_MUX_A_C            (7)
#define DQ_AI222_MUX_D_B            (8)         // 2 wire
#define DQ_AI222_MUX_C_B            (9)
#define DQ_AI222_MUX_A_B            (11)
#define DQ_AI222_MUX_D_A            (12)
#define DQ_AI222_MUX_C_A            (13)
#define DQ_AI222_MUX_B_A            (14)        // 3 wire & 4 wire
#define DQ_AI222_MUX_B_B            (15)        // special case for offset calibration.

// parameters for DqAdv222SetParams()
#define DQ_AI222_EXC_OFF            (0xCC)      // off
#define DQ_AI222_EXC_A_B_ON         (0x32)      // 3 wire
#define DQ_AI222_EXC_B_ON           (0xC2)      // 2 wire (DQ_AI222_EXC_B_ON and DQ_AI222_EXC_C_ON must use same IDAC)
#define DQ_AI222_EXC_C_ON           (0xC1)      // 4 wire
                                                // all IMAG settings include the mandatory DRDY setting
#define DQ_AI222_IMAG_OFF           (0x08)      // Excitation current  = off
#define DQ_AI222_IMAG_50U           (0x09)      // Excitation current  = 50uA
#define DQ_AI222_IMAG_100U          (0x0A)      // Excitation current  = 100uA
#define DQ_AI222_IMAG_250U          (0x0B)      // Excitation current  = 250uA
#define DQ_AI222_IMAG_500U          (0x0C)      // Excitation current  = 500uA
#define DQ_AI222_IMAG_750U          (0x0D)      // Excitation current  = 750uA
#define DQ_AI222_IMAG_1000U         (0x0E)      // Excitation current  = 1000uA
#define DQ_AI222_IMAG_1500U         (0x0F)      // Excitation current  = 1500uA

#define DQ_AI222_IMAG               (8)         // number of excitation current levels
#define DQ_AI222_IMAG_CAL           (0x80)      // calibration software use only

#define DQ_AI222_IMAG_INDEX(VAL)    (VAL-DQ_AI222_IMAG) // helper macros, input interval DQ_AI222_IMAG_OFF...DQ_AI222_IMAG_1500U,
                                                        // output interval 0...7

// excitation current value (uA)
#define DQ_AI222_IMAG_DEF_OFF       (0)         // 0 uA
#define DQ_AI222_IMAG_DEF_50U       (50)        // 50 uA - default
#define DQ_AI222_IMAG_DEF_100U      (100)       // 100 uA
#define DQ_AI222_IMAG_DEF_250U      (250)       // 250 uA
#define DQ_AI222_IMAG_DEF_500U      (500)       // 500 uA
#define DQ_AI222_IMAG_DEF_750U      (750)       // 750 uA
#define DQ_AI222_IMAG_DEF_1000U     (1000)      // 1000 uA
#define DQ_AI222_IMAG_DEF_1500U     (1500)      // 1500 uA

#define DQ_AI222_VREF_ON_REF0       (0x20)      // Internal reference ON, ext REF0 selected
#define DQ_AI222_VREF_ON_ONBD_SEL   (0x30)      // Internal reference ON, Onboard reference selected

// helper macros to reduce EEPROM space usage
#define DQ_AI222_24TO16(VAL)        (VAL>=0x800000)?(0x8000|((0xFFFFFF-VAL)&0x7FFF)):(VAL)         // 24bit->16bit, 3/4 wire
#define DQ_AI222_16TO24(VAL)        (VAL & 0x8000) ?(0xFFFFFF-(VAL&0x7FFF)):(VAL)                  // 16bit->24bit, 3/4 wire
#define DQ_AI222_24TO16_2W(VAL)     (VAL>=0x800000)?(0x8000|((0xFFFFFF-(VAL>>2))&0x7FFF)):(VAL>>2) // 24bit->16bit, 2 wire
#define DQ_AI222_16TO24_2W(VAL)     (VAL & 0x8000) ?(((0xFFFFFF-(((VAL&0x7FFF)<<2)&0xFFFFFC))|1)):(((VAL<<2)&0xFFFFFC)|1)// 16bit->24bit, 2 wire
// helper macros to convert to 24/32bit format
#define DQ_AI222_32TO24(SRC,DEST)   (DEST.calval[2]=(SRC&0xFF0000)>>16);(DEST.calval[1]=(SRC&0xFF00)>>8);(DEST.calval[0]=SRC&0xFF) //32bit->24bit, 2/3/4 wire
#define DQ_AI222_24TO32(SRC)        ((SRC.calval[2]<<16)|(SRC.calval[1]<<8)|(SRC.calval[0]))                                       //24bit->32bit, 2/3/4 wire

// mode parameter for DqAdv222Config(), self explanatory, define selects the wiring type and the max. resistance
// these values end up in p222->mode[] and are accessed by DqAdv222Read()
#define DQ_AI222_RTD_2_WIRE_40K     (0x400002)
#define DQ_AI222_RTD_3_WIRE_40K     (0x400003)
#define DQ_AI222_RTD_4_WIRE_40K     (0x400004)
#define DQ_AI222_RTD_2_WIRE_5K      (0x050002)
#define DQ_AI222_RTD_3_WIRE_5K      (0x050003)
#define DQ_AI222_RTD_4_WIRE_5K      (0x050004)
#define DQ_AI222_RTD_2_WIRE_1_25K   (0x012502)
#define DQ_AI222_RTD_3_WIRE_1_25K   (0x012503)
#define DQ_AI222_RTD_4_WIRE_1_25K   (0x012504)
#define DQ_AI222_RTD_2_WIRE_312     (0x003122)
#define DQ_AI222_RTD_3_WIRE_312     (0x003123)
#define DQ_AI222_RTD_4_WIRE_312     (0x003124)
#define DQ_AI222_RTD_2_WIRE_156     (0x001562)
#define DQ_AI222_RTD_3_WIRE_156     (0x001563)
#define DQ_AI222_RTD_4_WIRE_156     (0x001564)

// 222 defines, internal to DAQLib
#define DQ_AI222_FULL_SCALE         (16777215.0)// ADC converter full scale 0xFFFFFF

#define DQ_AI212_DEFAULT_OFFS_CAL   (0x0)       // ADS1247
#define DQ_AI212_DEFAULT_GAIN_CAL   (0x400000)  // ADS1247
#define DQ_AI222_DEFAULT_OFFS_CAL   (DQ_AI212_DEFAULT_OFFS_CAL)
#define DQ_AI222_DEFAULT_GAIN1_CAL  (DQ_AI212_DEFAULT_GAIN_CAL)
#define DQ_AI222_DEFAULT_GAIN2_CAL  (0x420000)
#define DQ_AI222_DEFAULT_RREF_CAL   (4990.0)    // default value of Rref (OHm)
#define DQ_AI222_DEFAULT_VREF_CAL   (2.048)     // default value of Vref (V)

// Upper part of the configuration word
#define DQ_AI212_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI212_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI212_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition


// Output FIFO to read data
#define DQ_AI212_FIFO_GET_DATA      (DQ_FIFO_GET_DATA)

#define DQ_AI212_NAMELEN            (16)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)
/* channel names */
typedef struct {
    char cname[DQ_AI212_CHAN][DQ_AI212_NAMELEN];
} DQCNAMES_212_, *pDQCNAMES_212_;

// per channel Offset/gain calibration values, 24 bits
typedef struct {
    uint32 c_offs[DQ_AI212_GAINS];              // 7 offsets per channel
    uint32 c_gain[DQ_AI212_GAINS];              // 7 gains per channel
} CAL_DAC_SET_212, *pCAL_DAC_SET_212;


// helper structure, 24 bit calibration value (aka uint24)
typedef struct {
    uint8 calval[3];
} CALVAL_222, *pCALVAL_222;

// for reading cal data to host
typedef struct {
    CALVAL_222 iexc_3[DQ_AI222_CHAN];
    CALVAL_222 iexc_4[DQ_AI222_CHAN];
    CALVAL_222 iexc_2[DQ_AI222_CHAN];
} CALSETIEXC_222_, *pCALSETIEXC_222_;

// cal data on host after using DQ_AI222_24TO32()
typedef struct {
    double measured_exc_3[DQ_AI212_CHAN];
    double measured_exc_4[DQ_AI212_CHAN];
    double measured_exc_2[DQ_AI212_CHAN];
}DQ222DATA2,*pDQ222DATA2;

// per channel Offset(16bit)/gain(24bit) calibration values
// offs1/gain1 - G32/0-156Ohm, G16/0-312Ohm, G2/0-1.25kOhm, G1/0-5kOhm. Vref=DQ_AI222_VREF_ON_REF0
// offs2/gain2 - G1/0-40kOhm. Vref=DQ_AI222_VREF_ON_ONBD_SEL
typedef struct {
    uint16 c_offs1[DQ_AI222_GAINS];         // offset1 coefficient (16 LSB bits)
    uint16 c_offs2[DQ_AI222_GAINS];         // offset2 coefficient (16 LSB bits)
                                            // offset1/offset2 format:
                                            // - 3/4 wire: bit#15(sign)+bit#14...#0(data).
                                            //             Full offset(24bits)=offset coefficient (if sign=0) OR
                                            //             0xFFFFFF-offset coefficient (if sign=1)
                                            // - 2   wire: bit#15(sign)+bit#14...#0(data>>2).
                                            //             Full offset(24bits)=((offset coefficient<<2)&0xFFFFFC)|1 ,if sign=0 OR
                                            //             (0xFFFFFF-(offset coefficient<<2))&0xFFFFFC|1, if sign=1
    CALVAL_222 c_gain1[DQ_AI222_GAINS];     // gain (24bit)
    CALVAL_222 c_gain2[DQ_AI222_GAINS];     // gain (24bit)
} CAL_DAC_SET_222, *pCAL_DAC_SET_222;

/* specific device structure - calibration values */
typedef struct {
    CAL_DAC_SET_212 conf[DQ_AI212_CHAN];        // 12 channels times (7*2) settings, input 0
    CAL_DAC_SET_212 confr[DQ_AI212_CHAN];       // 12 channels times (7*2) settings, input 1 (slow rates 222)
    uint16 res1[5];
    int16  res2[5];
    CALVAL_222 iexc[DQ_AI222_CHAN][DQ_AI222_IMAG]; // measured value of excitation current (uA) * 10000 (AI-222 only)
} DQCALSET_212_, *pDQCALSET_212_;

/* specific device structure - calibration values */
typedef struct {
    //  conf_x - offs and gains coefficients for 3 and 4 wire mode
    CAL_DAC_SET_222 conf_3[DQ_AI212_CHAN];
    CAL_DAC_SET_222 conf_4[DQ_AI212_CHAN];
    uint16 res1[5];
    int16  res2[5];
    // iexc_x - measured value of 50 uA excitation current in 3/4 and 2 wire mode * 10000, AI-222 only
    CALVAL_222 iexc_3[DQ_AI222_CHAN];
    CALVAL_222 iexc_4[DQ_AI222_CHAN];
    CALVAL_222 iexc_2[DQ_AI222_CHAN];
    //  conf_x - offs and gains coefficients for 2 wire mode
    CAL_DAC_SET_222 conf_2[DQ_AI212_CHAN];
} DQCALSET_222_, *pDQCALSET_222_;

/* specific device structure - calibration values */
typedef struct {
    CAL_DAC_SET_212 conf0_5[DQ_AI212_CHAN/2];   // 6 channels times 14 settings, input 0
    CAL_DAC_SET_212 conf6_11[DQ_AI212_CHAN/2];  // 6 channels times 14 settings, input 0
    CAL_DAC_SET_212 confr0_5[DQ_AI212_CHAN/2];  // 6 channels times 14 settings, input 1
    CAL_DAC_SET_212 confr6_11[DQ_AI212_CHAN/2]; // 6 channels times 14 settings, input 1
    uint16 res1[5];
    int16  res2[5];
    CALVAL_222 iexc[DQ_AI222_CHAN][DQ_AI222_IMAG]; // measured value of excitation current (uA) * 10000 (AI-222 only)
} DQCALSET_212_X, *pDQCALSET_212_X;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 resv3[5];
    uint32 chlst[DQ_AI212_CHAN*2];              // channel list - full
    uint32 conf;                                // control word - layer API flags
    uint32 cvclk;                               // CV clock
    uint32 clclk;                               // CL clock
    uint32 trig;                                // trigger conditions
    int clperint;                               // number of channel lists per interrupt; ignored if <1 or invalid
    uint32 movavg;
    uint32 resv2;
} DQOPMODEPRM_212_, *pDQOPMODEPRM_212_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    union {
        DQCALSET_212_ calset;
        DQCALSET_212_X calsetx;                 // calsetx pieces are smaller than DQMAXUDP
        DQCALSET_222_ calset_222;
    } cs;
    DQOPMODEPRM_212_ opmodeprm;
    DQCNAMES_212_ cname;
    DQPRMFLAGSA eeflags;
} DEVEEPROM_212_, *pDEVEEPROM_212_;
#pragma pack()


#define DQ_AI217_CHAN               (16)        // # of working channels ( channel #'s 0-15 )
#define DQ_AI218_CHAN               (8)         // # of working channels ( channel #'s 0-7 )
#define DQ_AI228_CHAN               (8)         // # of working channels ( channel #'s 0-7 )
#define DQ_AI217_CJC_CHAN           (1)         // number of available CJC channels
#define DQ_AI218_CJC_CHAN           (0)         // number of available CJC channels
#define DQ_AI228_CJC_CHAN           (0)         // number of available CJC channels
#define DQ_AI217_CJC_OFFSET         (16)        // offset of CJC channel
#define DQ_AI217_CJC_NON_AVG        (16)        // channel number for non-averaged cjc data (16 to 31 may be used)
#define DQ_AI217_CJC_AVG            (32)        // channel number for averaged cjc data (preferred)  (32 to 45 may be used)

                                                // Use DqAdv217GetPgaStatus() to access Pga Status in programs that use ACB.
                                                // Use the following offsets to make channel numbers for accessing PGA status
                                                // and data with pt/pt mode (DqAdv217Read) or with mapped modes.
#define DQ_AI217_PGA_STATUS_OFFSET  (46)        // starting channel number for PGA status (2 addresses)
#define DQ_AI217_PGA_DATA_OFFSET    (48)        // starting channel number for PGA data (DQ_AI217_PGAERR_ bits) (16 addresses)

#define DQ_AI217_PLL_LOGIC_VER      (0x10B0)    // lowest logic version number where reconfigurable pll appears for pacing the ADC
#define DQ_AI217_FIR_BANKS          (4)         // Number of Quad FIR modules (217), number of dual FIR modules (218,228)

#define DQ_AI217_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AI217_BASE               (BUS_FREQUENCY)     // 66MHz base frequency

#define DQ_AI217_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI217_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI218_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI219_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI217_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AI217_DEFTAPS            (128)       // number of taps in default FIR
#define DQ_AI217_MAXDECR            (65536)     // maximum decimation ratio

#define DQ_AI217_MAXTAPS            (512)       // maximum number of filter taps that software can ever allow
#define DQ_AI217_1_MAXTAPS          (128)       // maximum filter taps for AI-217-1
#define DQ_AI217_803_MAXTAPS        (512)       // maximum filter taps for AI-217-803,804
#define DQ_AI218_1_MAXTAPS          (256)       // maximum filter taps for AI-218-1
#define DQ_AI219_1_LE120K_MAXTAPS   (256)       // maximum filter taps for AI-219-1 using sample rates 120KHz or less
#define DQ_AI219_1_GT120K_MAXTAPS   (128)       // maximum filter taps for AI-219-1 using sample rates above 120KHz (16-bit mode)
#define DQ_AI228_300_MAXTAPS        (256)       // maximum filter taps for AI-228-300

//  data format for bData returned by DqAdv217Read(), used by AI-217, AI-218 and AI-228
// All 32 bits of bData are used for timestamp when channel number = DQ_LNCL_TIMESTAMP, otherwise as follows:
#define DQ_AI217_NEW_BDATA          (1L << 31)  // bit in DqAdv217Read() *bData that signals when fresh ADC data is available
#define DQ_AI218_DIO_0              (1L << 28)  // 218/228 only, state of channel's dio line
#define DQ_AI217_ADCDATAE           (23)        // 24-bits of ADC data msb
#define DQ_AI217_ADCDATAS           (0)         //                     lsb

#define DQ_AI217_COEFF_WIDTH        (24)        // bit width of FIR filter coefficients
#define DQ_AI217_FIR_TOTAL          (1<<(DQ_AI217_COEFF_WIDTH-1))  // 8388608, expected sum of FIR coeffs in order to maintain calibration

#define DQ_AI217_FIR_MOV_AVG_TAPS   (128)       // default length of FIR filter when AI217 sample rate is 234.375 or lower
#define DQ_AI218_FIR_MOV_AVG_TAPS   (256)       // default length of FIR filter when AI218/219/228 sample rate is 234.375 or lower

#define DQ_AI217_ADC_CLOCK_FACTOR   (8.0)       // value to multiply upon to get ADC pacer divider straight  AI-217,AI-218, AI-228
#define DQ_AI217_PLL_CLKDIV         (33)        // divisor for PLL clock
#define DQ_AI217_804_CLOCK_FACTOR   (32.0)      // value to multiply upon to get ADC pacer divider straight  AI-217-804
#define DQ_AI217_804_PLL_CLKDIV     (33)        // divisor for PLL clock
#define DQ_AI219_ADC_CLOCK_FACTOR   (1.0)       // value to multiply upon to get ADC pacer divider straight  AI-219
#define DQ_AI219_PLL_CLKDIV         (264)       // divisor for PLL clock

#define DQ_AI217_SPAN_V             (20.0)      // +/- 10V  AI-217, AI-218, AI-219
#define DQ_AI217_SPAN_H             (0xFFFFFF)
#define DQ_AI217_STEP               (DQ_AI217_SPAN_V/DQ_AI217_SPAN_H)
#define DQ_AI217_HEX_TO_V(HEX)      ((HEX)*DQ_AI217_STEP-DQ_AI217_SPAN_V/2.0)

#define DQ_AI217_020_SPAN_I         (0.20)      // +/- .1A  AI-217
#define DQ_AI217_SPAN_H             (0xFFFFFF)
#define DQ_AI217_020_STEP           (DQ_AI217_020_SPAN_I/DQ_AI217_SPAN_H)
#define DQ_AI217_HEX_TO_I(HEX)      ((HEX)*DQ_AI217_020_STEP-DQ_AI217_020_SPAN_I/2.0)

#define DQ_AI228_SPAN_V             (280.0)      // AI-228-1  +/- 140V
#define DQ_AI228_SPAN_H             (0xFFFFFF)
#define DQ_AI228_STEP               (DQ_AI228_SPAN_V/DQ_AI228_SPAN_H)
#define DQ_AI228_HEX_TO_V(HEX)      ((HEX)*DQ_AI228_STEP-DQ_AI228_SPAN_V/2.0)

#define DQ_AI228_300_SPAN_V         (600.0)      // AI-228-300  +/- 300V
#define DQ_AI228_300_SPAN_H         (0xFFFFFF)
#define DQ_AI228_300_STEP           (DQ_AI228_300_SPAN_V/DQ_AI228_300_SPAN_H)
#define DQ_AI228_300_HEX_TO_V(HEX)  ((HEX)*DQ_AI228_300_STEP-DQ_AI228_300_SPAN_V/2)

// channel select defines for commands DqAdv217SetFIR, DqAdv217SetCfgChannel etc
#define DQ_AI217_SEL_QFIR_A         (0x01)      // AI-217 select Quad FIR for Ain channels 0..3
#define DQ_AI217_SEL_QFIR_B         (0x02)      // AI-217 select Quad FIR for Ain channels 4..7
#define DQ_AI217_SEL_QFIR_C         (0x04)      // AI-217 select Quad FIR for Ain channels 8..11
#define DQ_AI217_SEL_QFIR_D         (0x08)      // AI-217 select Quad FIR for Ain channels 12..15
#define DQ_AI217_SEL_QFIR_ALL       (0x0f)

#define DQ_AI218_SEL_DFIR_A         (0x01)      // AI-218/228 select Dual FIR for Ain channels 0,1
#define DQ_AI218_SEL_DFIR_B         (0x02)      // AI-218/228 select Dual FIR for Ain channels 2,3
#define DQ_AI218_SEL_DFIR_C         (0x04)      // AI-218/228 select Dual FIR for Ain channels 4,5
#define DQ_AI218_SEL_DFIR_D         (0x08)      // AI-218/228 select Dual FIR for Ain channels 6,7
#define DQ_AI218_SEL_DFIR_ALL       (0x0f)

// Action mask defines for DqAdv217SetFIR
#define DQ_AI217_FIR_SET_INDEX      (0x80)      // override the automatic selection of the FIR index (for advanced users)
#define DQ_AI217_FIR_MAX_INDEX      (0x9)       // index of the most aggressive FIR filter, -3db@829Hz w/Fs = 120kHz
                                                // pass in tapsize parameter when DQ_AI217_FIR_SET_INDEX is used

#define DQ_AI217_FIR_SET_DEFAULT    (0x8)       // set and enable the default filter i.e. coeffs, taps ,decimation

#define DQ_AI217_FIR_COEFF_LOAD     (0x4)       // load coefficients, number of taps is the length of the coefficient data
#define DQ_AI217_FIR_SET_DECIMATION_RATE    (0x2)       // set decimation rate
#define DQ_AI217_FIR_ENABLE         (0x1)       // enable fir filter
#define DQ_AI217_FIR_DISABLE        (0x0)       // disable fir filter. if both enable and disable are specified, fir will be enabled
                                                // if neither are specified, fir will be disabled
#define DQ_AI217_FIR_CAL_ON         (0x200)     // set FIR  into  calibration mode (30kHz max, used by factory calibration routines)
#define DQ_AI217_FIR_CAL_OFF        (0x400)     // set FIR out of calibration mode (30kHz max, used by factory calibration routines)


#define DQ_AI217_SPAN               (20.0)      // 217, 218, 219
#define DQ_AI217_OFFSET             (DQ_AI217_SPAN/2.0)

#define DQ_AI217_STEP_2             (DQ_AI217_STEP/2.0)
#define DQ_AI217_STEP_4             (DQ_AI217_STEP/4.0)
#define DQ_AI217_STEP_4_CJC         (DQ_AI217_STEP/4.0)
#define DQ_AI217_STEP_8             (DQ_AI217_STEP/8.0)
#define DQ_AI217_STEP_16            (DQ_AI217_STEP/16.0)
#define DQ_AI217_STEP_32            (DQ_AI217_STEP/32.0)
#define DQ_AI217_STEP_64            (DQ_AI217_STEP/64.0)

#define DQ_AI217_OFFSET_2           (DQ_AI217_OFFSET/2.0)
#define DQ_AI217_OFFSET_4           (DQ_AI217_OFFSET/4.0)
#define DQ_AI217_OFFSET_4_CJC       (0.0)
#define DQ_AI217_OFFSET_8           (DQ_AI217_OFFSET/8.0)
#define DQ_AI217_OFFSET_16          (DQ_AI217_OFFSET/16.0)
#define DQ_AI217_OFFSET_32          (DQ_AI217_OFFSET/32.0)
#define DQ_AI217_OFFSET_64          (DQ_AI217_OFFSET/64.0)

#define DQ_AI217_020_SPAN           (0.20)      // 217-020
#define DQ_AI217_020_OFFSET         (0.10)

#define DQ_AI217_020_STEP_2         (DQ_AI217_020_STEP/2.0)   //  +- 0.05 A
#define DQ_AI217_020_STEP_4         (DQ_AI217_020_STEP/4.0)   //  +- 0.025 A
#define DQ_AI217_020_STEP_8         (DQ_AI217_020_STEP/8.0)   //  +- 0.0125 A
#define DQ_AI217_020_STEP_16        (DQ_AI217_020_STEP/16.0)
#define DQ_AI217_020_STEP_32        (DQ_AI217_020_STEP/32.0)
#define DQ_AI217_020_STEP_64        (DQ_AI217_020_STEP/64.0)

#define DQ_AI217_020_OFFSET_2       (DQ_AI217_020_OFFSET/2.0)
#define DQ_AI217_020_OFFSET_4       (DQ_AI217_020_OFFSET/4.0)
#define DQ_AI217_020_OFFSET_8       (DQ_AI217_020_OFFSET/8.0)
#define DQ_AI217_020_OFFSET_16      (DQ_AI217_020_OFFSET/16.0)
#define DQ_AI217_020_OFFSET_32      (DQ_AI217_020_OFFSET/32.0)
#define DQ_AI217_020_OFFSET_64      (DQ_AI217_020_OFFSET/64.0)

#define DQ_AI228_SPAN               (280.0)                 //AI-228-1
#define DQ_AI228_OFFSET             (140.0)

#define DQ_AI228_STEP_2             (DQ_AI228_STEP/2.0)
#define DQ_AI228_STEP_4             (DQ_AI228_STEP/4.0)
#define DQ_AI228_STEP_8             (DQ_AI228_STEP/8.0)
#define DQ_AI228_STEP_16            (DQ_AI228_STEP/16.0)
#define DQ_AI228_STEP_32            (DQ_AI228_STEP/32.0)
#define DQ_AI228_STEP_64            (DQ_AI228_STEP/64.0)

#define DQ_AI228_OFFSET_2           (DQ_AI228_OFFSET/2.0)
#define DQ_AI228_OFFSET_4           (DQ_AI228_OFFSET/4.0)
#define DQ_AI228_OFFSET_8           (DQ_AI228_OFFSET/8.0)
#define DQ_AI228_OFFSET_16          (DQ_AI228_OFFSET/16.0)
#define DQ_AI228_OFFSET_32          (DQ_AI228_OFFSET/32.0)
#define DQ_AI228_OFFSET_64          (DQ_AI228_OFFSET/64.0)

#define DQ_AI228_300_SPAN           (600.0)                 //AI-228-300
#define DQ_AI228_300_OFFSET         (300.0)

#define DQ_AI228_300_STEP_2         (DQ_AI228_300_STEP/2.0)
#define DQ_AI228_300_STEP_4         (DQ_AI228_300_STEP/4.0)
#define DQ_AI228_300_STEP_8         (DQ_AI228_300_STEP/8.0)
#define DQ_AI228_300_STEP_16        (DQ_AI228_300_STEP/16.0)
#define DQ_AI228_300_STEP_32        (DQ_AI228_300_STEP/32.0)
#define DQ_AI228_300_STEP_64        (DQ_AI228_300_STEP/64.0)

#define DQ_AI228_300_OFFSET_2       (DQ_AI228_300_OFFSET/2.0)
#define DQ_AI228_300_OFFSET_4       (DQ_AI228_300_OFFSET/4.0)
#define DQ_AI228_300_OFFSET_8       (DQ_AI228_300_OFFSET/8.0)
#define DQ_AI228_300_OFFSET_16      (DQ_AI228_300_OFFSET/16.0)
#define DQ_AI228_300_OFFSET_32      (DQ_AI228_300_OFFSET/32.0)
#define DQ_AI228_300_OFFSET_64      (DQ_AI228_300_OFFSET/64.0)

// temporary
#define DQ_AI218_828_SPAN_V         (600.0)         // was +/- 290V now +/300V
#define DQ_AI218_828_SPAN_H         (16777215.0)    //0xFFFFFF
#define DQ_AI218_828_STEP           (DQ_AI218_828_SPAN_V/DQ_AI218_828_SPAN_H)
#define DQ_AI218_828_HEX_TO_V(HEX)  ((HEX)*DQ_AI218_828_STEP-DQ_AI218_828_SPAN_V/2.0)

#define DQ_AI218_828_SPAN           (600.0)
#define DQ_AI218_828_OFFSET         (300.0)

#define DQ_AI218_828_STEP_2         (DQ_AI218_828_STEP/2.0)
#define DQ_AI218_828_STEP_4         (DQ_AI218_828_STEP/4.0)
#define DQ_AI218_828_STEP_8         (DQ_AI218_828_STEP/8.0)
#define DQ_AI218_828_STEP_16        (DQ_AI218_828_STEP/16.0)
#define DQ_AI218_828_STEP_32        (DQ_AI218_828_STEP/32.0)
#define DQ_AI218_828_STEP_64        (DQ_AI218_828_STEP/64.0)

#define DQ_AI218_828_OFFSET_2       (DQ_AI218_828_OFFSET/2.0)
#define DQ_AI218_828_OFFSET_4       (DQ_AI218_828_OFFSET/4.0)
#define DQ_AI218_828_OFFSET_8       (DQ_AI218_828_OFFSET/8.0)
#define DQ_AI218_828_OFFSET_16      (DQ_AI218_828_OFFSET/16.0)
#define DQ_AI218_828_OFFSET_32      (DQ_AI218_828_OFFSET/32.0)
#define DQ_AI218_828_OFFSET_64      (DQ_AI218_828_OFFSET/64.0)


//define for DQIOCTL_SETFILTER found in mod_def.h

#define DQ_AI217_MAXPLLCLFRQ        (120000.0)  // maximum delivered ACB sample rate (reduced channel count to meet aggregate limit)
#define DQ_AI217_MAXFRQ_REDUCE_INL  (30000.0)   // maximum ADC rate when delivered sample rates are less than this value
#define DQ_AI217_804MAXFRQ          (30000.0)   // maximum delivered ACB sample rate
#define DQ_AI217_SNAP_FREQ          (7500.0)    // default sample rate for pt-pt
#define DQ_AI218_SNAP_FREQ          (8000.0)    // default sample rate for pt-pt
#define DQ_AI228_888_SNAP_FREQ      (3200.0)    // should be 70200Hz for CSI
#define DQ_AI218_PT_PT_FIR_INDEX    (6)         // select default fir filter to use in pt-pt
#define DQ_AI217_SNAP_FREQ_803      (30000.0)   // default sample rate for pt-pt with 803 option
#define DQ_AI217_MINPLLCLFRQ        (1.0)       // minimum delivered ACB sample rate
#define DQ_AI217_MAXCLFRQ           (29891.30 * 4.0)  // maximum sample frequency when dividing 66MHz
#define DQ_AI217_MAXCLOCL           (DQ_AI217_MAXCLFRQ*4*DQ_AI217_ADC_CLOCK_FACTOR)   // actual ADC pacer clock derived from CLOCL
                                                // gets divided by DQ_AI217_CLOCK_FACTOR to produce ADC sample rate
#define DQ_AI217_MINCLOCL           (DQ_AI217_MAXCLOCL/2)   // minimum frequency to set CLOCL
#define DQ_AI217_STARTRATE          (DQ_AI217_BASE/30000-1)   // timer value to get 30000Hz

#define DQ_AI217_MAX_AVG            (0x14)      // max average factor for cjc
#define DQ_AI217_SET_CJC_AVG        (0x100)     // override the automatic selection of the cjc average, used internally by DqAdv217SetCjcAvg()
#define DQ_AI217_803_DEF_AVG        (6)         // by default, option 803 CJC averaging factor is 2^6 ( 64 samples averaged )

#define DQ_AI219_MAXPLLCLFRQ16      (180000.0)  // maximum delivered ACB sample rate (reduced resolution = 16 bits)
#define DQ_AI219_MAXPLLCLFRQ        (120000.0)  // maximum delivered ACB sample rate (reduced channel count to meet aggregate limit)
#define DQ_AI219_SNAP_FREQ          (7500.0)    // default sample rate for pt-pt

#define DQ_AI217_DEFAULT_GAIN_CAL   (0x0ba2e8b) // default gain cal for AI217 16 channels, AI218 8 channels
#define DQ_AI217_DEFAULT_OFFS_CAL   (0)
#define DQ_AI217_DEFAULT_CJC_GAIN_CAL  (0x0800000)
#define DQ_AI217_DEFAULT_CJC_OFFS_CAL  (0x0FF7000)

// gain setings for the AI-217, AI218, AI219, AI-228     These values get merged into the channel list using the DQ_LNCL_GAIN() macro
#define DQ_AI217_GAIN_1             (0)         // Gain 1    +/-10V
#define DQ_AI217_GAIN_2             (1)         // Gain 2    +/-5V
#define DQ_AI217_GAIN_4             (2)         // Gain 4    +/-2.5V
#define DQ_AI217_GAIN_8             (3)         // Gain 8    +/-1.25V
#define DQ_AI217_GAIN_16            (4)         // Gain 16
#define DQ_AI217_GAIN_32            (5)         // Gain 32
#define DQ_AI217_GAIN_64            (6)         // Gain 64
#define DQ_AI217_GAIN_4_CJC         (7)         // Special gain setting for AI217 CJC only, Gain is 4 with no offset correction

#define DQ_AI217_GAINS              (8)         // Total number of gains
#define DQ_AI217_GAINS_NORM         (7)         // number of normal gains, not counting CJC

#define DQ_AI218_GAIN_1             (0)         // Gain 1
#define DQ_AI218_GAIN_2             (1)         // Gain 2
#define DQ_AI218_GAIN_4             (2)         // Gain 4
#define DQ_AI218_GAIN_8             (3)         // Gain 8
#define DQ_AI218_GAIN_16            (4)         // Gain 16
#define DQ_AI218_GAIN_32            (5)         // Gain 32
#define DQ_AI218_GAIN_64            (6)         // Gain 64

#define DQ_AI228_GAIN_1             (0)         // Gain 1
#define DQ_AI228_GAIN_2             (1)         // Gain 2
#define DQ_AI228_GAIN_4             (2)         // Gain 4
#define DQ_AI228_GAIN_8             (3)         // Gain 8
#define DQ_AI228_GAIN_16            (4)         // Gain 16
#define DQ_AI228_GAIN_32            (5)         // Gain 32
#define DQ_AI228_GAIN_64            (6)         // Gain 64

// PGA status bits, from DqAdv217GetPgaStatus() or from DqAdv217Read() w/ DQ_AI217_PGA_DATA_OFFSET added to channel #.  From TI PGA280 datasheet
#define DQ_AI217_PGAERR_CHKERR      (1UL<<7)    // checksum error in SPI; (reporting of this error is not enabled)
#define DQ_AI217_PGAERR_IARERR      (1UL<<6)    // Input Amplifier saturated to supply rail
#define DQ_AI217_PGAERR_BUFA        (1UL<<5)    // Buffer active indication
#define DQ_AI217_PGAERR_ICAERR      (1UL<<4)    // input clamp conduction error, input slew rate is faster than amplifier slew rate
#define DQ_AI217_PGAERR_ERRFLAG     (1UL<<3)    // Error flag ( presently disabled )
#define DQ_AI217_PGAERR_OUTERR      (1UL<<2)    // Output Amplifier is clipping signal or over-current condition exists
#define DQ_AI217_PGAERR_GAINERR     (1UL<<1)    // Gain network overload, gain setting may be too high for the input signal
#define DQ_AI217_PGAERR_IOVERR      (1UL<<0)    // Input over-voltage error (sometimes caused by floating input, connect unused inputs to ground)

// channel 46 (pt/pt and mapped modes) - PGA Status Register, reports status for ADC channels 0-7
// channel 47 (pt/pt and mapped modes) - PGA Status Register, reports status for ADC channels 8-15
#define DQ_AI217_PGASR_DATA_READY_MASK          (0x00ff)    // bit field, new PGA status data is ready for channels 0-7(ch46) or 8-15(ch47)
#define DQ_AI217_PGASR_ERROR_REPORTED_MASK      (0xff00)    // bit field, an error was reported on one of the PGA status data channels

#define DQ_AI217_GET_PARAM_PGA      (0)         // command for DQIOCTL_GETPARAM
#define DQ_AI218_GET_IS_REG         (5)         // command for DQIOCTL_GETPARAM, read PLD scratch register
#define DQ_AI218_GET_DIO_READ       (6)         // command for DQIOCTL_GETPARAM, read dio inputs, used by DqAdv218ReadDioIn()

#define DQ_AI217_SET_CFG_LAYER      (1)         // command for DQIOCTL_SETPARAM, used internally by DqAdv217SetCfgLayer()
#define DQ_AI217_SET_CFG_LAYER_PGA  (0x10)      // DqAdv217SetCfgLayer() 'function' value to set PGA registers
#define DQ_AI217_SETCFG_ALL_CHAN    (0xffff)    // DqAdv217SetCfgLayer() 'channels' value to set the PGA config for all 16 channels
#define DQ_AI217_SET_CFG_LAYER_ADC  (0x11)      // DqAdv217SetCfgLayer() 'function' value to set improved ADC clocking mode
#define DQ_AI217_SET_ADC_DEFAULT    (0)         // DqAdv217SetCfgLayer() 'data' to set default sample rate calculation and configuration
#define DQ_AI217_SET_ADC_ENH        (1)         // DqAdv217SetCfgLayer() 'data' to set enhanced performance at lower sample rates

#define DQ_AI218_DIO_CONFIG         (2)         // command for DQIOCTL_SETPARAM,
#define DQ_AI218_DIO_WRITE          (3)
#define DQ_AI218_PGA_CONFIG         (4)         // command for DQIOCTL_SETPARAM,
#define DQ_AI218_SET_IS_REG         (5)         // command for DQIOCTL_SETPARAM, write PLD scratch register
#define DQ_AI218_SET_BIT_MUX        (6)         // command for DQIOCTL_SETPARAM, set built in test

// DqAdv218SetBitMux defines:
#define DQ_AI218_BIT_ALL_CHAN       (0xff)      // chan_mask: select all channels
#define DQ_AI218_BIT_OFF            (2)         // mux_pos: Select normal operation, BIT testing turned OFF (default state)
#define DQ_AI218_BIT_ALT_5V         (3)         // mux_pos: Self-test: 5V alternate input to PGA. Input signal has no effect
#define DQ_AI218_BIT_5V_IN          (4)         // mux_pos: Self-test: 5V normal input to PGA. Input signal may effect this (useful for detecting broken wiring)

// example data for DqAdv217SetCfgLayer()
// 16 bit TI PGA280 write data format:  4 bits constant value 4,  followed by 4 bits register #, followed by 8 bits of data
#define DQ_AI217_PDWR_PGA_I_SRC_ON  (0x470C)    // PGA280 reg 7 config value: Wire break detect current sources ON
#define DQ_AI217_PDWR_PGA_I_SRC_OFF (0x4700)    // PGA280 reg 7 config value: Wire break detect current sources OFF
#define DQ_AI217_PDWR_RESET_ERR_FL  (0x44FF)    // PGA280 reg 4 reset all DQ_AI217_PGAERR_xx status bits

#define DQ_UNUSED                   (0)         // parameter has no meaning in present context.
// special case - 228-888 serial reader of CSI data
#define DQL_IOCTL228_888_SETPARAMS        (0x1002)   // set zero-NULL-one levels
#define DQL_IOCTL228_888_READFIFO         (0x1003)   // read FIFO
#define DQL_IOCTL228_888_START            (0x1004)   // start I/O
#define DQL_IOCTL228_888_STOP             (0x1005)   // stop I/O

#define DQ_AI228_888_CONTROL   (1L<<31)    // add to the channel list mask to control behavior instead of setting it up
#define DQ_AI228_888_RESET_CL  (1L<<30)    // add to the channel list mask to reset FIFO and state machines of the selected channels

//-------------------------------------------------------------------------------
// 0x3000-0x31FC    AI-228-888 0/1/NULL level registers, FIFOs, etc
// AI-228-888 allows to set levels for the input voltage that would be translated
// to the four states corresponding to the logic 0, 1, NULL or out-of-range
// 00 - signal is within ZEROL..ZEROH range (logic 0)
// 01 - signal is within ONEL..ONEH range (logic 1)
// 10 - signal is within NULLL..NULLH range (logic NULL)
// 11 - signal is out of the range for all three states above
// All values are 16-bit and lower 8 bits are padded with LSB prior to
// comparing it with calibrated 24-bit data from the ADC

#define DQ_AI228_888_ZERO  (0)        // 2-bit code for the logic 0
#define DQ_AI228_888_ONE   (1)        // 2-bit code for the logic 1
#define DQ_AI228_888_NULL  (2)        // 2-bit code for the logic NULL
#define DQ_AI228_888_ERR   (3)        // 2-bit code for the errornous value

// Each channel can convert incoming analog data into 2-bit digital format,
// concatenate them into 32-bit words and save it to the dedicated 1K FIFOs.
// AI228_888_CFG register allows to synchronize these data streams by
// simultaneously resetting corresponding state machines and FIFOs
// Control bits for AI-228-888
#define DQ_AI228_888_CFG_CH7SYNC   (1L<<15)      // All channels ADCs are constantly acquiring data
#define DQ_AI228_888_CFG_CH6SYNC   (1L<<14)      // using the same clock, however channels can
#define DQ_AI228_888_CFG_CH5SYNC   (1L<<13)      // be re-synchronized individually or in groups
#define DQ_AI228_888_CFG_CH4SYNC   (1L<<12)      // by using SYNC bit. When this bit is set,
#define DQ_AI228_888_CFG_CH3SYNC   (1L<<11)      // corresponding analog->digital state machine
#define DQ_AI228_888_CFG_CH2SYNC   (1L<<10)      // is reset and input register is cleared upon
#define DQ_AI228_888_CFG_CH1SYNC   (1L<<9)       // receiving data from all 8 channels. Bit is
#define DQ_AI228_888_CFG_CH0SYNC   (1L<<8)       // auto-cleared once reset is completed
                                              //
#define DQ_AI228_888_CFG_CH7FR     (1L<<7)       // =1 in each bit resets corresponding
#define DQ_AI228_888_CFG_CH6FR     (1L<<6)       // channel FIFO, bit auto-clears
#define DQ_AI228_888_CFG_CH5FR     (1L<<5)       // (always read as 0)
#define DQ_AI228_888_CFG_CH4FR     (1L<<4)       //
#define DQ_AI228_888_CFG_CH3FR     (1L<<3)       //
#define DQ_AI228_888_CFG_CH2FR     (1L<<2)       //
#define DQ_AI228_888_CFG_CH1FR     (1L<<1)       //
#define DQ_AI228_888_CFG_CH0FR     (1L<<0)       //
#define DQ_AI228_888_CL_FIFO    (8)     // channel to access CL FIFO (channels 0..7 are for per-channel FIFOs)

#define DQ_AI228_888_FIFOSZ         (1024)  // FIFO size for each channel
#define DQ_AI228_888_MAX_EVT_DATA   (0x540) // max amount of the event data in the packet for all channels enabled

//-------------------------------------------------------------------------------
// AI-228-888 Input per-channel FIFO format
#define AI228_888_CH_CHSHIFT(N)         (((N)&7)<<1) // ZERO(00)/ONE(01)/NULL(10)/ERR(11)
#define AI228_888_CH_CHDATA(N, DATA)    (((DATA)&0x3)>>(((N)&7)<<1)) // retrieve channel data

//-------------------------------------------------------------------------------
// AI-228-888 Input CL FIFO format
#define AI228_888_CL_CHSHIFT(N)  (16+(((N)&7)<<1)) // ZERO(00)/ONE(01)/NULL(10)/ERR(11)
#define AI228_888_CL_CHDATA(N, DATA)    (((DATA)&0x3)>>(16+(((N)&7)<<1))) // retrieve channel data
#define AI228_888_CL_TSE(D) ((D)&0xffff)      // 16-bit timestamp (LSBs of the layer's TS)


// Event data for 228-888 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];     // data to follow
} EV228_888_ID, *pEV228_888_ID;

#define DqAdv228_888_ConfigEvents_PARAMSZ (4)        // maximum number of uint32 parameters after pEV403_ID

typedef enum {
    EV228_888_CLEAR = 0x1000,           // clear all events
    EV228_888_ON_DATA = 0x101,          // digital data received above FIFO watermark
    EV228_888_PERIODIC = 0x102          // periodic event (optionally period is reset every time DI_CHANGE event occurs)
} event228_888_t;

#define EV228_888__PERI_RESET        (1L<<0) // reset all FIFOs for AI-288-888 layer

#define DQ_AI217_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_AI217_CHAN+1][DQ_AI217_NAMELEN];  // add 1 for CJC
} DQCNAMES_217_, *pDQCNAMES_217_;

// per channel Offset/gain calibration values, 24 bits
typedef struct {
    uint32 c_offs[DQ_AI217_GAINS_NORM];         // 7 offsets per channel
    uint32 c_gain[DQ_AI217_GAINS_NORM];         // 7 gains per channel
} CAL_DAC_SET_217, *pCAL_DAC_SET_217;

/* specific device structure - calibration values */
typedef struct {
    CAL_DAC_SET_217 conf[DQ_AI217_CHAN];        // 16 channels times 14 settings
    uint32  cjc_offs;                           // cjc offset cal
    uint32  cjc_gain;                           // cjc gain cal
} DQCALSET_217_, *pDQCALSET_217_;

/* specific device structure - calibration values */
typedef struct {
    CAL_DAC_SET_217 conf0_7[DQ_AI217_CHAN/2];   // 8 channels times 14 settings
    CAL_DAC_SET_217 conf8_15[DQ_AI217_CHAN/2];  // 8 channels times 14 settings
    uint32  cjc_offs;                           // cjc offset cal
    uint32  cjc_gain;                           // cjc gain cal
} DQCALSET_217_X, *pDQCALSET_217_X;


/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
     uint32 chlst[DQ_AI217_CHAN+DQ_AI217_CJC_CHAN+1]; // channel list - full one extra for timestamp
     int clperint;                  // number of channel lists per interrupt; ignored if <1 or invalid
     uint32 conf;                   // control word - layer API flags
     uint32 cvclk;                  // CV clock
     uint32 clclk;                  // CL clock
     uint32 trig;                   // trigger conditions
     uint32 clkcfg;
     uint32 firdecr[DQ_AI217_FIR_BANKS];
     uint32 firfcfg[DQ_AI217_FIR_BANKS];
} DQOPMODEPRM_217_, *pDQOPMODEPRM_217_;

typedef struct {
     uint32 diocfg10[DQ_AI218_CHAN];   //
     uint32 diostate10[DQ_AI218_CHAN]; //
     uint32 pgapen;                    //
     uint32 pgarate;                   //
     uint32 adctype;                   // unused
     uint32 reserved[DQ_AI218_CHAN];
} DQINITPRM_218_, *pDQINITPRM_218_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQPRMFLAGS eeflags;
    union {
        DQCALSET_217_ calset;
        DQCALSET_217_X calsetx;
    } cs;
    DQOPMODEPRM_217_ opmodeprm;
    DQCNAMES_217_ cname;
    DQINITPRM_218_ initprm;
} DEVEEPROM_217_, *pDEVEEPROM_217_;

#pragma pack()


#define DQ_AI224_CHAN               (4)         // channels, 0 thru 3
#define DQ_AI224_DACS               (4)         // DACs per channel, 2 excitation, null, bridge completion
#define DQ_AI224_DAC_CAL_MULTIPLIER (53687)     // factor for millivolts to 16-bit binary conversion
#define DQ_AI224_DAC_CAL_SHIFT      (14)        // factor for millivolts to 16-bit binary conversion

#define DQ_AI224_INFOSZ             (DQ_MAX_INFO_SIZE)     // maximum size of information structure
#define DQ_AI224_BASE               (BUS_FREQUENCY)        // 66MHz base frequency
#define DQ_AI224_BASE_28MHZ         (28160000)  // generated by fixed frequency PLL
#define DQ_AI224_GAINS              (DQ_AI224_GAIN_512+1)  // number of gains supported= gain number of highest gain+1

#define DQ_AI224_MAXCLFRQ           (300000)    // maximum internal conversion rate
#define DQ_AI224_MAXCVFRQ           (300000)    // CL and CV are the same in ADC per channel layers
#define DQ_AI224_PT_PT_ADC_RATE     (100000.0)  // max ADC data rate for point by point

#define DQ_AI224_CALDACS            (0)         // number of calibration DACs
#define DQ_AI224_VREFS              (0)         // number of voltage references

#define DQ_AI224_RS                 (4990)      // fixed part of shunt resistance
#define DQ_AI224_SHUNT_NOMINAL      (200000)    // nominal max resistance of variable part of shunt
#define DQ_AI224_SHUNT_STEPS        (255)

#define DQ_AI224_SHUNT_FREQ         (100000)    // shunt measurement A/D rate

#define DQ_AI224_MAX_EXC            (10.0)      // maximum pos. DC excitation
#define DQ_AI224_MIN_EXC            (-10.0)     // minimum neg. DC excitation

#define DQ_AI224_FIR_STAGES         (2)         // each channel has 2 FIR filters in series, FIR0 followed by FIR 1
#define DQ_AI224_CUST_FIR0          (0)         // load custom FIR for stage 0
#define DQ_AI224_CUST_FIR1          (1)         // load custom FIR for stage 1
#define DQ_AI224_DEF_FIR0           (0xE)       // use default FIR for stage 0
#define DQ_AI224_DEF_FIR1           (0xF)       // use default FIR for stage 1
#define DQ_AI224_SELECT_FIR0        (0)         // FIR stage 0, stage parameter for DqAdv224SetFIR()
#define DQ_AI224_SELECT_FIR1        (1)         // FIR stage 1, stage parameter for DqAdv224SetFIR()

#define DQ_AI224_MAXDECR            (0x7FF)     // max decimation and mask
#define DQ_AI224_MAXTAPS0           (0x80)      // stage 0 is 128 taps max
#define DQ_AI224_MAXTAPS1           (0x200)     // stage 1 is 512 taps max, indices 4 thru 9
#define DQ_AI224_TAPMASK0           (0x7F)      // mask for stage 0 taps value
#define DQ_AI224_TAPMASK1           (0x1FF)     // mask for stage 1 taps value
#define DQ_AI224_COEFF_WIDTH        (16)        // bit width of FIR filter coefficients
#define DQ_AI224_FIR_TOTAL          (1<<(DQ_AI224_COEFF_WIDTH-1))   // 32768, expected sum of FIR coeffs for each stage

#define DQ_AI224_MAX_CH_LIST        ((DQ_AI224_CHAN*2)+1)   // maximum number of entries in the channel list

#define DQ_AI224_SPAN               (40.0)
#define DQ_AI224_OFFSET             (20.0)
#define DQ_AI224_STEP               (DQ_AI224_SPAN/0xFFFF)
#define DQ_AI224_STEP18             (DQ_AI224_SPAN/0x3FFFF)

// available gains

#define DQ_AI224_GAIN_1             (0)         // +/- 20.0V
#define DQ_AI224_GAIN_2             (1)         // +/- 10.0V
#define DQ_AI224_GAIN_4             (2)         // +/- 5.0V
#define DQ_AI224_GAIN_8             (3)         // +/- 2.5V
#define DQ_AI224_GAIN_16            (4)         // +/- 1.25V
#define DQ_AI224_GAIN_32            (5)         // +/- 0.625V
#define DQ_AI224_GAIN_64            (6)         // +/- 0.3125
#define DQ_AI224_GAIN_128           (7)         // +/- 0.15625
#define DQ_AI224_GAIN_256           (8)         // +/- 0.078125
#define DQ_AI224_GAIN_512           (9)         // +/- 0.0390625

#define DQ_AI224_DEFAULT_GAIN       (DQ_AI224_GAIN_1)
//-------------------------------------------
#define DQ_AI224_GAINV_0            (1)
#define DQ_AI224_GAINV_1            (2)
#define DQ_AI224_GAINV_2            (4)
#define DQ_AI224_GAINV_3            (8)
#define DQ_AI224_GAINV_4            (16)
#define DQ_AI224_GAINV_5            (32)
#define DQ_AI224_GAINV_6            (64)
#define DQ_AI224_GAINV_7            (128)
#define DQ_AI224_GAINV_8            (256)
#define DQ_AI224_GAINV_9            (512)
// -------------------------------------------------

#define DQ_AI224_STEP18_2           (DQ_AI224_STEP18/2.0)
#define DQ_AI224_STEP18_4           (DQ_AI224_STEP18/4.0)
#define DQ_AI224_STEP18_8           (DQ_AI224_STEP18/8.0)
#define DQ_AI224_STEP18_16          (DQ_AI224_STEP18/16.0)
#define DQ_AI224_STEP18_32          (DQ_AI224_STEP18/32.0)
#define DQ_AI224_STEP18_64          (DQ_AI224_STEP18/64.0)
#define DQ_AI224_STEP18_128         (DQ_AI224_STEP18/128.0)
#define DQ_AI224_STEP18_256         (DQ_AI224_STEP18/256.0)
#define DQ_AI224_STEP18_512         (DQ_AI224_STEP18/512.0)

#define DQ_AI224_OFFSET_2           (DQ_AI224_OFFSET/2.0)
#define DQ_AI224_OFFSET_4           (DQ_AI224_OFFSET/4.0)
#define DQ_AI224_OFFSET_8           (DQ_AI224_OFFSET/8.0)
#define DQ_AI224_OFFSET_16          (DQ_AI224_OFFSET/16.0)
#define DQ_AI224_OFFSET_32          (DQ_AI224_OFFSET/32.0)
#define DQ_AI224_OFFSET_64          (DQ_AI224_OFFSET/64.0)
#define DQ_AI224_OFFSET_128         (DQ_AI224_OFFSET/128.0)
#define DQ_AI224_OFFSET_256         (DQ_AI224_OFFSET/256.0)
#define DQ_AI224_OFFSET_512         (DQ_AI224_OFFSET/512.0)

// Macro to convert gain# to auto null scaling factor
#define DQ_AI224_ANULL_FACTOR(G)    (1.0)

// configuration of the front-end multiplexer - what to read back. Use with DQ_AI224_SET_CHAN() macro.
#define DQ_AI224_MUX_SS             (0x00)      // S+ to S-
#define DQ_AI224_MUX_CS             (0x10)      // Bridge comp - S-
#define DQ_AI224_MUX_EXCP           (0x20)      // P+ to S-
#define DQ_AI224_MUX_PPS            (0x30)      // P+ to PS+
#define DQ_AI224_MUX_NULL           (0x40)      // GND only for nulling
#define DQ_AI224_MUX_PS             (0x50)      // PS+ to PS-, measure excitation voltage
#define DQ_AI224_MUX_EXCN           (0x60)      // P- to S-
#define DQ_AI224_MUX_5K             (0x70)      // Vdrop on 4990 ohm resistor

// configure channel/read mode together into channel list
#define DQ_AI224_SET_CHAN(M,N)      (((M))|((N)&0x7)) // M= mux setting, N= channel #
#define DQ_AI224_AVG_FLAG           (1L<<2)     // for pt-pt mode, logical 'or' to channel # in channel list
                                                // to get averaged data instead of FIR filtered data

// IOCTLs, used internally by DAQLib
#define DQL_IOCTL224_SETCFG         (0x8)       // set a custom configuration
#define DQL_IOCTL224_SETEXC         (0x9)       // set excitation waveform parameters
#define DQL_IOCTL224_SETSHUNT       (0xA)       // enable/disable shunt calibration
#define DQL_IOCTL224_MEASSHUNT      (0xB)       // measure shunt resistance
#define DQL_IOCTL224_SETAVG         (0xC)       // set the averaging factor (channel #s 4-7 are pt-pt averaged data)

// For DQL_IOCTL_SETSHUNT
#define DQ_AI224_SHUNT_DISABLED     (0)         // self-explanatory
#define DQ_AI224_SHUNT_A            (2)         // across P+ and S-
#define DQ_AI224_SHUNT_B            (3)         // across P- and S-

// For DQL_IOCTL_SETEXC
#define DQ_AI224_SET_DC_EXC         (1)         // select DC excitation
#define DQ_AI224_SET_AC_EXC         (2)         // select AC excitation
#define DQ_AI224_SET_BCOMP          (3)         // adjust level for bridge completion
#define DQ_AI224_SET_NULL           (4)         // adjust null level

// define for DqAdv224SetNullLevel(), this value will turn nulling OFF. Values in nulling range (+/-10V) will turn nulling ON.
#define DQ_AI224_SET_NULLING_OFF    (500.0)     // user sets this value to turn nulling OFF.
                                                // By default nulling is OFF. Nulling is turned OFF when config mode is entered
#define DQ_AI224_NULLING_OFF_INT    (500000)    // Null off value used internally by firmware


// For DQIOCTL_SETFILTER
#define DQ_AI224_FIR_DISABLE        (0x0)       // disable fir filter. if both enable and disable are specified, fir will be enabled
#define DQ_AI224_FIR_ENABLE         (0x1)       // enable fir filter
#define DQ_AI224_FIR_SET_DECRATE    (0x2)       // set decimation rate
#define DQ_AI224_FIR_COEFF_LOAD     (0x4)       // load coefficients, number of taps is the length of the coefficient data
#define DQ_AI224_FIR_SET_DEFAULT    (0x8)       // set and enable the default filter i.e. coeffs, taps ,decimation
#define DQ_AI224_FIR_SET_SKIP_COUNT (0x20)      // set skip count by user for special applications

// For DQL_IOCTL224_MEASSHUNT
#define DQ_AI224_V_SHUNT_A          (0x1)       // measure shunt A  across P+ and S-
#define DQ_AI224_V_SHUNT_B          (0x2)       // measure shunt B  across P- and S-
#define DQ_AI224_V_R5K              (0x3)       // measure voltage on 4990 ohm resistor

// channel select defines for DAQLib commands DqAdv224SetFIR() and DqAdv224SetAveraging().
#define DQ_AI224_SEL_CHAN_0         (0x01)
#define DQ_AI224_SEL_CHAN_1         (0x02)
#define DQ_AI224_SEL_CHAN_2         (0x04)
#define DQ_AI224_SEL_CHAN_3         (0x08)
#define DQ_AI224_SEL_CHAN_ALL       (0x0f)

#define DQ_AI224_MAXAVG             (0x14)      // maximum average factor 20 = 2097152 for DqAdv224SetAveraging()
#define DQ_AI224_MIN_SAMPLE_RATE    (391.0)     // lowest ACB data rate
#define DQ_AI224_EXCA_DAC           (0)         // Excitation A
#define DQ_AI224_EXCB_DAC           (1)         // Excitation B
#define DQ_AI224_NULL_DAC           (2)         // PGA nulling
#define DQ_AI224_BCOMPL_DAC         (3)         // Bridge completion

// AI-224 channel numbers are accessible as follows:
#define DQ_AI224_MUX_MASK           (0x70)
#define DQ_AI224_CHTYPE             (0xf8)      // channel type mask (two lower bits are channel)
#define DQ_AI224_GETCHAN(N)         ((N)&0x3)
#define DQ_AI224_GET_AVG_FLAG(N)    ((N)&DQ_AI224_AVG_FLAG)
#define DQ_AI224_GET_CHGAIN(N)      (((N)&0xf00)>>8)
#define DQ_AI224_GET_CHMODE(N)      (((N)&0x070)>>4)     // for multiplexors
#define DQ_AI224_AVG_8              (3)         //
#define DQ_AI224_AVG_16             (4)         //
#define DQ_AI224_AVG_32             (5)         //
#define DQ_AI224_AVG_64             (6)         //
#define DQ_AI224_AVG_128            (7)         //
#define DQ_AI224_AVG_256            (8)         //
#define DQ_AI224_AVG_512            (9)         //
#define DQ_AI224_AVG_1024           (10)         //
#define DQ_AI224_AVG_2048           (11)         //
// Upper part of the configuration word - AI-224 specific
#define DQ_AI224_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mode
#define DQ_AI224_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_AI224_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AI224_MAX_PTS_PERIOD     (256)       // Maximum points per period to avoid overflowing adder

#define DQ_AI224_ZERO_LEVEL         (0x8000)    // default zero level for DACs
#define DQ_AI224_EXC_RMS_DEFAULT    (0x1f0000)  // default excitation level, straight binary full scale

#define DQ_AI224_MAX_DIV            (99)        // 330kHz is maximum recommended
#define DQ_AI224_MAX_DIV2           (199)       // 165kHz is maximum recommended
#define DQ_AI224_MAX_DIV3           (329)       // 100kHz is maximum recommended

#define DQ_AI224_MAX_FRQ            (600000)    // 600kHz is maximum internal sampling frequency

// Output FIFO to read data
#define DQ_AI224_FIFO_GET_DATA      (DQ_FIFO_GET_DATA)

#define DQ_AI224_ENABLE_EXC_A       (1L<<0)     // read from channel A
#define DQ_AI224_ENABLE_EXC_B       (1L<<1)     // ditto B

#define DQ_AO224_PHASE_SET(PHASE, DELAY) (((PHASE)<<18)|((DELAY)&0x3ffff))

#define DQ_AI224_CALCHAN            (8)
#define DQ_AI224_NAMELEN            (20)        // maximum length of the channel name (trailing 0 isn't included)


#pragma pack(1)
/* channel names */
typedef struct {
    char cname[DQ_AI224_CHAN][DQ_AI224_NAMELEN];
} DQCNAMES_224_, *pDQCNAMES_224_;

/* specific device structure - calibration values */
typedef struct {
    // For ADCs
    uint32 adc_gain[DQ_AI224_CHAN][DQ_AI224_GAINS]; // gain adjustments: 0..20000..3ffff
    uint32 adc_offs[DQ_AI224_CHAN][DQ_AI224_GAINS]; // offset adjustment 3ffff..0..1ffff
    uint32 adc_null_gain[DQ_AI224_CHAN][DQ_AI224_GAINS]; // gain adjustments: 0..20000..3ffff
    uint32 adc_null_offs[DQ_AI224_CHAN][DQ_AI224_GAINS]; // offset adjustment 3ffff..0..1ffff

    // For DACs
    uint16 dac_gain[DQ_AI224_CHAN][DQ_AI224_DACS];  // gain 0..8000..ffff     nulling OFF
    uint16 dac_offs[DQ_AI224_CHAN][DQ_AI224_DACS];  // offset  ffff..0..7fff
    uint16 dac_c_gain[DQ_AI224_CHAN][DQ_AI224_GAINS];  // gain 0..8000..ffff  nulling ON
    uint16 dac_c_offs[DQ_AI224_CHAN][DQ_AI224_GAINS];  // offset ffff..0..7fff
    int32  multiplier[DQ_AI224_DACS];               // store DQ_AI224_DAC_CAL_MULTIPLIER here
    uint16 shift[DQ_AI224_DACS];                    // store DQ_AI224_DAC_CAL_SHIFT here
    int8  dcalg[DQ_AI224_CHAN][DQ_AI224_DACS];   //  cal registers on DAC
    int8  dcalo[DQ_AI224_CHAN][DQ_AI224_DACS];   //  cal registers on DAC

} DQCALSET_224_, *pDQCALSET_224_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AI224_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;                   // <reserved>
    uint16 firtaps[DQ_AI224_CHAN];  // number of taps for each filter, 0 - bypass
    uint8  firdecr[DQ_AI224_CHAN];  // decimation ratio each filter

} DQOPMODEPRM_224_, *pDQOPMODEPRM_224_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQPRMFLAGS eeflags;
    DQCALSET_224_ calset;
    DQCNAMES_224_ cname;
    DQOPMODEPRM_224_ opmodeprm;
} DEVEEPROM_224_, *pDEVEEPROM_224_;
#pragma pack()

#define DQ_AI224_WFAVG              (16)


// definitions for AI-225 layer CLI part
#define DQ_AI225_CHAN               (26)        // number of channels
#define DQ_AI225_CHANNELS           (25)        // number of user ADC channels
#define DQ_AI225_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AI225_BASE               (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_AI225_CALLEVEL           (1024000000) // one volt in 1/1024th of uv
#define DQ_AI225_MAXCHAN            (128)
#define DQ_AI225_MAXRATE            (3200)

#define DQ_AI225_CLPERINT           (16)        // default number of full 26-channels CL per interrupt

// Fifo to read calibration voltages
#define DQ_AI225_FIFO_GET_DATA      DQ_FIFO_GET_DATA   // return data from buffer (LN_TMRER mode)
#define DQ_AI225_FIFO_GET_CAL       DQ_FIFO_GET_CAL    // return calibration values

// Default number of CL entries in the FIFO
#define DQ_AI225_CLENTRIES_DEF      (1)
#define DQ_AI225_TS_CHAN            (26)        // the 27th channel used for timestamp
// The 26th channel [25] is not used. it is included for backwards compatibility with the earliest
// version of the AI-225 that had an extra internal channel.
#define DQ_AI225_CHAN_(SM)          (((SM)&(1L<<DQ_AI225_TS_CHAN))?(DQ_AI225_CHAN+1):(DQ_AI225_CHAN))

// Calibration-related
#define DQ_AI225RANGE               (2.5)       // layer range
#define DQ_AI225BINRANGE            0xffffff    // binary range
#define DQ_AI225HALFRANGE           (1.25)      // half of the layer range
#define DQ_AI225ONEVOLTNV           1000000000  // one volt in nV

#define DQ_AI225_GAIN_1             (0)         // the only 225 gain available

// Conversion
#define DQ_AI225_SPAN               (2.5)
#define DQ_AI225_OFFSET             (1.25)
#define DQ_AI225_STEP               (DQ_AI225_SPAN/(double)0xffffff)

typedef struct {
    int32 cvolt;                    // calibration voltage
    int32 cval[DQ_AI225_CHAN];      // real values read at cal voltage
    int32 coffs[DQ_AI225_CHAN];     // offsets per channel
    double gain[DQ_AI225_CHAN];     // gain factor (calculated)
} DQAI225CALDATA, *pDQAI225CALDATA;

#define DQ_ACCESS_DIO_CFG_DIO1_IN   (2)
#define DQ_ACCESS_DIO_CFG_DIO1_OUT  (1)
#define DQ_ACCESS_DIO_CFG_READ_DI_ONLY (0)
#define DQ_ACCESS_DIO2_OUT          (1L<<0)
#define DQ_ACCESS_DIO1_OUT          (1L<<1)
#define DQ_ACCESS_DIO_STATUS_DIO2_OUT (1L<<0)
#define DQ_ACCESS_DIO_STATUS_DIO1_OUT (1L<<1)
#define DQ_ACCESS_DIO_STATUS_DIO0_IN  (1L<<2)
#define DQ_ACCESS_DIO_STATUS_DIO1_IN  (1L<<3)


// store/extract speed setting to/from the channel list
#define DQ_AI225_CLSETSPD(S)        (((S)&0xf)<<12)  // pack speed setting into channel list (1-10)
#define DQ_AI225_CLGETSPD(L)        (((L)&0xf000)>>12) // extract speed from the channel list
#define DQ_AI225_CLSPDMASK          (0xf000)    // mask whether speed is set

// Converter speed * 1000
#define DQ_LT2440_6_9S              (6875)      // 10
#define DQ_LT2440_13_7S             (13750)     // 9
#define DQ_LT2440_27_5S             (27500)     // 8
#define DQ_LT2440_55S               (55000)     // 7
#define DQ_LT2440_110S              (110000)    // 6
#define DQ_LT2440_220S              (220000)    // 5
#define DQ_LT2440_440S              (440000)    // 4
#define DQ_LT2440_880S              (880000)    // 3
#define DQ_LT2440_1760S             (1760000)   // 2
#define DQ_LT2440_3520S             (3520000)   // 1

#define DQ_LT2440_SPDS(N)           (3000000 >> ((N)-1))

#define DQIOCTL_DIO_SIGROUTING      (0x0a)
#define DQIOCTL_DIO_READ_DI_ONLY    (0x0b)

// Data conversion 32->24
#define DQ_LT2440_GETVAL(V)         ((((V)>>5)&0xffffff)^0x800000)    // return 24-bit value
#define DQ_LT2440_ISOVRRANGE(V)     ((((V)&(1L<<28))&&((V)&(1L<<29)))?1:0)
#define DQ_LT2440_ISUNDRANGE(V)     (((V)&((1L<<28)|(1L<<29)))?0:1)
#define DQ_LT2440_FF01(V)           ((V)&3)     // returns status of feed forward lines
#define DQ_LT2440_XTRABITS(V)       (((V)>>2)&7)// returns bits 25,26,27 of 29-bit resolution for averaging


#define DQ_LT2440_MAKEVAL(V)        (((V)^0x800000)<<5)    // convert

// FIFO-related defs
#define DQ_AI225_CL_TIMES           (2)         // upper and lower part of the buffer
#define DQ_AI225_FIFO_CH            (128)       // entries in the fifo
#define DQ_AI225_FIFO_BUFSZ         (16)        // number of FIFOs in allocated buffer

// Upper part of the configuration word - AI-225 specific
#define DQ_AI225_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI225_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO
#define DQ_AI225_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition


#define DQ_AI225_NAMELEN            (16)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_AI225_CHAN][DQ_AI225_NAMELEN];
} DQCNAMES_225_, *pDQCNAMES_225_;

/* specific device structure - calibration values */
typedef struct {
    int32 cvolt;                    /* cal voltage in nV */
    int32 cval[DQ_AI225_CHAN];      /* code at known voltage */
    int32 offs[DQ_AI225_CHAN];      /* offset adjustment */
} DQCALSET_225_, *pDQCALSET_225_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32  chlst[DQ_AI225_CHAN];   // channel list - bitmask
    uint32  conf;                   // control word - layer API flags
    uint32  spd;                    // CL clock in speed grades (1..10)
    uint32  trig;                   // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_225_, *pDQOPMODEPRM_225_;


/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS      ee;
    DQCALSET_225_    calset;
    DQOPMODEPRM_225_ opmodeprm;
    DQCNAMES_225_    cname;
    DQPRMFLAGS       eeflags;
    uint8            res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                                      - sizeof(DQCALSET_225_)
                                      - sizeof(DQOPMODEPRM_225_)
                                      - sizeof(DQCNAMES_225_)
                                      - sizeof(DQPRMFLAGS)
                                      - sizeof(uint32)];    // crc
} DEVEEPROM_225_, *pDEVEEPROM_225_;
#pragma pack()

#define DQ_AI254_CHAN               (4)           // channels
#define DQ_AI254_DACS               (4)           // DACs per channel
#define DQ_AI254_ADCS               (2)           // A/D per channel

#define DQ_AI254_AIN_CHAN           (8)           // 8 AI's max.
#define DQ_AI254_AOUT_CHAN          (16)          // 16 AO's max.
#define DQ_AI254_AIN_CL_SIZE        (9)           // 8 AI's and timestamp
#define DQ_AI254_AOUT_CL_SIZE       (16)          // 16 AO's

#define DQ_AI254_INFOSZ             (DQ_MAX_INFO_SIZE)   // maximum size of information structure
#define DQ_AI254_BASE               (BUS_FREQUENCY)      // 66MHz base frequency
#define DQ_AI254_GAINS              (4)           // number of gains supported

#define DQ_AI254_CLOCK33            (33000000)    // 33MHz clock
#define DQ_AI254_CLOCK24            (24000000)    // 24MHz clock

#define DQ_AI254_STARTDELAY         (2000)        // us

#define DQ_AI254_MINCLFRQ           (400)         // minimum LVDT rate
#define DQ_AI254_MAXCLFRQ           (20000)       // maximum LVDT rate - must match caps structure

#define DQ_AI254_MAXCVFRQ4          (320000)      // maximum digitization rate for four DACs
#define DQ_AI254_MAXCVFRQ2          (640000)      // maximum digitization rate for two DACs

#define DQ_AI254_CALDACS            (0)           // number of calibration DACs
#define DQ_AI254_VREFS              (0)           // number of voltage references

#define DQ_AI254_MAX_CH_LIST        (32)          // maximum number of entries in the channel list

#define DQ_AI254_SPAN               (80.0)
#define DQ_AI254_OFFSET             (40.0)
#define DQ_AI254_STEP               (DQ_AI254_SPAN/0xFFFF)
#define DQ_AI254_STEP16             (DQ_AI254_SPAN/0xFFFF)

#define DQ_AI254_SUM2RMS            (1.114303027) // coefficient to multiply Sa to to get RMS assuming ideal sine wave signal
#define DQ_AI254_AMP2RMS            (1.414213562)

#define DQ_AI254_MIN_FRQ_SMOKE_TEST (350.0)
#define DQ_AI254_MAX_FRQ_SMOKE_TEST (22000.0)

#define DQ_AI254_EXC_SPAN           (20.0)
#define DQ_AI254_EXC_OFFSET         (10.0)
#define DQ_AI254_EXC_STEP           (DQ_AI254_EXC_SPAN/0xFFFF)

#define DQ_AI254_GAINV              (1)
#define DQ_AI254_GAINV_2            (DQ_AI254_GAINV*2)
#define DQ_AI254_GAINV_5            (DQ_AI254_GAINV*5)
#define DQ_AI254_GAINV_10           (DQ_AI254_GAINV*10)

#define DQ_AI254_STEP_2             (DQ_AI254_STEP/2)
#define DQ_AI254_STEP_5             (DQ_AI254_STEP/5)
#define DQ_AI254_STEP_10            (DQ_AI254_STEP/10)

#define DQ_AO254_OFFSET             (5.0)
#define DQ_AO254_STEP               (10.0 / (double)0xffff)

// available gains
#define DQ_AI254_GAIN_1             (0)
#define DQ_AI254_GAIN_2             (1)
#define DQ_AI254_GAIN_4             (2)
#define DQ_AI254_GAIN_8             (3)

#define DQ_AI254_GAIN_5             (2)
#define DQ_AI254_GAIN_10            (3)

// Special channels - AIn
#define DQ_AI254_DIV_CAL            (0x00)      // calibrated result of division
#define DQ_AI254_DIV_RAW            (0x10)      // raw result of (Sa-Sb)/(Sa+Sb)
#define DQ_AI254_STATUS             (0x18)      // retrieve status information
#define DQ_AI254_AVG                (0x20)      // average position
#define DQ_AI254_ZC                 (0x30)      // number of counts for both half periods in point-by-point. 16bits and (16bits <<16)
#define DQ_AI254_ZC0                (0x30)      // number of counts for pos half period in mapped modes  (in 1/33000000)
#define DQ_AI254_ZC1                (0x38)      // number of counts for neg half period in mapped modes  (in 1/33000000)
#define DQ_AI254_LAST_A             (0x40)      // last value from A/D A
#define DQ_AI254_MAX_A              (0x48)      // maximum value A
#define DQ_AI254_LAST_B             (0x50)      // last value from A/D B
#define DQ_AI254_MAX_B              (0x58)      // maximum value B
#define DQ_AI254_LAST_Sa            (0x60)      // last calc value from Sa adder
#define DQ_AI254_MIN_A              (0x68)      // minimum value A
#define DQ_AI254_LAST_Sb            (0x70)      // last calc value from Sb adder
#define DQ_AI254_MIN_B              (0x78)      // minimum value B
#define DQ_AI254_STATUS             (0x18)      // retrieve status information

#define DQ_AI254_CHTYPE             (0xf8)      // channel type mask (two lower bits are channel)
#define DQ_AI254_CHNUM              (0x3)       // channel number only

// Special channels - AOut
#define DQ_AI254_GAIN_A             (0x00)      // gain of A excitation channel
#define DQ_AI254_GAIN_B             (0x10)      // gain of B excitation channel
#define DQ_AI254_PHASE_A            (0x20)      // phase of A excitation channel
#define DQ_AI254_PHASE_B            (0x30)      // phase of B excitation channel
#define DQ_AI254_PHASE_AUTO         (0x40)      // Autophase for 4-wire LVDT
#define DQ_AI254_FFIFO              (0x50)      // Fifo to drop values in
#define DQ_AI254_AOUT0_WR           (0x60)      // Write DC level into AOut0
#define DQ_AI254_AOUT1_WR           (0x70)      // Write DC level into AOut1
#define DQ_AI254_AOUT2_WR           (0x80)      // Write DC level into AOut2
#define DQ_AI254_AOUT3_WR           (0x90)      // Write DC level into AOut3

// IOCTLs
#define DQL_IOCTL254_SETCFG         (0x8)       // set a custom configuration
#define DQL_IOCTL254_SETEXC         (0x9)       // set excitation waveform parameters
#define DQL_IOCTL254_GETEXC         (0xA)       // get calculated excitation parameters
#define DQL_IOCTL254_START          (0xB)       // get calculated waveform parameters
#define DQL_IOCTL254_SETWF          (0xC)       // set excitation waveform
#define DQL_IOCTL254_DIO            (0xD)       // read-write DIO
#define DQL_IOCTL254_GETWF          (0xE)       // Get AIn measurements for input waveform
#define DQL_IOCTL254_SETEXT         (0xF)       // Set additional parameters

// Modes of operation used by DqAdv254SetMode() --------------------------------------------------------
#define DQ_AI254_MODE_INT_5         (0)         // Mode0: internal excitation of 5-wire LVDT
#define DQ_AI254_MODE_INT_4         (1)         // Mode1: internal excitation of 4-wire LVDT
#define DQ_AI254_MODE_EXT_5         (2)         // Mode2: external excitation of 5-wire LVDT
#define DQ_AI254_MODE_EXT_4         (3)         // Mode3: external excitation of 4-wire LVDT
#define DQ_AI254_MODE_SIM_5         (4)         // Mode4: simulation of the outputs of 5-wire LVDT
#define DQ_AI254_MODE_SIM_4         (5)         // Mode5: simulation of the outputs of 4-wire LVDT
//                                              // extended sim modes: for use with AI-256 (DqAdv256SetMode()) only.
#define DQ_AI254_MODE_SIM_5_INT     (6)         // Mode6: simulation of the outputs of 5-wire LVDT w/internal excitation
#define DQ_AI254_MODE_SIM_4_INT     (7)         // Mode7: simulation of the outputs of 4-wire LVDT w/internal excitation

// flags used by DqAdv254SetExt()
#define DQ_AI254_MODE_SETAVG        (1L<<0)     // Set position calculation moving average 0=1, 1=2, ..., 8=256
#define DQ_AI254_MODE_SETMMAVG      (1L<<1)     // Set min/max moving average 0=1, 1=2, ..., 8=256
#define DQ_AI254_MODE_SETZEROC      (1L<<2)     // Set zero crossing window 0=1,...,6=64 samples
#define DQ_AI254_MODE_SETZCLEVEL    (1L<<3)     // Set zero crossing level: 0x4000...0xC000
#define DQ_AI254_MODE_SET_SINE_SQR  (1L<<16)    // enable ouput of square waveform instead of sine
#define DQ_AI254_MODE_USE_SXAVG     (1L<<30)    // Use Sx averaging instead of Min/Max average for 4-wire scheme

                                                // By default, channel A is the input for ref excitation. Set this
                                                // flag bit in DqAdv254SetMode() 'flags' parameter to
#define DQ_AI254_MODE_USEREFB       (1L<<16)    // instead use channel B (S2+/S2-) for reference excitation ZC detection

typedef struct {
    uint32 PositionAvg;             // Set moving average window size: 0=1,...,8=256
    uint32 MinMaxAvg;               // Set min/max window size: 0=1,...,8=256
    uint32 ZeroCrossing;            // Set zero crossing window: 0=1,...,6=64
    uint32 ZeroLevel;               // Set zero crossing level
} DQ254SetExt, *pDQ254SetExt;

// Upper part of the configuration word - AI-254 specific
#define DQ_AI254_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AI254_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO
#define DQ_AI254_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AI254_MAX_PTS_PERIOD     (256)         // Maximum points per period to avoid overflowing adder

#define DQ_AI254_ZERO_LEVEL         (0x8000)      // default zero level
#define DQ_AI254_EXC_RMS_DEFAULT    (0x1f0000)    // default excitation level, straight binary full scale

#define DQ_AI254_MAX_DIV            (99)          // 330kHz is maximum recommended
#define DQ_AI254_MAX_DIV2           (199)         // 165kHz is maximum recommended
#define DQ_AI254_MAX_DIV3           (329)         // 165kHz is maximum recommended

#define DQ_AI254_MAX_FRQ            (330000)      // 330kHz is maximum sampling frequency

// Output FIFO to read data
#define DQ_AI254_FIFO_GET_DATA      (DQ_FIFO_GET_DATA)

#define DQ_AI254_ENABLE_EXC_A       (1L<<0) // read from channel A
#define DQ_AI254_ENABLE_EXC_B       (1L<<1) // ditto B

#define DQ_AO254_PHASE_SET(PHASE, DELAY) (((PHASE)<<18)|((DELAY)&0x3ffff))

#define DQ_AI256_LVDT_CHANONLY_MASK (0x01)
#define DQ_AI254_USROFFS_1          0x0         // zero user offset
#define DQ_AI254_USRGAIN_1          0x800000    // user gain of 1
#define DQ_AI254_CALCHAN            (8)

#define DQ_AI254_NAMELEN            (20)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)
/* channel names */
typedef struct {
    char cname[DQ_AI254_CHAN][DQ_AI254_NAMELEN];
} DQCNAMES_254_, *pDQCNAMES_254_;

/* specific device structure - calibration values */
typedef struct {
    // Final gain and offset
    uint32 u_gain[DQ_AI254_CHAN];
    uint32 u_offs[DQ_AI254_CHAN];

    // input A / gain 1
    uint16 voff_i_a[DQ_AI254_CHAN];
    uint16 gain_i_a[DQ_AI254_CHAN];

    // input B / gain 1
    uint16 voff_i_b[DQ_AI254_CHAN];
    uint16 gain_i_b[DQ_AI254_CHAN];

    // output A
    uint16 voff_o_a[DQ_AI254_CHAN];
    uint16 gain_o_a[DQ_AI254_CHAN];

    // output B
    uint16 voff_o_b[DQ_AI254_CHAN];
    uint16 gain_o_b[DQ_AI254_CHAN];

    // output C
    uint16 voff_o_c[DQ_AI254_CHAN];
    uint16 gain_o_c[DQ_AI254_CHAN];

    // output D
    uint16 voff_o_d[DQ_AI254_CHAN];
    uint16 gain_o_d[DQ_AI254_CHAN];

} DQCALCHAN_254_, *pDQCALCHAN_254_;

typedef struct {
    DQCALCHAN_254_ cal;

    // input A / gain 2,5,10
    uint16 voff_i_a[DQ_AI254_CHAN][DQ_AI254_GAINS];
    uint16 gain_i_a[DQ_AI254_CHAN][DQ_AI254_GAINS];

    // input B / gain 2,5,10
    uint16 voff_i_b[DQ_AI254_CHAN][DQ_AI254_GAINS];
    uint16 gain_i_b[DQ_AI254_CHAN][DQ_AI254_GAINS];

} DQCALSET_254_, *pDQCALSET_254_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AI254_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_254_, *pDQOPMODEPRM_254_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_254_ calset;
    DQOPMODEPRM_254_ opmodeprm;
    DQCNAMES_254_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_254_, *pDEVEEPROM_254_;
#pragma pack()

// for DQL_IOCTL254_GETWF
typedef struct {
    uint32 min_lvl;                 // waveform minimum
    uint32 max_lvl;                 // waveform maximum
    uint32 sum;                     // average accumulated sum (Sa or Sb)
    uint32 cal;                     // calibrated position
    uint32 raw;                     // raw position
    uint32 zc0;                     // zero-crossing 0
    uint32 zc1;                     // zero-crossing 1
    uint32 zc0_var;                 // variation of zc0
    uint32 zc1_var;                 // variation of zc1
    uint32 raw_var;                 // variation of the raw position
    uint32 clk_frq;                 // selected AIn/AOut clock
    float ampl;                     // waveform amplitude
    float freq;                     // waveform frequency
    float offs;                     // waveform offset
} WFPRM_254, *pWFPRM_254;

typedef struct {
    uint32 changain;                // channel and gain
    uint32 zero;                    // zero level, 0 == default (0x8000)
    uint32 clock;                   // A/D rate, 0 == maximum rate
    uint32 uzb;                     // TRUE == use ZC on channel B
    uint32 uaz;                     // TRUE == auto-zero
    uint32 s_e;                     // if divider is set (not-zero) , use Sa/Se
    uint32 period_ms;               // maximum expected waveform period, affect function return time
} WFMEASURE_254, *pWFMEASURE_254;

#define DQ_AI254_WFAVG              (16)


#define DQ_AI255_CHAN               (2)         // # of channels on AI-255 or AI-256
#define DQ_AI256_CHAN               (2)         // # of channels on AI-255 or AI-256
#define DQ_AI255_DACS               (4)         // excitation/simulation DACs per channel on AI-255 or AI-256
#define DQ_AI255_ADCS               (4)         // A/D per channel on AI-255 or AI-256
#define DQ_AI256_PADC_CHAN          (4)         // AI-256 - # of converter channels on each of the 2 auxiliary Power ADC's
#define DQ_AI256_PADC_CHAN_MASK     (0x03)      // mask to access AI-256 power adc channels

#define AI255_DEV_MODEL             (0x255)
#define AI256_DEV_MODEL             (0x256)
#define DQ_AI255_STARTDELAY         (5000)      // microseconds
#define DQ_AI255_AIN_CL_SIZE        (9)
#define DQ_AI255_AIN_CHAN           (8)
#define DQ_AI255_AOUT_CHAN          (8)

// Channels named
#define DQ_AI255_CHANNEL_A          (0)
#define DQ_AI255_CHANNEL_B          (1)
#define DQ_AI255_CHANNEL_C          (2)
#define DQ_AI255_CHANNEL_D          (3)

#define DQ_AI255_INFOSZ             DQ_MAX_INFO_SIZE   // maximum size of information structure
#define DQ_AI255_BASE               BUS_FREQUENCY      // 66MHz base frequency

#define DQ_AI255_GAINS              (4)         // number of gains supported, AI-255 or AI-256

#define DQ_AI255_CLOCK33            (33000000)  // 33MHz clock
#define DQ_AI255_CLOCK24            (24000000)  // 24MHz clock

#define DQ_AI255_MAXCLFRQ           (20000)     // maximum excitation rate
#define DQ_AI255_MAXCVFRQ           (330000)    // AI-255 maximum digitization rate (DAC)
#define DQ_AI255_MAXCVFRQ4          (330000)    // AI-255 maximum digitization rate (DAC) 4 simultaneous outputs
#define DQ_AI255_MAXCVFRQ3          (440000)    // AI-255 maximum digitization rate (DAC) 3 simultaneous outputs
#define DQ_AI255_MAXCVFRQ2          (660000)    // AI-255 maximum digitization rate (DAC) 2 simultaneous outputs
#define DQ_AI255_MAXCVFRQ1          (1000000)   // AI-255 maximum digitization rate (DAC) 1 output

#define DQ_AI256_MAXCVFRQ           (434210)    // AI-256 maximum digitization rate (DAC)
#define DQ_AI256_MAXCVFRQ4          (434210)    // AI-256 maximum digitization rate (DAC) 4 simultaneous outputs
#define DQ_AI256_MAXCVFRQ3          (578000)    // AI-256 maximum digitization rate (DAC) 3 simultaneous outputs
#define DQ_AI256_MAXCVFRQ2          (850000)    // AI-256 maximum digitization rate (DAC) 2 simultaneous outputs

#define DQ_AI255_CALDACS            (0)         // number of calibration DACs
#define DQ_AI255_VREFS              (0)         // number of voltage references

#define DQ_AI255_MAX_CH_LIST        (32)        // maximum number of entries in the channel list

// AI-255 and AI-256 have the same analog input span, ampl and offset
#define DQ_AI255_SPAN               (80.0)      // '255 total span for in and out, '256 in span
#define DQ_AI255_AMPL               (DQ_AI255_SPAN/2.0)     // amplitude
#define DQ_AI255_OFFSET             (DQ_AI255_SPAN/2.0)     // offset
#define DQ_AI255_STEP               (DQ_AI255_SPAN/65535.0)
#define DQ_AI255_STEP18             (DQ_AI255_SPAN/0x3FFFF)

#define DQ_AI255_815_SPAN           (370.0)                     // 130.8Vrms,  '255_815 total span for in
#define DQ_AI255_815_AMPL           (DQ_AI255_815_SPAN/2.0)     // amplitude
#define DQ_AI255_815_OFFSET         (DQ_AI255_815_SPAN/2.0)     // offset
#define DQ_AI255_815_STEP           (DQ_AI255_815_SPAN/65535.0)
#define DQ_AI255_815_STEP18         (DQ_AI255_815_SPAN/0x3FFFF)

#define DQ_AI255_815_STEP_2         (DQ_AI255_815_STEP/2.0)
#define DQ_AI255_815_STEP_5         (DQ_AI255_815_STEP/5.0)
#define DQ_AI255_815_STEP_10        (DQ_AI255_815_STEP/10.0)

#define DQ_AI255_815_OFFSET_2       (DQ_AI255_815_OFFSET/2.0)
#define DQ_AI255_815_OFFSET_5       (DQ_AI255_815_OFFSET/5.0)
#define DQ_AI255_815_OFFSET_10      (DQ_AI255_815_OFFSET/10.0)

#define DQ_AI256_AO_SPAN            (57.831)    // total '256 AO span
#define DQ_AI256_AO_STEP            (DQ_AI256_AO_SPAN/65535.0)
#define DQ_AI256_AO_AMPL            (DQ_AI256_AO_SPAN/2.0)  // amplitude
#define DQ_AI256_AO_OFFSET          (DQ_AI256_AO_SPAN/2.0)  // offset

#define DQ_AI255_360                (0x19228)   // 0 = 0 degrees, 0x19228 is 360 degrees angle
#define DQ_AI255_ACC_LIM            (DQ_AI255_360>>1)       // Acceleration limit is 180 degrees

#define DQ_AI255_GAINV              (1)
#define DQ_AI255_GAINV_2            (DQ_AI255_GAINV*2)
#define DQ_AI255_GAINV_5            (DQ_AI255_GAINV*5)
#define DQ_AI255_GAINV_10           (DQ_AI255_GAINV*10)

#define DQ_AI255_STEP_2             (DQ_AI255_STEP/2.0)
#define DQ_AI255_STEP_5             (DQ_AI255_STEP/5.0)
#define DQ_AI255_STEP_10            (DQ_AI255_STEP/10.0)

// available gains, bits [9:8] of the channel list entries for DqAdv255Read
#define DQ_AI255_GAIN_1             (0)
#define DQ_AI255_GAIN_2             (1)
#define DQ_AI255_GAIN_5             (2)
#define DQ_AI255_GAIN_10            (3)

#define DQ_AI255_OFFSET_2           (DQ_AI255_OFFSET/2.0)
#define DQ_AI255_OFFSET_5           (DQ_AI255_OFFSET/5.0)
#define DQ_AI255_OFFSET_10          (DQ_AI255_OFFSET/10.0)

// Special channels - AIn, used by DqAdv255Read
#define DQ_AI255_ANGLE_CAL          (0x00)      // calibrated angle
#define DQ_AI255_ACCEL_CAL          (0x10)      // calibrate acceleration
#define DQ_AI255_STATUS             (0x18)      // current status information
#define DQ_AI255_RAW_DATA           (0x20)      // raw position
#define DQ_AI255_ZC                 (0x30)      // number of counts for both half periods, >252Hz
//      DQ_AI255_LAST_X
#define DQ_AI255_LAST_A             (0x40)      // results of the last conversion A
#define DQ_AI255_LAST_B             (0x44)      // results of the last conversion B
#define DQ_AI255_LAST_C             (0x48)      // results of the last conversion C
#define DQ_AI255_LAST_D             (0x4C)      // results of the last conversion D
//      DQ_AI255_LAST_SxX
#define DQ_AI255_LAST_SxA           (0x50)      // last accumulated value from A/D A
#define DQ_AI255_LAST_SxB           (0x54)      // last accumulated value from A/D B
#define DQ_AI255_LAST_SxC           (0x58)      // last accumulated value from A/D C
#define DQ_AI255_LAST_SxD           (0x5C)      // last accumulated value from A/D D
//      DQ_AI255_MIN_X
#define DQ_AI255_MIN_A              (0x60)      // minimum reading A
#define DQ_AI255_MIN_B              (0x64)      // minimum reading B
#define DQ_AI255_MIN_C              (0x68)      // minimum reading C
#define DQ_AI255_MIN_D              (0x6C)      // minimum reading D
//      DQ_AI255_MAX_X
#define DQ_AI255_MAX_A              (0x70)      // maximum A
#define DQ_AI255_MAX_B              (0x74)      // maximum B
#define DQ_AI255_MAX_C              (0x78)      // maximum C
#define DQ_AI255_MAX_D              (0x7C)      // maximum D
#define DQ_AI255_PHASE_DET          (0x80)      // phase detector

 // use of DQ_AI255_LAST_SxA_AVG,DQ_AI255_LAST_SxB_AVG  on AI-256 requires logic 02.11.1E+
 // abs value of 24 bit accumulated value / 94720.0 = Vrms ( assuming ideal sinewave )
#define DQ_AI255_LAST_SxA_AVG       (0x88)      // averaged last accumulated value from A/D A
#define DQ_AI255_LAST_SxB_AVG       (0x8C)      // averaged last accumulated value from A/D B

#define DQ_AI255_CHTYPE             (0xfc)      // channel type mask

// Special channels - AOut
#define DQ_AI255_GAIN_A             (0x00)      // gain of A excitation channel
#define DQ_AI255_GAIN_B             (0x04)      // gain of B excitation channel
#define DQ_AI255_GAIN_C             (0x08)      // gain of C excitation channel
#define DQ_AI255_GAIN_D             (0x0C)      // gain of D excitation channel

#define DQ_AI255_PHASE_A            (0x10)      // phase of A excitation channel
#define DQ_AI255_PHASE_B            (0x14)      // phase of B excitation channel
#define DQ_AI255_PHASE_C            (0x18)      // phase of C excitation channel
#define DQ_AI255_PHASE_D            (0x1C)      // phase of D excitation channel

#define DQ_AI255_FFIFO              (0x20)      // write to the zero-crossing-enabled FIFO

#define DQ_AI255_AOUT0_WR           (0x30)      // Write DC level into AOut0
#define DQ_AI255_AOUT1_WR           (0x40)      // Write DC level into AOut1
#define DQ_AI255_AOUT2_WR           (0x50)      // Write DC level into AOut2
#define DQ_AI255_AOUT3_WR           (0x60)      // Write DC level into AOut3

//#define DQ_AI256_PHASE_AUTO         (0x70)      // Autophase for 4-wire LVDT
//#define DQ_AI256_FIFO               (0x74)      // Fifo to drop values in
// IOCTLs
#define DQL_IOCTL255_SETCFG         (0x8)       // set a custom configuration
#define DQL_IOCTL255_SETEXC         (0x9)       // set excitation waveform parameters
#define DQL_IOCTL255_GETEXC         (0xA)       // get calculated excitation parameters
#define DQL_IOCTL255_START          (0xB)       // get calculated waveform parameters
#define DQL_IOCTL255_SETWF          (0xC)       // set excitation waveform
#define DQL_IOCTL255_DIO            (0xD)       // read-write DIO
#define DQL_IOCTL255_GETWF          (0xE)       // Get AIn measurements for input waveform
#define DQL_IOCTL255_SETEXT         (0xF)       // Set additional parameters
#define DQL_IOCTL256_GET_PADC       (0x1001L)   // read the Power ADC values
                                                // data for calibration or diagnostic purposes
#define DQL_IOCTL256_CVTCHNL_254    (0x1002L)   // perform the '254 simulation output
#define DQL_IOCTL256_START_254      (0x1003L)   // perform the '254 simulation start
#define DQL_IOCTL256_SETCFG_254     (0x1004L)   // set config for '254 simulation

// IOCTL parameters
#define DQAI256_GETPARAM_GET        (0x10)      // get command used by DQIOCTL_GETPARAM
#define DQAI256_SETPARAM_SET        (0x10)      // set command used by DQIOCTL_SETPARAM
// Flags
#define DQ_AI256_UNCALFLAG          (0x80)      // flag for DqAdv255ReadPADC() to get uncalibrated data

// Modes of operation -------------------------------------------------------------------
#define DQ_AI255_MODE_SI_INT        (0)         // Synchro input, int. exc.
#define DQ_AI255_MODE_RI_INT        (1)         // Resolver input, int.exc.
#define DQ_AI255_MODE_SI_EXT        (2)         // Synchro input, ext. exc. - readback exc. on D
#define DQ_AI255_MODE_RI_EXT        (3)         // Resolver input, ext. exc. - readback exc. on D

#define DQ_AI255_MODE_SS_INT        (4)         // Synchro drive, int. exc. - fully sourced
#define DQ_AI255_MODE_RS_INT        (5)         // Resolver drive, int.exc. - fully sources
#define DQ_AI255_MODE_SS_EXT        (6)         // Synchro drive, ext. exc. - readback exc. on D
#define DQ_AI255_MODE_RS_EXT        (7)         // Resolver drive, ext. exc. - readback exc. on D
#define DQ_AI255_MODE_EN_AOUT       (8)
#define DQ_AI255_MODE_EN_AIN        (9)         // enable ABCD inputs to be used as generic analog input,
                                                // use DQ_AI255_LAST_X, DQ_AI255_MIN_X, DQ_AI255_MAX_X with DqAdv255Read()

#define DQ_AI255_MODE_SI_INTZ       (10)        // Synchro input, int. exc., Z grounded
#define DQ_AI255_MODE_SI_EXTZ       (11)        // Synchro input, ext. exc., Z grounded

#define DQ_AI255_MODE_SS_INTZ       (12)        // Synchro output, int. exc., Z grounded
#define DQ_AI255_MODE_SS_EXTZ       (13)        // Synchro output, ext. exc., Z grounded

#define DQ_AI256_MODE_SIM_5_EXT     (0x10)      // 254 Mode5: simulation of the outputs of 5-wire LVDT
#define DQ_AI256_MODE_SIM_4_EXT     (0x11)      // 254 Mode6: simulation of the outputs of 4-wire LVDT
#define DQ_AI256_MODE_SIM_5_INT     (0x12)      // 256 Mode7: simulation of the outputs of 5-wire LVDT with internal excitation(AI256 only)
#define DQ_AI256_MODE_SIM_4_INT     (0x13)      // 256 Mode8: simulation of the outputs of 4-wire LVDT with internal excitation(AI256 only)

#define DQ_AI255_MODE_DISABLE       (0xf)       // disable outputs

// Additional flags:
#define DQ_AI255_MODE_SETAVG        (1L<<0)     // Set Average 0=1, 1=2, ..., 8=256
#define DQ_AI255_MODE_SETZEROC      (1L<<1)     // Set zero crossing window 0=1,...,6=64 samples

typedef struct {
    uint32 PositionAvg;             // Set moving average window size: 0=1,...,8=256
    uint32 ZeroCrossing;            // Set zero crossing window: 0=1,...,6=64
} DQ255SetExt, *pDQ255SetExt;

#define DQ_AI255_RMS_LN_LN_TO_PP(V) ((V)*1.633) // Output amplitude conversion factor for synchro simulation output.
                                                // This macro converts the synchro's volts rms line-to-line spec to the
                                                // AI-255's Vpp output to ground requirement. This is a reduction of the
                                                // formula: Vpp = (Vrms / (2*sine(120))) * 2 * sqrt(2)
#define DQ_AI255_RMS_LN_LN_TO_RMS(V) ((V)*0.5774) // This macro converts the synchro's volts rms line-to-line spec to volts
                                                // rms referenced to ground.

#define DQ_AI255_RMS_TO_Z_RMS       (1.732050808)   // conversion factor for simulating Z-Gnd, divide required voltage by this factor

//Each AI-256 power channel has these 4 AI channels, aka ADC subchannels
#define DQ_AI256_SUBCH_NEGV         (0)         // -VA-CH
#define DQ_AI256_SUBCH_POSV         (1)         // +VCCH
#define DQ_AI256_SUBCH_I_DC         (2)         // DC current on common
#define DQ_AI256_SUBCH_THERM        (3)         // temperature of the ADC IC in degrees C

//The following are indices for bdata and fdata parameters of DAQLib function DqAdv256ReadPADC()
#define DQ_AI256_SUBCH_NEGV_0       (0)         // ch0 -VA-CH
#define DQ_AI256_SUBCH_POSV_0       (1)         // ch0 +VCCH
#define DQ_AI256_SUBCH_I_DC_0       (2)         // ch0 DC current on common
#define DQ_AI256_SUBCH_THERM_0      (3)         // ch0 temperature of the ADC IC in degrees C
#define DQ_AI256_SUBCH_NEGV_1       (4)         // ch1 -VA-CH
#define DQ_AI256_SUBCH_POSV_1       (5)         // ch1 +VCCH
#define DQ_AI256_SUBCH_I_DC_1       (6)         // ch1 DC current on common
#define DQ_AI256_SUBCH_THERM_1      (7)         // ch1 temperature of the ADC IC in degrees C
// status bits available in returned value from  DQ_AI255_STATUS
// All bits are cleared after the read but will re-appear if any of the status conditions persist.
#define DQ_AI255_AIN_STS_DR         (1L<<16)    // ADC data is ready
#define DQ_AI255_AIN_IR_TR          (1L<<7)     // Tangent calculations complete
#define DQ_AI255_AIN_IR_FE          (1L<<6)     // FIFO empty
#define DQ_AI255_AIN_IR_FHF         (1L<<5)     // FIFO half full
#define DQ_AI255_AIN_IR_FF          (1L<<4)     // FIFO full
#define DQ_AI255_AIN_IR_ZLH         (1L<<3)     // Rising  edge zero crossing detected
#define DQ_AI255_AIN_IR_ZHL         (1L<<2)     // Falling edge zero crossing detected
#define DQ_AI255_AIN_IR_AR          (1L<<1)     // Angle data is ready
#define DQ_AI255_AIN_IR_ACC         (1L<<0)     // Acceleration exceeds limit
// Upper part of the configuration word - AI-255/6 specific
#define DQ_AI255_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mode
#define DQ_AI255_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO
#define DQ_AI255_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AI255_MAX_PTS_PERIOD     (256)       // Maximum points per period to avoid overflowing adder

#define DQ_AI255_ZERO_LEVEL         (0x8000)    // default zero level
#define DQ_AI255_EXC_RMS_DEFAULT    (0x1f0000)  // default excitation level, straignt binary full scale

#define DQ_AI255_MAX_DIV            (99)        // 330kHz is maximum recommended
#define DQ_AI255_MAX_DIV2           (199)       // 165kHz is maximum recommended
#define DQ_AI255_MAX_DIV3           (329)       // 165kHz is maximum recommended

#define DQ_AI255_MAX_FRQ            (330000)    // 330kHz is maximum '255 sampling frequency
#define DQ_AI256_MAX_FRQ            (660000)    // 660kHz is maximum '256 AIN sampling frequency

// Output FIFO to read data
#define DQ_AI255_FIFO_GET_DATA      DQ_FIFO_GET_DATA

#define DQ_AI255_ENABLE_EXC_A       (1L<<0)     // read from channel A
#define DQ_AI255_ENABLE_EXC_B       (1L<<1)     // ditto B
#define DQ_AI255_ENABLE_EXC_C       (1L<<2)     // ditto C
#define DQ_AI255_ENABLE_EXC_D       (1L<<3)     // ditto D

//                                              define 'flags' parameter of DqAdv255SetMode()
#define DQ_AI255_FL_SIM_SYNC        (1L<<3)     // =1 - use synced sim output if hardware supports it
#define DQ_AI255_FL_NOAOUT          (1L<<2)     // =1 - do not reprogram analog output in INT modes
#define DQ_AI255_FL_HWLOOP          (1L<<1)     // =1 - use external excitation amplitude as a factor in calculating simulated voltage (> f.53)


#define DQ_AO255_PHASE_SET(PHASE, DELAY) (((PHASE)<<18)|((DELAY)&0x3ffff))

// Available commands for FFIFO waveform control
#define DQ_AI255_AOUT_FFCMD_WZ      (8L<<28)    // (==1L<<31)Wait for "zero" command, if set will delay advance from the FIFO
                                                // until corresponding waveform counter ("A" or "B") will pass through
                                                // the sample with index zero. This is done to change offset/gain/phase at
                                                // the zero crossing thus reducing possible spikes. This command is
                                                // combinable with any of the 8 other commands that immediately follow
#define DQ_AI255_AOUT_FFCMD_PHA     (0L<<28)    // Data bits will be targeted to PHA register
#define DQ_AI255_AOUT_FFCMD_PHB     (1L<<28)    // Data bits will be targeted to PHB register
#define DQ_AI255_AOUT_FFCMD_PHC     (2L<<28)    // Data bits will be targeted to PHC register
#define DQ_AI255_AOUT_FFCMD_PHD     (3L<<28)    // Data bits will be targeted to PHD register
#define DQ_AI255_AOUT_FFCMD_GA      (4L<<28)    // Data bits will be targeted to GAINA register
#define DQ_AI255_AOUT_FFCMD_GB      (5L<<28)    // Data bits will be targeted to GAINB register
#define DQ_AI255_AOUT_FFCMD_GC      (6L<<28)    // Data bits will be targeted to GAINC register
#define DQ_AI255_AOUT_FFCMD_GD      (7L<<28)    // Data bits will be targeted to GAIND register
#define DQ_AI255_AOUT_CMD_MASK      (7L<<28)    // mask to extract target register

#define DQ_AI255_COIL_X(D)          (-(D)-30)
#define DQ_AI255_COIL_Y(D)          (-(D)-150)
#define DQ_AI255_COIL_Z(D)          (-(D)-270)

#define DQ_AI255_COIL_X_r(D)        (-(D)-30.0/360.0*6.283185307179)
#define DQ_AI255_COIL_Y_r(D)        (-(D)-150.0/360.0*6.283185307179)
#define DQ_AI255_COIL_Z_r(D)        (-(D)-270.0/360.0*6.283185307179)

#define AI255_CHANONLY_MASK         (0x1)
#define AI255_GAIN_MASK             (0x3)

#define DQ_AI255_CHANONLY_MASK      (0x1)
#define DQ_AI255_GAIN_MASK          (0x3)

#define DQ_AI255_CALCHAN            (8)

#define DQ_AI255_NAMELEN            (20)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)
// channel names
typedef struct {
    char cname[DQ_AI255_CHAN][DQ_AI255_NAMELEN];
} DQCNAMES_255_, *pDQCNAMES_255_;

// specific device structure - calibration values
typedef struct {
    // Final gain and offset
    uint32 u_gain[DQ_AI255_CHAN];
    uint32 u_offs[DQ_AI255_CHAN];

    // input A
    uint16 voff_i_a[DQ_AI255_CHAN];
    uint16 gain_i_a[DQ_AI255_CHAN];

    // input B
    uint16 voff_i_b[DQ_AI255_CHAN];
    uint16 gain_i_b[DQ_AI255_CHAN];

    // input C
    uint16 voff_i_c[DQ_AI255_CHAN];
    uint16 gain_i_c[DQ_AI255_CHAN];

    // input D
    uint16 voff_i_d[DQ_AI255_CHAN];
    uint16 gain_i_d[DQ_AI255_CHAN];

    // output A
    uint16 voff_o_a[DQ_AI255_CHAN];
    uint16 gain_o_a[DQ_AI255_CHAN];

    // output B
    uint16 voff_o_b[DQ_AI255_CHAN];
    uint16 gain_o_b[DQ_AI255_CHAN];

    // output C
    uint16 voff_o_c[DQ_AI255_CHAN];
    uint16 gain_o_c[DQ_AI255_CHAN];

    // output D
    uint16 voff_o_d[DQ_AI255_CHAN];
    uint16 gain_o_d[DQ_AI255_CHAN];

} DQCALCHAN_255_, *pDQCALCHAN_255_;

typedef struct {
    DQCALCHAN_255_ cal;

    // input A / gain 2,5,10
    uint16 voff_i_a[DQ_AI255_CHAN][DQ_AI255_GAINS];
    uint16 gain_i_a[DQ_AI255_CHAN][DQ_AI255_GAINS];

    // input B / gain 2,5,10
    uint16 voff_i_b[DQ_AI255_CHAN][DQ_AI255_GAINS];
    uint16 gain_i_b[DQ_AI255_CHAN][DQ_AI255_GAINS];

    // input C / gain 2,5,10
    uint16 voff_i_c[DQ_AI255_CHAN][DQ_AI255_GAINS];
    uint16 gain_i_c[DQ_AI255_CHAN][DQ_AI255_GAINS];

    // input D / gain 2,5,10
    uint16 voff_i_d[DQ_AI255_CHAN][DQ_AI255_GAINS];
    uint16 gain_i_d[DQ_AI255_CHAN][DQ_AI255_GAINS];

} DQCALSET_255_, *pDQCALSET_255_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AI255_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_255_, *pDQOPMODEPRM_255_;

typedef struct {                    // Current value (hex) of the calibration shunt from internal monitor:
    uint16 offs [DQ_AI255_CHAN][DQ_AI256_PADC_CHAN];
    uint16 gain [DQ_AI255_CHAN][DQ_AI256_PADC_CHAN];
    uint16 pdac_ffff[DQ_AI255_CHAN];// approx 9443
    uint16 pdac_0000[DQ_AI255_CHAN];// approx 30616
    uint32 reserved[4];
} DQCALSET_256_, *pDQCALSET_256_;

typedef struct {
    uint32 oclimit[DQ_AI255_CHAN];  // over-current limit
    int32  rdcnt;
    uint32 adc_cfg[DQ_AI256_PADC_CHAN];
} DQOPMODEPRM_256_, *pDQOPMODEPRM_256_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_255_ calset;
    DQOPMODEPRM_255_ opmodeprm;
    DQCNAMES_255_ cname;
    DQPRMFLAGS eeflags;
    DQCALSET_256_ cal256;
    DQOPMODEPRM_256_ opmodeprm256;
} DEVEEPROM_255_, *pDEVEEPROM_255_;
#pragma pack()

// for DQL_IOCTL255_GETWF
typedef struct {
    uint32 min_lvl;                 // waveform minimum
    uint32 max_lvl;                 // waveform maximum
    uint32 sum;                     // average accumulated sum (Sa...Sd)
    uint32 cal;                     // calibrated angle
    uint32 raw;                     // raw angle
    uint32 zc0;                     // zero-crossing 0
    uint32 zc1;                     // zero-crossing 1
    uint32 zc0_var;                 // variation of zc0
    uint32 zc1_var;                 // variation of zc1
    uint32 cal_var;                 // variation of the angle position
    uint32 clk_frq;                 // selected AIn/AOut clock
    uint32 wf_phase;                // phase in 15.15ns clocks
    float ampl;                     // waveform amplitude
    float freq;                     // waveform frequency
    float offs;                     // waveform offset
} WFPRM_255, *pWFPRM_255;

typedef struct {
    uint32 changain;                // channel and gain
    uint32 zero;                    // zero level, 0 == default (0x8000)
    uint32 clock;                   // A/D rate, 0 == maximum rate
    uint32 uzb;                     // TRUE == use ZC on channel B
    uint32 uaz;                     // TRUE == auto-zero
    uint32 s_e;                     // if divider is set (not-zero) , use Sa/Se
    uint32 period_ms;               // maximum expected waveform period, affect function return time
    uint32 phase_meas;              // channel to use as reference (exc.input)
} WFMEASURE_255, *pWFMEASURE_255;

#define DQ_AI255_WFAVG              (16)

/* structure for AI-256 GETPARAM data */
typedef struct {
    int32 adcsts;                   // Reports combined status of the ADC subsystem
    int32 rdcnt;                    // Current value of the consecutive read counter setting
    int32 adccfg[DQ_AI256_PADC_CHAN];
} DQAI256DATAIN, *pDQAI256DATAIN;

/* structure for SETPARAM data (WRITE)*/
typedef struct {
    int32 cfgmask;                  // What parameters to set
    int32 cfg;                      // Set disconnection mode
    int32 portocm;                  // Set over-current interrupt mask
    int32 portocv0;                 // Set over-current limit value, chan0
    int32 portocv1;                 // Set over-current limit value, chan1
    int32 rdcnt;                    // Set number of "failed" samples prior to breaker engagement
    int32 adccfg[DQ_AI256_PADC_CHAN];  // "User" ADC conversion control words for ADC inputs
    int32 reserved[2];              // reserved for future use
} DQAI256DATAOUT, *pDQAI256DATAOUT;

// bit defines for the contents of DQAI256DATAOUT.cfgmask
#define DQAI256_CFGSET              (1L<<0)     // =1 if "cfg" contains valid data
#define DQAI256_PORTOCMSET          (1L<<1)     // =1 if "portocm" contains valid data
#define DQAI256_PORTOCV0SET         (1L<<2)     // =1 if "portocv0" contains valid data
#define DQAI256_PORTOCV1SET         (1L<<3)     // =1 if "portocv1" contains valid data
#define DQAI256_RDCNTSET            (1L<<4)     // =1 if "rdcnt" contains valid data
#define DQAI256_ADCCFG0SET          (1L<<5)     // =1 if "adccfg[0]" contains valid data
#define DQAI256_ADCCFG1SET          (1L<<6)     // =1 if "adccfg[1]" contains valid data
#define DQAI256_ADCCFG2SET          (1L<<7)     // =1 if "adccfg[2]" contains valid data
#define DQAI256_ADCCFG3SET          (1L<<8)     // =1 if "adccfg[3]" contains valid data


#define DQ_DMM261_CHAN              (16)        // # of working channels
                                                // Use DqAdv261GetPgaStatus() to access Pga Status in programs that use ACB.
                                                // Use the following offsets to make channel numbers for accessing PGA status
                                                // and data with pt/pt mode (DqAdv261Read) or with mapped modes.
#define DQ_DMM261_GUARDIAN_CHAN     (5)         // number of guardian channels, 4 voltages and temperature
#define DQ_DMM261_PGA_STATUS_OFFSET (46)        // starting channel number for PGA status (2 addresses)
#define DQ_DMM261_PGA_DATA_OFFSET   (48)        // starting channel number for PGA data (DQ_DMM261_PGAERR_ bits) (16 addresses)
#define DQ_DMM261_CL_SIZE           (27)

#define DQ_DMM261_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_DMM261_BASE              (BUS_FREQUENCY)     // 66MHz base frequency

#define DQ_DMM261_MODESCAN          (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_DMM261_MODEFIFO          (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_DMM261_MODECONT          (DQ_FIFO_MODECONT)  // continuous acquisition

// define channel list (CL) channel numbers for constructing CL used by DqAdv261Read() for point by point or
// used by DqRtDmapAddChannel for setting up RtDMap
// start 'user voltage channels'
#define DQ_DMM261_VDC_CAL_CH        (0x00)      // DCV calibrated voltage with or without FIR filtering
#define DQ_DMM261_VDC_SAVG_CH       (0x01)      // DCV reading using 'special averaging mode'
#define DQ_DMM261_VDC_AVG_PER_CH    (0x02)      // DCV averaged value over "n_ac_periods/n_ac_uS" V
#define DQ_DMM261_VDC_AVG_DCS_CH    (0x03)      // DCV averaged value over "DMM261_ADCV_DCS" V
//#define DQ_DMM261_VDC_VREF_CH     (0x04)      // DCV 0.0248756V reference on INP2, internal test. only active when it's the only user voltage channel in CL
#define DQ_DMM261_VAC_RMS_CH        (0x05)      // AC RMS voltage value
#define DQ_DMM261_VAC_SAVG_CH       (0x06)      // AC RMS reading using 'special averaging mode'
#define DQ_DMM261_VAC_MIN_CH        (0x07)      // ACV peak-  Minimum voltage value within data during the last AC period
#define DQ_DMM261_VAC_MAX_CH        (0x08)      // ACV peak+  Maximum voltage value within data during the last AC period
#define DQ_DMM261_VAC_FREQ_CH       (0x09)      // last detected AC voltage frequency,  range(gain) ignored
// end  'user voltage channels'

// start 'user current channels'
#define DQ_DMM261_IDC_CAL_CH        (0x10)      // IDC calibrated current with or without FIR filtering
#define DQ_DMM261_IDC_SAVG_CH       (0x11)      // IDC current reading using 'special averaging mode'
#define DQ_DMM261_IDC_AVG_PER_CH    (0x12)      // DC averaged value over "n_ac_periods/n_ac_uS" I
#define DQ_DMM261_IDC_AVG_DCS_CH    (0x13)      // DC averaged value over "DMM261_ADCI_DCS" I
//#define DQ_DMM261_IDC_VREF_CH     (0x14)      // DC 0.0248756V reference on INP2, internal test. only active when it's the only user current channel in CL
#define DQ_DMM261_IAC_RMS_CH        (0x15)      // AC RMS current value
#define DQ_DMM261_IAC_SAVG_CH       (0x16)      // AC RMS current using 'special averaging mode'
#define DQ_DMM261_IAC_MIN_CH        (0x17)      // ACI peak-  Minimum current value within data during the average period
#define DQ_DMM261_IAC_MAX_CH        (0x18)      // ACI Peak+  Maximum current value within data during the average period
#define DQ_DMM261_IAC_FREQ_CH       (0x19)      // last detected AC current frequency, range(gain) ignored
// end 'user current channels'

// start 'guardian and calibration channels'
#define DQ_DMM261_GIDC_CH           (0x20)      // always-on current monitor as DC, for shunt protection
#define DQ_DMM261_GIAC_CH           (0x21)      // always-on current monitor w/rms conversion, for protection and power measurement
#define DQ_DMM261_GV0_CH            (0x22)      // -17.5 Volt supply
#define DQ_DMM261_GV1_CH            (0x23)      // +17.5 Volt supply     .4375
#define DQ_DMM261_GV2_CH            (0x24)      // -5.5 Volt supply
#define DQ_DMM261_GV3_CH            (0x25)      // +5.5 Volt supply      .1375
#define DQ_DMM261_TEMP_CH           (0x26)      // degrees C    temperature in the Guardian ADC IC
#define DQ_DMM261_GIAC_MIN_CH       (0x27)      // always-on current monitor, -peak current
#define DQ_DMM261_GIAC_MAX_CH       (0x28)      // always-on current monitor, +peak current
// start 'reference voltage channels'  for test and calibration purposes only
#define DQ_DMM261_VDC_VREF_CH       (0x04)      // DCV 0.0248756V reference on INP2, internal test. only active when it's the only user voltage channel in CL
#define DQ_DMM261_IDC_VREF_CH       (0x14)      // DCI 0.0248756V reference on INP2, internal test. only active when it's the only user current channel in CL
#define DQ_DMM261_VREF_5V           (0x38)      // used for save of actual 5V reference at calibration time
#define DQ_DMM261_VREF_25MV         (0x39)      // used for save of actual 25mV references at calibration time
// end  'reference voltage channels'
// end 'guardian and calibration channels'

#define DQ_DMM261_READY_STATUS      (0x3F)      // this channel number gets the ready status

// start 'resistance channels'
#define DQ_DMM261_RES_CH            (0x30)      // resistance measurement result
#define DQ_DMM261_RREF_CH           (0x31)      // resistance reference   result (test purposes only)
#define DQ_DMM261_R_IEXC_CH         (0x32)      // adjust res excitation (test and calibration purposes only)
// end 'resistance channels'

#define DQ_DMM261_R_RANGES          (8)         // number of resistance ranges
//      2 wire resistance ranges for DqAdv261SetResRange() uint32 range
#define DQ_DMM261_R_2W_10           (0x20)
#define DQ_DMM261_R_2W_100          (0x21)
#define DQ_DMM261_R_2W_1K           (0x22)
#define DQ_DMM261_R_2W_10K          (0x23)
#define DQ_DMM261_R_2W_100K         (0x24)
#define DQ_DMM261_R_2W_1M           (0x25)
#define DQ_DMM261_R_2W_10M          (0x26)
#define DQ_DMM261_R_2W_100M         (0x27)
#define DQ_DMM261_R_2W_AUTORANGE    (0x2F)      // ex: clist[x] = DQ_LNCL_CHANRANGE(DQ_DMM261_RES_CH,DQ_DMM261_R_2W_AUTO);

//      4 wire resistance ranges for DqAdv261SetResRange() uint32 range
#define DQ_DMM261_R_4W_10           (0x40)
#define DQ_DMM261_R_4W_100          (0x41)
#define DQ_DMM261_R_4W_1K           (0x42)
#define DQ_DMM261_R_4W_10K          (0x43)
#define DQ_DMM261_R_4W_100K         (0x44)
#define DQ_DMM261_R_4W_1M           (0x45)
#define DQ_DMM261_R_4W_10M          (0x46)
#define DQ_DMM261_R_4W_100M         (DQ_DMM261_R_2W_100M)      // we can only use 2 wire connection above 10M
#define DQ_DMM261_R_4W_AUTORANGE    (0x4F)      // ex: clist[x] = DQ_LNCL_CHANRANGE(DQ_DMM261_RES_CH,DQ_DMM261_R_4W_AUTO);

                                    /// constants to setup shunt protection system
#define DQ_DMM261_GI_STEPS          (4095)
#define DQ_DMM261_GI_SPAN_MA        ((uint32)(DQ_DMM261_GI_SPAN * 1000.0))  // mADC

// default values for always-on shunt protection
#define DQ_DMM261_GI_ILIMIT         (55)        // mADC
#define DQ_DMM261_GI_HYST           (30)
#define DQ_DMM261_GI_ILIMIT_AC      (30)        // mAAC
#define DQ_DMM261_GI_HYST_AC        (30)

#define DQ_DMM261_DEF_10K_REF_X100  (1000000)   // ohms X 100, default value of 10K reference resistor
#define DQ_DMM261_DEF_10K           (10000.0)   // ohms, default value of 10K reference resistor
#define DQ_DMM261_DEF_100M          (10000000.0)// ohms, default value of 100Meg RN1 resistor
#define DQ_DMM261_DEF_RN1_RES       (10000000)  // ohms, default end to end resistance of the RN1 divider

//  data format for bData returned by DqAdv261Read()
// All 32 bits of bData are used for timestamp when channel number = DQ_LNCL_TIMESTAMP, otherwise as follows:
#define DQ_DMM261_NEW_BDATA         (1L<<31)    // bit in DqAdv261Read() *bData that signals when fresh ADC data is available
#define DQ_DMM261_RMS_VALID         (1L<<30)    // bit in DqAdv261Read() *bData that indicates valid AC zero crossings
#define DQ_DMM261_RES_NOPEN         (1L<<30)    // bit in DqAdv261Read() *bData that signals when no resistance continuity is detected
#define DQ_DMM261_AC_CLIP           (1L<<29)    // bit in DqAdv261Read() *bData that indicates when AC input is clipping
#define DQ_DMM261_OVER_RANGE        (1L<<29)    // bit in DqAdv261Read() *bData that indicates when input is over-range
#define DQ_DMM261_V_X100_RANGE      (1L<<28)    // bit in DqAdv261Read() *bData that indicates DC voltage high range is active
#define DQ_DMM261_I_2A_RANGE        (1L<<28)    // bit in DqAdv261Read() *bData =1 0.1ohm shunt is in use, =1 res meas ON
// bits 27..24
#define DQ_DMM261_BDATA_AUTORANGE   (1L<<27)    // DqAdv261Read() tests this bit, 1=autorange mode
#define DQ_DMM261_BDATA_RES_100M    (7L<<24)    // resistance 100M range for autorange
#define DQ_DMM261_AUTOIDX2          (1L<<26)
#define DQ_DMM261_AUTOIDX1          (1L<<25)
#define DQ_DMM261_AUTOIDX0          (1L<<24)    // autorange index ls bit
#define DQ_DMM261_AUTOIDX(N)        (((N)>>24) & 0x07)

// data format for status returned by DqAdv261Read()
#define DQ_DMM261_READ_STS_DCV_SETTLE_WARN  (1L << 3)   // DC voltage data may still be settling
#define DQ_DMM261_READ_STS_PROT_RANGE       (1L << 2)   // protection has previously tripped, but layer has reconfigured for
                                                        // safe range to wait for data to reenter user range. once data is within
                                                        // user range, layer will reconfigure to user range
#define DQ_DMM261_READ_STS_PROT_TRIP        (1L << 1)   // protection is currently tripped, layer may try to reconfigure if not in max range
#define DQ_DMM261_READ_STS_PROT_TRIP_MAX    (1L << 0)   // protection tripped in max range, layer will not try to reconfigure

#define DQ_DMM261_ADCDATAE          (23)        // 24-bits of ADC data msb, end
#define DQ_DMM261_ADCDATAS          (0)         //                     lsb, start

#define DQ_DMM261_V_X100_MULT       (100.0)
#define DQ_DMM261_I_A_RANGE_R       (0.10)      // shunt ohms r138
#define DQ_DMM261_I_MA_RANGE_R      (10.10)     // shunt ohms r134 + r138
#define DQ_DMM261_RATIO_IEXC        (DQ_DMM261_I_MA_RANGE_R / DQ_DMM261_I_A_RANGE_R)  // = 101
#define DQ_DMM261_ACV_SCALER        (998000.0 / 33000.0 + 1.0)  // approx (31.24242)
#define DQ_DMM261_ADDL_SCALE_FACTOR (1.375)     // 1 3/8.   gain factor added by setting pga280 reg0 bit7

#define DQ_DMM261_SPAN_V            (40.0)      // +/- 20V,  theoretical limit of DQ_DMM261_RANGE_12_5
#define DQ_DMM261_SPAN_H_24         (0xFFFFFF)

#define DQ_DMM261_STEP_V            (DQ_DMM261_SPAN_V/DQ_DMM261_SPAN_H_24) // G0  +/-15V (+/-20V scaling) 330AC
#define DQ_DMM261_STEP_2_V          (DQ_DMM261_STEP_V/2.0)              // G1  +/-10V
#define DQ_DMM261_STEP_4_V          (DQ_DMM261_STEP_V/4.0)              // G2  5                          110AC
#define DQ_DMM261_STEP_8_V          (DQ_DMM261_STEP_V/8.0)              // G3  2.5
#define DQ_DMM261_STEP_16_V         (DQ_DMM261_STEP_V/16.0)             // G4  1.25
#define DQ_DMM261_STEP_32_V         (DQ_DMM261_STEP_V/32.0)             // G5  0.625                       13AC
#define DQ_DMM261_STEP_64_V         (DQ_DMM261_STEP_V/64.0)             // G6  0.3125
#define DQ_DMM261_STEP_128_V        (DQ_DMM261_STEP_V/128.0)            // G7  0.15625
#define DQ_DMM261_STEP_256_V        (DQ_DMM261_STEP_V/256.0)            // G8  0.078..                     1.7AC
#define DQ_DMM261_STEP_512_V        (DQ_DMM261_STEP_V/512.0)            // G9  0.039..                     0.8AC

#define DQ_DMM261_OFFSET_V          (DQ_DMM261_SPAN_V/2.0)
#define DQ_DMM261_OFFSET_2_V        (DQ_DMM261_OFFSET_V/2.0)
#define DQ_DMM261_OFFSET_4_V        (DQ_DMM261_OFFSET_V/4.0)
#define DQ_DMM261_OFFSET_8_V        (DQ_DMM261_OFFSET_V/8.0)
#define DQ_DMM261_OFFSET_16_V       (DQ_DMM261_OFFSET_V/16.0)
#define DQ_DMM261_OFFSET_32_V       (DQ_DMM261_OFFSET_V/32.0)
#define DQ_DMM261_OFFSET_64_V       (DQ_DMM261_OFFSET_V/64.0)
#define DQ_DMM261_OFFSET_128_V      (DQ_DMM261_OFFSET_V/128.0)
#define DQ_DMM261_OFFSET_256_V      (DQ_DMM261_OFFSET_V/256.0)
#define DQ_DMM261_OFFSET_512_V      (DQ_DMM261_OFFSET_V/512.0)

#define DQ_DMM261_I_MIN_GAIN_A      (16.0)
#define DQ_DMM261_I_MIN_GAIN_MA     (2.0)
#define DQ_DMM261_SPAN_I_A          (DQ_DMM261_V_REFERENCE * 2.0 / DQ_DMM261_I_MIN_GAIN_A )        // +/- 3.125A =6.250
#define DQ_DMM261_SPAN_I_MA         (DQ_DMM261_V_REFERENCE * 2.0 / DQ_DMM261_I_MIN_GAIN_MA )        //

// mA shunt = 10
#define DQ_DMM261_STEP_I_A_0        (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_A_RANGE_R)                                      // range setting 0
#define DQ_DMM261_STEP_I_A_1        (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_A_RANGE_R /2.0 )                                // range setting 1
#define DQ_DMM261_STEP_I_A_2        (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_A_RANGE_R / 8.0 / DQ_DMM261_ADDL_SCALE_FACTOR)  // range setting 2
#define DQ_DMM261_STEP_I_MA_2       (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_MA_RANGE_R * 8.0 )         // range setting 2
#define DQ_DMM261_STEP_I_MA_3       (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_MA_RANGE_R /* / DQ_DMM261_ADDL_SCALE_FACTOR*/)  // range setting 3
#define DQ_DMM261_STEP_I_MA_3_AC    (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_MA_RANGE_R /* / DQ_DMM261_ADDL_SCALE_FACTOR*/)  // range setting 3 for AC current
#define DQ_DMM261_STEP_I_MA_4       (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_MA_RANGE_R /8.0 / DQ_DMM261_ADDL_SCALE_FACTOR)  // range setting 4
#define DQ_DMM261_STEP_I_MA_4_AC    (DQ_DMM261_SPAN_I_A/DQ_DMM261_SPAN_H_24 / DQ_DMM261_I_MA_RANGE_R /8.0 / DQ_DMM261_ADDL_SCALE_FACTOR)  // range setting 4 for AC current

#define DQ_DMM261_OFFSET_I_A_0      (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_A_RANGE_R)               // range setting 0
#define DQ_DMM261_OFFSET_I_A_1      (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_A_RANGE_R /2.0)                                  // range setting 1
#define DQ_DMM261_OFFSET_I_A_2      (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_A_RANGE_R /8.0 / DQ_DMM261_ADDL_SCALE_FACTOR)// range setting 2
#define DQ_DMM261_OFFSET_I_MA_2     (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_MA_RANGE_R *8.0 )// range setting 2
#define DQ_DMM261_OFFSET_I_MA_3     (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_MA_RANGE_R/* / DQ_DMM261_ADDL_SCALE_FACTOR*/)  // range setting 3
#define DQ_DMM261_OFFSET_I_MA_3_AC  (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_MA_RANGE_R/* / DQ_DMM261_ADDL_SCALE_FACTOR*/)  // range setting 3 for AC current
#define DQ_DMM261_OFFSET_I_MA_4     (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_MA_RANGE_R /8.0 / DQ_DMM261_ADDL_SCALE_FACTOR)  // range setting 4
#define DQ_DMM261_OFFSET_I_MA_4_AC  (DQ_DMM261_SPAN_I_A /2.0 / DQ_DMM261_I_MA_RANGE_R /8.0 / DQ_DMM261_ADDL_SCALE_FACTOR)  // range setting for AC current4


// DC current -   gain settings
#define DQ_DMM261_AUTORANGE_ADC     (0x0F)      // ex: clist[x] = DQ_LNCL_CHANRANGE(DQ_DMM261_IDC_SAVG_CH,DQ_DMM261_AUTORANGE_ADC);
#define DQ_DMM261_RANGE_3_ADC       (0)         // Range 0   +-3.0Amps DC
#define DQ_DMM261_RANGE_1_5_ADC     (1)         // Range 1   +-1.5Amps DC
#define DQ_DMM261_RANGE_0_150_ADC   (2)         // Range 2   +-0.150Amps DC
#define DQ_DMM261_RANGE_0_015_ADC   (3)         // Range 3   +-0.015Amps DC
#define DQ_DMM261_RANGE_0_0015_ADC  (4)         // Range 4   +-0.0015Amps DC
#define DQ_DMM261_RANGE_VREF_25MV   (5)         // Range for 0.0248756V reference

// AC current -    gain settings
#define DQ_DMM261_AUTORANGE_AAC     (0x0F)      // use : clist[x] = DQ_LNCL_CHANRANGE(DQ_DMM261_IAC_SAVG_CH,DQ_DMM261_IAC_AUTORANGE);
#define DQ_DMM261_RANGE_2_AAC       (0)         // Range 0   2.0Amps  AC sine       6.24App max before clipping
#define DQ_DMM261_RANGE_1_AAC       (1)         // Range 1   1.1Amps   AC sine      3.12App max before clipping
#define DQ_DMM261_RANGE_0_150_AAC   (2)         // Range 2   0.150Amps  AC sine     0.568App max before clipping
#define DQ_DMM261_RANGE_0_015_AAC   (3)         // Range 3   0.015Amps  AC sine     0.048App max before clipping    10 ohm shunt
#define DQ_DMM261_RANGE_0_0015_AAC  (4)         // Range 4   0.0015Amps  AC sine    0.00452App max before clipping  10 ohm shunt
#define DQ_DMM261_I_VREF_LOC        (5)         // internal lookup value for vref testing
#define DQ_DMM261_IDC_RANGES        (11)        // 2 * 5 user current ranges plus 1 extra at end for the 0.0248756V reference
#define DQ_DMM261_IAC_RANGES        (10)        // 2 * 5 user current ranges

#define DQ_DMM261_VRANGES           (17)        // Total number of main voltage gains, includes vref
#define DQ_DMM261_RES_RANGES        (DQ_DMM261_R_RANGES)
#define DQ_DMM261_RDRANGES          (DQ_DMM261_R_RANGES)         // reserved space

// DC Voltage range(nee gain) settings for AI-261. channel list gets these values merged with 'voltage  channels' the  using the DQ_LNCL_RANGE() macro
#define DQ_DMM261_AUTORANGE_VDC     (0x0F)
#define DQ_DMM261_RANGE_500         (0x02)      // +-500V
#define DQ_DMM261_300VDC            (0x02)
#define DQ_DMM261_RANGE_125         (0x04)      // +-125V
#define DQ_DMM261_100VDC            (0x04)
#define DQ_DMM261_RANGE_12_5        (0x10)      // +-12.5V
#define DQ_DMM261_10VDC             (0x10)
#define DQ_DMM261_RANGE_1_25        (0x14)      // +-1.25V
#define DQ_DMM261_1VDC              (0x14)
#define DQ_DMM261_RANGE_0_15625     (0x17)      // +-0.15625V
#define DQ_DMM261_0_1VDC            (0x17)
#define DQ_DMM261_RANGE_0_0390625   (0x19)      // +-0.0390625V
#define DQ_DMM261_0_030VDC          (0x19)
#define DQ_DMM261_VDC_RANGES        (18 + 1)    // 18 possible DC voltage ranges plus 1 extra at end for the 0.0248756V reference
#define DQ_DMM261_VAC_RANGES        (12)        // 12 possible AC voltage ranges

#define DQ_DMM261_AUTORANGE_VAC     (0x0F)
#define DQ_DMM261_AC_RANGE_330      (0x20)      //~              275Vrms sine, 390Vrms square
#define DQ_DMM261_300VAC            (0x20)
#define DQ_DMM261_AC_RANGE_110      (0x22)      //~  312.42Vpp 110.4Vrms sine, 156Vrms square
#define DQ_DMM261_100VAC            (0x22)
#define DQ_DMM261_AC_RANGE_13       (0x25)      //~  39.052Vpp 17.114Vrms sine, 19.5Vrms square
#define DQ_DMM261_10VAC             (0x25)
#define DQ_DMM261_AC_RANGE_1_7      (0x28)      //~  4.881Vpp   1.725Vrms sine, 2.4Vrms square
#define DQ_DMM261_1_5VAC            (0x28)
#define DQ_DMM261_AC_RANGE_0_8      (0x29)      //~  2.440Vpp    0.85Vrms sine, 1.2Vrms square
#define DQ_DMM261_0_5VAC            (0x29)


#define DQ_DMM261_V_REFERENCE       (5.0)       // span at input to ADC at G=1
#define DQ_DMM261_GVT_CHAN          (5)         // GVT channel count, 4 voltages and 1 temperature
#define DQ_DMM261_GVT_SPAN          (DQ_DMM261_V_REFERENCE * DQ_DMM261_V_SCALER)    // V user span
#define DQ_DMM261_GVT_OFFSET        (DQ_DMM261_GVT_SPAN/2.0)
#define DQ_DMM261_GVT_STEP          (DQ_DMM261_GVT_SPAN/ 65535.0)  // approx 3.1mV/step
#define DQ_DMM261_V_SCALER          ((20000.0/499.0)+1.0)  // voltage scaling factor= ~41.08, ADC0,ADC1,ADC2,ADC3

                                    // LTC2486 PTAT TempCo =93.5uV/degC = 0.0000935
#define DQ_DMM261_T_SLOPE           (0.0000935 / (DQ_DMM261_V_REFERENCE / 65535.0)) // ADC counts per deg C, ADC4
#define DQ_DMM261_T_OFFSET          (273.15)    // Kelvin to deg C
#define DQ_DMM261_DEF_24_OFFSET_CAL (0)         // hardware is a 24-bits signed value, software can use 32-bit signed, bits 31:24 are ignored
#define DQ_DMM261_DEF_24_GAIN_CAL   (0x800000)  // 24-bits unsigned, 0x800000 is G=1, 0xFFFFFF is G=1.999999
#define DQ_DMM261_DEF_24_CAL_LIMIT  (0x4000)    // 24-bits, arbitrary value for component tolerance check
#define DQ_DMM261_DEF_24_MSB        (1L<<23)    //
#define DQ_DMM261_DEF_23_LSB_MASK   (0x7FFFFF)
#define DQ_DMM261_DEF_16_OFFSET_CAL (0)         // 16-bits
#define DQ_DMM261_DEF_16_GAIN_CAL   (0x8000)    // 16-bits
#define DQ_DMM261_DEF_16_CAL_LIMIT  (0x400)     // 16-bits
#define DQ_DMM261_DEF_12_OFFSET_CAL (0)         // 12-bits
#define DQ_DMM261_DEF_12_GAIN_CAL   (0x800)     // 12-bits
#define DQ_DMM261_DEF_12_CAL_LIMIT  (0x40)      // 12-bits
#define DQ_DMM261_GMAX_OFF_CAL_DEV  (0x1000)    //
#define DQ_DMM261_GMAX_GAIN_CAL_DEV (3277)
#define DQ_DMM261_MIN_ADC_WAIT      (160)       // minimum # of milliseconds between ADC reads
#define DQ_DMM261_ADC_EOC           (1L<<18)    // guardian
#define DQ_DMM261_ADC_SIG           (1L<<16)    // guardian
#define DQ_DMM261_ADC_MSB           (1L<<15)    // guardian
#define DQ_DMM261_MAX_AUTO_TRIES    (25)        // Maximum number of attempts to calibrate current DAC
#define DQ_DMM261_REXC_MIN          (0x81b089)  // Min acceptable value for R excitation auto calibration 0x81b089 = 6.6V
#define DQ_DMM261_REXC_MAX          (0x824dd2)  // Max acceptable value for R excitation auto calibration 0x824dd2 = 9.0V
#define DQ_DMM261_REXC_SETPOINT     (((DQ_DMM261_REXC_MAX - DQ_DMM261_REXC_MIN) / 2) + DQ_DMM261_REXC_MIN)    // Mid point between min and max acceptable value
#define DQ_DMM261_CAL_DAC_STEP      (40)        // The amount to change the current dac between each cal attempt
#define DQ_DMM261_V_DAC_STEP        (872)       // The number of LSBs voltage reading changes per 1 LSB change on DAC, value was calculated through testing
#define DQ_DMM261_REXC_CAL_START    (0x70)      // Start value for resistance excitation auto calibration

#define DQ_DMM261_DEF_LIMIT_1247    (0x8000)    // placeholder,tbd

#define DQ_DMM261_GI_SPAN           (6.24)      // guardian current A , input range is +-3.12A, r146 = 7.05K ohms
#define DQ_DMM261_GI_OFFSET         (DQ_DMM261_GI_SPAN/2.0)
#define DQ_DMM261_GI_STEP           (DQ_DMM261_GI_SPAN/(double)0xfff)
#define DQ_DMM261_GIAC_STEP         (DQ_DMM261_GI_SPAN/(double)0xffffff)

             // DqAdv261SetConfig() item parameter, DQ_DMM261_MODE_ and DQ_DMM261_CONFIG_
// note: mode defines are no longer needed. The firmware will set the correct measurement mode based upon the channel number
#define DQ_DMM261_MODE_R_MEAS       (0x30)      // code to set resistance measurement mode used internally by DqAdv261SetResRange
#define DQ_DMM261_MODE_RES_MEAS     (0x30)      // code to set resistance measurement mode used internally by DqAdv261SetResRange
#define DQ_DMM261_MODE_GUARDIAN     (0x31)      // code to set guardian measurement mode
#define DQ_DMM261_MODE_STANDBY      (0x32)      // code to set standby mode, not implemented
#define DQ_DMM261_MODE_DCV_MEAS     (0x33)      // code to set DC voltage measurement mode
#define DQ_DMM261_MODE_ACV_MEAS     (0x34)      // code to set AC voltage measurement mode
#define DQ_DMM261_MODE_DCI_MEAS     (0x35)      // code to set DC current measurement mode
#define DQ_DMM261_MODE_ACI_MEAS     (0x36)      // code to set AC current measurement mode
#define DQ_DMM261_MODE_DCP_MEAS     (0x37)      // code to set DC power measurement mode
#define DQ_DMM261_MODE_ACP_MEAS     (0x38)      // code to set AC power measurement mode

#define DQ_DMM261_CONFIG_RIDAC      (0x51)      // code to set resistance mode current source. for calibration purposes only.
#define DQ_DMM261_CONFIG_V_ZC       (0x54)      // code to set AC voltage zero crossing detect # of samples
#define DQ_DMM261_CONFIG_V_ZL       (0x55)      // code to set AC voltage zero crossing level (sets explict ZC mode and 16-bit level)
#define DQ_DMM261_CONFIG_V_ZC_MODE  (0x5B)      // code to set AC voltage zero crossing autozero mode (ZMM, ZRMS, ZDC)
#define DQ_DMM261_CONFIG_I_ZC       (0x56)      // code to set AC current zero crossing detect # of samples
#define DQ_DMM261_CONFIG_I_ZL       (0x57)      // code to set AC current zero crossing level (sets explict ZC mode and 16-bit level)
#define DQ_DMM261_CONFIG_I_ZC_MODE  (0x5C)      // code to set AC current zero crossing autozero mode (ZMM, ZRMS, ZDC)
#define DQ_DMM261_CONFIG_VREF_OVEN  (0x58)      // code to set voltage reference heater
#define DQ_DMM261_CONFIG_LINE_HZ    (0x59)      // code to set AC line frequency   'value' range 25..450 Hz, default = 60Hz
#define DQ_DMM261_CONFIG_RD_CYCLES  (0x5A)      // code to set number of line cycles per read  aka:NPLC  'value' = # cycles
#define DQ_DMM261_CONFIG_V_FIR      (0x5D)      // set FIR to OFF or enable 1 of the 4 filter profiles
#define DQ_DMM261_CONFIG_I_FIR      (0x5F)      // set FIR to OFF or enable 1 of the 4 filter profiles
#define DQ_DMM261_CONFIG_FIR_CUTOFF (0x61)      // get FIR cutoff freqs, , '*flags' points to a uint32[8] array
#define DQ_DMM261_CONFIG_I_RESET    (0x62)      // reset the current range after an over-current range change
#define DQ_DMM261_CONFIG_V_PK_AVG   (0x63)      // code to set moving average of AC voltage +/-peak readings
#define DQ_DMM261_CONFIG_I_PK_AVG   (0x64)      // code to set moving average of AC current +/-peak readings
#define DQ_DMM261_CONFIG_DISCON_TIME (0x66)     // time in seconds after which inputs are disconnected

    // DqAdv261SetConfig 'value' parameter
    // when 'item' = measurement mode (DQ_DMM261_MODE_DCV_MEAS ... DQ_DMM261_MODE_ACI_MEAS)
#define DQ_DMM261_MEAS_NORMAL       (0x00)      // normal measurement
#define DQ_DMM261_MEAS_AZERO        (0x01)      // measure ground reference in auto-zero mode

    // DqAdv261SetConfig 'value' parameter
    // when 'item' = DQ_DMM261_CONFIG_V_ZC or DQ_DMM261_CONFIG_I_ZC
#define DQ_DMM261_ZCC_1_SAMPL       (0)
#define DQ_DMM261_ZCC_2_SAMPL       (1)
#define DQ_DMM261_ZCC_4_SAMPL       (2)
#define DQ_DMM261_ZCC_8_SAMPL       (3)
#define DQ_DMM261_ZCC_16_SAMPL      (4)
#define DQ_DMM261_ZCC_32_SAMPL      (5)
#define DQ_DMM261_ZCC_64_SAMPL      (6)
#define DQ_DMM261_ZCC_128_SAMPL     (7)
#define DQ_DMM261_ZCC_256_SAMPL     (8)

// defines for value parameter of DqAdv261SetConfig when item = DQ_DMM261_CONFIG_V_ZC_MODE or DQ_DMM261_CONFIG_I_ZC_MODE
// auto-zero of zero crossing (ZC) is unrelated to auto-zero measurement mode
#define DMM261_ADCVI_ZCC_ZMD_ZMM    (1)         // 1 - auto-zero using DMM261_ADCx_MAX-DMM261_ADCx_MIN)/2
#define DMM261_ADCVI_ZCC_ZMD_ZRMS   (2)         // 2 - auto-zero using last period DC average. currently not supported, will default to DMM261_ADCVI_ZCC_ZMD_ZMM
#define DMM261_ADCVI_ZCC_ZMD_ZDC    (3)         // 3 - auto-zero using DMM261_ADCx_DC. currently not supported, will default to DMM261_ADCVI_ZCC_ZMD_ZMM
                                    // Note: that all auto-zero modes will use DMM261_ADCx_DC
                                    // when no valid AC waveform is detected

// user defines for value parameter of DqAdv261SetConfig
// when item parameter = DQ_DMM261_CONFIG_V_FIR, DQ_DMM261_CONFIG_I_FIR, DQ_DMM261_CONFIG_V_FIR_DEC or DQ_DMM261_CONFIG_I_FIR_DEC
// These are also the only legal values for EEPROM initprm to use to configure FIR
#define DMM261_CFG_VI_FIR_OFF       (0)         // 0  fir is bypassed, ADC data goes directly to input of DC averager and RMS conversion
#define DMM261_CFG_VI_FIR_24HZ      (1)         // 1  fir enabled with 24Hz cutoff
#define DMM261_CFG_VI_FIR_50HZ      (2)         // 2  fir enabled with 50Hz cutoff
#define DMM261_CFG_VI_FIR_100HZ     (3)         // 3  fir enabled with 100Hz cutoff
#define DMM261_CFG_VI_FIR_1KHZ      (4)         // 4  fir enabled with 1kHz cutoff

//DqAdv261SetConfig 'value' parameter when 'item' = DQ_DMM261_CONFIG_RD_CYCLES
#define DMM261_CFG_CYCLES_60HZ_MAX  (900)       // max line cycles for DC measurements (15 seconds)
#define DMM261_CFG_CYCLES_50HZ_MAX  (750)       // max line cycles for DC measurements (15 seconds)
#define DMM261_CFG_CYCLES_60HZ_MIN  (1)         // 1 line cycle
#define DMM261_CFG_CYCLES_50HZ_MIN  (1)         // 1 line cycle
#define DMM261_CFG_CYCLES_DEFAULT   (29)        // same as DMM261_DEFAULT_NPLC, max NPLC for AC measurements
//#define DMM261_DEFAULT_LINE_FREQ  (60)        // default power line frequency

//DqAdv261SetConfig 'value' parameter when 'item' = DQ_DMM261_CONFIG_LINE_HZ
#define DMM261_CONFIG_LINE_HZ_DEFAULT      (60)
#define DMM261_CONFIG_LINE_HZ_MIN          (25)
#define DMM261_CONFIG_LINE_HZ_MAX          (450)

    // DqAdv261SetConfig 'value' parameter
    // when 'item' = DQ_DMM261_CONFIG_V_PK_AVG or DQ_DMM261_CONFIG_I_PK_AVG
#define DQ_DMM261_AVG_1_SAMPL       (0)
#define DQ_DMM261_AVG_2_SAMPL       (1)
#define DQ_DMM261_AVG_4_SAMPL       (2)
#define DQ_DMM261_AVG_8_SAMPL       (3)
#define DQ_DMM261_AVG_16_SAMPL      (4)
#define DQ_DMM261_AVG_32_SAMPL      (5)
#define DQ_DMM261_AVG_64_SAMPL      (6)
#define DQ_DMM261_AVG_128_SAMPL     (7)
#define DQ_DMM261_PKAVG_DEFAULT     (6)
#define DQ_DMM261_PKAVG_MASK        (0x7)

#define DQ_DMM261_GET_STATUS_LIST   (0x20)      // internal DAQLib command to implement DqAdv261ReadStatus()
#define DQ_DMM261_GET_STATUS_SZ_MAX (10)
#define DQ_DMM261_GET_ST_GSTS       (0x00)      // DqAdv261ReadStatus() slist cmd to read DMM261_GSTS
#define DQ_DMM261_GET_ST_INT        (0x01)      // DqAdv261ReadStatus() slist cmd to read DMM261_GISR
#define DQ_DMM261_GET_ST_HEAT       (0x02)      // DqAdv261ReadStatus() slist cmd to read DMM261_HSTS
#define DQ_DMM261_GET_ST_ADCR       (0x03)      // DqAdv261ReadStatus() slist cmd to read DMM261_ADCR_STS
#define DQ_DMM261_GET_ST_GIMON      (0x04)      // DqAdv261ReadStatus() slist cmd to read DMM261_ADCG_STS
#define DQ_DMM261_GET_ST_G_ADC      (0x05)      // DqAdv261ReadStatus() slist cmd to read DMM261_ADCT_STS
#define DQ_DMM261_GET_ST_PGA        (0x06)      // DqAdv261ReadStatus() slist cmd to read DMM261_PSTS_A
#define DQ_DMM261_GET_ST_EXP_ST     (0x07)      // DqAdv261ReadStatus() slist cmd to read EXPLORER_STATUS

// start: testing defines for UEI use
#define DQ_DMM261_CONFIG_WDTEST     (0x97)      // item code to test watchdog
#define DQ_DMM261_MODE_STATUS_MTTY  (0x98)      // item code to print relay status on mttty
#define DQ_DMM261_WRITE_DONGLE      (0x99)      // item code to write to test plug
#define DQ_DMM261_MODE_TEST_READ    (0x200)     // item code to read Res ADC, <value> =reg, data returned in *flags
#define DQ_DMM261_MODE_TEST_WRITE   (0x201)     // item code to write Res ADC, reg=<value&0xf>, data= <value>>4>
#define DQ_DMM261_MODE_TEST_FLAG    (1L<<31)    // OR to _TEST_READ and _TEST_WRITE <value> to restart ADC after r/w
#define DQ_DMM261_MODE_TEST_RW3     (1L<<30)    // OR to _TEST_READ and _TEST_WRITE <value> to r/w 3 registers
#define DQ_DMM261_AZERO_IEXC_OFF    (0x202)     // item code to turn exc relay at 0x2000.1 OFF
#define DQ_DMM261_AZERO_SAVE        (0x203)     // item code to sav autozero values
// DqAdv261SetConfig 'value' parameter
// when 'item' = DQ_DMM261_WRITE_DONGLE         // defines for DMM-261 test plug
#define DQ_DMM261_DIO_D_12MA        (0x01)      // 12 mA to current input
#define DQ_DMM261_DIO_D_19_5V       (0x02)      // 19.5 Volts to voltage input
#define DQ_DMM261_DIO_D_VREF_5V     (0x04)      // 5 Volt reference to voltage input
#define DQ_DMM261_DIO_D_1K_OHM      (0x08)      // 1K resistance
//end: testing defines for UEI use

    // status bits when read as a channel number DQ_DMM261_READY_STATUS (0x3F)
#define DQ_DMM261_GSTS_ADCI_OVR     (1L<<30)    // =1 - ADCI data is out of ADC input range
#define DQ_DMM261_GSTS_ADCV_OVR     (1L<<29)    // =1 - ADCV data is out of ADC input range
#define DQ_DMM261_GSTS_ADCI_DCR     (1L<<28)    // =1 - DC is ready from ADCI (LTC2380-24)

#define DQ_DMM261_GSTS_ADCI_ACR     (1L<<27)    // =1 - AC is ready from ADCI (LTC2380-24)
#define DQ_DMM261_GSTS_ADCI_MMR     (1L<<26)    // =1 - min/max is ready from ADCI (LTC2380-24)
#define DQ_DMM261_GSTS_ADCI_DR      (1L<<25)    // =1 - data is ready from ADCI (LTC2380-24)
#define DQ_DMM261_GSTS_ADCV_DCR     (1L<<24)    // =1 - DC is ready from ADCV (LTC2380-24)

#define DQ_DMM261_GSTS_ADCV_ACR     (1L<<23)    // =1 - AC is ready from ADCV (LTC2380-24)
#define DQ_DMM261_GSTS_ADCV_MMR     (1L<<22)    // =1 - min/max is ready from ADCV (LTC2380-24)
#define DQ_DMM261_GSTS_ADCV_DR      (1L<<21)    // =1 - data is ready from ADCV (LTC2380-24)
#define DQ_DMM261_GSTS_ADCR_CLR     (1L<<20)    // =1 - resistance ADC channel list processing is complete

#define DQ_DMM261_GSTS_ADCR_DR      (1L<<19)    // =1 - data is ready from resistance ADC
#define DQ_DMM261_GSTS_ADCG_DR      (1L<<18)    // =1 - data is ready from ADCG (AD7476)
#define DQ_DMM261_GSTS_ADCT_ERR     (1L<<17)    // =1 - ADCT data error (out of range, not ready) (LTC2486)
#define DQ_DMM261_GSTS_ADCT_DR      (1L<<16)    // =1 - data is ready from ADCT (LTC2486)
    // Static bits 15..0
#define DQ_DMM261_GSTS_ADCR_HF      (1L<<15)    // =1 - ADCR FIFO is above watermark
#define DQ_DMM261_GSTS_ADCR_FF      (1L<<14)    // =1 - ADCR FIFO is full
#define DQ_DMM261_GSTS_ADCV_HF      (1L<<13)    // =1 - ADCV FIFO is above watermark
#define DQ_DMM261_GSTS_ADCV_FF      (1L<<12)    // =1 - ADCV FIFO is full

#define DQ_DMM261_GSTS_ADCI_HF      (1L<<11)    // =1 - ADCI FIFO is above watermark
#define DQ_DMM261_GSTS_ADCI_FF      (1L<<10)    // =1 - ADCI FIFO is full
#define DQ_DMM261_GSTS_WDE          (1L<<9)     // =1 - watchdog expired  0 to GCFG 0x2000.15...0x2000.7 to disable
#define DQ_DMM261_GSTS_ADCV_ACI     (1L<<8)     // =1 - valid AC is detected by ADCI (LTC2380-24)

#define DQ_DMM261_GSTS_ADCV_ACV     (1L<<7)     // =1 - valid AC is detected by ADCV (LTC2380-24)
#define DQ_DMM261_GSTS_RL_ACDC      (1L<<6)     // Current actual RL ACDC status (=1-ON, AC is selected)
#define DQ_DMM261_GSTS_RL_VIN       (1L<<5)     // Current actual RL VIN status (=1-ON)
#define DQ_DMM261_GSTS_RL_LR        (1L<<4)     // Current actual RL LR status (=1-ON,low range is selected), 0 = 100X gain

#define DQ_DMM261_GSTS_RL_AZ        (1L<<3)     // Current actual RL AZ status (=1-ON)
#define DQ_DMM261_GSTS_RL_4W        (1L<<2)     // Current actual RL 4W status (=1-2W,  =0-4W)
#define DQ_DMM261_GSTS_RL_IEXC      (1L<<1)     // Current actual RL IEXC (low current range) status (=1-ON. 50mA_10ohm), 0=2A_0.1ohm
#define DQ_DMM261_GSTS_RL_FLT       (1L<<0)     // relay fault,  RL_VIN fault or RL_IEXC fault                                        0
// PGA status bits, from DqAdv261GetPgaStatus() or from DqAdv261Read() w/ DQ_DMM261_PGA_DATA_OFFSET added to channel #.  From TI PGA280 datasheet
#define DQ_DMM261_PGAERR_CHKERR     (1UL<<7)    // checksum error in SPI; (reporting of this error is not enabled)
#define DQ_DMM261_PGAERR_IARERR     (1UL<<6)    // Input Amplifier saturated to supply rail
#define DQ_DMM261_PGAERR_BUFA       (1UL<<5)    // Buffer active indication
#define DQ_DMM261_PGAERR_ICAERR     (1UL<<4)    // input clamp conduction error, input slew rate is faster than amplifier slew rate
#define DQ_DMM261_PGAERR_ERRFLAG    (1UL<<3)    // Error flag ( presently disabled )
#define DQ_DMM261_PGAERR_OUTERR     (1UL<<2)    // Output Amplifier is clipping signal or over-current condition exists
#define DQ_DMM261_PGAERR_GAINERR    (1UL<<1)    // Gain network overload, gain setting may be too high for the input signal
#define DQ_DMM261_PGAERR_IOVERR     (1UL<<0)    // Input over-voltage error



#define DQ_DMM261_PDWR_GPIO_R8_CFG  (0x0007)    // PGA280 reg 8 set 3 lsb's of GPIO to be outputs

#define DQ_UNUSED                   (0)         // recommended value to use when a parameter has no meaning in the present context.


#define DQ_DMM261_NAMELEN           (16)        // maximum length of the channel name (trailing 0 isn't included)
#define DQCAL_RESERVED              (4)
#define DQCAL_AZERO                 (25)


#pragma pack(1)
/* channel names */
typedef struct {
    char cname[DQ_DMM261_CHAN+1][DQ_DMM261_NAMELEN];  //
} DQCNAMES_261_, *pDQCNAMES_261_;

// per channel Offset/gain calibration values, 24 bits
typedef struct {
    uint32 c_offs[DQ_DMM261_IDC_RANGES];        // 11 offsets for main V and I,
    uint32 c_gain[DQ_DMM261_IDC_RANGES];        // 11 gains for main V and I,
} DQCAL_DAC_INT_261_IDC, *pDQCAL_DAC_INT_261_IDC;
typedef struct {

    uint32 c_offs[DQ_DMM261_IAC_RANGES];        // 10 offsets for main V and I,
    uint32 c_gain[DQ_DMM261_IAC_RANGES];        // 10 gains for main V and I,
    uint32 pk_offs[DQ_DMM261_IAC_RANGES];       // 10 offsets for peak.
    uint32 pk_gain[DQ_DMM261_IAC_RANGES];       // 10 gains for peak
} DQCAL_DAC_INT_261_IAC, *pDQCAL_DAC_INT_261_IAC;

// per channel Offset/gain calibration values, 24 bits
typedef struct {
    uint32 c_offs[DQ_DMM261_VDC_RANGES];        // 18 offsets for main V and I,
    uint32 c_gain[DQ_DMM261_VDC_RANGES];        // 18 gains for main V and I,
} DQCAL_DAC_INT_261_VDC, *pDQCAL_DAC_INT_261_DC;

// per channel Offset/gain calibration values, 24 bits
typedef struct {
    uint32 c_offs[DQ_DMM261_VAC_RANGES];        // 11 offsets for ACV +1 for 25mV ref.
    uint32 c_gain[DQ_DMM261_VAC_RANGES];        // 11 gains for ACV,
    uint32 pk_offs[DQ_DMM261_VAC_RANGES];       // 11 offsets for ACV peak
    uint32 pk_gain[DQ_DMM261_VAC_RANGES];       // 11 gains for ACV peak
} DQCAL_DAC_INT_261_VAC, *pDQCAL_DAC_INT_261_AC;

typedef struct {
    uint32 c_offs;                              // 1 offset for each guardian channel
    uint32 c_gain;                              // 1 gain   for each guardian channel
} DQCAL_OFF_GN_261, *pDQCAL_OFF_GN_261;


typedef struct {
    int32 c_offs[DQ_DMM261_RES_RANGES];
    uint32 c_gain[DQ_DMM261_RES_RANGES];
    int32 ref_offs;        // reference
    uint32 ref_gain;
    uint32 excite[DQ_DMM261_RES_RANGES];        // excitation current for resistance measurement
    // if each res range needs its own ref calibration then we'll need this:
    //uint32 ref_offs[DQ_DMM261_RES_RANGES];    // reference
    //uint32 ref_gain[DQ_DMM261_RES_RANGES];
} DQCAL_DAC_SETRDEF_261, *pDQCAL_DAC_SETRDEF_261;

typedef struct {
    DQCAL_OFF_GN_261 vt;    // 5 gains   for guardian voltage and temp
} DQCAL_DAC_SETGVT_261, *pDQCAL_DAC_SETGVT_261;
/* specific device structure - calibration values */

typedef struct {
    DQCAL_DAC_SETGVT_261 confgvt[DQ_DMM261_GUARDIAN_CHAN];     // UM1  4 voltages and temperature DQ_DMM261_GVT_CHAN, apply in DAQLib
    DQCAL_OFF_GN_261 confgi;        // UAG1 dc current monitor
    uint32 limit_ma;                // guardian dc limit
    uint32 hyst_ma;                 // guardian dc hyst
    uint32 ref_r_res_x100;          // reserved to cal the reference resistor, for now we assume 10K exactly
    uint32 rn1_res;                 // reserved to cal the 100Meg shunt resistance , for now we assume 100Meg exactly
    uint32 reserved[DQCAL_RESERVED];// reserved 4 values, init[0] as zero to use default 10K ref and 100M shunt
    DQCAL_OFF_GN_261 confgiac;      // UAG1 ac current monitor, calibrated for AC power measurements
    uint32 limit_ma_ac;             // guardian ac limit
    uint32 hyst_ma_ac;              // guardian ac hyst
    DQCAL_DAC_SETRDEF_261 confrd;   // UGR1 resistance reference + device under test
    DQCAL_DAC_INT_261_IDC calidc;   // internal cal main I dc channel,
    DQCAL_DAC_INT_261_IAC caliac;   // internal cal main I ac channel,
    DQCAL_DAC_INT_261_VDC calvdc;   // internal cal main DCV
    DQCAL_DAC_INT_261_VAC calvac;   // internal cal main ACV
    int32 vref5_10nv;               // 5V reference in 10 nanovolt units
    int32 vref25v_10nv;             // 24.8756mV reference on voltage channel in 10 nanovolt units
    int32 vref25i_10nv;             // 24.8756mV reference on current channel in 10 nanovolt units
    uint32 more_res[DQCAL_RESERVED];
} DQCALSET_261_, *pDQCALSET_261_;



/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
     uint32 chlst[DQ_DMM261_CHAN];  // channel list - full one extra for timestamp
     int clperint;                  // number of channel lists per interrupt; ignored if <1 or invalid
     uint32 conf;                   // control word - layer API flags
     uint32 cvclk;                  // CV clock
     uint32 clclk;                  // CL clock
     uint32 trig;                   // trigger conditions
     uint32 clkcfg;
     uint32 resvd;
} DQOPMODEPRM_261_, *pDQOPMODEPRM_261_;

typedef struct {
    uint32 cfg;                     // mode configuration (user-level flags, like op mode)
    uint32 val[DQ_DMM261_CHAN];     // line states in init mode
    uint32 line_freq;
    uint32 line_cycles;
    uint32 v_fir;                   // 0= off, 1..4= cutoffs
    uint32 i_fir;                   // 0= off, 1..4= cutoffs
    uint32 resvd;
} DQINITPRM_261_, *pDQINITPRM_261_;


typedef struct {
    uint32 cfg;                     /* mode configuration (user-level flags, like op mode) */
    uint32 val[DQ_DMM261_CHAN];     /* line states in shutdown mode */
    uint32 resvd;
} DQSDOWNPRM_261_, *pDQSDOWNPRM_261_;

typedef struct {
    uint32 date_a;
    uint32 date_b;
}DQAZDATE_261_, *pDQAZDATE_261_ ;

typedef struct {
    int16 offmod[DQCAL_AZERO];
    int16 offres[DQCAL_RESERVED];    // reserved
}DQAZEROS_261_, *pDQAZEROS_261_ ;


typedef struct {    // Space reserved in DEVEEPROM_261_ for future use
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQPRMFLAGSA)
                           - sizeof(DQINITPRM_261_)
                           - sizeof(DQOPMODEPRM_261_)
                           - sizeof(DQSDOWNPRM_261_)
                           - sizeof(DQCNAMES_261_)
                           - sizeof(DQCALSET_261_)
                           - sizeof(DQAZDATE_261_)
                           - sizeof(DQAZEROS_261_) // a
                           - sizeof(DQAZEROS_261_) // b
                           - sizeof(DQEEPROMTAIL)];
} DQEERSVD_261_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS      ee;
    DQPRMFLAGSA      eeflags;
    DQINITPRM_261_   initprm;
    DQOPMODEPRM_261_ opmodeprm;
    DQSDOWNPRM_261_  sdownprm;
    DQCNAMES_261_    cname;
    DQCALSET_261_    calset;
    DQAZDATE_261_    azdate;
    DQAZEROS_261_    zdata_a;
    DQAZEROS_261_    zdata_b;
    DQEERSVD_261_    reserved;      // do not read at init; reading slows down bootup
    DQEEPROMTAIL     eever_crc;     // contains eeprom version and CRC
} DEVEEPROM_261_, *pDEVEEPROM_261_;


// definitions for AO-301 layer CLI part
#define DQ_AO301_CHAN               (8)         // working channels
#define DQ_AO308_CHAN               (8)         // working channels
#define DQ_AO301_CHANSVC            (32)        // total channels including service
#define DQ_AO301_INFOSZ             DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_AO301_BASE               BUS_FREQUENCY  // 66MHz base frequency

#define DQ_AO301_DMAPCV             ((DQ_AO301_BASE/160000)-1)
#define DQ_AO301_STARTRATE          DQ_AO301_DMAPCV

#define DQ_AO301_MAXCLFRQ           (100000)
#define DQ_AO301_MAXCVFRQ           (800000)    // 100kHz per channel
#define DQ_AO301_MIDSCALE           (0x8000)    // 0V

#define DQ_AO301_SPAN               (20.0)
#define DQ_AO301_OFFSET             (10.0)
#define DQ_AO301_STEP               (DQ_AO301_SPAN/65535.0)

#define DQ_AO308_352_SPAN           (27.034)
#define DQ_AO308_352_OFFSET         (13.517)
#define DQ_AO308_352_STEP           (DQ_AO308_352_SPAN/65535.0)

#define DQ_AO308_353_SPAN           (80.0)
#define DQ_AO308_353_OFFSET         (40.0)
#define DQ_AO308_353_STEP           (DQ_AO308_353_SPAN/65535.0F)

// definitions for AO-332 and AO-333 layer
#define DQ_AO332_CHAN               (32)        // working analog output channels
#define DQ_AO333_ADC_CHAN           (32)        // working ADC channels
#define DQ_AO332_CHANMASK           (DQ_AO332_CHAN-1) // channels bit mask - assumes power of 2
#define DQ_AO332_CL_CH_MASK         ((DQ_AO332_CHANMASK)<<16) // channels bit mask - bits 20:16
#define DQ_AO332_CHANSVC            (32)        // total channels including service
#define DQ_AO332_INFOSZ             (DQ_MAX_INFO_SIZE)      // maximum size of information structure
#define DQ_AO332_BASE               (BUS_FREQUENCY)  // 66MHz base frequency

#define DQ_AO332_DMAPCV             ((DQ_AO332_BASE/8000)-1)
#define DQ_AO332_STARTRATE          (DQ_AO332_DMAPCV)

#define DQ_AO332_MAXCLFRQ           (100000)
#define DQ_AO332_MAXCVFRQ           (800000)  // 100kHz per channel
#define DQ_AO332_MIDSCALE           (0x8000)

#define DQ_AO332_SPAN               (20.0)
#define DQ_AO332_OFFSET             (10.0)
#define DQ_AO332_STEP               (DQ_AO332_SPAN/65535.0)

// additional definitions for AO-333
#define DQ_AO333_ADC_SPAN           (20.0)
#define DQ_AO333_ADC_OFFSET         (10.0)
#define DQ_AO333_ADC_STEP24         (DQ_AO333_ADC_SPAN/(double)0xffffff)
#define DQ_AO333_ADC_STEP           (DQ_AO333_ADC_SPAN/(double)0xffff)

// AO-333 for calibration use only
#define DQIOCTL_AO333_CALIBRATE     (0x08)
#define DQIOCTL_AO333_CALIBRATE_RESULT  (0x09)

#define DQ_AO333_DEF_OFFSET_CAL     (0x69)      // default offset for AO-333 ADC
#define DQ_AO333_MAX_OFFSET_CAL_DEV (0x120)     // Max amount that offset can deviate from default
                                                // offset without throwing a calibration error
#define DQ_AO333_DEF_GAIN_CAL       (0x7c60)    // default gain calibration for AO-333 ADC
#define DQ_AO333_MAX_GAIN_CAL_DEV   (0x0600)    // Max amount that gain can deviate from default
                                                // gain without throwing a calibration error
#define DQ_AO333_DEF_GAIN_SF_CAL    (0x0b)      // default scaling factor. The raw ADC reading is multiplied by
                                                // this factor/2 before the gain calibration is applied
#define DQ_AO333_CAL_READINGS_AVGD  (12)        // number of readings that the calibration code will average
                                                // together before using the 0V and 9.5V readings in a calculation
#define DQ_AO333_ADC_RESULT         (0x2100)    // base address of the 32 ADC result registers. increment by 4
#define DQ_AO333_I2C_NEW_DATA       (0x2018)    // address of the 'new data ready' flag register
#define DQ_AO333_I2C_CTRL           (0x2000)    // address of the i2c control register
#define DQ_AO333_I2C_CTRL_RDY_ALL   (1L<<1)     // 'ready_all' bit in i2c control register
#define DQ_AO333_CAL_P9_5V          (0xf998)    // 16-bit value to send to AO-333 to make +9.5V on output
#define DQ_AO333_CAL_N9_5V          (0x0666)    // 16-bit value to send to AO-333 to make -9.5V on output
#define DQ_AO333_CAL_0V             (DQ_AO332_MIDSCALE-1) // 16-bit value to send to AO-333 to make 0V on output
#define DQ_AO333_MAX_N9_5V_DEV      (0x2a)      // Max amount that the -9.5V readback value can deviate from
                                                // the DQ_AO333_CAL_N9_5V value without throwing an error
#define AO333_CAL_ADC_RA_HIGH       (-99)       // Calibration error, 'ready_all' bit stuck high
#define AO333_CAL_ADC_RA_LOW        (-98)       // Calibration error, 'ready_all' bit stuck low
#define AO333_CAL_ADC_RD_FAIL       (-97)       // Calibration error, ADC read failure
#define AO333_CAL_ADC_OFFSET_RANGE  (-96)       // Calibration error, offset cal value out of range
#define AO333_CAL_ADC_N9_5_LIMIT    (-95)       // Calibration error, -9.5V reading out of tolerance
#define AO333_CAL_ADC_GAIN_RANGE    (-94)       // Calibration error, gain cal value out of range
#define AO333_CAL_ADC_EE_ERR        (-93)       // Calibration error, eeprom error
#define AO333_CAL_ADC_SUCCESS       (1)         // Calibration completed normally


// defines for use with DqAdv308WriteISConfig()
#define DQL_AO308_EXT_REDGE         (1L<<7)     // (option 800 only) select rising edge of iso ext to toggle LDAC
#define DQL_AO308_LDACEXT1          (1L<<6)     // (option 800 only) use DIO line ISO_EXT1 (pin4)to toggle LDAC
#define DQL_AO308_LDACEXT0          (1L<<5)     // (option 800 only) use DIO line ISO_EXT0 (pin3)to toggle LDAC
#define DQL_AO308_MASK_800          (7L<<5)     // (option 800 only)

#define DQL_EXT_DEV_PREAMBLE        (0xa3<<24)
#define DQL_EXT_DEV_CMDMASK         (0x7)
#define DQL_EXT_DEV_CMDMASK_SHFT    (21)
#define DQL_EXT_DEV_DATAMASK        (0xfffff)
#define DQL_EXT_DEV_DATAMASK_SHFT   (1)
#define DQL_EXT_DEV_RETURN_PREABLE_MASK (0xe0000000)
#define DQL_EXT_DEV_RETURN_PREABLE  (0xa0000000)
// -----------------------------------------------------------------------

// FIFO control
#define DQ_AI301_CL_TIMES           (2)         // upper and lower part of the buffer
#define DQ_AI301_FIFO_CH            (128)       // entries in the fifo
#define DQ_AI301_FIFO_BUFSZ         (16)        // buffers (old style)

// Upper part of the configuration word - AO-301 specific
#define DQ_AO301_POS10              (1L << 23)  // 0..10V
#define DQ_AO301_NEG10              (2L << 23)  // -10..0 V
#define DQ_AO301_BI10               (3L << 23)  // +/-10V
#define DQ_AO301_OFF                (0L << 23)  // DACs off
#define DQ_AO301_ENCOUT             (1L << 22)  // enable output strobe

#define DQ_AO301_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mode
#define DQ_AO301_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous output with FIFO
#define DQ_AO301_MODECONT           (DQ_FIFO_MODECONT)  // waveform mode - continuous
#define DQ_AO301_MODEWFGEN          (3L << 16)  // waveform mode - hardware

#define DQ_AO301_FIFO_SET_DATA      DQ_FIFO_SET_DATA

// ISTR301_SYNC_WRITE bits
// Define configuration of the bi-directional DIO lines on the PDNA-AI-308 layers
#define DQL_ISTR301_DIO0INV         (1L<<7)     // DIO0 (CLKOUT) inversion flag
#define DQL_ISTR301_DIO0MODE        (5)         // # of the DIO0 mode configuration bit
#define DQL_ISTR301_DIO0DEF         (0L<<5)     // default mode, DIO0 - output = iso_int0
#define DQL_ISTR301_DIO0OUT         (1L<<5)     // Assigned output, output defined by DIO0SRC
#define DQL_ISTR301_DIO0GPIN        (2L<<5)     // GPIO input
#define DQL_ISTR301_DIO0GPOUT       (3L<<5)     // GPIO output
#define DQL_ISTR301_DIO0VAL         (1L<<4)     // Value of the GPIO output
#define DQL_ISTR301_DIO0SRC         (0)         // Source selector in assigned output mode
#define DQL_ISTR301_DIO0INT0        (0L<<0)     // iso_int0 selected as a source
#define DQL_ISTR301_DIO0INT1        (1L<<0)     // iso_int1 selected as a source
#define DQL_ISTR301_DIO0SRC2        (2L<<0)     // conversion start strobe selected as a source
#define DQL_ISTR301_DIO0SRC3        (3L<<0)     // ADC busy strobe selected as a source

#define DQL_ISTR301_DIO1INV         (1L<<15)    // DIO1 (EXTCLK) inversion flag
#define DQL_ISTR301_DIO1MODE        (13)        // # of the DIO1 mode configuration bit
#define DQL_ISTR301_DIO1DEF         (0L<<13)    // default mode, DIO1 - input --> iso_ext0
#define DQL_ISTR301_DIO1OUT         (1L<<13)    // Assigned output, output defined by DIO1SRC
#define DQL_ISTR301_DIO1GPIN        (2L<<13)    // GPIO input
#define DQL_ISTR301_DIO1GPOUT       (3L<<13)    // GPIO output
#define DQL_ISTR301_DIO1VAL         (1L<<12)    // Value of the GPIO output
#define DQL_ISTR301_DIO1SRC         (8)         // Source selector in assigned output mode
#define DQL_ISTR301_DIO1INT0        (0L<<8)     // iso_int0 selected as a source
#define DQL_ISTR301_DIO1INT1        (1L<<8)     // iso_int1 selected as a source
#define DQL_ISTR301_DIO1SRC2        (2L<<8)     // conversion start strobe selected as a source
#define DQL_ISTR301_DIO1SRC3        (3L<<8)     // ADC busy strobe selected as a source

#define DQL_ISTR301_DIO2INV         (1L<<23)    // DIO2 (EXTTRIG) inversion flag
#define DQL_ISTR301_DIO2MODE        (21)        // # of the DIO2 mode configuration bit
#define DQL_ISTR301_DIO2DEF         (0L<<21)    // default mode, DIO2 - input --> iso_ext1
#define DQL_ISTR301_DIO2OUT         (1L<<21)    // Assigned output, output defined by DIO2SRC
#define DQL_ISTR301_DIO2GPIN        (2L<<21)    // GPIO input
#define DQL_ISTR301_DIO2GPOUT       (3L<<21)    // GPIO output
#define DQL_ISTR301_DIO2VAL         (1L<<20)    // Value of the GPIO output
#define DQL_ISTR301_DIO2SRC         (16)        // Source selector in assigned output mode
#define DQL_ISTR301_DIO2INT0        (0L<<16)    // iso_int0 selected as a source
#define DQL_ISTR301_DIO2INT1        (1L<<16)    // iso_int1 selected as a source
#define DQL_ISTR301_DIO2SRC2        (2L<<16)    // conversion start strobe selected as a source
#define DQL_ISTR301_DIO2SRC3        (3L<<16)    // ADC busy strobe selected as a source
#define DQL_AO301_SYNC_WRITE        (0xC1000000)// Command mask for the SYNC CFG command

// AO-308
// default input :  dio0  iso_ext0    pin 3
// default input :  dio1  iso_ext1    pin 4
// default output:  dio2  iso_int0    pin 22
//                             gnd    pin 1,21


/* specific device structure - calibration values */
#define DQ_AO301_CALSZ              (4)
#define DQ_AO301_DCALSZ             (16)

#define DQ_AO301_NAMELEN            (32)  // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* ------------ 302 and 308 structures -------------------------------------- */
/* channel names */
typedef struct {
    char cname[DQ_AO301_CHAN][DQ_AO301_NAMELEN];
} DQCNAMES_301_, *pDQCNAMES_301_;

/* specific device structure - calibration values */
typedef struct {
    uint16 cal[DQ_AO301_CALSZ];     /* four calibration DAQs - main board */
    uint8  dcal[DQ_AO301_DCALSZ];   /* 16 cal DACs on daughter card */
} DQCALSET_301_, *pDQCALSET_301_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AO301_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    uint32 cfg;                     // mode configuration
    uint16 val[DQ_AO301_CHAN];      // start-up values for op mode
    int clperint;                   // <reserved>
} DQOPMODEPRM_301_, *pDQOPMODEPRM_301_;

typedef struct {
    uint32 cfg;                     /* mode configuration (user-level flags, like op mode) */
    uint16 val[DQ_AO301_CHAN];      /* line states in init mode */
} DQINITPRM_301_, *pDQINITPRM_301_;

typedef struct {
    uint32 cfg;                     /* mode configuration (user-level flags, like op mode) */
    uint16 val[DQ_AO301_CHAN];      /* line states in shutdown mode */
} DQSDOWNPRM_301_, *pDQSDOWNPRM_301_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_301_ calset;
    DQOPMODEPRM_301_ opmodeprm;
    DQINITPRM_301_ initprm;
    DQSDOWNPRM_301_ sdownprm;
    DQCNAMES_301_ cname;
    DQPRMFLAGS eeflags;
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQCALSET_301_)
                           - sizeof(DQOPMODEPRM_301_)
                           - sizeof(DQINITPRM_301_)
                           - sizeof(DQSDOWNPRM_301_)
                           - sizeof(DQCNAMES_301_)
                           - sizeof(DQPRMFLAGS)
                           - sizeof(uint32)];         // crc
} DEVEEPROM_301_, *pDEVEEPROM_301_;


/* ------------ 332 structures ---------------------------------------------- */
#define DQ_AO332_CALSZ              (32)
#define DQ_AO333_CALSZ              (32)
#define DQ_AO332_NAMELEN            12  // 12*32 = 384 bytes

/* channel names */
typedef struct {
    char cname[DQ_AO332_CHAN][DQ_AO332_NAMELEN];
} DQCNAMES_332_, *pDQCNAMES_332_;

/* specific device structure - calibration values */
typedef struct {
    uint16 mreg[DQ_AO332_CALSZ];    // M-register value, 0xffff = gain of 1
    uint16 creg[DQ_AO332_CALSZ];    // C-register value 0x8000 is a mid-scale
    uint16 offsdac0;                // offset DAC0 for group 0 (0x0..0x2000)
    uint16 offsdac1;                // offset DAC1 for groups 1,2,3 (0x0..0x2000)
} DQCALSET_332_, *pDQCALSET_332_;

/* specific device structure - calibration values */
typedef struct {
    int16 offs[DQ_AO333_CALSZ];     // offset adjustment for ADC
    uint16 gain[DQ_AO333_CALSZ];    // gain adjustment for ADC
    uint16 gain_sf;                 // gain scale factor times 2.
                                    // offset adjusted data gets multiplied by this factor. then divided by 2
} DQCALSET_333_, *pDQCALSET_333_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AO332_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    uint32 cfg;                     // mode configuration
    uint16 val[DQ_AO332_CHAN];      // start-up values for op mode
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_332_, *pDQOPMODEPRM_332_;

typedef struct {
    uint32 cfg;                     // mode configuration (user-level flags, like op mode)
    uint16 val[DQ_AO332_CHAN];      // line states in init mode
} DQINITPRM_332_, *pDQINITPRM_332_;

typedef struct {
    uint32 cfg;                     /* mode configuration (user-level flags, like op mode) */
    uint16 val[DQ_AO332_CHAN];      /* line states in shutdown mode */
} DQSDOWNPRM_332_, *pDQSDOWNPRM_332_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_332_ calset;
    DQOPMODEPRM_332_ opmodeprm;
    DQINITPRM_332_ initprm;
    DQSDOWNPRM_332_ sdownprm;
    DQCNAMES_332_ cname;
    DQPRMFLAGS eeflags;
    DQCALSET_333_ calset3;              // calibration values for 333
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQCALSET_332_)
                           - sizeof(DQOPMODEPRM_332_)
                           - sizeof(DQINITPRM_332_)
                           - sizeof(DQSDOWNPRM_332_)
                           - sizeof(DQCNAMES_332_)
                           - sizeof(DQPRMFLAGS)
                           - sizeof(DQCALSET_333_)
                           - sizeof(uint32)];       // crc
} DEVEEPROM_332_, *pDEVEEPROM_332_;

#pragma pack()

// additional flag for DqAcbInitOps() acb.dirflags.
// enable or disable the outputting of eeprom init values at start of acb. Default is enabled
#define DQ_ACB_EE_INIT_ON           (0x10000)  // enable
#define DQ_ACB_EE_INIT_OFF          (0x20000)  // disable output of eeprom init values at start of acb

#define DQ_AO3XX_EEINIT_INHIBIT     (0x210)     // command sent to firmware by DAQLib to inhibit setting of eeprom init values at start of ACB output
#define DQ_AO3XX_INHIBIT_EE         (0x01)      // for use with DQ_AO3XX_EEINIT_INHIBIT
#define DQ_AO3XX_ENABLE_EE          (0x00)      // for use with DQ_AO3XX_EEINIT_INHIBIT
#define DQL_IOCTL301_WRITEWF        (10L)       // write waveform
#define DQL_IOCTL301_CTRLWF         (11L)       // control waveform output

#define DQL_IOCTL3XX_READ_TEST      (12L)       // use with production test fixture only
#define DQL_IOCTL308_WR_CFG         (13L)       // write isolated side config register


#define DQ_IOCTL3XX_RD_TEST_INIT    (0L)        //
#define DQ_IOCTL3XX_RD_TEST_CVT     (1L)
#define DQ_IOCTL3XX_RD_TEST_END     (2L)
#define DQ_3XX_RD_TEST_SPAN         (2.5)
#define DQ_3XX_RD_TEST_STEP         (DQ_3XX_RD_TEST_SPAN/(double)0xffffff)
#define DQ_3XX_RD_TEST_OFFSET       (DQ_3XX_RD_TEST_SPAN/2.0)
#define DQ_308_RD_TEST_SF_350       ((10240.0)/(240.0))  //
#define DQ_308_RD_TEST_SF_353       ((39240.0)/(240.0))  //
#define DQ_308_RD_TEST_SF_V15       ((19840.0)/(240.0))  //
#define DQ_308_RD_TEST_SF_VEX       ((51240.0)/(240.0))  // use with production test fixture only
#define DQ_308_RD_TEST_CHANS        (12)        // number of returned readings 308
#define DQ_332_RD_TEST_CHANS        (32)        // number of returned readings 332
                                                // use with production test fixture only


#define DQ_AO3xx_STOP_WF            (0)         // stop waveform output
#define DQ_AO3xx_START_WF           (1)         // start waveform output
#define DQ_AO3xx_PAUSE_WF           (2)         // pause waveform
#define DQ_AO3xx_CONT_WF            (3)         // continue waveform output
#define DQ_AO3xx_PROG_WF            (4)         // program waveform


// definitions for AO-318 layer CLI part
#define DQ_AO318_CHAN               (8)         // D/A channels
#define DQ_AO319_CHAN               (8)         // D/A channels
#define DQ_TC378_CHAN               (8)         // D/A channels
#define DQ_AO318_ADC_CH             (5)         // ADC channels per D/A block, A,V,V,V,degC
#define DQ_AO319_ADC_CH             (3)         // ADC channels per D/A block, A,V,degC
#define DQ_TC378_ADC_CH             (3)         // ADC channels per D/A block, A,V,degC
#define DQ_AO318_CHANSVC            (DQ_AO318_CHAN * DQ_AO318_ADC_CH)
#define DQ_AO318_CB_CH              (3)         // number of CircuitBreaker configurations per channel
#define DQ_AO318_INFOSZ             DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_AO318_BASE               BUS_FREQUENCY   // 66MHz base frequency

#define DQ_AO318_ADC_BASE           (DQ_AO318_BASE)

#define DQ_AO318_DMAPCL             ((DQ_AO318_BASE/2000)-1)
#define DQ_AO318_STARTRATE          DQ_AO318_DMAPCL

#define DQ_AO318_MIDSCALE           (0x8000)     // midscale = 0V or 10mA
#define DQ_AO318_020_INIT_A         (0x0)        // 0mA for 318-020/024, or 4mA for 319-420
#define DQ_AO318_020_INIT_B         (0x80C4)     // -70uA constant value for 020 DACB calibration - UEI internal use
#define DQ_AO318_024_INIT_B         (0x80D3)     // -70uA constant value for 024 DACB calibration - UEI internal use
#define DQ_AO318_420_INIT_B         (0x3fd4)     // default for 4-20mA option

#ifdef __UEIPAC__

    #define DQ_AO319_420_INIT_B     (0x7420)     // default ch B value for AO319 w/ 4-20mA option
    #define DQ_AO319_DEF_GAIN_CAL_A (0x7DC2)     // default ch A gain calibration AO-319-420

#else

    #define DQ_AO319_420_INIT_B     (0x7620)     // default ch B value for AO319 w/ 4-20mA option
    #define DQ_AO319_DEF_GAIN_CAL_A (0x7D20)     // default ch A gain calibration AO-319-420

#endif

#define DQ_AO318_CB_INIT            (0xfffe0001) // circuit breaker initial value
#define DQ_AO318_CB_INIT_CONNECT    (0xffff0000) // circuit breaker value to disable circuit breaking (output always connected)
#define DQ_TC378_INIT_B             (0x7606)     // default ch B value for TC-378, normalizes a DAC default offset
#define DQ_TC378_DEF_OFFS_CAL_3     (0xfd2c)     // default ADC offset calibration for TC-378 Aout ( ch3 )
#define DQ_TC378_DCJC_CH            (3)          // number of ADT7420 cjc sensors on TC-378

#define DQ_AO318_CH_MASK            (0x7)
#define DQ_AO318_CL_CH_MASK         ((DQ_AO318_CH_MASK)<<16)
#define DQ_AO318_ADC_CHAN_MASK      (0x7)
#define DQ_AO318_SEL_CHAN_ALL       (0xFF)      // chan_mask parm for DqAdv318CBStatus(),DqAdv318SetCBLevels() and DqAdv318SetConfig()

#define DQ_AO318_MAKE_CL(CH,SUBCH)  ((((CH)&DQ_AO318_CH_MASK)<<3)|((SUBCH)& DQ_AO318_ADC_CHAN_MASK))
#define DQ_AO318_GET_R_CH(CLE)      (((CLE)>>3)&DQ_AO318_CH_MASK)      // get channel number from combined channel and subchannel

// voltage -10V..+10V DAC output
#define DQ_AO318_SPAN               (20.0)      // volts
#define DQ_AO318_OFFSET             (10.0)      // half of span
#define DQ_AO318_STEP               (DQ_AO318_SPAN/65535.0)

// current 0..20mA DAC output (-020 model)
#define DQ_AO318_020_SPAN           (20.0)      // milliamps
#define DQ_AO318_020_OFFSET         (0.0)
#define DQ_AO318_020_STEP           (DQ_AO318_020_SPAN/65535.0)

// current 0..24mA DAC output (-024 model)
#define DQ_AO318_024_SPAN           (24.0)      // milliamps
#define DQ_AO318_024_OFFSET         (0.0)
#define DQ_AO318_024_STEP           (DQ_AO318_024_SPAN/65535.0)

// current 4..20mA DAC output (319-420 model)
#define DQ_AO319_MIN                (4.0)
#define DQ_AO319_MAX                (20.0)
#define DQ_AO319_420_SPAN           (DQ_AO319_MAX-DQ_AO319_MIN)      // 16 milliamps
#define DQ_AO319_420_OFFSET         (-4.0)
#define DQ_AO319_420_STEP           (DQ_AO319_420_SPAN/65535.0)
#define DQ_AO319_SPAN               (DQ_AO319_MAX-DQ_AO319_MIN)      // 16 milliamps
#define DQ_AO319_OFFSET             (-4.0)
#define DQ_AO319_STEP               (DQ_AO319_SPAN/65535.0)

// voltage -0.125V..+0.125V DAC output for TC-378
#define DQ_TC378_SPAN               (0.250)      // volts
#define DQ_TC378_OFFSET             (0.125)
#define DQ_TC378_STEP               (DQ_TC378_SPAN/65535.0)

#define DQ_AO318_ADC_INTCLK         (7.5)      // if ADC is internally clocked
#define DQ_AO318_ADC_DEF            (20.0)     // 5Hz is default A/D rate
#define DQ_AO318_ADC_SETTLE         (5)        // in 10s of ms, should be 100/DQ_AO318_ADC_DEF
#define DQ_AO318_CB_DEF             (5)        // frequency CB are programmed for

#define DQ_AO318_CHANMASK           (DQ_AO318_CHAN-1) // channels bit mask - assumes power of 2
#define DQ_AO318_BCHAN              (0x10)      // channel modifier to write to "B" channel
#define DQ_AO318_CAL_OFFGAIN        (0x20)      // whether write to offset or gain DAC/ADC - UEI internal use
#define DQ_AO318_CAL_DACADC         (0x40)      // select to write DAC or ADC calibration  - UEI internal use

#define DQ_AO318_ADCCH_IIN          (0)         // ADC channel number for AOut current
#define DQ_AO318_ADCCH_AOUTAP       (1)         // ADC channel number for AOutA buffer voltage
#define DQ_AO318_ADCCH_AOUTBP       (2)         // ADC channel number for AOutB buffer voltage
#define DQ_AO318_ADCCH_AOUTA        (3)         // ADC channel number for AOutA voltage at the connector pin
#define DQ_AO318_ADCCH_TEMP         (4)         // Internal ADC channel number for temperature
#define DQ_TC378_ADCCH_CJC          (5)         // ADC channel number for external ADT7420 digital temperature sensors
#define DQ_AO318_ADCCH_UNUSED       (7)         // number to use  to skip an unused ADC config

// AO318 main status register retrieved by DqAdv318CBStatus() in status[0]
// Current status of the AO318 access module, "sticky" bits are auto-cleared after each read
//
#define DQ_AO318_STS_CB7_CS         (1L<<23)    // Current status of the circuit breaker on the channels 7-0
#define DQ_AO318_STS_CB6_CS         (1L<<22)    // =1 - CB tripped
#define DQ_AO318_STS_CB5_CS         (1L<<21)    //
#define DQ_AO318_STS_CB4_CS         (1L<<20)    //
#define DQ_AO318_STS_CB3_CS         (1L<<19)    //
#define DQ_AO318_STS_CB2_CS         (1L<<18)    //
#define DQ_AO318_STS_CB1_CS         (1L<<17)    //
#define DQ_AO318_STS_CB0_CS         (1L<<16)    //

// Bits 15-0 are "sticky"
#define DQ_AO318_STS_ADC7_RDY       (1L<<15)    // Set to one each time when ADC state machine for the corresponding channel
#define DQ_AO318_STS_ADC6_RDY       (1L<<14)    // finishes all conversions, cleared after read. Note that ADC state machine
#define DQ_AO318_STS_ADC5_RDY       (1L<<13)    // may perform up to 5 independent conversions. This bit will be set after
#define DQ_AO318_STS_ADC4_RDY       (1L<<12)    // result from the last conversion is stored into corresponding register
#define DQ_AO318_STS_ADC3_RDY       (1L<<11)    //
#define DQ_AO318_STS_ADC2_RDY       (1L<<10)    //
#define DQ_AO318_STS_ADC1_RDY       (1L<<9)     //
#define DQ_AO318_STS_ADC0_RDY       (1L<<8)     //
#define DQ_AO318_STS_CB7            (1L<<7)     // =1 - Circuit breaker was tripped on channels 7-0
#define DQ_AO318_STS_CB6            (1L<<6)     //
#define DQ_AO318_STS_CB5            (1L<<5)     //
#define DQ_AO318_STS_CB4            (1L<<4)     //
#define DQ_AO318_STS_CB3            (1L<<3)     //
#define DQ_AO318_STS_CB2            (1L<<2)     //
#define DQ_AO318_STS_CB1            (1L<<1)     //
#define DQ_AO318_STS_CB0            (1L<<0)     //

// AO318 channel status register retrieved by DqAdv318CBStatus() in status[1]+
// Read from this register returns status of the CB, sticky bits are cleared after each read
// Bits 31-16 representing current (dynamic) status
//
#define DQ_AO318_CSTS_DACBSY        (1L<<27)    // =1 when DAC SPI interface is busy
#define DQ_AO318_CSTS_DACFHF        (1L<<26)    // =1 when DAC FIFO word count is below or equal to watermark
#define DQ_AO318_CSTS_DACFE         (1L<<25)    // =1 when DAC FIFO is empty (reads will be ignored)
#define DQ_AO318_CSTS_DACFF         (1L<<24)    // =1 when DAC FIFO is full (writes will be ignored)

#define DQ_AO318_CSTS_DACB          (1L<<23)    // =1 if DACB is currently disabled
#define DQ_AO318_CSTS_UC2           (1L<<22)    // =1 if corresponding "under limit" condition is currently detected, please note that
#define DQ_AO318_CSTS_UC1           (1L<<21)    //    internally generated currents or voltages will be immediately disconnected when
#define DQ_AO318_CSTS_UC0           (1L<<20)    //    the breaker trips, so the "under limit" condition will not be seen.

#define DQ_AO318_CSTS_DACA          (1L<<19)    // =1 if DACA is currently disabled
#define DQ_AO318_CSTS_OC2           (1L<<18)    // =1 if corresponding "over limit" condition is currently detected, please note that
#define DQ_AO318_CSTS_OC1           (1L<<17)    //    internally generated currents or voltages will be immediately disconnected when
#define DQ_AO318_CSTS_OC0           (1L<<16)    //    the breaker trips, so the "over limit" condition will not be seen.

// Bits 15-0 are "sticky" bits, persist until read
#define DQ_AO318_CSTS_DACFRLD       (1L<<8)     // =1 - DAC FIFO reload complete

#define DQ_AO318_CSTS_DACB_S        (1L<<7)     // =1 if DACB was previously disabled
#define DQ_AO318_CSTS_UC2_S         (1L<<6)     // =1 if corresponding "under limit" condition was ever detected
#define DQ_AO318_CSTS_UC1_S         (1L<<5)     //             "             "            "
#define DQ_AO318_CSTS_UC0_S         (1L<<4)     //             "             "            "

#define DQ_AO318_CSTS_DACA_S        (1L<<3)     // =1 if DACA was previously disabled
#define DQ_AO318_CSTS_OC2_S         (1L<<2)     // =1 if corresponding "over limit" condition was ever detected
#define DQ_AO318_CSTS_OC1_S         (1L<<1)     //             "             "            "
#define DQ_AO318_CSTS_OC0_S         (1L<<0)     //             "             "            "

#define DQ_AO318_CH_ID(S)           (((S)>>DQ_AO318_ADCCH_SHIFT)&7)  // extract conversion type from bdata[]
// conversion type, defines conversion type based upon results from DQ_AO318_CH_ID(S) for AO318 model 1.
// These defines are also used by the firmware to program the guardian ADC state machine,
// where the defined values are used to index into the calibration data
#define DQ_AO318_ADC_CH_I           (0)         // output current (over 0.1 Ohm shunt)
#define DQ_AO318_ADC_CH_A_int       (1)         // voltage on the output A at the buffer
#define DQ_AO318_ADC_CH_B_int       (2)         // voltage on the output B at the buffer
#define DQ_AO318_ADC_CH_AB_ext      (3)         // voltage on output after the relay. AKA AO319 Vext
#define DQ_AO318_ADC_CH_TEMP        (4)         // temperature channel

#define DQ_AO318_ADC_CH_UNUSED      (7)         // channel is unused

// conversion type, defines conversion type based upon results from DQ_AO318_CH_ID(S) for AO318 models 020 and 024
#define DQ_AO318_020_ADC_CH_I       (0)         // output current (over 10 Ohm shunt)
#define DQ_AO318_020_ADC_INT_1      (1)         // internal buffer voltage 1  ( deprecated )
#define DQ_AO318_020_ADC_INT_2      (2)         // internal buffer voltage 2  ( deprecated )
#define DQ_AO318_020_ADC_CH_INT_1   (1)         // internal buffer voltage 1
#define DQ_AO318_020_ADC_CH_INT_2   (2)         // internal buffer voltage 2
#define DQ_AO318_020_ADC_CH_EXT     (3)         // voltage on output A after the relay
//#define DQ_AO318_ADC_CH_TEMP      (4)         // temperature channel
//#define DQ_AO318_ADC_CH_UNUSED    (7)         // channel is unused

// conversion type, defines conversion type based upon results from DQ_AO318_CH_ID(S) for TC378 model 1
#define DQ_TC378_ADC_CH_I           (0)         // output current (over 5 Ohm shunt)
#define DQ_TC378_ADC_CH_INT         (1)         // internal buffer voltage 1
#define DQ_TC378_ADC_CH_INT_REF     (DQ_TC378_ADC_CH_UNUSED)     // internal reference (unused)
#define DQ_TC378_ADC_CH_EXT         (3)         // voltage on output after the relay
#define DQ_TC378_ADC_CH_TEMP        (4)         // internal to ADC temperature channel
#define DQ_TC378_CJC_TEMP           (5)         // one of 3 external ADT7420 CJC temperature channels for TC-378 only
#define DQ_TC378_SEC_OFFSET         (6)         // repurpose the unused conversion slot for optional timestamp
#define DQ_TC378_ADC_CH_UNUSED      (7)         // channel is unused, don't attempt conversion

#define DQ_AO318_ADC_VREF           (2.5)       // AO-318 and AO-319

#define DQ_AO318_ISH                (0.1)       //  318-1 shunt = 100mOhms
#define DQ_AO318_ADC_I_STEP         ((DQ_AO318_ADC_VREF/128.0)/65535.0)     // +/-2.5V range * gain(128)=
#define DQ_AO318_ADC_I_OFFSET       (DQ_AO318_ADC_VREF/128.0/2.0)           // (0.00976)

#define DQ_AO318_ISH_020            (10.0)      //  318-020, 318-024 shunt = 10 ohms
#define DQ_AO318_ADC_I_STEP_020     ((DQ_AO318_ADC_VREF/4.0)/65535.0)       // +/-1.25V range * gain(4)
#define DQ_AO318_ADC_I_OFFSET_020   (DQ_AO318_ADC_VREF/4.0/2.0)

#define DQ_AO318_ADC_V_STEP         (2.0*DQ_AO318_ADC_V_OFFSET/65535.0)  // +/-2.5V range/gain(4) and 1/51 divider gives +/-16.0V range
#define DQ_AO318_ADC_V_OFFSET       (16.0)      // 16V range is actually (+-) ((2.5V/2) * 51 / 4) = 15.9375

#define DQ_AO318_T_SLOPE            (0.0000935 / (DQ_AO318_ADC_VREF / 65535.0))  // ADC counts per deg C, ADC4
#define DQ_AO318_T_OFFSET           (273.15)    // Kelvin to deg C

#define DQ_AO318_ADC_I_2_CODE(N)    (((N)-DQ_AO318_ADC_I_OFFSET)/DQ_AO318_ADC_I_STEP)
#define DQ_AO318_ADC_V_2_CODE(N)    (((N)-DQ_AO318_ADC_V_OFFSET)/DQ_AO318_ADC_V_STEP)
#define DQ_AO318_ADC_T_2_CODE(N)    (((N)-DQ_AO318_T_OFFSET)*DQ_AO318_T_SLOPE)

#define DQ_TC378_ISH                (5.0)       //  378-1 Ohms
#define DQ_TC378_ADC_I_STEP         ((DQ_AO318_ADC_VREF/8.0)/65535.0)   // +/-2.5V range * gain(8)=
#define DQ_TC378_ADC_I_OFFSET       (DQ_AO318_ADC_VREF/8.0/2.0)         // (0.00976)

#define DQ_TC378_ADC_V_STEP         (DQ_AO318_ADC_VREF/1.0/65535.0)     //  g=1
#define DQ_TC378_ADC_V_OFFSET       (DQ_AO318_ADC_VREF/1.0/2.0 )        //  g=1, span=vref

#define DQ_TC378_CH_DCJC0           (61)        // channel number for tc378 cjc #0
#define DQ_TC378_CH_DCJC1           (62)        // channel number for tc378 cjc #1
#define DQ_TC378_CH_DCJC2           (63)        // channel number for tc378 cjc #2

#define DQ_AO319_ISH                (10.0)      // 319 shunt = 10 Ohms
#define DQ_AO319_ADC_I_STEP         ((DQ_AO318_ADC_VREF/4.0)/65535.0)   // +/-2.5V range * gain(4)=
#define DQ_AO319_ADC_I_OFFSET       (DQ_AO318_ADC_VREF/4.0/2.0)         //  g=4

#define DQ_AO319_V_SCALER_23        ((499000.0/10000.0)+1.0)  // voltage scaling factor(50.9)    //  voltage scaling factor, ADC2-3
#define DQ_AO319_ADC_V_STEP         ((DQ_AO318_ADC_VREF/1.0/65535.0) * DQ_AO319_V_SCALER_23)     //  g=1
#define DQ_AO319_ADC_V_OFFSET       ((DQ_AO318_ADC_VREF/1.0/2.0 )  * DQ_AO319_V_SCALER_23)       //  g=1, span=vref
#define DQ_AO318_ADCCAL_EN          (1L<<31)  //  =1 if fresh data appears in each bdata element of DqAdv318ReadADC(), auto-cleared
#define DQ_AO318_ADC_NEW            (1L<<31)  //  =1 if fresh data appears in each bdata element of DqAdv318ReadADC(), auto-cleared
#define DQ_AO318_ADCCAL_CB_STS      (1L<<30)  //  =1 if circuit breaker for this channel is tripped (logics 02.14.15 or newer)

#define DQ_AO318_ADCCH_SHIFT        (25)        // 3-bit hw channel number in returned data

#define DQ_AO318_DEF_ADC_OFFS_CAL   (0x0)       // default offset for AO-318 ADC
#define DQ_AO318_MAX_ADC_OFFS_CAL_DEV (0x200)   // Max amount that offset can deviate from default
                                                // offset without throwing a calibration error
#define DQ_AO318_DEF_ADC_GAIN_CAL   (0x8000)    // default gain calibration for AO-318 ADC
#define DQ_AO318_MAX_ADC_GAIN_CAL_DEV (0x0600)  // Max amount that gain can deviate from default

#define DQ_AO318_DEF_DAC_OFFS_CAL   (0x0)       // default offset for AO-318 DAC
#define DQ_AO318_MAX_DAC_OFFS_CAL_DEV (0x200)   // Max amount that offset can deviate from default
                                                // offset without throwing a calibration error
#define DQ_AO318_DEF_DAC_GAIN_CAL   (0x8000)    // default gain calibration for AO-318 DAC
#define DQ_AO318_MAX_DAC_GAIN_CAL_DEV (0x0600)  // Max amount that gain can deviate from default

/* ------------ 318 structures -------------------------------------- */
/* channel names */

// Guardian parameters control

#define DQL_IOCTL318_WR_PRM         (14L)       // write/read guardian parameters for AO-318 (also used by TC-378 and RTD-388)
#define DQ_TC378_ADC_ENB            (0x12)      // setparam subcommand used by DqAdv378ADCEnable() to selectively turn off guardian ADC's

#define DQL_IOCTL318_PRM_SETCB      (0x1)       // set value for CircuitBreaker
#define DQL_IOCTL318_GET_CB_STAT    (0x2)       // request CircuitBreaker status (and re-engage CBs if requested)
#define DQL_IOCTL318_PRM_GETCB      (0x3)       // readback values for CircuitBreaker (used by PowerDNA Explorer)

#pragma pack(1)
// DQAO318BRK_CFG structure is used to send the user's floating point circuit breaker trip values to the 378, 319, 318 or 318-020/024
// by using DqAdv318SetCBLevels(). Internally, the library function will convert the floating point values to integer, then
// populate a DQAO318CFG struct and send the integer values to the 318, 319 or 378 using the DqAdv318SetConfig() call.
typedef struct {
    float  CB_val_min_f[DQ_AO318_CB_CH];        // CB low side breaker compare values,e.g.  -16..0V, -96mA...0,  -30 degreesC
    float  CB_val_max_f[DQ_AO318_CB_CH];        // CB high side breaker compare values,e.g.  0..+16V, 0..96mA  , +70 degreesC
    uint8  units[DQ_AO318_CB_CH];               // V,I,T  selection of Voltage, current(I) or Temperature for breaker compare values
} DQAO318BRK_CFG, *pDQAO318BRK_CFG;

//                                              // units, use in DQAO318BRK_CFG.units
#define DQAO318_CB_UNIT_I           ('I')       // current  in A
#define DQAO318_CB_UNIT_V           ('V')       // voltage, in V
#define DQAO318_CB_UNIT_T           ('T')       // temperature in deg C
#define DQAO318_CB_UNIT_U           ('U')       // unused CB. corresponding CB_val_min_f and CB_val_max_f values will overwritten with values that will never trip
#define DQAO318_CB_UNIT_N           ('N')       // no change, current breaker compare values will remain unchanged

// structure for AO-318 configuration. Used by DqAdv318SetConfig()
typedef struct {
    uint32 prmmask;                             // bitmask: which parameters are valid and needs to be set
    uint32 en_DAC;                              // select A (1) or B (2) outputs or both (3) or turn them off (0)
    uint32 ADC_CL[DQ_AO318_ADC_CH];             // ADC channel list (DQ_AO318_ADC_CH_UNUSED fills unused positions)
    float  ADC_rate;                            // rate of ADC converter if external clock is used 2Hz..50Hz
    uint32 CB_val_min[DQ_AO318_CB_CH];          // CircuitBreaker minimum value, code 0..ffff
    uint32 CB_val_max[DQ_AO318_CB_CH];          // CircuitBreaker maximum value, code 0..ffff
    uint32 CB_mode;                             // CB source (channel) and reenabling mode
    uint32 rdcnt;                               // number -1 of consecutive ADC readings beyond limit that are required to break, 0..15
    float  CB_rate;                             // CB reenabling rate used when DQ_AO318_CB_A_AUTO or DQ_AO318_CB_B_AUTO is used by CB_mode.
                                                // Default setting is 0.5Hz = every 2 seconds, range is from 0.025 to 5 Hz.
} DQAO318CFG, *pDQAO318CFG;

// .prmmask = bitfield to specify what to set
#define DQ_AO318_CBCFG_DAC          (1L<<0)     // (en_DAC is valid) Outputs ON/OFF,  in dual-redundant mode select whether DAC A or B to use
#define DQ_AO318_CBCFG_SETADCCL     (1L<<1)     // (ADC_CL and ADC_rate valid) set CL for ADCs and rate
#define DQ_AO318_CBCFG_SETCB        (1L<<2)     // (CB_val_min and CB_val_max are valid) set min/max CB comparison values
#define DQ_AO318_CBCFG_SETCBSRC     (1L<<3)     // (CB_mode, rdcnt and CB_rate are valid) assign a source ADC channel for each
                                                // circuit-breaker and set re-enabling rate and/or number of attempt to reconnect CBs

// .en_DAC  For DAC selection - select whether DAC_A or DAC_B is enabled with
// DqAdv318SetConfig()  contents of DQAO318CFG.en_DAC when prmmask | DQ_AO318_CBCFG_DAC
// Dual-redundant AO318-1 models only allow 1 output at a time. On AO318-020 and AO318-024 models, only 'DACEN_A is supported
// This selection also allows the user to turn selected outputs OFF. Outputs turned OFF with .en_DAC can only be turned back ON with .en_DAC
#define DQAO318CFG_DACEN_A          (1L<<0)     // A enabled  (A is default upon startup)
#define DQAO318CFG_DACEN_B          (1L<<1)     // B enabled  (B is not for use by AO318-020, AO318-024 or AO-319)
#define DQAO316CFG_DACEN_A_B        (DQAO318CFG_DACEN_A | DQAO318CFG_DACEN_B)     // AO316 models only, both enabled
#define DQAO318CFG_DACEN_OFF        (0)         // AO outputs turned OFF

// .ADC_CL  By default (automatically upon power-up) the ADC_CL is configured as follows:
//      ADC_CL[0] = DQ_AO318_ADC_CH_I;      by using DQ_AO318_ADC0() for AO318-1 and DQ_AO318_ADC0_020() for AO318-020
//      ADC_CL[1] = DQ_AO318_ADC_CH_A_int;  by using DQ_AO318_ADC1()
//      ADC_CL[2] = DQ_AO318_ADC_CH_B_int;  by using DQ_AO318_ADC2()
//      ADC_CL[3] = DQ_AO318_ADC_CH_AB_ext; by using DQ_AO318_ADC3()
//      ADC_CL[4] = DQ_AO318_ADC_CH_TEMP;   by using DQ_AO318_ADC4()
//
//      For example, to acquire only 2 ADC channels, monitoring Output current and output voltage use the following .ADC_CL:
//      ADC_CL[0] = DQ_AO318_ADC_CH_I;
//      ADC_CL[1] = DQ_AO318_ADC_CH_AB_ext;  // for 318-1, or use DQ_AO318_020_ADC_CH_EXT for 318-020
//      ADC_CL[2] = DQ_AO318_ADC_CH_UNUSED;  // prevent wasted ADC conversion time which slows the rate of the wanted channels
//      ADC_CL[3] = DQ_AO318_ADC_CH_UNUSED;  // prevent wasted ADC conversion time
//      ADC_CL[4] = DQ_AO318_ADC_CH_UNUSED;  // prevent wasted ADC conversion time

// .ADC_rate  - sets the ADC conversion rate, legal values for .ADC_rate are:
//      0.0      -  use default 7.5Hz conversion rate
//      2.0
//      5.0
//      7.5      -  also use default 7.5Hz conversion rate
//      10.0
//      20.0
//      30.0
//      40.0
//      50.0
//      Please note that Resolution, linearity and noise performance are all improved as ADC_rate decreases.

// .CB_val_min
// .CB_val_max - These contain the binary values that are compared by the ADC hardware to effect the circuit breaker action.
//      Use DqAdv318SetCBLevels() function to set these values

// .CB_mode. Bitwise OR the following 6 defines as required to form the .CB_mode value
#define DQ_AO318_CB_A_AUTO          (1L<<20)    // enable the auto-reenable of circuit breaker ch.A, else use .CB_rate
#define DQ_AO318_CB_B_AUTO          (1L<<21)    //  ditto B
#define DQ_AO318_CB_A_SEL0(N)       (((N)&3)<<8)// select A breaker 0 ADC source, (N) will be DQ_AO318_MINMAX_0,1,2 or DQ_AO318_MINMAX_DISABLE
#define DQ_AO318_CB_A_SEL1(N)       (((N)&3)<<10)   //    A         1
#define DQ_AO318_CB_B_SEL0(N)       (((N)&3)<<12)   //    B         0
#define DQ_AO318_CB_B_SEL1(N)       (((N)&3)<<14)   //    B         1
                                                // indices to use with DQ_AO318_CB_x_SELx(N) macros
#define DQ_AO318_MINMAX_0           (0)         // use CB_val_min[0] and CB_val_max[0], paired with adc reading defined by ADC_CL[0]
#define DQ_AO318_MINMAX_1           (1)         // use CB_val_min[1] and CB_val_max[1], paired with adc reading defined by ADC_CL[1]
#define DQ_AO318_MINMAX_2           (2)         // use CB_val_min[2] and CB_val_max[2], paired with adc reading defined by ADC_CL[2]
#define DQ_AO318_MINMAX_DISABLE     (3)         // no Circuit Breaker action

// .rdcnt
#define DQ_AO318_CB_COUNT_MIN       (0)         // = 1.   rdcnt may range from 0 to 15
#define DQ_AO318_CB_COUNT_MAX       (15)        // = 16.
#define DQ_AO318_CB_COUNT_DEFAULT   (1)         //
#define DQ_AO319_CB_COUNT_DEFAULT   (0)         //
#define DQ_AO378_CB_COUNT_DEFAULT   (5)         //

// .CB_rate
#define DQAO318CFG_CB_RATE_MAX      (5.0)       // maximum CB reenabling rate,  5 times a second
#define DQAO318CFG_CB_RATE_MIN      (0.025)     // minimum CB reenabling rate,  once every 40 seconds
#define DQAO318CFG_CB_RATE_DEFAULT  (0.5)       // default CB reenabling rate,  every 2 seconds

#define DQ_AO318_NAMELEN            (16)        // maximum length of the channel name (trailing 0 isn't included)

typedef struct {
    char cname[DQ_AO318_CHAN][DQ_AO318_NAMELEN];
} DQCNAMES_318_, *pDQCNAMES_318_;

/* specific device structure - calibration values */
typedef struct {
    uint16 gain_a[DQ_AO318_CHAN];   // for each channel of DAC A
    uint16 offs_a[DQ_AO318_CHAN];
    uint16 gain_b[DQ_AO318_CHAN];   // for each channel of DAC B
    uint16 offs_b[DQ_AO318_CHAN];
    uint16 gain_adc[DQ_AO318_CHAN][DQ_AO318_ADC_CH];    // Gain for ADC channels, indexed by bits 27:25 of returned data
    uint16 offs_adc[DQ_AO318_CHAN][DQ_AO318_ADC_CH];    // Offset for ADC channels, indexed by bits 27:25 of returned data
} DQCALSET_318_, *pDQCALSET_318_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AO318_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    uint32 cfg;                     // mode configuration
    uint16 val_a[DQ_AO318_CHAN];    // values for op mode (DAC A)
    uint16 val_b[DQ_AO318_CHAN];    // values for op mode (DAC B)
    uint32 cb_minmax[DQ_AO318_CHAN][DQ_AO318_CB_CH];   // default max/min CB values
    uint32 cb_mode[DQ_AO318_CHAN];  // default CB behavior
    int clperint;                   // DQ_FIFO_CLPERINT by default
    uint32 rsv[DQ_AO318_CHAN];      // reserved for future use
} DQOPMODEPRM_318_, *pDQOPMODEPRM_318_;

typedef struct {
    uint32 cfg;                     // mode configuration (user-level flags, like op mode)
    uint16 val_a[DQ_AO318_CHAN];    // values for init mode (DAC A)
    uint16 val_b[DQ_AO318_CHAN];    // values for init mode (DAC B), sets fixed offset for -020, -024 -420 and 378
    uint32 adc_cl[DQ_AO318_CHAN][DQ_AO318_ADC_CH];     // adc channel list
    uint32 cb_minmax[DQ_AO318_CHAN][DQ_AO318_CB_CH];   // default max/min CB values
} DQINITPRM_318_, *pDQINITPRM_318_;

typedef struct {
    uint32 cfg;                     // mode configuration (user-level flags, like op mode)
    uint16 val_a[DQ_AO318_CHAN];    // values for shutdown mode (DAC A)
    uint16 val_b[DQ_AO318_CHAN];    // values for shutdown mode (DAC B), sets fixed offset for -020 -024 and 378
} DQSDOWNPRM_318_, *pDQSDOWNPRM_318_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_318_ calset;
    DQCNAMES_318_ cname;
    DQOPMODEPRM_318_ opmodeprm;
    DQINITPRM_318_ initprm;
    DQSDOWNPRM_318_ sdownprm;
    DQPRMFLAGS eeflags;
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQCALSET_318_)
                           - sizeof(DQCNAMES_318_)
                           - sizeof(DQOPMODEPRM_318_)
                           - sizeof(DQINITPRM_318_)
                           - sizeof(DQSDOWNPRM_318_)
                           - sizeof(DQPRMFLAGS)
                           - sizeof(uint32)];   // crc
} DEVEEPROM_318_, *pDEVEEPROM_318_;
#pragma pack()



// definitions for AO-358 layer CLI part
#define DQ_AO358_CHAN               (8)         // working channels
#define DQ_AO358_CH_MASK            (DQ_AO358_CHAN-1) // working channel mask
#define DQ_AO358_FIFO_CH            (128)
#define DQ_AO358_CL_TIMES           (2)         // upper and lower part of the buffer
#define DQ_AO358_ADC_CHAN_CHAN      (5)         // number of ADC channels per channel
#define DQ_AO358_ADC_CHANS          (DQ_AO358_CHAN*DQ_AO358_ADC_CHAN_CHAN)  // total # of ADC channels
#define DQ_AO358_ADC_CHAN_MASK      (0x07)      // mask to isolate DQ_AO358_ADC_CHAN_CHAN
#define DQ_AO358_INFOSZ             (DQ_MAX_INFO_SIZE) // maximum size of information structure
#define DQ_AO358_BASE               (BUS_FREQUENCY)  // 66MHz base frequency

#define DQ_AO358_DMAPCV             ((DQ_AO358_BASE/8000)-1)
#define DQ_AO358_STARTRATE          (DQ_AO358_DMAPCV)

#define DQ_AO358_MAXCLFRQ           (10000)
#define DQ_AO358_MAXCVFRQ           (DQ_AO358_MAXCLFRQ*DQ_AO358_CHAN)     // 10kHz per channel
#define DQ_AO358_DEF_MIDPOS         (800)

//---------------------------------------------------------------------------------------
// LCR specific bits
#define DQ_AO358_LCR_LED            (1L<<1)     // LED control in LCR
#define DQ_AO358_LCR_DCDIS          (1L<<0)     // Disable all DC/DC


// user cmd defines for DqAdv358ExCalAccess()
#define DQ_AO358_EE_CHK_STS         (0x01)      // check status of read, write or erase function
#define DQ_AO358_EE_RD_ID_ADDR      (0x21)      // Read silicon ID, set read address, read address is
                                                // auto-incremented by size of read command
#define DQ_AO358_EE_RD              (0x22)      // Issue Read command - 1 to 1024 bytes
#define DQ_AO358_EE_WR_OPEN         (0x31)      // open the device for writing, set write address, address
                                                // is auto-incremented by size of write command
#define DQ_AO358_EE_ERASE           (0x32)      // Erase device
#define DQ_AO358_EE_WR              (0x33)      // Write bytes command - 1-256 data bytes
#define DQ_AO358_EE_WR_CLOSE        (0x34)      // close the device for writing
#define DQ_AO358_EE_ERASE_SECTOR    (0x35)      // erase 1/4 of the device

#define DQ_AO358_EE_RD_MAX_LEN      (1024)      // read 1Kb per call
#define DQ_AO358_EE_WR_MAX_LEN      (256)       // write 256 bytes per call

// value returned by DQ_AO358_EE_RD_ID_ADDR command
#define DQ_AO358_EE_ID_1M           (0x10)      // id is for 131072 byte part default
#define DQ_AO358_EE_ID_4M           (0x12)      // id is for 524288 byte part optional

// values returned by DQ_AO358_EE_CHK_STS command
                                                // returned 32bit word [0], nonzero = system is busy
#define DQ_AO358_EE_ESTS_COMPLETE   (1L<<31)    // returned 32bit word [1], =1, ee operation complete
#define DQ_AO358_EE_ESTS_ERR        (1L<<30)    // returned 32bit word [1], =1, invalid command detected
#define DQ_AO358_EE_ESTS_BUSY       (1L<<4)     // returned 32bit word [1], =1, ee system is busy
#define DQ_AO358_EE_ESTS_RFF        (1L<<3)     // returned 32bit word [1], =1, read fifo is full
#define DQ_AO358_EE_ESTS_RFHF       (1L<<2)     // returned 32bit word [1], =1, read fifo above watermark
#define DQ_AO358_EE_ESTS_WFE        (1L<<1)     // returned 32bit word [1], =1, write fifo empty
#define DQ_AO358_EE_ESTS_WFHF       (1L<<0)     // returned 32bit word [1], =1, write fifo below watermark
#define DQ_AO358_EE_INVALID_RDSTS   (1L<<31)    // returned 32bit word [2], =1, status is invalid
#define DQ_AO358_EE_RDSTS_BP        (3L<<2)     // returned 32bit word [2], =1, write protected
#define DQ_AO358_EE_RDSTS_WEL       (1L<<1)     // returned 32bit word [2], =1, write enabled
#define DQ_AO358_EE_RDSTS_WIP       (1L<<0)     // returned 32bit word [2], =1, write in progress
                                                // returned 32bit word [3] = read address
                                                // returned 32bit word [4] = write address
#define DQ_AO358_EE_CHKSTS_RETLEN   (5)         // EE_CHK_STS command returns 5 words

#define DQ_UNUSED_FOR_THIS_CMD      (0)

// values used internally by DqAdv358Write()
#define DQ_AO358_WRITE_STOP         ((3L<<22)|(3L<<10)) // value used internally by DqAdv358Write()
#define DQ_AO358_WR_CH_SHIFT        (28)        // shift position of channel number in ACB data
#define DQ_AO358_FINE_SHIFT         (12)        // shift position of fine code in ACB data
#define DQ_AO358_COARSE_SHIFT       (0)         // shift position of coarse code in ACB data
#define DQ_AO358_WR_CMD_ACB         (1<<24)     // write command for ACB data


// user helper macro for DqAdv358Write(), combines the channel number, coarse and fine settings
#define DQ_AO358_CFCH_MERGE(C,F,CH) (((C)&0x3FF)|(((F)&0x3FF)<<DQ_AO358_FINE_SHIFT)|((CH)<<DQ_AO358_WR_CH_SHIFT))

//Each AO358 channel has these 5 AI channels, aka ADC subchannels
#define DQ_AO358_SUBCH_I_SENSE      (0)         // current through the variable resistance
#define DQ_AO358_SUBCH_EX1          (1)         // excitation across variable part of bridge
#define DQ_AO358_SUBCH_EX2          (2)         // excitation across fixed part of bridge
#define DQ_AO358_SUBCH_VS_N         (3)         // voltage on S-
#define DQ_AO358_SUBCH_THERM        (4)         // temperature of ADC near bridge

// AO-358 channel list helper macro. Combines the channel and ADC subchannel numbers for DqAdv358ReadADC()
#define DQ_AO358_MAKE_CL(CH,SUBCH)  ((((CH)&DQ_AO358_CH_MASK)<<3)|((SUBCH)& DQ_AO358_ADC_CHAN_MASK))
#define DQ_AO358_CL_MASK            (0x3f)      // mask to isolate result of DQ_AO358_MAKE_CL()

// AO-358 Read ADC conversion factors
#define DQ_AO385_AI_SPAN            (5.0)
#define DQ_AO385_OFFSET             (DQ_AO385_AI_SPAN/2.0)
#define DQ_AO385_STEP               (DQ_AO385_AI_SPAN/(double)0xffffff)
#define DQ_AO385_EXC_SCALER         (51.75124)  // excitation voltage scaling factor
#define DQ_AO385_350_I_SHUNT        (4.7)       // voltage to current conversion factor
#define DQ_AO385_T_SLOPE            (0.0000935 / DQ_AO385_STEP)     // ADC counts per deg C
#define DQ_AO385_T_OFFSET           (273.15)    // Kelvin to deg C

#define DQ_AO385_EXC_SCALER_700     (51.73)     // resistor voltage scaling factor
#define DQ_AO385_R4_MIN_350         (344.75)    // min resistance of option 350
#define DQ_AO385_R4_MAX_350         (355.25)    // max resistance of option 350
#define DQ_AO385_R4_MIN_350_804     (341.50)    // min resistance of option 804
#define DQ_AO385_R4_MAX_350_804     (358.50)    // max resistance of option 804
#define DQ_AO385_AO_SPAN_350_804    (DQ_AO385_R4_MAX_350_804-DQ_AO385_R4_MIN_350_804)
#define DQ_AO385_AO_SPAN_350        (DQ_AO385_R4_MAX_350-DQ_AO385_R4_MIN_350)
#define DQ_AO385_R4_MIN_700         (700.0)     // min resistance of option 700
#define DQ_AO385_R4_MAX_700         (1500.0)    // max resistance of option 700
#define DQ_AO385_R4_MIN_102         (984.0)     // min resistance of option 102
#define DQ_AO385_R4_MAX_102         (1016.0)    // max resistance of option 102
#define DQ_AO385_AO_SPAN_102        (DQ_AO385_R4_MAX_102-DQ_AO385_R4_MIN_102)
#define DQ_AO358_R_END_102          (196.0)
#define DQ_AO358_R_END_DEFAULT      (0.0)

// ------- calibration constants used internally by DAQLib and calibration software ------
// AO-358-350 option   (option 835 too)
#define DQ_AO385_RLUT_SZ            (65536)
#define DQ_AO385_RFINE_AT_CAL       (256)
#define DQ_AO385_RFINE_AT_CAL_804   (256)
#define DQ_AO385_RPOT_MASK          (0x3ff)
#define DQ_AO385_RPOT_MAX           (1023.0)    // double, # of steps in digipot
#define DQ_AO385_RPOT_MAX_I         (1023)      // integer
#define DQ_AO358_RPOTNOM_350        (20000.0)   // nominal value of the pot
#define DQ_AO358_RWIPER_350         (60.0)      // wiper resistance in Ohms
#define DQ_AO358_R123_350           (1050.011)  // Ohm
#define DQ_AO358_RPAR_350           (365.0)
#define DQ_AO358_RPAR_350_804       (370.0)
#define DQ_AO358_RDIV_350           (20804.0)
#define DQ_AO358_RPROTC_350         (3000.0)    // coarse protection resistance
#define DQ_AO358_RPROTC_350_804     (2490.0)    // coarse protection resistance
#define DQ_AO358_RPROTF_350         (120000.0)  // fine protection resistance
#define DQ_AO358_RPROTF_350_804     (110000.0)  // fine protection resistance
#define DQ_AO358_RF_0X100_350       (5004.887586)   // when calibration is performed, the fine pot is held constant at 0x100.
                                                    // This is the calculated value of the 20K pot at 0x100
#define DQ_AO358_RSTART_350         (344.75)
#define DQ_AO358_RSTART_350_804     (341.50)
#define DQ_AO358_CONVERGE_LIMIT     (500)
#define DQ_AO358_R4DELTA            (12.37112)
#define DQ_AO358_R4DELTA_804        (22.54399)
#define DQ_AO358_R4FDELTA           (0.09885)
#define DQ_AO358_R4FDELTA_804       (0.12274)

// values for AO-358-700 option
#define DQ_AO358_R123_700           (-1.0)      // -1.0 is open circuit
#define DQ_AO385_RFINE_AT_CAL_700   (0x00)
#define DQ_AO358_RPAR_700           (1740.0)
#define DQ_AO358_RDIV_700           (51730.0)
#define DQ_AO358_RPROTC_700         (0.0)
#define DQ_AO358_RPROTF_700         (22100.0)
#define DQ_AO358_RSTART_700         (700.0)
#define DQ_AO385_AO_SPAN_700        (800.0)
#define DQ_AO358_R4DELTA_700        (341.93255)
#define DQ_AO358_R4FDELTA_700       (26.8884)
#define DQ_AO358_RF_0X14_700        (0)         // when calibration is performed, the fine pot is held constant at 0x.
                                                // This is the calculated value of the 20K pot at 0x00
// values for AO-358-102 option  (1000 ohm)
#define DQ_AO358_R123_102           (3000.0953)
#define DQ_AO385_RFINE_AT_CAL_102   (0x00)
#define DQ_AO358_RPAR_102           (909.0)
#define DQ_AO358_RDIV_102           (20804.0)
#define DQ_AO358_RPROTC_102         (4999.0)
#define DQ_AO358_RPROTF_102         (120000.0)
#define DQ_AO358_RPOTNOM_102        (20000.0)   // nominal value of the pot
#define DQ_AO358_RWIPER_102         (60.0)      // wiper resistance in Ohms
#define DQ_AO358_RSTART_102         (981.554)
#define DQ_AO358_R4DELTA_102        (48.423)
#define DQ_AO358_R4FDELTA_102       (0.53118)
#define DQ_AO358_RF_0X100_102       (0)         // when calibration is performed, the fine pot is held constant at 0x100.
                                                // This is the calculated value of the 20K pot at 0x00


/* specific device structure - calibration values */

#define DQ_AO358_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)
#pragma pack(1)

/* ------------ 358 structures -------------------------------------- */
/* channel names */
typedef struct {
    char cname[DQ_AO358_CHAN][DQ_AO358_NAMELEN];
} DQCNAMES_358_, *pDQCNAMES_358_;

/* specific device structure - calibration values */
typedef struct {
    uint32 placeholder;
} DQCALSET_358_, *pDQCALSET_358_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_AO358_CHAN*2];  // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    uint32 cfg;                     // mode configuration
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_358_, *pDQOPMODEPRM_358_;

typedef struct {
    uint32 cfg;                     /* mode configuration (user-level flags, like op mode) */
} DQINITPRM_358_, *pDQINITPRM_358_;

typedef struct {
    uint32 cfg;                     /* mode configuration (user-level flags, like op mode) */
    uint16 sd_coarse[DQ_AO358_CHAN];/* coarse pot setting in shutdown mode */
    uint16 sd_fine[DQ_AO358_CHAN];  /*  fine  pot setting in shutdown mode */
} DQSDOWNPRM_358_, *pDQSDOWNPRM_358_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQPRMFLAGS eeflags;
    DQCALSET_358_ calset;
    DQOPMODEPRM_358_ opmodeprm;
    DQINITPRM_358_ initprm;
    DQSDOWNPRM_358_ sdownprm;
    DQCNAMES_358_ cname;
} DEVEEPROM_358_, *pDEVEEPROM_358_;
#pragma pack()


#define DQL_IOCTL358_WRITEWF        (10L)       // 0x0a write waveform
#define DQL_IOCTL358_CTRLWF         (11L)       // 0x0b control waveform output
#define DQL_IOCTL358_RW_XEEPROM     (0x0f)      // read and write extended eeprom device

#pragma pack(1)
typedef struct {
    uint32  adc_gain[DQ_AO358_ADC_CHAN_CHAN];
    uint32  adc_offs[DQ_AO358_ADC_CHAN_CHAN];
    uint16  dp_cal_mid_fine;        // calibrated null (350 ohm, 1100 ohm) f
    uint16  dp_cal_mid_coarse;      // calibrated null (350 ohm, 1100 ohm) c
    uint16  min_coarse;             // calibrated protection value
    uint16  resvd1;
    double  r_3ff0c0;               // value measured at calibration time, used to calculate the gain calibration of fine pot.f=3ff,c=c0
    double  resvd3;
    //         values of the resistors in milliohms for:
    //                                option 350 or 835       option 700        option 804     option 102
    uint32  r_shunt;                //       4,700              4,700             4,700          4,700+r_end
    uint32  r_prot_c;               //   3,000,000                  0         2,490,000      4,999,000
    uint32  r_prot_f;               // 120,000,000         22,100,000       110,000,000    120,000,000
    uint32  r_par;                  //     365,000          1,740,000           370,000        909,000
    uint32  r_end;                  //           0                  0                 0        196,000
    uint32  r_div;                  //  20,804,000         51,730,000        20,804,000     20,804,000
    uint32  r_br_1;                 //     350,000         0xffffffff           350,000      1,000,000
    uint32  r_br_2;                 //     350,000         0xffffffff           350,000      1,000,000
    uint32  r_br_3;                 //     350,011         0xffffffff           350,011      1,000,095
    uint32  r_wiper;                //      60,000             60,000            60,000         60,000
    uint32  r_pot_nom;              //  20,000,000         20,000,000        20,000,000     20,000,000
    uint32  r_f_at_cal;             //   5,004,888                  0         5,004,888
    uint32  r_span;                 //      10,500            800,000            17,500         32,000
    uint32  r_start;                //     344,750            700,000           341,250        981,554
    uint32  rf_at_cal;              //       0x100                  0             0x100
    double  r4delta;                //  (12.37112)         (341.9325)        (22.54399)     (48.42314)
    double  r4fdelta;               //   (0.09885)         (26.88843)         (0.12274)      (0.53118)
    uint32  r_offs;                 //                         10,150   //  signed value in milliohms + 10,000
    uint32  r_gain;                 //                         10,570   //  signed value in milliohms + 10,000

    uint32  resvd2[27];             // extra space to make struct be 256 bytes long
} DQ_358CAL_HEAD, *pDQ_358CAL_HEAD;

typedef struct {                    // 16384 bytes
    DQ_358CAL_HEAD cal_data;
    double dp_cal_c[1024];          // resistance value of all settings of coarse pot with fine pot setting held at 0x100
    double reserved2[992];
} DQEXCAL_358, *pDQEXCAL_358;

typedef struct {                    // 131072
    DQEXCAL_358 chnl[DQ_AO358_CHAN];
} DQEXCAL_358_8, *pDQEXCAL_358_8;
#pragma pack()


#define DQ_AO364_CHAN               (4)
#define DQ_AO364_CHAN_MASK          (0x3)
#define DQ_AO364_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_AO364_BASE_66            (66000000)   // 66MHz DNx base frequency
#define DQ_AO364_PLL_BASE           (264000000)  // 264MHz rate of the "central" PLLs

#define DQ_AO364_DAC_RES            16
#define DQ_AO364_SPAN               (24.0)
#define DQ_AO364_OFFSET             (12.0)
#define DQ_AO364_STEP               (DQ_AO364_SPAN/0xFFFF)

#define DQ_AO364_ODAC_RES           20
#define DQ_AO364_ODAC_SPAN          (24.0)
#define DQ_AO364_ODAC_OFFSET        (12.0)
#define DQ_AO364_ODAC_STEP          (DQ_AO364_ODAC_SPAN/0xFFFFF)    // 20 bit converter is an option
#define DQ_AO364_ODAC_STEP16        (DQ_AO364_ODAC_SPAN/0xFFFF)

#define AO364_DEV_MODEL             0x364
#define DQ_AO364_DEV_MODEL          (0x364)
#define DQ_AO364_LOGIC_VER_RTDMAP   (0x1523)    // minimum logic version required for rtdmap support ,
                                                // old versions can give a -13 error in DqAdv364ConvertSim()
#define DQ_AO364_DMAPCV             (DQ_AO364_BASE_66/1000-1)

#define DQ_AO364_DAC_CH             0x10      // an offset to access main DAC channels in the channel list
#define DQ_AO364_DAC_GAIN1          0x20      // flag tells to force gain of 1
#define DQ_AO364_DAC_GAIN2          0x60      // flag tells to force gain of 2
#define DQ_AO364_DAC_GAIN5          0xA0      // flag tells to force gain of 5
#define DQ_AO364_DAC_GAIN10         0xE0      // flag tells to force gain of 10

// special RTDMAP channel numbers, bitwise OR to channel number
#define DQ_AO364_MAP_GAIN_CH        (0x0100)    // rtdmap channel, gain
#define DQ_AO364_MAP_OFFS_CH        (0x0200)    // rtdmap channel, offset
#define DQ_AO364_MAP_DFCW_CH        (0x0300)    // rtdmap channel, frequency
#define DQ_AO364_MAP_DSCR_CH        (0x0400)    // rtdmap channel, shift


#define DQ_AO364_DAC_MIDSCALE       0x7fff   // mid scale for main DAC (16 bit)
#define DQ_AO364_ODAC_MIDSCALE      0x7ffff  // mid scale for offset DAC (20 bit, 18 are valid)

#define DQ_AO364_DAC_M12            0x1      // set main DAC to -14V (16 bit)
#define DQ_AO364_DAC_P12            0xFFFE   // set main DAC to +14V (16 bit)
#define DQ_AO364_ODAC_M12           0x1      // set offset DAC to -14V (20 bit, 18 are valid)
#define DQ_AO364_ODAC_P12           0xFFFFE  // set offset DAC to +14V (20 bit, 18 are valid)

//#define DQ_AO364_DAC_M14            0x2AF    // set main DAC to -14V (16 bit)
//#define DQ_AO364_DAC_P14            0xFD50   // set main DAC to +14V (16 bit)
//#define DQ_AO364_ODAC_M14           0x2AF8   // set offset DAC to -14V (20 bit, 18 are valid)
//#define DQ_AO364_ODAC_P14           0xFD508  // set offset DAC to +14V (20 bit, 18 are valid)

#define DQ_AO364_PLL                (4)         // number of PLLs available per channel

#define DQ_AO364_MAXCLFRQ           (200000)    // maxmium waveform frequency
#define DQ_AO364_MINCLFRQ           (1.0/(4096*256)) // minimum waveform frequency ~=1uHz

#define DQ_AO364_MINQUANT           (1000000)   // minimum quantization frequency main DAC
#define DQ_AO364_MAXQUANT           (16500000)  // maximum quantization frequency main DAC
#define DQ_AO364_MAXQUANT_ODAC      (1000000)   // maximum quantization frequency offset DAC


// DIO0, DIO1 - source selectiong, DIR0, DIR1 - output if TRUE/input if FALSE
#define AO364IS_SYNC_DIO(DIO0, DIR0, DIO1, DIR1)  ((((DIO0)&0x3F)<<4)|(((DIO1)&0x3F)<<12)|((DIR0)?AO364IS_DIO_DIR0:0)|((DIR1)?AO364IS_DIO_DIR1:0))

// Available DIO sources
#define AO364IS_DIO_SW_OCLK        (14)       // Offset DAC clock
#define AO364IS_DIO_SW_DCLK        (13)       // Main DAC clock
#define AO364IS_DIO_SW_TOUT        (12)       // Trigger output, available only on channel 0
#define AO364IS_DIO_SW_TIN         (11)       // Trigger input, available only on channel 0
#define AO364IS_DIO_SW_ATRG        (10)       // TRIG_IN line
#define AO364IS_DIO_SW_REF1        (9)        // Delay IC1 reference output
#define AO364IS_DIO_SW_REF0        (8)        // Delay IC0 reference output
#define AO364IS_DIO_SW_DLY1        (7)        // Delay IC1 clock output
#define AO364IS_DIO_SW_DLY0        (6)        // Delay IC0 clock output
#define AO364IS_DIO_SW_PLL4        (5)        // PLL4 clock output
#define AO364IS_DIO_SW_PLL3        (4)        // PLL3 clock output
#define AO364IS_DIO_SW_PLL2        (3)        // PLL2 clock output
#define AO364IS_DIO_SW_PLL1        (2)        // PLL1 clock output
#define AO364IS_DIO_SW_ONE         (1)        // Static output - logic one
#define AO364IS_DIO_SW_ZERO        (0)        // Static output - logic zero


// Read bits
#define AO364IS_DIO_DIO1_HL    (1L<<23)   // High-low transition on DIO1 was detected,
                                          // auto-cleared after read from AO364IS_DIO
#define AO364IS_DIO_DIO1_LH    (1L<<22)   // Low-high transition on DIO1 was detected,
                                          // auto-cleared after read from AO364IS_DIO
#define AO364IS_DIO_DIO0_HL    (1L<<21)   // High-low transition on DIO0 was detected,
                                          // auto-cleared after read from AO364IS_DIO
#define AO364IS_DIO_DIO0_LH    (1L<<20)   // Low-high transition on DIO0 was detected,
                                          // auto-cleared after read from AO364IS_DIO
#define AO364IS_DIO_DIO1       (1L<<19)   // Current state of the DIO1
#define AO364IS_DIO_DIO0       (1L<<18)   // Current state of the DIO0
// Bits 16-0 represent last data written to AO364IS_DIO

#define AO36IS_NUM_GAINS       (4)        // Number of gains: 1,2,5,10


//#define AO364IS_PGA            0014,    // W    PGA gain selector register
// By default AO-364 uses PGA AD8250 with gains 1/2/5/10, there are pin-compatible parts with
// gains 1/2/4/8 (AD8251) and 1/10/100/1000 (AD8253). Gain is set via AO364IS_PGA register,
// gain can be set directly by writing to this register or indirectly as part of the offset
// DAC waveform data
#define AO364IS_PGA_A1        (1L<<1)        // Drives PGA pin A1
#define AO364IS_PGA_A0        (1L<<0)        // Drives PGA pin A0
#define AI364IS_PGA_GAIN(G)   ((G)&0x3)

#define AI364IS_PGA_GAIN10   3
#define AI364IS_PGA_GAIN5    2
#define AI364IS_PGA_GAIN2    1
#define AI364IS_PGA_GAIN1    0


// default PLL loop filter values for 264MHz from 66Mhz
#define AO364_C3PLL0_CFG_R        (27)   // loop resistance - 5 bits
#define AO364_C3PLL0_CFG_C        (0)    // loop filter cap - 2 bits
#define AO364_C3PLL0_CFG_I        (1)    // charge pump current - 3 bits
#define AO364_C3PLL0_M            (16)   // default modulus for m counter
#define AO364_C3PLL0_N            (4)    // default modulus for n counter
#define AO364_C3PLL0_C0           (1)    // output 0 post-scale counter = 20MHz
#define AO364_C3PLL0_C2           (1)    // output 1 post-scale counter
#define AO364_C3PLL0_VCO_POST     (1)    // vco post divider 1 bit


// default PLL loop filter values for 10,737,419Hz clock from 264MHz
#define AO364_C3PLL1_CFG_R        (27)   // loop resistance - 5 bits
#define AO364_C3PLL1_CFG_C        (0)    // loop filter cap - 2 bits
#define AO364_C3PLL1_CFG_I        (1)    // charge pump current - 3 bits
#define AO364_C3PLL1_M            (46)   // default modulus for m counter
#define AO364_C3PLL1_N            (13)   // default modulus for n counter
#define AO364_C3PLL1_C0           (87)   // output 0 post-scale counter = 20MHz
#define AO364_C3PLL1_C2           (1)    // output 1 post-scale counter
#define AO364_C3PLL1_VCO_POST     (1)    // vco post divider 1 bit

#define DQ_AO364IS_DDDSCR_SHT_STD   (18)        // take upper 12 bits from 32-bit NCO for
#define DQ_AO364IS_DFWC_PERIOD_F    (100.0001699) // the same in double precision
// ----- AO364 constants exported to the library --------------

#pragma pack(1)

// IOCTLs
#define DQL_IOCTL364_SETCFG         (0x8)       // set configuration
#define DQL_IOCTL364_TRIGSWEEP      (0x9)       // trigger sweep
#define DQL_IOCTL364_RSV1           (0xA)       // reserved
#define DQL_IOCTL364_START          (0xB)       // get calculated waveform parameters
#define DQL_IOCTL364_RSV2           (0xC)       // reserved
#define DQL_IOCTL364_DIO            (0xD)       // read-write DIO
#define DQL_IOCTL364_SETEXT         (0xE)       // Set extended parameters <reserved>
#define DQL_IOCTL364_RW_XEEPROM     (0xF)       // read and write extended eeprom device

#define DQL_IOCTL364_SET_WF         (0x1001L)   // Set waveform parameters
#define DQL_IOCTL364_SET_AWF        (0x1002L)   // Set AWF parameters
#define DQL_IOCTL364_WRITE_AWF      (0x1003L)   // Write samples for AWF
#define DQL_IOCTL364_SELECT_AWF     (0x1004L)   // Select one of the stored waveform and its parameters
#define DQL_IOCTL364_SET_SWEEP      (0x1005L)   // Set sweep function parameters
#define DQL_IOCTL364_SET_OWF        (0x1006L)   // Set Offset WF parameters
#define DQL_IOCTL364_WRITE_OWF      (0x1007L)   // Write samples for Offset WF
#define DQL_IOCTL364_SET_CLKS       (0x1008L)   // Set/retrieve base clock frequencies
#define DQL_IOCTL364_SET_WF_CL      (0x1009L)   // Set waveform parameters simultaneously using channel list
#define DQL_IOCTL364_SET_PLL        (0x100AL)   // program PLL
#define DQL_IOCTL364_SET_TMR1       (0x100BL)   // program TMR1 as a trigger source

// For DQL_IOCTL364_SETCFG      parameters for DqAdv364SetConfig()
//
// Update clock and/or trigger can be generated either on the channel (suffix "_C") or on the layer (suffix "_L")
// Since there is only a single TRIG_IN line for each channel from the NIS side either clock or trigger
// can be routed to the isolated channel
//
// Every isolated channel has TRIG_IN line from NIS side and DIO0 (normally clock) and DIO1 (normally trigger)
// from the 62-pin connector
// Ch0 has two additional lines CH0-TIN and CH0-TOUT
//
//
//         +-----------+                              +---------+
// DIO0 -> | Channel 0 | <- TRIG_IN     - isolation - |   NIS   |
// DIO1 -> |           | <- CH0_TIN     -             |         | --> SYNC0
//         |           | -> CH0_TOUT    -             |         | --> SYNC2
//         +-----------+                              |         |
//             . . .                                  |         | <-- SYNC1
//         +-----------+                              |         | <-- SYNC3
// DIO0 -> | Channels  | <- TRIG_IN     - isolation - |         |
// DIO1 -> |   1..3    |                              |         |
//         |           |                              |         |
//         +-----------+                              +---------+
//
//
// Channel 0 has a special hardware to synchronize waveform with other channels. It can generate clock on CH0-TOUT
// and NIS logic distribute clock to TRIG_IN of each channel. Simultaneously this clock can be fed into SYNC0 or SYNC2
// to be distributed to other layers and/or other racks. Thus a multi-rack installation can be synchronized to a single
// layer
//
// Every channel including channel 0 can use NIS clock from CH0_TIN and named ALT0
// The source of this clock is selected in <sync_mode>
//
// Configurations examples
//  <clk_src> = clock source      <trig_src> = trigger source      <syncmode> = clock/trigger routing
//
// Independent channels
// DQ_AO364CFG_CLK_PLL_C           DQ_AO364CFG_TRG_...                   0
//
// Externally clocked from DIO0 line
// DQ_AO364CFG_CLK_DIO0_C          DQ_AO364CFG_TRG_...                   0
//
// Syncrhonized with channel 0
// channel 0
// DQ_AO364CFG_CLK_PLL_C           DQ_AO364CFG_TRG_...                   DQ_AO364CFG_CLKOUT_CH0
// other channels
// DQ_AO364CFG_CLK_ALT0_L          DQ_AO364CFG_TRG_CONT_L                0
//
// When multile layers/racks are synchronized with Ch0
//
// channel 0
// DQ_AO364CFG_CLK_PLL_C           DQ_AO364CFG_TRG_...                   DQ_AO364CFG_CLKOUT_SYNCx
// other channels
// DQ_AO364CFG_CLK_SYNCx_L         DQ_AO364CFG_TRG_CONT_L                0
//
//
// Channel 0 triggered from a SYNCx line
// DQ_AO364CFG_CLK_...             DQ_AO364CFG_TRG_ALT0_C
//
//
// ---------------------------------------------
// clock sources <clk_src> ---------------------
// offset DAC
#define DQ_AO364CFG_OCLK_DIO1       (4L<<8)     // use channel DIO0 line for clock
#define DQ_AO364CFG_OCLK_DIO0       (3L<<8)     // use channel DIO1 line for clock
                                                // make sure there is no collision between offset DAC clock and
                                                // external main DAC clock (DIO0) and Trigger (DIO1)
                                                // and DIO line is not assigned for output
#define DQ_AO364CFG_OCLK_DAC        (2L<<8)     // main DAC clock divider is a source of ODAC
#define DQ_AO364CFG_OCLK_PLL        (1L<<8)     // PLL is the source of ODAC (clock is independent to main DAC)
                                                // an integer fraction of the main DAC frequency is used to clock offset DAC
                                                // for offset DAC PLL4 is selected as a default. It may be re-assigned or disabled if
                                                // the main DAC uses this PLL
#define DQ_AO364CFG_OCLK_SW         (0L<<8)     // ODAC is clocked in the software (DC offset only)

// main DAC
#define DQ_AO364CFG_CLK_SYNC2_L     (7L<<0)     // use SYNC2 line for clock (SYNC2 -> TRIG_IN)
#define DQ_AO364CFG_CLK_SYNC0_L     (5L<<0)     // use SYNC0 line for clock (SYNC0 -> TRIG_IN)
#define DQ_AO364CFG_CLK_ALT0_L      (4L<<0)     // use channel 0 clock routed from (CH0_TOUT -> TRIG_IN) of the channel
#define DQ_AO364CFG_CLK_TMR_L       (3L<<0)     // clock from internal TMR1 timebase (NIS TMR0 -> TRIG_IN)

#define DQ_AO364CFG_CLK_DIO0_C      (2L<<0)     // use channel DIO0 line for clock
#define DQ_AO364CFG_CLK_PLL_C       (1L<<0)     // clock channel from its own PLL
                                                // Note: in PLL mode channel starts to use PLL1 as a clock source
                                                // but switched to PLL4 when another frequency is selected since 66MHz->PLL2->PLL1 and
                                                // 66MHz->PLL3->PLL4 to have a secondary precise base frequency to step onto
                                                // Since PLL takes 0.5s to settle there is no sweep in PLL mode
#define DQ_AO364CFG_CLK_SW          (0L<<8)     // DAC is clocked in the software (DC offset only)

// trigger sources <trig_src> ------------------
// DqAdv364SetConfig() trig_src parameter
#define DQ_AO364CFG_OTRG_EDGE       (1L<<29)    // use trigger line as a gate for offset DAC
#define DQ_AO364CFG_TRG_EDGE        (1L<<28)    // use trigger line as a gate main DAC
#define DQ_AO364CFG_TRG_ONCE        (1L<<27)    // trigger will otuput waveform once - one time per trigger
                                                // waveform must be completed before trigger cen re-trigger it
// offset DAC triggers - source of the trigger signal
#define DQ_AO364CFG_OTRG_CONT_L     (7L<<8)     // no trigger, layer outputs when clock is available (use with NIS clocking)
#define DQ_AO364CFG_OTRG_SYNC3_L    (6L<<8)     // use SYNC3 line as a trigger (SYNC3 -> TRIG_IN)
#define DQ_AO364CFG_OTRG_SYNC1_L    (4L<<8)     // use SYNC1 line as a trigger (SYNC1 -> TRIG_IN)
#define DQ_AO364CFG_OTRG_ALT0_C     (3L<<8)     // use channel 0 CH0_TOUT line for trigger (CH0_TOUT -> TRIG_IN)
                                                // set <sync_mode> to connec CH0_TOUT to the source
#define DQ_AO364CFG_OTRG_DIO1_C     (2L<<8)     // use channel DIO1 line for trigger
#define DQ_AO364CFG_OTRG_SW_C       (1L<<8)     // use software trigger (simultaneous only within single layer)

// main DAC triggers (work for both WF and AWF modes)
// re-synch mode (input trigger line)
#define DQ_AO364CFG_TRG_MODE02      (7L<<5)     // re-sync trigger mode mask (retriggers waveform output each time upon external clock)
#define DQ_AO364CFG_TRG_MODE_NORM   (0L<<5)     // 000 - normal;
#define DQ_AO364CFG_TRG_MODE_DIO1   (1L<<5)     // 001 - trigger resets waveform index to a defined value upon DIO1
#define DQ_AO364CFG_TRG_MODE_SYNC1  (2L<<5)     // 010 - trigger resets waveform index to a defined value upon SYNC1 pulse
#define DQ_AO364CFG_TRG_MODE_SYNC3  (3L<<5)     // 011 - trigger resets waveform index to a defined value upon SYNC3 pulse
#define DQ_AO364CFG_TRG_MODE_ALT0   (4L<<5)     // 100 - trigger resets waveform index to a clock from ALT0 line (CH0-TIN)

// source of the trigger signal
#define DQ_AO364CFG_TRG_SYNC3_L     (6L<<0)     // use SYNC3 line as a trigger
#define DQ_AO364CFG_TRG_SYNC1_L     (4L<<0)     // use SYNC1 line as a trigger
#define DQ_AO364CFG_TRG_ALT0_C      (3L<<0)     // use channel 0 CH0_TOUT line for trigger (CH0_TOUT -> TRIG_IN)
                                                // set <sync_mode> to connec CH0_TOUT to the source
#define DQ_AO364CFG_TRG_CH0_L       DQ_AO364CFG_TRG_ALT0_C     // (depricated)
#define DQ_AO364CFG_TRG_DIO1_C      (2L<<0)     // use channel DIO1 line for trigger
#define DQ_AO364CFG_TRG_SW_C        (1L<<0)     // use software trigger (simultaneous only within single layer)


// clock feed <sync_mode> ----------------------
// define bit 31 of DqAdv364SetConfig() sync_mode parameter
#define DQ_AO364CFG_DCDC_DOWN       (1L<<31)    // force analog power DCDC to shut down on the channel
                                                // this is permanent shutdown, IOM reboot will be required to
                                                // bring this channel up again

#define DQ_AO364CFG_CLKOUT_FREQ     (1L<<30)    // divide PLL to output waveform start clock instead of update clock
                                                // this must be used if waveform re-start mode is used (i.e. restart
                                                // stored waveform upon each clock) [not implemented]
                                                
// define bits 13:12 of DqAdv364SetConfig() sync_mode parameter
// If either of these defines is bitwise ORed into the sync_mode parameter, the RTDMAPed DDS waveform outputs will
// update to the new settings at the specified zero crossing direction. If both of these are used, the
// outputs will update at the first zero cross.
#define DQ_AO364CFG_MAP_ZCROSS_R    (1L<<13)     // set rtdmapped swf outputs to update on Rising zero cross
#define DQ_AO364CFG_MAP_ZCROSS_F    (1L<<12)     // set rtdmapped swf outputs to update on Falling zero cross
#define DQ_AO364CFG_MAP_ZCROSS_FIRST (DQ_AO364CFG_MAP_ZCROSS_R | DQ_AO364CFG_MAP_ZCROSS_F) // update on first occurring zero cross

// define bits 9:8 of DqAdv364SetConfig() sync_mode parameter
// ---- PGA settings - allow to reduce output span while maintaning full resolution
#define DQ_AO364CFG_PGA_1_2         (3L<<8)     // set PGA to produce 1/2 of the range (+/-5V)
#define DQ_AO364CFG_PGA_1_5         (2L<<8)     // set PGA to produce 1/5th of the range (+/2V)
#define DQ_AO364CFG_PGA_1_10        (1L<<8)     // set PGA to produce 1/10th of the range (+/-1V)

// define bits 7:4 of DqAdv364SetConfig() sync_mode parameter
// Following settings apply to channel 0 only
// Select where channel 0 takes its clock
#define DQ_AO364CFG_CH0_SYNC3       (3L<<4)     // route SYNC3 as a source for CH0_TIN
#define DQ_AO364CFG_CH0_SYNC1       (1L<<4)     // route SYNC1 as a source for CH0_TIN

// define bits 3:0 of DqAdv364SetConfig() sync_mode parameter
// Select where channel 0 outputs its clock
#define DQ_AO364CFG_CLKOUT_DIO1     (5L<<0)     // output DIO1 trigger to CH0_TOUT
#define DQ_AO364CFG_CLKOUT_DIO0     (4L<<0)     // output DIO0 clock to CH0_TOUT
#define DQ_AO364CFG_CLKOUT_CH0      (3L<<0)     // output CH0 update clock up to CH0_TOUT line
#define DQ_AO364CFG_CLKOUT_SYNC2    (2L<<0)     // output CH0 PLL update clock to SYNC2
#define DQ_AO364CFG_CLKOUT_SYNC0    (1L<<0)     // output CH0 PLL update clock to SYNC0
// ------------------------------------------------------------------------------------------

// For DQL_IOCTL364_SET_WF
// for <mode>
#define DQ_AO364CFG_WF_PLL          (1L<<24)    // use PLL mode of operation
#define DQ_AO364CFG_WF_DDS          (0L<<24)    // use DDS (direct digital synthesis mode)

#define DQ_AO364CFG_WF_INVERT       (2L<<4)     // apply inversion function to the waveform
#define DQ_AO364CFG_WF_MIRROR       (1L<<4)     // apply mirror function to the waveform
#define DQ_AO364CFG_WF_PULSE        (4L<<0)     // standard WF is a trapezoid, use fall/rise/duty to create pulse
                                                // sqaure or triangle
#define DQ_AO364CFG_WF_RAMP         (3L<<0)     // standard WF is a ramp
#define DQ_AO364CFG_WF_SAW          (2L<<0)     // standard WF is a saw tooth
#define DQ_AO364CFG_WF_SINE         (1L<<0)     // standard WF is a sinewave
#define DQ_AO364CFG_WF_CUSTOM       (0L<<0)     // custom SWF waveform of 4096 samples is loaded via DqAdv364WriteAWF

typedef struct {
    float duty_cycle;       // apply duty cycle (for pulse only)
    float rise_time;        // apply rise time, % [0..1] (for pulse, saw tooth)
    float fall_time;        // apply fall time, % [0..1] (for pulse, saw tooth)
} DQAO364STDWF, *pDQAO364STDWF;

// <flags> for DQAO364WFPRM
#define DQ_AO364CFG_WF_SHAPE        (1L<<5)     // reload waveform shape
#define DQ_AO364CFG_WF_TIME         (1L<<4)     // apply new time <reserved>
#define DQ_AO364CFG_WF_PHASE        (1L<<3)     // apply new phase
#define DQ_AO364CFG_WF_OFFS         (1L<<2)     // apply new offset
#define DQ_AO364CFG_WF_SPAN         (1L<<1)     // apply new span
#define DQ_AO364CFG_WF_FREQ         (1L<<0)     // apply new frequency

#define DQ_AO364_WF_BLK_SZ           (256)    // standard waveform load block size
#define DQ_AO364_WF_SZ              (4096)    // standard waveform size

typedef struct {
    uint32 flags;     // configuration flags (what to set)
    double freq;      // frequency
    double span;      // waveform span (volts)
    double offset;    // waveform offset (volts)
    double phase;     // waveform phase (degrees)
    double set_time;  // time to apply parameters
} DQAO364WFPRM, *pDQAO364WFPRM;


#define DQ_AO364SIMFLAGSPAN         (0)         // bit position offsets into  DQAO364SIMPRM.flags
#define DQ_AO364SIMFLAGOFFS         (4)         //
#define DQ_AO364SIMFLAGFREQ         (8)         //
#define DQ_AO364SPANFLAG(CH)        (1L << (DQ_AO364SIMFLAGSPAN +((CH)&3)))
#define DQ_AO364OFFSFLAG(CH)        (1L << (DQ_AO364SIMFLAGOFFS +((CH)&3)))
#define DQ_AO364FREQFLAG(CH)        (1L << (DQ_AO364SIMFLAGFREQ +((CH)&3)))
// set DQAO364SIMPRM.flags bit0 to '1' when .span[ch_0] is to be used
// set DQAO364SIMPRM.flags bit1 to '1' when .span[ch_1] is to be used
// set DQAO364SIMPRM.flags bit2 to '1' when .span[ch_2] is to be used
// set DQAO364SIMPRM.flags bit3 to '1' when .span[ch_3] is to be used
// set DQAO364SIMPRM.flags bit4 to '1' when .offset[ch_0] is to be used
// set DQAO364SIMPRM.flags bit5 to '1' when .offset[ch_1] is to be used
// set DQAO364SIMPRM.flags bit6 to '1' when .offset[ch_2] is to be used
// set DQAO364SIMPRM.flags bit7 to '1' when .offset[ch_3] is to be used
// set DQAO364SIMPRM.flags bit8 to '1' when .freq[ch_0] is to be used
// set DQAO364SIMPRM.flags bit9 to '1' when .freq[ch_1] is to be used
// set DQAO364SIMPRM.flags bit10 to '1' when .freq[ch_2] is to be used
// set DQAO364SIMPRM.flags bit11 to '1' when .freq[ch_3] is to be used
typedef struct {                    // rtdmap setup struct
    uint32 flags;                   // configuration flags (what to set)
    double span[DQ_AO364_CHAN];     // waveform span (volts)
    double offset[DQ_AO364_CHAN];   // waveform offset (volts)
    double freq[DQ_AO364_CHAN];     // frequency, Hz
} DQAO364SIMPRM, *pDQAO364SIMPRM;

// For DQL_IOCTL364_SET_AWF
typedef struct {
  uint32 buf_size;    // the size of the buffer, bytes (mult.128)
  uint32 d_size;      // the size of the data in the buffer
  uint32 buf_next;    // AO364_AUTONEXT flag and next buffer ID for linked list ops.
  uint32 flags;       // buffer control flags
} DQAO364BUFLST, *pDQAO364BUFLST;

// For DQL_IOCTL364_SET_SWEEP - can be used only in DDS mode
//
#define DQ_AO364_SWEEP_SETONLY  (1L<<22)    // set sweep parameters, arm sweep but don't trigger it
#define DQ_AO364_SWEEP_STOP     (1L<<21)    // stop selected sweeps where they are now and return to pre-sweep values

#define DQ_AO364_SWEEP_N_PER    (1L<<20)    // use <periods> and <steps> to define sweep mode

#define DQ_AO364_SWEEP_PHASE    (1L<<19)    // phase sweep enabled
#define DQ_AO364_SWEEP_OFFS     (1L<<18)    // offset sweep enabled
#define DQ_AO364_SWEEP_AMPL     (1L<<17)    // amplitude sweep enabled
#define DQ_AO364_SWEEP_FREQ     (1L<<16)    // frequency sweep enabled

#define DQ_AO364_SWEEP_ALL      (0xf<<16)   // all sweeps selected

#define DQ_AO364_SWEEP_CONT     (1L<<2)     // continue sweep cycle until reprogrammed

#define DQ_AO364_SWEEP_UP       (0)  // sweep up and stop
#define DQ_AO364_SWEEP_DN       (1)  // sweep down and stop
#define DQ_AO364_SWEEP_UPDN     (2)  // sweep down and stop
#define DQ_AO364_SWEEP_DNUP     (3)  // sweep up and stop

#pragma pack(1)

typedef struct {
    uint32 flags;         // configuration flags (form of the sweep, once or continuous)
    uint32 steps_up;      // number of steps in the sweep up for n-period mode
    uint32 steps_dn;      // number of steps in the sweep down for n-period mode
    uint32 periods;       // number of periods

    double start_freq;    // lower frequency
    double end_freq;      // upper frequency

    double start_ampl;    // lower amplitude
    double end_ampl;      // upper amplitude

    double start_offs;    // lower offset
    double end_offs;      // upper offset

    double start_phase;   // lower phase
    double end_phase;     // upper phase

    double sweep_time;    // the length of sweep up (>= 1ms)

} DQAO364WFSWEEP, *pDQAO364WFSWEEP;

#pragma pack()

#define DQ_AO364_MAX_AWF_BUFS   64      // maximum number of AO buffers for AWF mode

// for DQL_IOCTL364_WRITE_AWF and DQL_IOCTL364_WRITE_OWF
#define DQ_L364_MAX_AWF_FRAME_SZ     (1024*1024)
#define DQ_L364_MAX_OWF_FRAME_SZ     (4096)

#define DQL_IOCTL364_FRAME_SE    (1L<<1L)    // First frame of single-frame sequence
#define DQL_IOCTL364_FRAME_S     (2L<<1L)    // First frame of multi-frame sequence
#define DQL_IOCTL364_FRAME_C     (3L<<1L)    // Tell to continue sending frames
#define DQL_IOCTL364_FRAME_E     (4L<<1L)    // Last frame (or only frame) of frame sequence
#define DQL_IOCTL364_FRAMEMASK   (7L<<1L)    // Mask

#define DQL_AO364_WRITE_USEDBL   (1L<<1)     // convert double into raw for write functions
#define DQL_AO364_WRITE_STDWF    (1L<<0)     // overwrite standard waveform memory locations (4096 samples max)

// user cmd defines for DqAdv364ExCalAccess()
#define DQ_AO364_EE_CHK_STS         (0x01)      // check status of read, write or erase function
#define DQ_AO364_EE_RD_ID_ADDR      (0x21)      // Read silicon ID, set read address, read address is
                                                // auto-incremented by size of read command
#define DQ_AO364_EE_RD              (0x22)      // Issue Read command - 1 to 1024 bytes
#define DQ_AO364_EE_WR_OPEN         (0x31)      // open the device for writing, set write address, address
                                                // is auto-incremented by size of write command
#define DQ_AO364_EE_ERASE           (0x32)      // Erase device
#define DQ_AO364_EE_WR              (0x33)      // Write bytes command - 1-256 data bytes
#define DQ_AO364_EE_WR_CLOSE        (0x34)      // close the device for writing
#define DQ_AO364_EE_ERASE_SECTOR    (0x35)      // erase 1/4 of the device

#define DQ_AO364_EE_RD_MAX_LEN      (1024)      // read 1Kb per call
#define DQ_AO364_EE_WR_MAX_LEN      (256)       // write 256 bytes per call

// value returned by DQ_AO364_EE_RD_ID_ADDR command
#define DQ_AO364_EE_ID_1M           (0x10)      // id is for 131072 byte part default
#define DQ_AO364_EE_ID_4M           (0x12)      // id is for 524288 byte part optional

// values returned by DQ_AO364_EE_CHK_STS command
                                                // returned 32bit word [0], nonzero = system is busy
#define DQ_AO364_EE_ESTS_COMPLETE   (1L<<31)    // returned 32bit word [1], =1, ee operation complete
#define DQ_AO364_EE_ESTS_ERR        (1L<<30)    // returned 32bit word [1], =1, invalid command detected
#define DQ_AO364_EE_ESTS_BUSY       (1L<<4)     // returned 32bit word [1], =1, ee system is busy
#define DQ_AO364_EE_ESTS_RFF        (1L<<3)     // returned 32bit word [1], =1, read fifo is full
#define DQ_AO364_EE_ESTS_RFHF       (1L<<2)     // returned 32bit word [1], =1, read fifo above watermark
#define DQ_AO364_EE_ESTS_WFE        (1L<<1)     // returned 32bit word [1], =1, write fifo empty
#define DQ_AO364_EE_ESTS_WFHF       (1L<<0)     // returned 32bit word [1], =1, write fifo below watermark
#define DQ_AO364_EE_INVALID_RDSTS   (1L<<31)    // returned 32bit word [2], =1, status is invalid
#define DQ_AO364_EE_RDSTS_BP        (3L<<2)     // returned 32bit word [2], =1, write protected
#define DQ_AO364_EE_RDSTS_WEL       (1L<<1)     // returned 32bit word [2], =1, write enabled
#define DQ_AO364_EE_RDSTS_WIP       (1L<<0)     // returned 32bit word [2], =1, write in progress
                                                // returned 32bit word [3] = read address
                                                // returned 32bit word [4] = write address
#define DQ_AO364_EE_CHKSTS_RETLEN   (5)         // EE_CHK_STS command returns 5 words

// For setting PLL
#define DQ_AO364_MAXPLLCLFRQ        (16500000)  // 16.5MHz is the maximum DAC rate supported (50MHz datasheet)
#define DQ_AO364_MINPLLCLFRQ        (10000)     // 10kHz is the minimum waveform synthesis frequency
#define DQ_AO364_MAXPLL_CLKDIV      (512)       // maximum Cx divisor for PLL clock

// For setting calibration values (pDQSETCAL->dac value)
#define DQ_AO364_DAC_GAIN           (1)         // gain register of main DAC
#define DQ_AO364_DAC_OFFS           (2)         // offset register of main DAC
#define DQ_AO364_ODAC_GAIN          (3)         // gain register of offset DAC
#define DQ_AO364_ODAC_OFFS          (4)         // offset register of offset DAC

// for DQL_IOCTL364_SET_TMR1


// for DQIOCTL_GETPARAM
#define DQ_AO364_GETCURVAL          (1)         // GET CURrent VALues of the sweep
#define DQ_AO364_GETWFGF            (2)         // GET WaveForm Gain Factors for rtdmap
#pragma pack()

#pragma pack(1)

#define DQ_L364_NAMELEN             (32)  // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cnames[DQ_AO364_CHAN][DQ_L364_NAMELEN];
} DQCNAMES_364_, *pDQCNAMES_364_;

/* specific device structure - calibration values */
typedef struct {
    uint32 val;
    uint32 gain_dac[DQ_AO364_CHAN][AO36IS_NUM_GAINS];
    uint32 offs_dac[DQ_AO364_CHAN][AO36IS_NUM_GAINS];
    uint32 gain_odac[DQ_AO364_CHAN][AO36IS_NUM_GAINS];
    uint32 offs_odac[DQ_AO364_CHAN][AO36IS_NUM_GAINS];
} DQCALSET_364_, *pDQCALSET_364_;

typedef struct {
    uint32 val;                     // DC/DC states (cfg register) in init mode
    uint32 dac_wr[DQ_AO364_CHAN];
    uint32 odac_wr[DQ_AO364_CHAN];
    uint32 states[DQ_AO364_CHAN];   // Gain and output buffer settings
} DQINITPRM_364_, *pDQINITPRM_364_;

#define DQ_AO364_CH_DIS_MASK(N)     ((N)&0xf)   // if "1" then the channel DC/DC is diasbled


typedef struct {
    uint32 lcr;
    uint32 dac_wr[DQ_AO364_CHAN];
    uint32 odac_wr[DQ_AO364_CHAN];
    uint32 states[DQ_AO364_CHAN];   // Gain and output buffer settings
    uint32 fwcfg;
    uint32 fwdc;
    uint32 fwdiv;
    uint32 fwclk_min;
    uint32 fwclk_max;
} DQOPMODEPRM_364_, *pDQOPMODEPRM_364_;

typedef struct {
    uint32 val;                     // DC/DC states (cfg register) in shutdown mode
    uint32 dac_wr[DQ_AO364_CHAN];
    uint32 odac_wr[DQ_AO364_CHAN];
    uint32 states[DQ_AO364_CHAN];   // Gain and output buffer settings
} DQSDOWNPRM_364_, *pDQSDOWNPRM_364_;

#define DQPRM_364_STATES_ENABLE     1
#define DQPRM_364_STATES_GAIN1      0
#define DQPRM_364_STATES_GAIN_0_5   2
#define DQPRM_364_STATES_GAIN_0_2   4
#define DQPRM_364_STATES_GAIN_0_1   6

#define DQPRM_364_STATES_GET_GAIN(N)  (3-(((N)&0x6)>>1))


typedef struct {
    uint32  flag_ver;
} DQPRMFLAGS_364_, *pDQPRMFLAGS_364_;


// Event data for 364 layer
typedef struct {
    uint32 chan;            // channel information
    uint32 evtype;          // type of the event
    uint32 tstamp;          // timestamp of event
    uint32 size;            // size of the following data in bytes
    uint32 avail;           // number of free words in the buffer
    uint8 data[DQ_FLEX_ARRAY];           // data to follow (one character takes one byte)
} EV364_ID, *pEV364_ID;

typedef enum {
    EV364_CLEAR = 0x1000,   // clear all events

    EV364_PERIODIC = 0x101, // periodic event (+ status for all channels)

    // output events
    EV364_STARTED,          // output started (external trigger)
    EV364_STOPPED,          // output stopped (EoB or trigger)
    EV364_PLL_SETTLED,      // PLL settled to the programmed frequency
    EV364_DIO_EV,           // DIO line edge
    EV364_WDAC_WM,          // Waveform DAC is past watermark
    EV364_WDAC_EB,          // Waveform DAC end-of-buffer
    EV364_ODAC_WM,          // Offset DAC is past watermark
    EV364_ODAC_EB,          // Offset DAC end-of-buffer

    // FIFO events
    EV364_IN_FIFO,          // event FIFO above watermark
    EV364_OUT_FIFO,         // output FIFO below watermark

    // Firmware errors
    EV364_OVERFLOW,         // buffer underflow - cleared
    EV364_UNXP              // unexpected error (most likely buffer error)

} event364_t;

#define DqAdv364ConfigEvents_PARAMSZ (7)        // maximum number of uint32 parameters after pEV364_ID

#define AO364_EPCSX_HDRSZ       256     // size of the header
#define AO364_EPCSX_ALT_CODE    1024    // address where FPGA code starts
#define AO364_EPCSX_BLOCK_SZ    1024    // block size to read from EPCSX
#define AO364_EPCSX_MAX_BLOCKS  1024    // maximum number of blocks to load (safeguard)
#define AO364_IS_WF_SZ          1024    // amount of data to communicate with isolated logic

typedef struct {
    uint32 size;        // size of the stored EEPROM code
    uint32 version;     // version of the code
    uint32 datecode;    // date YYYYMMDD
    uint32 crc;         // CRC of the code
    uint32 res[256-4];    // make it to 1kB

    // --------------------------------------------------
    uint8 fpga_boot[DQ_FLEX_ARRAY];  // stored FPGA code

} DQEXEE_364, *pDQEXEE_364;

typedef struct {
    uint32 busy;    // busy flag
    uint32 ests;    // AO364_ESTS value, see logic document for details
    uint32 rdsts;   // RDSTS value from the EPCS device. This value can only be accessed when the busy flag is zero. The msbit will be set when the value is invalid.
    uint32 rd_addr; // read address that the next DQ_AO364_EE_RD command will use
    uint32 wr_addr; // write address that the next DQ_AO364_EE_WR command will use.
} DQEXEE_STS_364, *pDQEXEE_STS_364;

typedef struct {
    float samplerate;   // requested
    float actual;       // actual
    uint32 base;        // base clock, Hz
    uint32 m;           // M-multiplyer
    uint32 n;           // N-divider
    uint32 c0;          // C0 divider
    uint32 c2;          // C2 divider
    uint32 I;           // charge pump current (3 bits)
    uint32 R;           // loop resistance (5 bits)
    uint32 C;           // loop capacitor (2 bits)
    uint32 vco_post;    // VCO post scale divider
    uint32 baseclock;   // base clock
    uint32 mul_factor;  // for use in PLL mode to stretch waveform
    uint32 mul_pwr;     // power of 2 multiplication
    uint32 div_factor;  // divider to shorten it
    uint32 div_pwr;     // power of 2 division
} DQ_PLL_364, *pDQ_PLL_364;

#define DQ_AO364_DG_DEFAULT         (0.868)   // rtdmap default gains
#define DQ_AO364_ODG_DEFAULT        (0.97)
#pragma pack()

// definitions for RTD-388 layer CLI part
#define DQ_RTD388_CHAN              (8)         // D/A (D/R) channels
#define DQ_RTD388_ADC_CH            (2)         // ADC channels per channel
#define DQ_RTD388_RES_CH            (19)        // 18 D/A resistors per channel + Ron
#define DQ_RTD388_RES_CH_16         (16)        // 16 parallel D/A resistors per channel (0-15)
#define DQ_RTD388_RES_CH_1K_OFFS    (16)        // 17th series D/A resistor
#define DQ_RTD388_RES_CH_2K_OFFS    (17)        // 18th series D/A resistor
#define DQ_RTD388_RES_CH_RON_OFFS   (18)        // 19th resistor (Ron)
#define DQ_RTD388_K_RANGES          (5)         // offset adjust for ranges (DAQLib only)
#define DQ_RTD388_CB_CH             (2)         // number of circuit breakers per channel
#define DQ_RTD388_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_RTD388_BASE              (BUS_FREQUENCY)     // 66MHz
#define DQ_RTD388_MODESCAN          (DQ_FIFO_MODESCAN)  // single scan update mode
#define DQ_RTD388_MODEFIFO          (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_RTD388_MODECONT          (DQ_FIFO_MODECONT)  // continuous acquisition
#define DQ_RTD388_ADC_DEF           (6)
#define DQ_RTD388_ADC_SETTLE        (10)
#define DQ_RTD388_MAXCLFRQ          (2000)
#define DQ_RTD388_MAXCVFRQ          (2000)
#define DQ_RTD388_16_BIT_TABLE_LEN  (65536)
//        defines ending in _1 for 1000 ohm, _2 for 100 ohm
#define DQ_RTD388_RES_NOMINAL_1     (1000)
#define DQ_RTD388_MIN_RES_REQ_1     (180)       // ohms
#define DQ_RTD388_MAX_RES_REQ_1     (3900)
#define DQ_RTD388_LUT_GUARDBAND_1   (2)
#define DQ_RTD388_MIN_RES_LUT_1     (DQ_RTD388_MIN_RES_REQ_1 - DQ_RTD388_LUT_GUARDBAND_1)    // error limit for resistance request
#define DQ_RTD388_MAX_RES_LUT_1     (DQ_RTD388_MAX_RES_REQ_1 + DQ_RTD388_LUT_GUARDBAND_1)    // error limit for resistance request
#define DQ_RTD388_BIN_HI_BITS_3K    (0x00000)
#define DQ_RTD388_BIN_HI_BITS_2K    (0x10000)
#define DQ_RTD388_BIN_HI_BITS_1K    (0x20000)
#define DQ_RTD388_BIN_HI_BITS_0K    (0x30000)
#define DQ_RTD388_BIN_HI_BITS_MASK  (0x30000)
#define DQ_RTD388_OHM_LUT_TBL_MIN   (DQ_RTD388_MIN_RES_REQ_1 - DQ_RTD388_LUT_GUARDBAND_1)
#define DQ_RTD388_OHM_LUT_TBL_MAX   (DQ_RTD388_RES_NOMINAL_1 + DQ_RTD388_MIN_RES_REQ_1 + DQ_RTD388_LUT_GUARDBAND_1 )  //(1182)
#define DQ_RTD388_OHM_TBL_SIZE_1    (DQ_RTD388_OHM_LUT_TBL_MAX - DQ_RTD388_OHM_LUT_TBL_MIN + 1)  // 178 through 1182 ohms , 1005
#define DQ_RTD388_STEPS_PER_OHM_1   (32)        // = 1/DQ_RTD388_LOOKUP_STEP_1 (power of 2 always)
#define DQ_RTD388_LOOKUP_STEP_1     (1.0/DQ_RTD388_STEPS_PER_OHM_1)     // lookup resolution ohms
#define DQ_RTD388_RELAY_RON         (0.18285)   // ohms

#define DQ_RTD388_RES_NOMINAL_2     (100)       // nominal value of 388-100
#define DQ_RTD388_MIN_RES_REQ_2     (23.0)      // ohms , user's min request
#define DQ_RTD388_LUT_GUARDBAND_2   (1)         // ohms, make sure part tolerance does not cause lut over/underflow
#define DQ_RTD388_OHM_TBL_SIZE_2    (125)       // 125 ohms of resistance lookup, 22->147
#define DQ_RTD388_RANGE0_R_2        (90)        // nominal value of first range resistor
#define DQ_RTD388_RANGE1_R_2        (180)       // nominal value of second range resistor
#define DQ_RTD388_RANGE2_R_2        (DQ_RTD388_RANGE0_R_2 + DQ_RTD388_RANGE1_R_2)    // 270 ohms, first + second
#define DQ_RTD388_MAX_RES_REQ_2     (DQ_RTD388_RANGE2_R_2 + DQ_RTD388_MIN_RES_LUT_2 + DQ_RTD388_OHM_TBL_SIZE_2 - DQ_RTD388_LUT_GUARDBAND_2) // 415
#define DQ_RTD388_MIN_RES_LUT_2     (DQ_RTD388_MIN_RES_REQ_2 - DQ_RTD388_LUT_GUARDBAND_2)  // resistance of first entry in lut =22

#define DQ_RTD388_STEPS_PER_OHM_2   (256)       // = 1/DQ_RTD388_LOOKUP_STEP_1 (power of 2 always)
#define DQ_RTD388_LOOKUP_STEP_2     (1.0/DQ_RTD388_STEPS_PER_OHM_2)     // lookup resolution ohms

#define DQL_IOCTL388_WR_PRM         (14L)       // write/read guardian parameters for RTD-388
                                                // is an alias of DQL_IOCTL318_WR_PRM

// RTD-388 Read ADC conversion factors
#define DQ_RTD388_VREF              (3.173)     // nominal reference voltage
#define DQ_RTD388_ADC_STEP          (DQ_RTD388_VREF/(double)0xffffff)
#define DQ_RTD388_I_SHUNT           (0.1)       // ohms
#define DQ_RTD388_I_SPAN            (DQ_RTD388_VREF / DQ_RTD388_I_SHUNT)   // = unattainable +-15.87A!
#define DQ_RTD388_I_STEP            (DQ_RTD388_ADC_STEP / DQ_RTD388_I_SHUNT)
#define DQ_RTD388_I_OFFSET          (DQ_RTD388_I_SPAN/2.0)
#define DQ_RTD388_I_2A              (0x6fdd24)  // ADC reading at 2.0A
#define DQ_RTD388_T_SLOPE           (0.0014 / DQ_RTD388_ADC_STEP)           // ADC counts per degree
#define DQ_RTD388_T_OFFSET          (273.15)    // Kelvin to degrees C
#define DQ_RTD388_T_105_DEGREES     (0xAAB693)  // ADC reading at 105 degrees C for circuit breaker setting
#define DQ_RTD388_I_PM4MA           (0x800842)  // abs val of ADC reading at +-4mA for circuit breaker setting
#define DQ_RTD388_I_DEFAULT_TRIP    (0x80094B)  // default trip setting for ADCLIM0 , approx 4.5mA

                                    // convert degrees C to circuit breaker compare level, = .CB_limit_t
#define DQ_RTD388_CB_C_TO_ADC(C)    (0x800000 + (uint32)(((C) + DQ_RTD388_T_OFFSET) * DQ_RTD388_T_SLOPE))
                                    // convert Idc value to circuit breaker compare level, = .CB_limit_i
//#define absf(A)    (((A) > 0.0)?(A):(-1.0*(A)))   // absf missing in some setups, un-comment if needed
#define DQ_RTD388_CB_I_TO_ADC(I)    ((uint32)((absf(I) + DQ_RTD388_I_OFFSET) / DQ_RTD388_I_STEP))

        // command codes used internally by DAQLib
#define DQL_IOCTL388_PRM_SETCB      (0x1)       // set value for CircuitBreaker and layer config
#define DQL_IOCTL388_GET_CB_STAT    (0x2)       // request CircuitBreaker status (and re-engage CBs if requested)
#define DQL_IOCTL388_PRM_GETCB      (0x3)       // readback values for CircuitBreaker and layer config (used by PowerDNA Explorer)
#define DQ_RTD388_ADC_ENB           (0x12)      // used by DqAdv388ADCEnable()
#define DQ_RTD388_WR_DIAG           (0x13)      // used by DqAdv388WriteDiag()

        // resistance output channel numbers for DqAdv388Write
#define DQ_RTD388_OUT_CH_0          (0)
#define DQ_RTD388_OUT_CH_1          (1)
#define DQ_RTD388_OUT_CH_2          (2)
#define DQ_RTD388_OUT_CH_3          (3)
#define DQ_RTD388_OUT_CH_4          (4)
#define DQ_RTD388_OUT_CH_5          (5)
#define DQ_RTD388_OUT_CH_6          (6)
#define DQ_RTD388_OUT_CH_7          (7)

        // current readback channel numbers for DqAdv388ReadADC
#define DQ_RTD388_I_IN_CH_0         (0x10)      // read current from channel 0
#define DQ_RTD388_I_IN_CH_1         (0x11)      // read current from channel 1
#define DQ_RTD388_I_IN_CH_2         (0x12)      //  "       "     "     "    2
#define DQ_RTD388_I_IN_CH_3         (0x13)
#define DQ_RTD388_I_IN_CH_4         (0x14)
#define DQ_RTD388_I_IN_CH_5         (0x15)
#define DQ_RTD388_I_IN_CH_6         (0x16)
#define DQ_RTD388_I_IN_CH_7         (0x17)      //  "       "     "     "    7

        // temperature read channel numbers for DqAdv388ReadADC
#define DQ_RTD388_T_CH_0            (0x20)      // read temperature from channel 0
#define DQ_RTD388_T_CH_1            (0x21)      // read temperature from channel 1
#define DQ_RTD388_T_CH_2            (0x22)      //   "       "        "     "    2
#define DQ_RTD388_T_CH_3            (0x23)
#define DQ_RTD388_T_CH_4            (0x24)
#define DQ_RTD388_T_CH_5            (0x25)
#define DQ_RTD388_T_CH_6            (0x26)
#define DQ_RTD388_T_CH_7            (0x27)      //   "       "        "     "    7

        // diagnostic binary resistance control readback channel numbers, data returned in DqAdv388ReadADC bdata
#define DQ_RTD388_D_CH_0            (0x30)      // diagnostic binary data readback from channel 0
#define DQ_RTD388_D_CH_1            (0x31)      // diagnostic binary data readback from channel 1
#define DQ_RTD388_D_CH_2            (0x32)      //      "       "     "      "      "      "    2
#define DQ_RTD388_D_CH_3            (0x33)
#define DQ_RTD388_D_CH_4            (0x34)
#define DQ_RTD388_D_CH_5            (0x35)
#define DQ_RTD388_D_CH_6            (0x36)
#define DQ_RTD388_D_CH_7            (0x37)      //      "       "     "      "      "      "    7


#define DQ_RTD388_CHAN_MASK         (0x07)
#define DQ_RTD388_ADC_CHAN_MASK     (0x70)

#define DQ_RTD388_SEL_CHAN_ALL      (0xFF)      // channel mask for DAQLib, for instance DqAdv388CBStatus() chan_mask parameter
#define DQ_RTD388_MAKE_CL(i,j)      ((((j)==0)? DQ_RTD388_I_IN_CH_0 : ((j)==1)? DQ_RTD388_T_CH_0 : DQ_RTD388_D_CH_0 ) | ((i)&DQ_RTD388_CHAN_MASK))

#define DQ_RTD388_CAL_OFFSETS       (0x20)      // DAQLib flag for calibration purposes only
#define DQ_RTD388_GET_CAL_VALUES    (0x40)      // DAQLib flag for test purposes
//   General status register -   appears as return value from DqAdv388CBStatus() = status[0]
//  Current status of the RTD388 access module, "sticky" bits are auto-cleared after each read

#define DQ_RTD388_STS_RLSC7         (1L<<31)    // current state of the "short circuit" control
#define DQ_RTD388_STS_RLSC6         (1L<<30)    // =1 - shorted
#define DQ_RTD388_STS_RLSC5         (1L<<29)    //
#define DQ_RTD388_STS_RLSC4         (1L<<28)    //
#define DQ_RTD388_STS_RLSC3         (1L<<27)    //
#define DQ_RTD388_STS_RLSC2         (1L<<26)    //
#define DQ_RTD388_STS_RLSC1         (1L<<25)    //
#define DQ_RTD388_STS_RLSC0         (1L<<24)    //
#define DQ_RTD388_STS_CB7_CS        (1L<<23)    // Current status of the circuit breaker on the channels 7-0
#define DQ_RTD388_STS_CB6_CS        (1L<<22)    // =1 - CB tripped
#define DQ_RTD388_STS_CB5_CS        (1L<<21)    //
#define DQ_RTD388_STS_CB4_CS        (1L<<20)    //
#define DQ_RTD388_STS_CB3_CS        (1L<<19)    //
#define DQ_RTD388_STS_CB2_CS        (1L<<18)    //
#define DQ_RTD388_STS_CB1_CS        (1L<<17)    //
#define DQ_RTD388_STS_CB0_CS        (1L<<16)    //
// Bits 15-0 are "sticky"
#define DQ_RTD388_STS_ADC7_RDY      (1L<<15)    // Set to one each time when ADC state machine for the corresponding channel
#define DQ_RTD388_STS_ADC6_RDY      (1L<<14)    // finishes all conversions, cleared after read. Note that ADC state machine
#define DQ_RTD388_STS_ADC5_RDY      (1L<<13)    // may perform up to 2 independent conversions. This bit will be set after
#define DQ_RTD388_STS_ADC4_RDY      (1L<<12)    // result from the last conversion is stored into corresponding register
#define DQ_RTD388_STS_ADC3_RDY      (1L<<11)    //
#define DQ_RTD388_STS_ADC2_RDY      (1L<<10)    //
#define DQ_RTD388_STS_ADC1_RDY      (1L<<9)     //
#define DQ_RTD388_STS_ADC0_RDY      (1L<<8)     //
#define DQ_RTD388_STS_CB7           (1L<<7)     // =1 - Circuit breaker was tripped on channels 7-0
#define DQ_RTD388_STS_CB6           (1L<<6)     //
#define DQ_RTD388_STS_CB5           (1L<<5)     //
#define DQ_RTD388_STS_CB4           (1L<<4)     //
#define DQ_RTD388_STS_CB3           (1L<<3)     //
#define DQ_RTD388_STS_CB2           (1L<<2)     //
#define DQ_RTD388_STS_CB1           (1L<<1)     //
#define DQ_RTD388_STS_CB0           (1L<<0)     //
// structure for RTD-388 configuration. Used by DqAdv388SetConfig()
typedef struct {
    uint32 prmmask;                             // bitmask: which parameters are valid and needs to be set
    uint32 rdcnt;                               // number -1 of consecutive ADC readings beyond limit that are required to break, 0..15
    uint32 CB_limit_i;                          // CircuitBreaker current limit value, code 0x800000..ffffff
    uint32 CB_limit_t;                          // CircuitBreaker temperaure limit value, code 0x800000..ffffff
    uint32 CB_enables;                          // enable/disable circuit breakers
} DQRTD388CFG, *pDQRTD388CFG;
// .prmmask = bitfield to specify what to set
#define DQ_RTD388_CFG_READ_COUNT    (1L<<0)     // (rdcnt valid)
#define DQ_RTD388_CFG_SETCB_LIMIT   (1L<<1)     // (CB_limit_i,t values are valid) set CB comparison value
#define DQ_RTD388_CFG_SETCB_ENABLES (1L<<2)     // (CB_enables is valid)
// .rdcnt
#define DQ_RTD388_CB_COUNT_MIN      (0)         // = 1.   rdcnt may range from 0 to 15
#define DQ_RTD388_CB_COUNT_MAX      (15)        // = 16.
#define DQ_RTD388_CB_COUNT_DEFAULT  (5)         // = 5.
// .CB_limit_i
    // 24 bit comparison value     CB_limit_i = absolute current, populate using DQ_RTD388_CB_I_TO_ADC(I) macro
// .CB_limit_t
    // 24 bit comparison value     CB_limit_t = temperature, populate using DQ_RTD388_CB_C_TO_ADC(C) macro
// .CB_enables;
#define DQ_RTD388_CB_EN_CURRENT     (1L<<0)     // =1 - enable CB trip by current, trips when absolute value of current is above CB_limit_i
#define DQ_RTD388_CB_EN_TEMPERATURE (1L<<1)     // =1 - enable CB trip by temperature, trips when temperature is above CB_limit_t


// channel status DqAdv318CBStatus()return value = status[1] and beyond, appearing for channels enabled by chan_mask parameter
#define DQ_RTD388_CSTS_FHF          (21)        // =1 when DAC FIFO word count is below watermark
#define DQ_RTD388_CSTS_CFE          (20)        // =1 when DAC FIFO is empty (reads will be ignored)
#define DQ_RTD388_CSTS_FF           (19)        // =1 when DAC FIFO is full (writes will be ignored)
#define DQ_RTD388_CSTS_RLD          (18)        // =1 if relays were disconnected by CB
#define DQ_RTD388_CSTS_OC1          (17)        // =1 if corresponding "over limit" condition is detected
#define DQ_RTD388_CSTS_OC0          (16)        //
// Bits 15-0 are "sticky" bits
#define DQ_RTD388_CSTS_RLD_S        (1L<<4)     // =1 if relays were disconnected by CB
#define DQ_RTD388_CSTS_ADC1DR_S     (1L<<3)     // =1 if calibrated ADC data is ready for channel 1
#define DQ_RTD388_CSTS_ADC0DR_S     (1L<<2)     // =1 if calibrated ADC data is ready for channel 0
#define DQ_RTD388_CSTS_OC1_S        (1L<<1)     // =1 if corresponding "over limit" condition was ever detected
#define DQ_RTD388_CSTS_OC0_S        (1L<<0)     //

// RTD Relay FIFO is used to configure relays and set a delay prior to applying new resistance.
// NOTE: output channel list can be used to place data to the relay FIFOs, in this case channel #
// should be specified in bits 22..20 of the channel list data.

// Format of data for DqAdv388WriteBin() which is same as data returned by DqAdv388Write() when binvals != NULL:
#define DQ_RTD388_LNCL_NEXT         (31)        // bit reserved for DQ_LNCL_NEXT in single scan channel list mode
#define DQ_RTD388_RLFDR_DLY7        (30)        // 8-bit delay in 12.5us increments prior to changing relays to desired state
#define DQ_RTD388_RLFDR_DLY0        (23)        // (0= no delay)
#define DQ_RTD388_RLFDR_CHN2        (22)        // In output channel list mode - channel number (0..7),
#define DQ_RTD388_RLFDR_CHN0        (20)        // write with 0s when in single scan channel list mode
#define DQ_RTD388_RLFDR_RSV19       (19)        // Reserved, write with 0
#define DQ_RTD388_RLFDR_RSV18       (18)        // Reserved, write with 0
#define DQ_RTD388_RLFDR_RSB         (1L<<17)    // Control series relay B (=1 - DO NOT add 2K to resistance)
#define DQ_RTD388_RLFDR_RSA         (1L<<16)    // Control series relay A (=1 - DO NOT add 1K to resistance)
#define DQ_RTD388_RLFDR_RD15        (15)        // 16-bit relay control word, applied to the parallel relays
#define DQ_RTD388_RLFDR_RD0         (0)         // (=1 - turn relay ON)

#define DQ_RTD388_CL_DATA_MASK      (0xFF83FFFF)
#define DQ_RTD388_CL_CH_SHIFT       (DQ_RTD388_RLFDR_CHN0)
#define DQ_RTD388_CHANMASK          (DQ_RTD388_CHAN - 1)
#define DQ_RTD388_CL_CH_MASK        (DQ_RTD388_CHANMASK << DQ_RTD388_CL_CH_SHIFT)
#define DQ_AO388_RANGE_MASK         (DQ_RTD388_RLFDR_RSA | DQ_RTD388_RLFDR_RSB)
#define DQ_RTD388_CL_GET_CH(BV)     (((BV)>>DQ_RTD388_CL_CH_SHIFT)&DQ_RTD388_CHANMASK)
#define DQ_RTD388_CL_ADD_CH(BV,CH)  ((((CH)&DQ_RTD388_CHANMASK)<<DQ_RTD388_CL_CH_SHIFT) | (DQ_RTD388_CL_DATA_MASK & (BV)))
#define DQ_RTD388_CL_DLAY_MASK      (0x7F800000)        // delay shift = DQ_RTD388_RLFDR_DLY0
#define DQ_RTD388_CL_SET_DLAY(BV,D) (((BV) & ~DQ_RTD388_CL_DLAY_MASK) | ((D) << DQ_RTD388_RLFDR_DLY0))
#define DQ_RTD388_RLF_DLY_MAX       (255)
#define DQ_RTD388_MAX_WR_PER_PKT    (128)       // max allowed length of channel list when calling DqAdv388Write() or DqAdv388WriteBin()
#define DQ_RTD388_DEFAULT_RELAY     (0x3b254)   // non-calibrated nominal value at powerup, approx 1K  ohms on a 388-1
#define DQ_RTD388_DEFAULT_RELAY_2   (0x34b3c)   // non-calibrated nominal value at powerup, approx 100 ohms on a 388-100
// data format of DqAdv388ReadADC(*bdata)  or  *rawBuffer data from RtDmap
#define DQ_RTD388_ADCCAL_EN         (1L<<31)    //  =1 if fresh data was written to this register since last read, auto-cleared
#define DQ_RTD388_ADCCAL_CB_STS     (1L<<30)    //  =1 if circuit breaker for this channel is tripped
#define DQ_RTD388_ADCCAL_CH_ID2     (26)        //  hardware ADC channel ID bit2.    Hardware ID is stored by host along with
#define DQ_RTD388_ADCCAL_CH_ID0     (24)        //  hardware ADC channel ID bit0.    channel config location in memory.
#define DQ_RTD388_ADCCAL_MSB        (23)        //  RTD388_ADCDATA_MSB,  //  24-bit calibrated straight binary calibrated ADC data
#define DQ_RTD388_ADCCAL_LSB        (0)         //  RTD388_ADCDATA_LSB,  //

#define DQ_RTD388_NAMELEN           (16)        // maximum length of the channel name (trailing 0 isn't included)


typedef struct {
    char cname[DQ_RTD388_CHAN][DQ_RTD388_NAMELEN];
} DQCNAMES_388_, *pDQCNAMES_388_;

/* specific device structure - calibration values */
typedef struct {
    // floats sent to host for calibration of resistance
    float da_res[DQ_RTD388_CHAN][DQ_RTD388_RES_CH];     // 375,750,1820,..180000,1000,2000,0.18                   //
    float da_offs[DQ_RTD388_CHAN][DQ_RTD388_K_RANGES];  // 1K, 2K and 3K resistance offsets

    // uint32s only used by logic
    uint32 gain_adc[DQ_RTD388_CHAN][DQ_RTD388_ADC_CH];  // Gain for 24-bit ADC channels
    //for current measurement, input A is assumed to be + relative to input B. mul by -1 occurs in driver
    uint32 offs_adc[DQ_RTD388_CHAN][DQ_RTD388_ADC_CH];  // Offset for 24-bit ADC channels,
} DQCALSET_388_, *pDQCALSET_388_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 val[DQ_RTD388_CHAN+1];   // RDAC values = channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    uint32 cfg;                     // mode configuration
    int clperint;                   // DQ_FIFO_CLPERINT by default
    uint32 rsv[DQ_RTD388_CHAN];      // reserved for future use
} DQOPMODEPRM_388_, *pDQOPMODEPRM_388_;

typedef struct {
    uint32 val[DQ_RTD388_CHAN];     // RDAC default values
    uint32 cb_limit[DQ_RTD388_CHAN][DQ_RTD388_CB_CH];     // default max/min CB values
    uint32 cb_mode[DQ_RTD388_CHAN]; // default CB behavior
    uint32 rsv2[DQ_RTD388_CHAN];    // reserved for future use
} DQINITPRM_388_, *pDQINITPRM_388_;

typedef struct {
    uint32 val[DQ_RTD388_CHAN];     // values for shutdown mode
    uint32 cfg;                     // mode configuration (user-level flags, like op mode)
} DQSDOWNPRM_388_, *pDQSDOWNPRM_388_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_388_ calset;
    DQCNAMES_388_ cname;
    DQOPMODEPRM_388_ opmodeprm;
    DQINITPRM_388_ initprm;
    DQSDOWNPRM_388_ sdownprm;
    DQPRMFLAGS eeflags;
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQCALSET_388_)
                           - sizeof(DQCNAMES_388_)
                           - sizeof(DQOPMODEPRM_388_)
                           - sizeof(DQINITPRM_388_)
                           - sizeof(DQSDOWNPRM_388_)
                           - sizeof(DQPRMFLAGS)
                           - sizeof(uint32)];   // crc
} DEVEEPROM_388_, *pDEVEEPROM_388_;



#define DQ_L401_CHAN                (24)
#define DQ_L414_CHAN                (14)
#define DQ_L414_ICHAN               (4)         // number of guardian ADC channels
#define DQ_L418_CHAN                (18)
#define DQ_L430_CHAN                (30)
#define DQ_L401_INFOSZ              DQ_MAX_INFO_SIZE    // maximum size of information structure
#define DQ_L401_BASE                BUS_FREQUENCY       // 66MHz base frequency
#define DQ_L401_MAXCLFRQ            (100000)
#define DQ_L401_MAXCVFRQ            (100000)

#define DQL_IOCTL401_CFG_DI_CHANGE  (0x0D)      // configure DI change event port and edge
#define DQL_IOCTL401_WAIT_DI_CHANGE (0x0E)      // Wait for a DI change event to occur

// Event data for 401 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];     // data to follow
} EV401_ID, *pEV401_ID;

#define DqAdv401ConfigEvents_PARAMSZ (2)        // maximum number of uint32 parameters after pEV401_ID

typedef enum {
    EV401_CLEAR = 0x1000,           // clear all events
    EV401_DI_CHANGE = 0x101,        // digital input change
    EV401_PERIODIC = 0x102          // periodic event (optionally period is reset every time DI_CHANGE event occurs)
} event401_t;

#define EV401_PERI_RESET            (1L<<0)     // reset timeout upon transmitting COS event


#define DQ_LTC1661_VAL(V)           (((V) & 0x3FF)<<2)    // value

// Device modes when switched into operation mode
// these bits are presented in the upper part of configuration word
#define DQ_L401_MODESCAN            (DQ_FIFO_MODESCAN)  // single scan update mod (no buffer)
#define DQ_L401_MODEDGE             (1UL << 16)         // edge detect mode
#define DQ_L401_MODEFIFO            (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO (simplified buffer)
#define DQ_L401_MODECONT            (DQ_FIFO_MODECONT)  // continuous acquisition (buffered)

#define DQ_L401_HYSTEN              (1UL<<18)   // hysteresis programming is enabled

#define DIO401_2_4_5_CMDRDWR        (DQL_CL_CMD1)   // CL port read/write command


//===================================================================================
// MUX-414/418  defines
//-----------------------------------------------------------------------------------
#define DQIOCTL_GET414STATUS        (0x08)      // used internally by DAQLib
#define DQIOCTL_SET414CONFIG        (0x09)      // used internally by DAQLib
#define DQ_414_PDNAEX_GET_CFG       (0x32324591)// used internally by DAQLib

// Channel list commands, also used internally by  DqAdv414Write()
#define DQ_MUX_CMD_PORT0            (0)         // Write to port0
#define DQ_MUX_CMD_A_RELAYS         (1)         // Write to "A" relays
#define DQ_MUX_CMD_B_RELAYS         (2)         // Write to "B" relays
#define DQ_MUX_CMD_C_RELAYS         (3)         // Write to "C" relays
#define DQ_MUX_CMD_PORT1            (4)         // Write to port1 (MUX418 only)

// used internally by DqAdv414SetCfg()
#define DQ_MUX414_CFG_DI_MODE       (1L<<26)    // 0=(level) / 1=edge
#define DQ_MUX414_CFG_DI_POL        (1L<<25)    // Polarity of sync_in strobe: 0=(low)falling / 1=(high)rising

// format of data for '414,'418  *status returned by DqAdv414ReadStatus(), DqAdv414ReadADC() and by DqAdv40xRead()
#define DQ_MUX414_STS_ADCDR         (1L<<17)    // =1 - new unread data is ready from ADC
#define DQ_MUX414_STS_OVR           (1L<<16)    // =1 - DOut overrun (a write occurred while busy)
#define DQ_MUX414_STS_BUSY          (1L<<3)     // =1 - state machine is busy, writes are ignored
#define DQ_MUX414_STS_SYNCWAIT      (1L<<2)     // =1 when output state machine waits for the external SYNC/ready
#define DQ_MUX414_STS_RDY           (1L<<1)     // =1 when relays are settled (ready)
#define DQ_MUX414_STS_DI_STS        (1L<<0)     // Report logic state of the sync_in pin,  ('418 pin 65) ('414 pin 48)

// format of data for port = DQ_MUX_CMD_PORT0
#define DQ_MUX414_PORT_CH13_D1      (27)        // Select state of channel 13,
#define DQ_MUX414_PORT_CH13_D0      (26)        //
//..                "                "                                     12 ... 1,
#define DQ_MUX414_PORT_CH0_D1       (1)         // Select state of channel 0
#define DQ_MUX414_PORT_CH0_D0       (0)         // ST =  0 - OFF, 1 - "A", 2 - "B", 3 - "C"

#define DQ_MUX414_PORT0_CH_OFF      (0)         // ST values for DQ_MUX414_PORT0_13() macro
#define DQ_MUX414_PORT0_CH_A        (1)         // ST =  0 - OFF, 1 - "A", 2 - "B", 3 - "C"
#define DQ_MUX414_PORT0_CH_B        (2)         //
#define DQ_MUX414_PORT0_CH_C        (3)         //

#define DQ_MUX414_PORT0_13(CH,ST)   ((ST)<<((CH)+(CH)))

// format of data for port = DQ_MUX_CMD_PORT1
#define DQ_MUX414_PORT1_CH17_D1     (7)         // Select state of channel 17,
#define DQ_MUX414_PORT1_CH17_D0     (6)         //
//..                "                "                                     16, 15,
#define DQ_MUX414_PORT1_CH14_D1     (1)         // Select state of channel 14
#define DQ_MUX414_PORT1_CH14_D0     (0)         // ST =  0 - OFF, 1 - "A", 2 - "B", 3 - "C"
                                                //
#define DQ_MUX414_PORT1_CH_OFF      (0)         // ST values for DQ_MUX414_PORT14_17() macro
#define DQ_MUX414_PORT1_CH_A        (1)         // ST =  0 - OFF, 1 - "A", 2 - "B", 3 - "C"
#define DQ_MUX414_PORT1_CH_B        (2)         //
#define DQ_MUX414_PORT1_CH_C        (3)         //

#define DQ_MUX414_PORT14_17(CH,ST)  ((ST)<<((CH)+(CH)-28))

#define DQ_MUX414_X_RELAYS_IMM      (1L<<29)    // =1 - apply new relay values immediately (0 - when data is written to MUX414_A_RELAYS)
#define DQ_MUX414_SET_BBM           (1L<<28)    // =1 - enable break-before-make protection
                                                // These 2 #defines are applied internally by DqAdv414Write(), not for use in user code.

/* structure for DqAdv414Write data */
typedef struct {
    int32 rflags;                   // select registers to write and add option flags
    int32 mux_select[2];            // MUX414_PORTx registers (0/1) port0=bits[27:0], port[1]=bits[7:0]
    int32 relay_select[3];          // MUX_x_RELAY registers (0=A,1=B,2=C), 414 uses bits[13:0], 418 uses bits[17:0]
} DQ414W, *pDQ414W;

// DQ414W.rflags = indicate which registers to write, select one of the following W_RELAY or W_PORT defines bitwise OR'd
//      with any or all of the DQ_MUX414_W_OPTION_xxx defines
//
#define DQ_MUX414_W_RELAY_A         (0x01)      // write relay_select[0]
#define DQ_MUX414_W_RELAY_B         (0x02)      // write relay_select[1]
#define DQ_MUX414_W_RELAY_BA        (0x03)      // write relay_select[1] and relay_select[0]
#define DQ_MUX414_W_RELAY_C         (0x04)      // write relay_select[2]
#define DQ_MUX414_W_RELAY_CA        (0x05)      // write relay_select[2] and relay_select[0]
#define DQ_MUX414_W_RELAY_CB        (0x06)      // write relay_select[2] and relay_select[1]
#define DQ_MUX414_W_RELAY_CBA       (0x07)      // write relay_select[2],    relay_select[1] and relay_select[0]
#define DQ_MUX414_W_PORT0           (0x10)      // write mux_select[0]
#define DQ_MUX414_W_PORT1           (0x20)      // write mux_select[1]
#define DQ_MUX414_W_PORT10          (0x30)      // write mux_select[1] and mux_select[0]
//
#define DQ_MUX414_W_OPTION_SIN      (1L<<31)    // =1 - wait for the selected in MUX414_CFG_DI_POL/MODE edge or (level) before
                                                //      applying the new settings to the relays (handshaking)
#define DQ_MUX414_W_OPTION_SOUT     (1L<<30)    // =1 - assert SYNC_OUT (MUX414_CFG_DO modes 6..9)
#define DQ_MUX414_W_OPTION_NO_BBM   (1L<<28)    // =1 - disable break-before-make protection

/* structure for DqAdv414ReadADC data */
typedef struct {
    double adc_in;                  // read input pin voltage relative to system power supply ground
    double adc_3_3;                 // layer selftest, monitor internal 3.3V supply
    double adc_2_5;                 // layer selftest, monitor internal 2.5V supply
    double adc_deg_c;               // adc temperature in degrees C
    uint32 status;                  // status identical to .status returned by DqAdv414ReadStatus()
    uint32 timestamp;               // timestamp
} DQ414ADC, *pDQ414ADC;

/* structure for DqAdv414SetCfg data */
typedef struct {
    uint32 on_delay;                // 10uS units, range 1..256, time before next command is accepted
    uint32 off_delay;               // 10uS units, range 1..256, breaking time of break-before-make
    uint32 di_mode;                 // sync in pin operation mode,  0 =(level) / 1 =edge
    uint32 di_polarity;             // Polarity of sync_in strobe: 0=(low)falling / 1=(high)rising
    uint32 sync_out_pw;             // sync_out pin pulse length upon write for sync_out_mode 6 and 7
                                    // 0 - 1uS, 1 - 10uS, 2 - 100uS, 3 - 1mS 4..15 - reserved

    uint32 sync_out_mode;           // sync_out pin mode of operation
                                    // 0 - drive sync_out pin with constant logic '0' (approx 0V)
                                    // 1 - drive sync_out pin with constant logic '1' (approx 3.15V)
                                    // 2..5 - sync_out pin driven by internal SYNC BUS[0]..[3]
                                    // 6 - positive going pulse on relay write  ( sync out pin normally low )
                                    // 7 - negative going pulse on relay write  ( sync out pin normally high )
                                    // 8 - logic '1' level on "relays ready" (test plug expects this setting) ( sync out pin normally high )
                                    // 9 - logic '0' level on "relays ready", will pulse during 'off_delay' ( sync out pin normally low )
    uint32 sync_skip;               // 0= normal operation, 1= stop waiting for sync_in strobe, self clearing
} DQ414CFG, *pDQ414CFG;

/* structure for DqAdv414ReadStatus data */
typedef struct {
    uint32 relay_a;                 //
    uint32 relay_b;                 //
    uint32 relay_c;                 //
    uint32 status;                  //
} DQ414STATUS, *pDQ414STATUS;


// ADC defines used internally by DqAdv414Read()
#define DQ_MUX414_ADC_DATA_EOC      (1L<<18)    // "EOC" bit, 0 indicates valid data,
                                                // 1 - conversion result read too soon (hardware error)
#define DQ_MUX414_ADC_DATA_SIG      (1L<<16)    // Sign bit, if this bit is same as MSB - conversion out of the range
#define DQ_MUX414_ADC_DATA_MSB      (1L<<15)    // Data MSB bit
#define DQ_MUX414_ADC_DATA_LSB      (1L<<0)     // Data LSB bit

#define DQ_MUX414_ADC_DATA_ERR      (0x7FFFF)   // Indicates ADC data overrange/underrange

#define DQ_MUX418_ADC_VREF          (2.5)       // volts
#define DQ_MUX418_ADC_OFFSET        (DQ_MUX418_ADC_VREF / 2.0)
#define DQ_MUX418_ADC_STEP          (DQ_MUX418_ADC_VREF / 65535.0)

#define DQ_MUX418_V_SCALER          ((22100.0/1000.0)+1.0)  // voltage scaling factor(23.1)  //  voltage scaling factor, ADC0-2
#define DQ_MUX418_T_SLOPE           (0.0000935 / (DQ_MUX418_ADC_VREF / (double)0xFFFF))      //  ADC counts per deg C, ADC4
#define DQ_MUX418_T_OFFSET          (273.0)     //  Kelvin to deg C

#define DQIOCTL_GET461STATUS        (0x0A)      // used internally by DAQLib, get status
#define DQIOCTL_SET461CONFIG        (0x0B)      // used internally by DAQLib, set 461 configuration
#define DQIOCTL_GET461COUNT         (0x0C)      // used internally by DAQLib, get 461 relay switch count
// 0xD and 0xE are used by DQL_IOCTL401_CFG_DI_CHANGE and DQL_IOCTL401_WAIT_DI_CHANGE
#define DQIOCTL_SET461CHANNEL       (0x0F)      // used internally by DAQLib, set 461 channel

// CAUTION! Enabling all relays together will destroy relay drivers
#define DQ_MUX461_CMD_RELAYS_NOPROT (0x2f)      // Write to direct relay register. This is currently disabled

// DqAdv461SetChannel command
#define DQ_MUX461_CMD_SETCHAN           (0)     // Write to channel control port
#define DQ_MUX461_SETCHAN_CHAN          (13)    // number of usable channels
// DqAdv461SetChannel <dmm_mode>
#define DQ_MUX461_SETCHAN_DMM_DISABLE   (0)     // Disable all relays
#define DQ_MUX461_SETCHAN_DMM_V         (1)     // Configure relays for DMM voltage mode
#define DQ_MUX461_SETCHAN_DMM_I         (2)     // Configure relays for DMM current mode
#define DQ_MUX461_SETCHAN_DMM_RES2      (3)     // Configure relays for DMM two-wire resistance mode
#define DQ_MUX461_SETCHAN_DMM_RES4      (4)     // Configure relays for DMM four-wire resistance mode
// DqAdv461SetChannel <relay_select>
#define DQ_MUX461_SETCHAN_RL_DISABLE    (0)         // Disable 'A' and 'B' relay
#define DQ_MUX461_SETCHAN_RL_A          (1L << 0)   // Enable 'A' relay
#define DQ_MUX461_SETCHAN_RL_B          (1L << 1)   // Enable 'B' relay
#define DQ_MUX461_SETCHAN_RL_A_B        (DQ_MUX461_SETCHAN_RL_A | DQ_MUX461_SETCHAN_RL_B)   // Enable 'A' and 'B' relay. Only available when using DQ_MUX461_SETCHAN_DMM_RES4
// DqAdv461SetChannel <sync>
#define DQ_MUX461_SETCHAN_SYNC_IN       (1L << 0)   // Wait for the configured <sync_in_mode> <sync_in_polarity> on SYNC_IN before applying this new configuration
#define DQ_MUX461_SETCHAN_SYNC_OUT      (1L << 1)   // Assert SYNC_OUT based on configured <sync_out_mode>

// DqAdv461ReadStatus
#define DQ_MUX461_STS_ADCDR         (1L<<17)    // =1 - new unread data is ready from ADC
#define DQ_MUX461_STS_OVR           (1L<<16)    // =1 - DOut overrun (a write occurred while busy)
#define DQ_MUX461_STS_BUSY          (1L<<3)     // =1 - state machine is busy
#define DQ_MUX461_STS_SYNCWAIT      (1L<<2)     // =1 when output state machine waits for external SYNC/ready
#define DQ_MUX461_STS_RDY           (1L<<1)     // =1 when relays are settled (ready)
#define DQ_MUX461_STS_DI_STS        (1L<<0)     // Report status of the sync_in pin

#define DQ_MUX461_NUM_CNT_CEL       (3)         // number of switch count cells

#define DQ_MUX461_A_RELAY_COUNT     (13)        // number of A relays
#define DQ_MUX461_B_RELAY_COUNT     (13)        // number of B relays
#define DQ_MUX461_D_RELAY_COUNT     (4)         // number of D relays
#define DQ_MUX461_TOTAL_RELAYS      (DQ_MUX461_A_RELAY_COUNT + DQ_MUX461_B_RELAY_COUNT + DQ_MUX461_D_RELAY_COUNT)

#define DQ_MUX461_W_OPTION_SIN      (1L<<1)     // =1 - wait for the selected in MUX461_CFG_DI_POL/MODE edge (or level) before
                                                //      applying the new settings to the relays (handshaking)
#define DQ_MUX461_W_OPTION_SOUT     (1L<<0)     // =1 - assert SYNC_OUT (MUX461_CFG_DO modes 6..9) must use with test plug
#define DQ_MUX461_W_A0              (1L<<0)     // enable A0
#define DQ_MUX461_W_A12             (1L<<12)    // enable A12
#define DQ_MUX461_W_A(N)            (1L<<(N))   // enable Nth A relay
#define DQ_MUX461_W_B0              (1L<<0)     // enable B0
#define DQ_MUX461_W_B12             (1L<<12)    // enable B12
#define DQ_MUX461_W_B(N)            (1L<<(N))   // enable Nth B relay
#define DQ_MUX461_W_D1              (1L<<0)     // enable D1
#define DQ_MUX461_W_D2              (1L<<1)     // enable D2
#define DQ_MUX461_W_D3              (1L<<2)     // enable D3
#define DQ_MUX461_W_D4              (1L<<3)     // enable D4
#define DQ_MUX461_W_D(N)            (1L<<(N))   // enable (N+1) D relay

#pragma pack(1)

typedef struct {
    int32 a_count[DQ_MUX461_A_RELAY_COUNT];     // count of times each relay has been energized
    int32 b_count[DQ_MUX461_B_RELAY_COUNT];     // values are signed to easily verify which eeprom
    int32 d_count[DQ_MUX461_D_RELAY_COUNT];     // cell to load and minimize data loss
} DQ461COUNT, *pDQ461COUNT;

/* structure for DqAdv461ReadADC data */
typedef struct {
    double adc_24;                  // monitor internal 24V supply
    double adc_3_3;                 // monitor internal 3.3V supply
    double adc_5VR;                 // monitor internal relay driver voltage
    double adc_deg_c;               // adc temperature in degrees C
    uint32 status;                  // status
    uint32 timestamp;               // timestamp
} DQ461ADC, *pDQ461ADC;

/* structure for DqAdv461SetCfg data */
typedef struct {
    uint32 d_bbm_mode;          // Configuration to perform break-before-make for "D" relays. If DMM mode
                                // remains the same, break-before-make should be suppressed
                                // to increase life span of these relays. See DQ_MUX461_SETCFG_D_BBM_ defines

    uint32 on_delay;            // 100uS units, range 1..256, time after a write before next write will start being applied. ie on_delay = 5 results in 500uS delay between writes
    uint32 off_delay;           // 100uS units, range 1..256, breaking time of break-before-make for relays. ie off_delay = 5 results in 500uS break time

    uint32 sync_in_mode;        // SYNC_IN pin operation mode. See DQ_MUX461_SETCFG_SYNC_IN_MODE_ defines
    uint32 sync_in_polarity;    // Polarity of SYNC_IN strobe. See DQ_MUX461_SETCFG_SYNC_IN_POLARITY_ defines

    uint32 sync_out_pw;         // SYNC_OUT pin pulse length when <sync_out_mode> = DQ_MUX461_SETCFG_SYNC_OUT_MODE_HIGH_PULSE and DQ_MUX461_SETCFG_SYNC_OUT_MODE_LOW_PULSE
                                // See DQ_MUX461_SETCFG_SYNC_OUT_PW_ defines
    uint32 sync_out_mode;       // SYNC_OUT pin mode of operation. See DQ_MUX461_SETCFG_SYNC_OUT_MODE_ defines

    uint32 sync_skip;           // Configuration to skip waiting for SYNC_IN. See DQ_MUX461_SETCFG_SYNC_ defines
} DQ461CFG, *pDQ461CFG;

// <d_bbm_mode>, 'D' relays are changed during <dmm_mode> changes when a write occurs. If the same <dmm_mode>
//              is going to be continuously used without changing, break-before-make can be disabled on
//              these relays to increase their life span.
#define DQ_MUX461_SETCFG_D_BBM_DISABLE  (0) // Disable 'D' relay break-before-make
#define DQ_MUX461_SETCFG_D_BBM_ENABLE   (1) // Enable 'D' relay break-before-make

// <sync_in_mode>
#define DQ_MUX461_SETCFG_SYNC_IN_MODE_LEVEL (0) // Checks for level of SYNC_IN when using DQ_MUX461_SETCHAN_SYNC_IN during a write
#define DQ_MUX461_SETCFG_SYNC_IN_MODE_EDGE  (1) // Checks for edge of SYNC_IN when using DQ_MUX461_SETCHAN_SYNC_IN during a write

// <sync_in_polarity>
#define DQ_MUX461_SETCFG_SYNC_IN_POLARITY_LOW   (0) // Waits for low level or falling edge of SYNC_IN when using DQ_MUX461_SETCHAN_SYNC_IN during a write
#define DQ_MUX461_SETCFG_SYNC_IN_POLARITY_HIGH  (1) // Waits for high level or rising edge of SYNC_IN when using DQ_MUX461_SETCHAN_SYNC_IN during a write

// <sync_out_pw>
#define DQ_MUX461_SETCFG_SYNC_OUT_PW_1US    (0) // SYNC_OUT pulse width = 1uS
#define DQ_MUX461_SETCFG_SYNC_OUT_PW_10US   (1) // SYNC_OUT pulse width = 10uS
#define DQ_MUX461_SETCFG_SYNC_OUT_PW_100US  (2) // SYNC_OUT pulse width = 100uS
#define DQ_MUX461_SETCFG_SYNC_OUT_PW_1MS    (3) // SYNC_OUT pulse width = 1mS

// <sync_out_mode>
#define DQ_MUX461_SETCFG_SYNC_OUT_MODE_LOW          (0) // drive constant logic '0' on SYNC_OUT
#define DQ_MUX461_SETCFG_SYNC_OUT_MODE_HIGH         (1) // drive constant logic '1' on SYNC_OUT
#define DQ_MUX461_SETCFG_SYNC_OUT_MODE_HIGH_PULSE   (6) // SYNC_OUT is normally low, generates high pulse on write
#define DQ_MUX461_SETCFG_SYNC_OUT_MODE_LOW_PULSE    (7) // SYNC_OUT is normally high, generates low pulse on write
#define DQ_MUX461_SETCFG_SYNC_OUT_MODE_HIGH_ON_RDY  (8) // SYNC_OUT is normally low, goes high when relays are in ready state
#define DQ_MUX461_SETCFG_SYNC_OUT_MODE_LOW_ON_RDY   (9) // SYNC_OUT is normally high, goes low when relays are in ready state

// <sync_skip>
#define DQ_MUX461_SETCFG_SYNC_NO_SKIP   (0) // If DQ_MUX461_SETCHAN_SYNC_IN was used in a previous write, layer will continue waiting for SYNC_IN to apply latest write
#define DQ_MUX461_SETCFG_SYNC_SKIP      (1) // If DQ_MUX461_SETCHAN_SYNC_IN was used in a previous write, skip waiting for SYNC_IN to apply latest write.
                                            // SYNC_IN will only be skipped if layer is currently waiting for SYNC_IN to apply latest write.

/* structure for DqAdv461ReadStatus data */
typedef struct {
    uint32 port0_write;             // last write
    uint32 port0_state;             // current state
    uint32 status;
    uint32 a_state;                 // current state of relays
    uint32 b_state;
    uint32 d_state;
} DQ461STATUS, *pDQ461STATUS;

#pragma pack()


#define DQ_L401_NAMELEN             (20)        // maximum length of the channel name (trailing 0 isn't included)
#define DQ_L414_NAMELEN             (20)
#define DQ_L430_NAMELEN             (16)

#pragma pack(1)
/* channel names */
typedef struct {
    char cname[DQ_L401_CHAN][DQ_L401_NAMELEN];
} DQCNAMES_401_, *pDQCNAMES_401_;


/* channel OP MODE parameters */
typedef struct {
    uint32 chlst[DQ_L401_CHAN*2];   // channel list for I/O - uncompressed
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    uint16 hyst[2];                 // hysteresis DACs A and B
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_401_, *pDQOPMODEPRM_401_;

typedef struct {
    uint32 val;                     /* line states in init mode */
} DQINITPRM_401_, *pDQINITPRM_401_;

typedef struct {
    uint32 val;                     /* line states in shutdown mode */
} DQSDOWNPRM_401_, *pDQSDOWNPRM_401_;

typedef struct {
    uint32 cfg2000;                 /* relay configuration in init mode */
    uint32 a_relays;                /* relay states in init mode */
    uint32 b_relays;                /* relay states in init mode */
    uint32 c_relays;                /* relay states in init mode */
}DQINITPRM_414_, *pDQINITPRM_414_;

typedef struct {
    uint32 cfg2000;                 /* relay configuration in shutdown mode */
    uint32 a_relays;                /* relay states in shutdown mode */
    uint32 b_relays;                /* relay states in shutdown mode */
    uint32 c_relays;                /* relay states in shutdown mode */
} DQSDOWNPRM_414_, *pDQSDOWNPRM_414_;

typedef struct {
    uint32 cfg_2000;
    uint32 cfg_2xch;
} DQINITPRM_461_, *pDQINITPRM_461_;

typedef struct {
    uint32 cfg_2000;
    uint32 cfg_2xch;
} DQSDOWNPRM_461_, *pDQSDOWNPRM_461_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_401_ opmodeprm;
    DQINITPRM_401_ initprm;
    DQSDOWNPRM_401_ sdownprm;
    DQCNAMES_401_ cname;            // DQCNAMES_430_ occupies the same amount of space (480 bytes) as DQCNAMES_401_:
                                    // 1) 401: DQ_L401_NAMELEN*DQ_L401_CHAN=20*24=480
                                    // 2) 430: DQ_L430_NAMELEN*DQ_L430_CHAN=16*30=480
                                    // 3) 461: DQ_L461_NAMELEN*DQ_L461_CHAN=26*18=468  be sure to skip over 12 unused spaces
    DQPRMFLAGSA eeflags;
    DQINITPRM_414_  initprm414;
    DQSDOWNPRM_414_ sdownprm414;

    DQINITPRM_461_  initprm461;
    DQSDOWNPRM_461_ sdownprm461;

    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                       - sizeof(DQOPMODEPRM_401_)
                       - sizeof(DQINITPRM_401_)
                       - sizeof(DQSDOWNPRM_401_)
                       - sizeof(DQCNAMES_401_)
                       - sizeof(DQPRMFLAGSA)
                       - sizeof(DQINITPRM_414_)
                       - sizeof(DQSDOWNPRM_414_)
                       - sizeof(DQINITPRM_461_)
                       - sizeof(DQSDOWNPRM_461_)
                       - (DQ_MUX461_NUM_CNT_CEL * sizeof(DQ461COUNT))
                       - sizeof(uint32)];       // crc

    DQ461COUNT switch_count[DQ_MUX461_NUM_CNT_CEL];  // must be at end for correct CRC calc
} DEVEEPROM_401_, *pDEVEEPROM_401_;

#pragma pack()


typedef struct {
    uint32 pos_edge_status;
    uint32 neg_edge_status;
} DIIEVENTPRM_401;

#define DQ_DIO403_LINES             (48)        // number of I/O lines
#define DQ_DIO403_CHAN              (2)         // working channels
#define DQ_DIO403_CHANSVC           (2)         // total channels including service
#define DQ_DIO403_INFOSZ            DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_DIO403_BASE              BUS_FREQUENCY  // 66MHz base frequency

#define DQ_DIO403_PORTS             (6)         // 6 8-bit ports in total

#define DQ_DIO448_LINES             (48)        // number of I/O lines
#define DQ_DIO448_CHAN              (2)         // working channels
#define DQ_DIO448_CHANSVC           (52)        // total channels including service
#define DQ_DIO448_INFOSZ            DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_DIO448_BASE              BUS_FREQUENCY  // 66MHz base frequency

#define DQL_IOCTL403_CFG_DI_CHANGE  (11L)       // configure DI change event port and edge
#define DQL_IOCTL403_WAIT_DI_CHANGE (12L)       // Wait for a DI change event to occur

#define DQ_DIO448_PORTS             (2)         // 2 ports in total
#define DQ_DIO448_RANGE             (45.0)      // full voltage range
#define DQ_DIO448_STEP              (0.000686646)
#define DQ_DIO448_CALDACS           (4)
#define DQ_DIO448_CVT_CHNL(V)       ((((float)(V))*DQ_DIO448_STEP)-(DQ_DIO448_RANGE/2))   // conversion macro
#define DQ_DIO448_MIN_uVCnt         (600)       // Minimum step in uV/count
#define DQ_DIO448_MAX_uVCnt         (800)       // Maximum step in uV/count
#define DQ_DIO448_MAX_Offset        (250)       // Maximum allowed offset after hardware calibration
#define DQ_DIO448_MAX_Hyst          (30.0)      // Maximum hysteresis setting

#define DQ_DIO403_MAXCVFRQ          (10000)     // 10kHz max

// Event data for 403 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];     // data to follow
} EV403_ID, *pEV403_ID;

#define DqAdv403ConfigEvents_PARAMSZ (4)        // maximum number of uint32 parameters after pEV403_ID

typedef enum {
    EV403_CLEAR = 0x1000,           // clear all events
    EV403_DI_CHANGE = 0x101,        // digital input change
    EV403_PERIODIC = 0x102          // periodic event (optionally period is reset every time DI_CHANGE event occurs)
} event403_t;

#define EV403_PERI_RESET        (1L<<0) // reset timeout upon transmitting COS event

//
// DIO-403 port-to-register-to-pin-name-to-dsub-pin mapping , used by DqAdv403SetIo()
// enable ports 0..5 for write (otherwise they are in tristate - read)
#define DQ_DIO403_ENPORT5           (1UL << 28)
#define DQ_DIO403_ENPORT4           (1UL << 27)
#define DQ_DIO403_ENPORT3           (1UL << 26)
#define DQ_DIO403_ENPORT2           (1UL << 25)
#define DQ_DIO403_ENPORT1           (1UL << 24)
#define DQ_DIO403_ENPORT0           (1UL << 23)

//
// port-bit register-bit  pin-name  DsubPin#    port for DqAdv403SetIo()
//   0   0        0   0     DIO0      20           DQ_DIO403_ENPORT0
//   0   1        0   1     DIO1      41           DQ_DIO403_ENPORT0
//   0   2        0   2     DIO2      61           DQ_DIO403_ENPORT0
//   0   3        0   3     DIO3      19           DQ_DIO403_ENPORT0
//   0   4        0   4     DIO4      40           DQ_DIO403_ENPORT0
//   0   5        0   5     DIO5      60           DQ_DIO403_ENPORT0
//   0   6        0   6     DIO6      18           DQ_DIO403_ENPORT0
//   0   7        0   7     DIO7      39           DQ_DIO403_ENPORT0
//   0   8        1   0     DIO8      59           DQ_DIO403_ENPORT1
//   0   9        1   1     DIO9      17           DQ_DIO403_ENPORT1
//   0  10        1   2     DIO10     38           DQ_DIO403_ENPORT1
//   0  11        1   3     DIO11     58           DQ_DIO403_ENPORT1
//   0  12        1   4     DIO12     16           DQ_DIO403_ENPORT1
//   0  13        1   5     DIO13     37           DQ_DIO403_ENPORT1
//   0  14        1   6     DIO14     57           DQ_DIO403_ENPORT1
//   0  15        1   7     DIO15     15           DQ_DIO403_ENPORT1
//   0  16        2   0     DIO16     36           DQ_DIO403_ENPORT2
//   0  17        2   1     DIO17     56           DQ_DIO403_ENPORT2
//   0  18        2   2     DIO18     14           DQ_DIO403_ENPORT2
//   0  19        2   3     DIO19     35           DQ_DIO403_ENPORT2
//   0  20        2   4     DIO20     55           DQ_DIO403_ENPORT2
//   0  21        2   5     DIO21     13           DQ_DIO403_ENPORT2
//   0  22        2   6     DIO22     34           DQ_DIO403_ENPORT2
//   0  23        2   7     DIO23     54           DQ_DIO403_ENPORT2
//   1   0        3   0     DIO24     12           DQ_DIO403_ENPORT3
//   1   1        3   1     DIO25     33           DQ_DIO403_ENPORT3
//   1   2        3   2     DIO26     53           DQ_DIO403_ENPORT3
//   1   3        3   3     DIO27     11           DQ_DIO403_ENPORT3
//   1   4        3   4     DIO28     32           DQ_DIO403_ENPORT3
//   1   5        3   5     DIO29     52           DQ_DIO403_ENPORT3
//   1   6        3   6     DIO30     10           DQ_DIO403_ENPORT3
//   1   7        3   7     DIO31     31           DQ_DIO403_ENPORT3
//   1   8        4   0     DIO32     51           DQ_DIO403_ENPORT4
//   1   9        4   1     DIO33      9           DQ_DIO403_ENPORT4
//   1  10        4   2     DIO34     30           DQ_DIO403_ENPORT4
//   1  11        4   3     DIO35     50           DQ_DIO403_ENPORT4
//   1  12        4   4     DIO36      8           DQ_DIO403_ENPORT4
//   1  13        4   5     DIO37     29           DQ_DIO403_ENPORT4
//   1  14        4   6     DIO38     49           DQ_DIO403_ENPORT4
//   1  15        4   7     DIO39      7           DQ_DIO403_ENPORT4
//   1  16        5   0     DIO40     28           DQ_DIO403_ENPORT5
//   1  17        5   1     DIO41     48           DQ_DIO403_ENPORT5
//   1  18        5   2     DIO42      6           DQ_DIO403_ENPORT5
//   1  19        5   3     DIO43     27           DQ_DIO403_ENPORT5
//   1  20        5   4     DIO44     47           DQ_DIO403_ENPORT5
//   1  21        5   5     DIO45      5           DQ_DIO403_ENPORT5
//   1  22        5   6     DIO46     26           DQ_DIO403_ENPORT5
//   1  23        5   7     DIO47     46           DQ_DIO403_ENPORT5
//                          DGND       1,2,22,23,42,43,44
//                          TRIG0      4
//                          TRIG1     45
//                          TRIG2     25
//                          +5V       21

// Upper part of the configuration word - AI-201 specific
#define DQ_DIO403_MODESCAN          (DQ_FIFO_MODESCAN)  // single scan update mod (no buffer) (0L<<16)
#define DQ_DIO403_MODEFIFO          (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO (simplified buffer) (2L<<16)
#define DQ_DIO403_MODECONT          (DQ_FIFO_MODECONT)  // continuous acquisition (buffered)  (3L<<16)

// enable ports 0..5 for write (otherwise they are in tristate - read)
#define DQ_DIO403_ENPORT5           (1UL << 28)
#define DQ_DIO403_ENPORT4           (1UL << 27)
#define DQ_DIO403_ENPORT3           (1UL << 26)
#define DQ_DIO403_ENPORT2           (1UL << 25)
#define DQ_DIO403_ENPORT1           (1UL << 24)
#define DQ_DIO403_ENPORT0           (1UL << 23)

// Output FIFO to read data
#define DQ_DIO403_FIFO_GET_DATA     DQ_FIFO_GET_DATA

// Input FIFO to read data
#define DQ_DIO403_FIFO_SET_DATA     DQ_FIFO_SET_DATA

// channel numbers for DIO448_MUXES
#define DQL_CHAN448_CHSE(N)         (((N)&0x3f)|0x40)   // single-ended channels 0..47
#define DQL_CHAN448_CHDF(N)         (((N)&0x1f)|0x40)   // differential channel 0..23 -> 64..87
#define DQL_CHAN448_PWR0            (0x30)      // user power 0/TCPOS
#define DQL_CHAN448_PWR1            (0x31)      // user power 1/TCNEG
#define DQL_CHAN448_GNDPIN          (0x32)      // user ground pin
#define DQL_CHAN448_VREF25          (0x33)      // Vref 2.500V - for use by UEI calibration software only
#define DQL_CHAN448_STATUS          (0x34)      // Virtual status channel
#define DQL_CHAN448_TCJC            (0x58)      // TCPOS/TCNEG DI
#define DQL_CHAN448_GNDPINDI        (0x59)      // USER_GND - AGND1
#define DQL_CHAN448_VREF25DI        (0x5A)      // Vref 2.5V - AGND1
#define DQL_CHAN448_GNDDI           (0x5B)      // differential ground to comp mux offset
#define DQL_CHAN448_ADCCHAN         (0x40)      // channels above it are ADC channels for DMap


#define DQ_DIO403_NAMELEN           (10)        // maximum length of the channel name (trailing 0 isn't included)
#define DQ_DIO448_NAMELEN           (10)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names for 403 */
typedef struct {
    char cname[DQ_DIO403_LINES][DQ_DIO403_NAMELEN];
} DQCNAMES_403_, *pDQCNAMES_403_;


typedef struct {
    char chlst[DQ_DIO403_CHAN*2];   /* channel list */
    uint32 cfg;                     /* control word - as it should be written */
    uint32 val[DQ_DIO403_CHAN];     /* initial settings in shutdown mode */
    uint32 cvclk;                   /* CV clock */
    uint32 clclk;                   /* CL clock */
    uint32 trig;                    /* trigger */
    int clperint;                   // <reserved>
} DQOPMODEPRM_403_, *pDQOPMODEPRM_403_;

typedef struct {
    uint32 cfg;                     /* control word - as it should be written */
    uint32 val[DQ_DIO403_PORTS];    /* voltages in init mode */
} DQINITPRM_403_, *pDQINITPRM_403_;

typedef struct {
    uint32 cfg;                     /* control word - as it should be written */
    uint32 val[DQ_DIO403_PORTS];    /* settings in shutdown mode */
} DQSDOWNPRM_403_, *pDQSDOWNPRM_403_;

/* combined structure to be allocated after CMNDEVS */
#define RES_403_SIZE                (DQ_EEMAXSIZE - sizeof(DQEECMNDEVS) \
                                    - sizeof(DQOPMODEPRM_403_) \
                                    - sizeof(DQINITPRM_403_) \
                                    - sizeof(DQSDOWNPRM_403_) \
                                    - sizeof(DQCNAMES_403_) \
                                    - sizeof(DQPRMFLAGS) \
                                    - sizeof(uint32) )  // crc
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_403_ opmodeprm;
    DQINITPRM_403_ initprm;
    DQSDOWNPRM_403_ sdownprm;
    DQCNAMES_403_ cname;
    DQPRMFLAGS eeflags;
    uint8 res[RES_403_SIZE];
} DEVEEPROM_403_, *pDEVEEPROM_403_;

/* channel names for 448 */
typedef struct {
    char cname[DQ_DIO448_LINES][DQ_DIO448_NAMELEN];
} DQCNAMES_448_, *pDQCNAMES_448_;

typedef struct {
    char chlst[DQ_DIO448_CHAN*2];   /* channel list */
    uint32 cfg;                     /* control word - as it should be written */
    uint32 cvclk;                   /* CV clock */
    uint32 clclk;                   /* CL clock */
    uint32 trig;                    /* trigger */
    int clperint;                   // <reserved>
} DQOPMODEPRM_448_, *pDQOPMODEPRM_448_;

typedef struct {
    uint32 cfg;                     /* control word - as it should be written */
    uint16 v_low[DQ_DIO448_PORTS];  /* low logic level for each port */
    uint16 v_high[DQ_DIO448_PORTS]; /* ditto high logic level */
} DQINITPRM_448_, *pDQINITPRM_448_;

typedef struct {
    uint8  cal[DQ_DIO448_CALDACS];  // calibration coeffs to load to DACs {gain,offset}
    // * following values are _after_ hardware calibration is applied *
    uint16 r_offset[DQ_DIO448_PORTS]; // actual offset at Channel to AGND
    uint16 r_usrgnd;                // measured user ground
    uint32 uv_2_5_ref;              // 2.5V reference, calibrated in uV
    int uv_low;                     // voltage level applied at low, uV
    int uv_high;                    // voltage level applied at high, uV
    uint16 r_low[DQ_DIO448_PORTS];  // reading at low for even and odd channels
    uint16 r_high[DQ_DIO448_PORTS]; // ditto at high
    //double step[DQ_DIO448_PORTS]; // V per bit
} DQCALSET_448_, *pDQCALSET_448_;

/* combined structure to be allocated after CMNDEVS */
#define RES_448_SIZE                (DQ_EEMAXSIZE - sizeof(DQEECMNDEVS) \
                                    - sizeof(DQCALSET_448_)  \
                                    - sizeof(DQOPMODEPRM_448_) \
                                    - sizeof(DQINITPRM_448_)  \
                                    - sizeof(DQCNAMES_448_) \
                                    - sizeof(DQPRMFLAGS) \
                                    - sizeof(uint32) )    // crc
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_448_ calset;
    DQOPMODEPRM_448_ opmodeprm;
    DQINITPRM_448_ initprm;
    DQCNAMES_448_ cname;
    DQPRMFLAGS eeflags;
    uint8 res[RES_448_SIZE];
} DEVEEPROM_448_, *pDEVEEPROM_448_;


/* structure for SETPARAM data (WRITE) */
typedef struct {
    uint32 cfgmask;                 // What parameters to set
    uint32 cfg;                     // 00 Set configuration
    uint32 adcdly;                  // ADC channel-to-channel delay, in 1.5us resolution (0x10 is minimum)
    uint32 reserved0;
    uint32 reserved1;
    uint32 reserved2;
} DQDIO448DATAOUT, *pDQDIO448DATAOUT;

#define DQDIO448_CFGSET             (1L<<0)     // =1 if "cfg" contain valid data
#define DQDIO448_ADCDLYSET          (1L<<1)     // =1 if "adcdly" contain valid data

#define DQDIO448_SETPARAM_SET       (0)         // set parameters
#define DQDIO448_GETPARAM_GET       (0)         // get parameters

// ioctls
#define DQL_IOCTL448_SET_LEVELS     (0x6)       // sets low- and high- levels
#define DQL_IOCTL448_SET_DBREGS     (0x7)       // sets debouncer registers

#define DQ_448_PDNAEX_GET_LEVELS    (0xF1)      // used internally by Explorer

#pragma pack()


#define DQ_DIO416_CHAN              (16)
#define DQ_DIO416_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_DIO416_BASE              (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_DIO416_MAXCLFRQ          (100000)
#define DQ_DIO416_MAXCVFRQ          (100000)

#define DQ_DIO432_CHAN              (32)
#define DQ_DIO432_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_DIO432_BASE              (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_DIO432_MAXCLFRQ          (100000)
#define DQ_DIO432_MAXCVFRQ          (100000)

// constant definitions
// for LCR/IER/IMR/ISR/ICR - see cli2.h

//===================================================================================
// DIO416 declarations
//-----------------------------------------------------------------------------------

#define DQL_DIO416_CFG              (0x2000)    // R/W    Selects disconnection mode for the over-current limit (2 modes are available:
                                                // auto-re-enable and user re-enable) . User re-enable is a default mode that requires
                                                // write to the DIO416_PORT0OUT to re-enable output on the disabled channel. If any
                                                // selected bit in DIO416_CFG register is set to 1, logic will try to re-enable disabled
                                                // output every 1sec.
#define DQL_DIO416_PORT0OUT         (0x2004)    // R/W Write to this register updates output port (bits 15-0 are valid)
#define DQL_DIO416_DISCFG           (0x2008)    // W    Overrides circuit breaker - 1 in bit corresponding to the channel number means
                                                // that circuit breaker will be ignored.
#define DQL_DIO416_DISSTS           (0x2008)    // R    Reports list of the disabled channels, bits 31-16 are sticky (report that
                                                // channel was disabled at least once), bits 15-0 report current status of the
                                                // corresponding channel. Sticky bits are cleared after each read
#define DQL_DIO416_ADCSTS           (0x200C)    // R     Current ADC speed settings + state machine status
#define DQL_DIO416_ADCSPD           (0x200C)    // W     4-bit conversion speed code + ADC timing settings
#define DQL_DIO416_PORT0OCS         (0x2010)    // R     Over- current status register
#define DQL_DIO416_PORT0OCM         (0x2010)    // W     Over- current interrupt mask register
#define DQL_DIO416_PORT0UCS         (0x2014)    // R    Under- current status register
#define DQL_DIO416_PORT0UCM         (0x2014)    // W    Under- current interrupt mask register
#define DQL_DIO416_RDCNT            (0x2018)    // R/W    Consecutive failed read counter. Internal state machine constantly monitors
                                                // current that flowing through the output channels, this register is used to set number
                                                // of consecutive reads in which over- current condition may be detected but ignored
                                                // prior to disabling the digital output channel. Valid values are 0-31
#define DQL_DIO416_ADCDATA0         (0x201C)    // R    ADC data returned based on CLI_DIO416_ADCCFG0
#define DQL_DIO416_ADCCFG0          (0x201C)    // W    Low-side ADC configuration    LTC2446/2447 control word - will be transferred over
                                                // to ADC after all internal state machine acquisitions are complete, following
                                                // conversion results will be stored in DIO416_ADCDATA register. If this register = 0
                                                // - no additional conversions will be performed
#define DQL_DIO416_ADCDATA1         (0x2020)    // R    see CLI_DIO416_ADCDATA0 (but for high-side A/D)
#define DQL_DIO416_ADCCFG1          (0x2020)    // W     see CLI_DIO416_ADCCFG0 (but for high-side A/D)
#define DQL_DIO416_DISDIV           (0x2024)    // R/W    Divider for re-enable clock
#define DQL_DIO416_DOUTACT          (0x2028)    // R    Actual value driven on DOUT (channels 0/2/4/8/10/12/14 are inverted
#define DQL_DIO416_OCLS             (0x2040)    // Over-current limit registers START address
                                                // R/W    16 registers, set overcurrent limit in LTC2447 data format, 24LSBs valid
#define DQL_DIO416_OCLE             (0x207C)    // Over-current limit registers END address
#define DQL_DIO416_UCLS             (0x2080)    // Under-current limit registers START address
                                                // R/W    16 registers, set undercurrent limit in LTC2447 data format, 24LSBs valid
#define DQL_DIO416_UCLE             (0x20BC)    // Under-current limit registers END address
#define DQL_DIO416_ADCS             (0x20C0)    // Last conversion result from the corresponding channel registers START address
                                                // R    16 registers, Last value read from the ADC for the corresponding channel
#define DQL_DIO416_ADCE             (0x20FC)    // Last conversion result from the corresponding channel registers END address

//----- Registers bit description/definitions
// 0x200C ADCSPD bits 3:0 - select ADC speed
//                                  Code         ADC speed Rate/channel p-p noise    Break time mS
//                                                                      (mA @ +/-2A) @ 4 decision samples
#define DQ_L416_ADCSPD_190          (1)         // 3.52KHz   190Hz/ch       5.5          20
#define DQ_L416_ADCSPD_130          (2)         // 1.76KHz   130Hz          5            25
#define DQ_L416_ADCSPD_85           (3)         // 880Hz      85Hz          3.6          40
#define DQ_L416_ADCSPD_45           (4)         // 440Hz      45Hz          2.9          70
#define DQ_L416_ADCSPD_22           (5)         // 220Hz      22Hz          1.25        130
#define DQ_L416_ADCSPD_12           (6)         // 110Hz      12Hz          1.1         250
#define DQ_L416_ADCSPD_6_5          (7)         // 55Hz        6.5Hz        0.84        500
#define DQ_L416_ADCSPD_3_2          (8)         // 27.5Hz      3.2Hz        0.77       1000
#define DQ_L416_ADCSPD_1_6          (9)         // 13.75Hz     1.6Hz        0.36       2000
#define DQ_L416_ADCSPD_0_8          (15)        // 6.875Hz     0.8Hz        0.26       4000
                                     // All other combinations are reserved and should not be used
#define DQ_L416_ADCSPD_UONLY        (31)        // if =1 - switch to user-only conversion mode (for easy debug with scope)
#define DQ_L416_ADCSPD_NOBUSY       (30)        // if =1 - do not restart SM on BUSY
#define DQ_L416_ADCSPD_24BIT        (29)        // if =1 - reformat output data into 24-bit for easy reading (default)
#define DQ_L416_ADCSPD_ADCFE        (28)        // if =1 - read data from the ADC on the falling edge of the clock
#define DQ_L416_ADCSPD_DIVMSB       (27)        // Divider for the 66MHz clock that should be supplied to the ADC
#define DQ_L416_ADCSPD_DIVLSB       (20)        // should be >=3 for the proper operation, defult = 16
#define DQ_L416_ADCSPD_ASL1BIT      (19)        // Offset output by <<1 (for debug purposes only)
#define DQ_L416_ADCSPD_MSB          (3)         // MSB for the speed selector
#define DQ_L416_ADCSPD_LSB          (0)         // LSB for the speed selector
//------------------------------------------------------------------------------------------------
// 0x200C ADCSTS - status and debug bits for the ADC converter and state machines
// Bits 31:20 and 3:0 reflect current values written to the corresponding bits of ADCCFG register
#define DQ_L416_ADCSTS_ADC1CH_MSB   (18)        // Currently acquired channel number for the high-side ADC
#define DQ_L416_ADCSTS_ADC1CH_LSB   (16)        //
#define DQ_L416_ADCSTS_ADC0CH_MSB   (14)        // Currently acquired channel number for the low-side ADC
#define DQ_L416_ADCSTS_ADC0CH_LSB   (12)        //
#define DQ_L416_ADCSTS_ADC1TO       (11)        // If=1 - timeout was detected from high-side ADC
#define DQ_L416_ADCSTS_ADC1SM_MSB   (10)        // high-side ADC state machine status
#define DQ_L416_ADCSTS_ADC1SM_LSB   (8)         //
#define DQ_L416_ADCSTS_ADC0TO       (7)         // If=1 - timeout was detected from low-side ADC
#define DQ_L416_ADCSTS_ADC0SM_MSB   (6)         // low-side ADC state machine status
#define DQ_L416_ADCSTS_ADC0SM_LSB   (4)         //
//------------------------------------------------------------------------------------------------
// 0x20C0-20FC - ADCDATA registers. In Native format mode return 32-bit result from ADC
// in 24-bit mode (default) return 24 bit data and 2-bit over/under/in-range status from ADC
#define DQ_L416_ADCDATA_OR          (3)         // Status field values for the ADC result in 24-bit
#define DQ_L416_ADCDATA_UR          (1)         // mode OR=over-range of the ADC (>=2A)
#define DQ_L416_ADCDATA_OK          (0)         // UR=under-range of the ADC (<=-2A), OK - within ADC range
#define DQ_L416_ADCDATA_STS1        (28)        // Conversion result status bits (OR/UR,OK)
#define DQ_L416_ADCDATA_STS0        (27)        //
#define DQ_L416_ADCDATA_MSB         (23)        // MSB for the 24-bit data (straight binary)
#define DQ_L416_ADCDATA_LSB         (0)         // LSB for the 24-bit data

//--------------------------------------------------------------------------------------------------------------------
// Conversion result format for all LTC24xx family:
//    CLI_LTC24xx_EOC    (31)   //  /EOC (End-Of-Conversion), conversion completed when = 0
//    CLI_LTC24xx_DMY    (30)   //  DMY (dummy) bit -  should be 0
//    CLI_LTC24xx_SIG    (29)   //    SIG and MSB bits define result sign and/ or valideness
//    CLI_LTC24xx_MSB    (28)   //   1       1      - data is above maximum
//    CLI_LTC24xx_BIT22  (27)   //   1       0      - result is positive (>0)
//    CLI_LTC24xx_BIT0    (5)   //   0       1      - result is negative (<0)
//    CLI_LTC24xx_SUB4    (4)   //   0       0      - data is below minimum
//    CLI_LTC24xx_SUB3    (3)   //
//    CLI_LTC24xx_SUB2    (2)   //
//    CLI_LTC24xx_SUB1    (1)   // SUB4-SUB0 are sub-LSB (may be used for better, then 24-bit resolution)
//    CLI_LTC24xx_SUB0    (0)   //
//--------------------------------------------------------------------------------------------------------------------
//    CLI_LTC24xx_DATA  (0x1FFFFFE) // Extract 24-bit result of the conversion
//-----------------------------------------------------------------------------------
// DIO-416 - specific status bits in LSR (0x0+RD). Following standard bits are re-assigned for the DIO-416 layer
#define DQ_LSR416_VCCIS             (23)        // DIO-416 - 1=vcc_ok -  VCC available on the isolated side
#define DQ_LSR416_CLKIN_TRIG        (22)        // DIO-416 - clkin/trig pin from DB-37
#define DQ_LSR416_CLOUT             (20)        // DIO-416 - clout pin to DB-37


//===================================================================================
// DIO-432/433 declarations
//-----------------------------------------------------------------------------------
#define DQL_DIO432_BASES            (0x2000)    // Common 432/433 address space
#define DQL_DIO432_BASEE            (0x20FC)    //

// Global register addresses
#define DQL_DIO432_DIN              (0x2000)    // R Current value of the all digital output pins (32 channels)
#define DQL_DIO432_DOUT             (0x2004)    // R/W 32-bit Digital output port, translates to BLK0(0-15 ch) and BLK1 (16-31 ch)

// -- same as on 416 (see 416 for the block addresses)
#define DQL_DIO432_BLK0S            (0x2100)    // DIO Block 0 (bits 15:0) start/base
#define DQL_DIO432_BLK0E            (0x22FC)    // DIO Block 0 end
#define DQL_DIO432_BLK0             (0x100)     // DIO Block 0 offset
#define DQL_DIO432_BLK1S            (0x2300)    // DIO Block 1 (bits 31:16) start/base
#define DQL_DIO432_BLK1E            (0x24FC)    // DIO Block 1 end
#define DQL_DIO432_BLK1             (0x300)     // DIO Block 1 offset
// -- different from 416
#define DQL_DIO432_BLK2S            (0x2500)    // VIN Block 2 (bits 15:0) start/base
#define DQL_DIO432_BLK2E            (0x25FC)    // VIN Block 2 end
#define DQL_DIO432_BLK2             (0x500)     // VIN Block 2 offset
#define DQL_DIO432_BLK3S            (0x2600)    // VIN Block 3 (bits 31:16) start/base
#define DQL_DIO432_BLK3E            (0x26FC)    // VIN Block 3 end
#define DQL_DIO432_BLK3             (0x600)     // VIN Block 3 offset

#define DQL_DIO432_DIOS             (0x2700)    // DOut PWM Sweep configuration area start
#define DQL_DIO432_CLKDIV           (0x2708)    // R/W 32-bit divider for the 66MHz frequency for
                                                // the PWM, used to set length of PWM period
#define DQL_DIO432_PWMDIV           (0x270C)    // R/W 32-bit divider for the 66MHz frequency for
                                                // the PWM, used to set PWM base frequency
#define DQL_DIO432_DIODIVS          (0x2800)    // DOut PWM dividers start
#define DQL_DIO432_DIODIVE          (0x287C)    // DOut PWM dividers end
#define DQL_DIO432_DIOCFGS          (0x2880)    // DOut PWM configuration start
#define DQL_DIO432_DIOCFGE          (0x28FC)    // DOut PWM configuration end
#define DQL_DIO432_DIOUSRS          (0x2900)    // DOut PWM user duty cycle start
#define DQL_DIO432_DIOUSRE          (0x297C)    // DOut PWM user duty cycle end
#define DQL_DIO432_DIOE             (0x297C)    // DOut PWM Sweep configuration area end

// Register reletively to the "base+block" addresses.
// Base is 0x2000 and "block" addresses are 0x500/0x600
#define DQL_DIO432_VINCFG           (0x00)      // R/W VIN ADC Configuration
#define DQL_DIO432_VINSTS           (0x04)      // R/W VIN ADC Status
#define DQL_DIO432_USERCFG          (0x08)      // R/W ADC Configuration for "user" conversion
#define DQL_DIO432_USERDATA         (0x0C)      // R/W ADC result for "user" conversion
#define DQL_DIO432_ADCDATAS         (0x80)      // R   Up to 16 ADC results
#define DQL_DIO432_ADCDATAE         (0xBC)      // R

#define DQL_DIO432_VINCFG_UONLY     (31)        // if =1 - switch to user-only conversion mode (for easy debug with scope)
#define DQL_DIO432_VINCFG_24BIT     (30)        // if =1 - reformat output data into 24-bit for easy reading (default)
#define DQL_DIO432_VINCFG_ADCFE     (29)        // if =1 - read data from the ADC on the falling edge of the clock
#define DQL_DIO432_VINCFG_ASL1BIT   (28)        // Offset output by <<1 (for debug purposes only)
#define DQL_DIO432_VINCFG_DIVMSB    (27)        // Divider for the 66MHz clock that should be supplied to the ADC
#define DQL_DIO432_VINCFG_DIVLSB    (20)        // should be >=3 for the proper operation, default = 16
#define DQL_DIO432_VINCFG_SPEEDMSB  (19)        // ADC Speed code - varies from ADC to ADC
#define DQL_DIO432_VINCFG_SPEEDLSB  (16)        //
#define DQL_DIO432_VINCFG_DIMSB     (15)        // Differential flag, per channel (up to 16 channels)
#define DQL_DIO432_VINCFG_DILSB     (0)         //

#define DQL_DIO432_DIO_OFFSET(CH)   ((((CH)&0x1F)<(DQ_DIO432_CHAN/2))?DQL_DIO432_BLK0:DQL_DIO432_BLK1)  // DIO Block offset depends of channel number
#define DQL_DIO432_VIN_OFFSET(CH)   ((((CH)&0x1F)<(DQ_DIO432_CHAN/2))?DQL_DIO432_BLK2:DQL_DIO432_BLK3)  // VIN Block offset depends of channel number
#define DQL_DIO432_OFFSET0          (DQL_DIO432_BLK0)   // offset for the first control block of DIO-432
#define DQL_DIO432_OFFSET1          (DQL_DIO432_BLK1)   // offset for the second control block of DIO-432

#define DQL_IS_DIO432(N)            (((N) == 0x432)||((N) == 0x433))

// DIO432/433 channels number converter (voltage)
#define DQL_DIO432_VIN_CH_MAP(N)    (DQL_DIO432_BASES | DQL_DIO432_VIN_OFFSET(N) | DQL_DIO432_ADCDATAS | (((N)&0xF) <<2))
// DIO432/433 channels number converter (current)
#define DQL_DIO432_IIN_CH_IDX(N)    ((((N)&0xF) < 8L) ? ((((N)&0xF) << 3)+4L) : (((N)&0xF)<<3))
#define DQL_DIO432_IIN_CH_MAP(N)    (DQL_DIO432_BASES | DQL_DIO432_DIO_OFFSET(N) | DQL_DIO416_ADCS | DQL_DIO432_IIN_CH_IDX(N))
#define DQL_DIO432_OCL_CH_MAP(N)    (DQL_DIO432_BASES | DQL_DIO432_DIO_OFFSET(N) | DQL_DIO416_OCLS | (((N)&0xF) <<2))
#define DQL_DIO432_UCL_CH_MAP(N)    (DQL_DIO432_BASES | DQL_DIO432_DIO_OFFSET(N) | DQL_DIO416_UCLS | (((N)&0xF) <<2))


// END of DIO416/432/433 declarations
//===================================================================================

// ----------------- calibration (over/under current limits) ------

#define DQ_L416_MAXCURRENT          (2.0)       // Max current limit, AMPS
#define DQ_L416_MINCURRENT          (-2.0)      // Minimum current limit, AMPS (actual current is 0.01 to 2A)
#define DQ_L432_MAXCURRENT          (2.0)       // Max current limit, AMPS
#define DQ_L432_MINCURRENT          (-2.0)      // Minimum current limit, AMPS (actual current is 0.01 to 2A)
#define DQ_L432_MAXVOLTAGE          (63.75)     // Max voltage limit, VOLTS
#define DQ_L432_MINVOLTAGE          (-63.75)    // Minimum voltage limit, VOLTS

#define DQ_L416_MAXRAW              (0x00FFFFFF)// Max current limit, raw value
#define DQ_L416_MINRAW              (0x00000000)// Minimum current limit, raw value
#define DQ_L432_MAXRAW_16BIT        (0x0000FFFF)// Max current/voltage limit (16 bit), raw value
#define DQ_L432_MAXRAW_24BIT        (0x00FFFFFF)// Max current/voltage limit (24 bit), raw value
#define DQ_L432_MINRAW              (0x00000000)// Minimum current limit, raw value

// Device modes when switched into operation mode
// these bits are presented in the upper part of configuration word
#define DQ_L416_MODESCAN            (DQ_FIFO_MODESCAN)  // single scan update mod (no buffer)
#define DQ_L416_MODEFIFO            (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO (simplified buffer)
#define DQ_L416_MODECONT            (DQ_FIFO_MODECONT)  // continuous acquisition (buffered)

#define DIO416_CMDRDWR              (DQL_CL_CMD1) // CL port read/write command

#define DQDIO432_SETPARAM_SET       (0)         // set parameters
#define DQDIO432_SETPARAM_PWM       (1)         // set PWM parameters

#define DQDIO432_GETPARAM_GET       (0)         // get parameters
#define DQDIO432_GETPARAM_PWM       (1)         // get PWM parameters

#define DQL_IOCTL432_SETDCDC        (0x8)       // set DC/DC state


#define DQ_L416_NAMELEN             (20)        // maximum length of the channel name (trailing 0 isn't included)
#define DQ_L432_NAMELEN             (10)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_DIO416_CHAN][DQ_L416_NAMELEN];
} DQCNAMES_416_, *pDQCNAMES_416_;

typedef struct {
    char cname[DQ_DIO432_CHAN][DQ_L432_NAMELEN];
} DQCNAMES_432_, *pDQCNAMES_432_;


/* specific device structure - calibration values */
typedef struct {                    // Current value (hex) of the calibration shunt from internal monitor:
    int32 iint00[DQ_DIO416_CHAN];   //  Low/High-side FETs are closed
    int32 iint11[DQ_DIO416_CHAN];   //  Low/High-side FETs are opened
                                    // Current value (uA) of the calibration shunt from external measuring device:
    int32 iext00[DQ_DIO416_CHAN];   //  Low/High-side FETs are closed
    int32 iext11[DQ_DIO416_CHAN];   //  Low/High-side FETs are opened
} DQCALSET_416_, *pDQCALSET_416_;

typedef struct {
    int16 i_offset[DQ_DIO432_CHAN];
    int16 i_gain[DQ_DIO432_CHAN];
    int16 v_offset[DQ_DIO432_CHAN];
    int16 v_gain[DQ_DIO432_CHAN];
} DQCALSET_432_, *pDQCALSET_432_;

typedef struct {
    uint32 chlst[DQ_DIO416_CHAN*2]; // channel list for I/O - uncompressed
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    uint32 oclimit[DQ_DIO416_CHAN]; // over-current limit
    uint32 uclimit[DQ_DIO416_CHAN]; // under-current limit (functionality not currently supported)
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_416_, *pDQOPMODEPRM_416_;

typedef struct {
    //uint32 chlst;                 // channel list for compressed
    uint32 chlst[DQ_DIO432_CHAN];   // channel list for I/O - uncompressed
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    uint32 oclimit[DQ_DIO432_CHAN]; // over-current limit
    uint32 uclimit[DQ_DIO432_CHAN]; // under-current limit
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_432_, *pDQOPMODEPRM_432_;

typedef struct {
    uint32 val;                     /* line states in init mode */
} DQINITPRM_416_, *pDQINITPRM_416_;

typedef struct {
    uint32 val;                     /* line states in shutdown mode */
} DQSDOWNPRM_416_, *pDQSDOWNPRM_416_;

typedef struct {
    uint32 val;                     /* line states in init mode */
} DQINITPRM_432_, *pDQINITPRM_432_;

typedef struct {
    uint32 val;                     /* line states in shutdown mode */
} DQSDOWNPRM_432_, *pDQSDOWNPRM_432_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_416_ calset;
    DQOPMODEPRM_416_ opmodeprm;
    DQINITPRM_416_ initprm;
    DQSDOWNPRM_416_ sdownprm;
    DQCNAMES_416_ cname;
    DQPRMFLAGS eeflags;
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQCALSET_416_)
                           - sizeof(DQOPMODEPRM_416_)
                           - sizeof(DQINITPRM_416_)
                           - sizeof(DQSDOWNPRM_416_)
                           - sizeof(DQCNAMES_416_)
                           - sizeof(DQPRMFLAGS)
                           - sizeof(uint32)];

} DEVEEPROM_416_, *pDEVEEPROM_416_;

typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_432_ calset;
    DQOPMODEPRM_432_ opmodeprm;
    DQINITPRM_432_ initprm;
    DQSDOWNPRM_432_ sdownprm;
    DQCNAMES_432_ cname;
    DQPRMFLAGS eeflags;
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)
                           - sizeof(DQCALSET_432_)
                           - sizeof(DQOPMODEPRM_432_)
                           - sizeof(DQINITPRM_432_)
                           - sizeof(DQSDOWNPRM_432_)
                           - sizeof(DQCNAMES_432_)
                           - sizeof(DQPRMFLAGS)
                           - sizeof(uint32)];

} DEVEEPROM_432_, *pDEVEEPROM_432_;

/* structure for CVTCHAN data */
typedef struct {
    int32 cfg;                      // Current disconnection mode
    int32 port0out;                 // Current value written to the output port
    int32 adcsts;                   // Current status of the ADC configuration/state machines
    int32 port0ocs;                 // Over-current interrupt status
    int32 port0ucs;                 // Under-current interrupt status
    int32 rdcnt;                    // Current value of the consequtive read counter setting
    int32 adcdata0;                 // Result of the user-defined conversion on Low-side ADC
    int32 adcdata1;                 // Result of the user-defined conversion on High-side ADC
    int32 disdiv;                   // Current value of the re-enable divider
    int32 dout;                     // Actual value driven by the DOUT port (Note: channels 0/2/4/6/8/10/12/14 inverted)
    int32 vccis;                    // VCC available on the isolated side
    int32 ocl[DQ_DIO416_CHAN];      // Current value of the over-current limits
    int32 ucl[DQ_DIO416_CHAN];      // Current value of the under-current limits
    int32 adc[DQ_DIO416_CHAN];      // Current value of the conversion results (hex)
    int32 cur[DQ_DIO416_CHAN];      // Current value of the conversion results (uA)
} DQDIO416DATAIN, *pDQDIO416DATAIN;

/* structure for SETPARAM data */
typedef struct {
    int32 cfgset;                   // =1 if "cfg" contain valid data
    int32 cfg;                      // Set disconnection mode
    int32 discfgset;                // =1 if "discfg" contain valid data
    int32 discfg;                   // Override circuit breaker
    int32 adcspdset;                // =1 if "adcspdset" contain valid data
    int32 adcspd;                   // Set ADC Timing
    int32 port0ocmset;              // =1 if "port0ocmset" contain valid data
    int32 port0ocm;                 // Set over-current interrupt mask
    int32 port0ucmset;              // =1 if "port0ucmset" contain valid data
    int32 port0ucm;                 // Set under-current interrupt mask
    int32 rdcntset;                 // =1 if "rdcntset" contain valid data
    int32 rdcnt;                    // Set number of "failed" samples prior breaker engagement
    int32 adccfg0set;               // =1 if "adccfg0set" contain valid data
    int32 adccfg0;                  // "User" ADC conversion control word for low-side ADC
    int32 adccfg1set;               // =1 if "adccfg1set" contain valid data
    int32 adccfg1;                  // "User" ADC conversion control word for high-side ADC
    int32 disdivset;                // =1 if "disdivset" contain valid data
    int32 disdiv;                   // 66MHz divider for the re-enable counter
} DQDIO416DATAOUT, *pDQDIO416DATAOUT;

/* structure for GETPARAM data (READ) */
typedef struct {
    uint32 portout;                 // Current value written to the output port (31-0 ch)
    uint32 portocs;                 // Over-current interrupt status (31-0 ch)
    uint32 portucs;                 // Under-current interrupt status (31-0 ch)
    uint32 rdcnt;                   // Current value of the consequtive read counter setting
                                    // Number of "failed" reads prior to disabling the channel (5 bit - [4:0])
    uint32 disdiv;                  // Current value of the re-enable divider (32 bit)
    uint32 dout;                    // Actual value driven by the DOUT port (31-0 ch)
    uint32 vccis;                   // VCC available (0/1) on the isolated side
    uint32 adc_i[DQ_DIO432_CHAN];   // Current value of the measured current (raw)
    uint32 adc_v[DQ_DIO432_CHAN];   // Current value of the measured voltage (raw)
} DQDIO432DATAIN, *pDQDIO432DATAIN;

// structure to control soft-start and PWM mode
typedef struct {
    uint8   channel;                // channel number
    uint8   mode;                   // mode of operation
    uint16  duty_cycle;             // duty cycle or divider for the CLKDIV frequency
} DQDIO432PWM, *pDQDIO432PWM;

#define DQDIO432_PWM_DISABLED       (0)         // PWM and soft start disabled
#define DQDIO432_PWM_SOFTSTART      (1)         // use PWM to soft-start (when output changes from 0 to 1)
#define DQDIO432_PWM_SOFTSTOP       (2)         // use PWM to soft-stop (when output changes from 1 to 0)
#define DQDIO432_PWM_SOFTBOTH       (3)         // use PWM to soft-start and soft-stop
#define DQDIO432_PWM_MODE           (4)         // use output in PWM mode
#define DQDIO432_PWM_MODE_GATED     (5)         // use output in gated PWM mode (logic rev 02.11.0A or greater)

typedef struct {
#ifdef __KERNEL__ // TRUE when building Linux kernel driver
    // Avoid name collision with current already defined in asm-generic/current.h
    double current_[DQ_DIO432_CHAN]; // Current value of the measured current (Ampers)
#else
    double current[DQ_DIO432_CHAN]; // Current value of the measured current (Ampers)
#endif
    double voltage[DQ_DIO432_CHAN]; // Current value of the measured voltage (Volts)
} DQDIO432CVTD, *pDQDIO432CVTD;

/* structure for SETPARAM data (WRITE) */
typedef struct {
    uint32 cfgmask;                 // What parameters to set
    uint32 cfg;                     // 00 Set disconnection mode
    uint32 discfg;                  // 08 Override circuit breaker
    uint32 adcspd;                  // 0c Set ADC Timing
    uint32 portocm;                 // 10 Set over-current detection mask
    uint32 portucm;                 // 14 Set under-current detection mask
    uint32 rdcnt;                   // 18 Set number of "failed" samples prior breaker engagement,Valid values are 0-31
    uint32 disdiv;                  // 24 66MHz divider for the re-enable counter
} DQDIO432DATAOUT, *pDQDIO432DATAOUT;

// define the bits in DQDIO432DATAOUT.cfgmask
#define DQDIO432_CFGSET             (1L<<0)     // =1 if "cfg" contain valid data
#define DQDIO432_DISCFGSET          (1L<<1)     // =1 if "discfg" contain valid data
#define DQDIO432_ADCSPDSET          (1L<<2)     // =1 if "adcspdset" contain valid data
#define DQDIO432_PORT0OCMSET        (1L<<3)     // =1 if "port0ocmset" contain valid data
#define DQDIO432_PORT0UCMSET        (1L<<4)     // =1 if "port0ucmset" contain valid data
#define DQDIO432_RDCNTSET           (1L<<5)     // =1 if "rdcntset" contain valid data
#define DQDIO432_DISDIVSET          (1L<<6)     // =1 if "disdivset" contain valid data

// DMap channels (input):
// 0..31 - current, 32..63 - voltage
#define DQ_DIO432_PORT0OCS_CH       (0x40)      // over-current state port 0
#define DQ_DIO432_PORT1OCS_CH       (0x41)      // over-current state port 1
#define DQ_DIO432_PORT0ACT_CH       (0x42)      // actual DOut port 0 (after circuit breaker)
#define DQ_DIO432_PORT1ACT_CH       (0x43)      // actual DOut port 1 (after circuit breaker)
#define DQ_DIO432_PORT0DISSTS_CH    (0x44)      // disabled lines status port 0
#define DQ_DIO432_PORT1DISSTS_CH    (0x45)      // disabled lines status port 1

// DMap channels (output)
// 0 - output, 32-63 - PWM setting (duty cycle) for the channel
#define DQ_DIO432_DIOUSRS           (0x20)      // PWM data from this channel

#pragma pack()


#define DQ_DIO449_LINES             (48)
#define DQ_DIO449_PORTS             (2)         // 2 ports in total, 24 bits on each port
#define DQ_DIO449_LINES_PER_PORT    (DQ_DIO449_LINES/DQ_DIO449_PORTS)   // 24
#define DQ_DIO449_READ_BLOCK_VALS   (256)       // size of data readback memory
#define DQ_DIO449_READ_BLOCK_SIZE   (DQ_DIO449_READ_BLOCK_VALS+1) // size of data readback. Last value is gain setting

#define DQ_DIO449_CHAN              (2)         // working DIO channels
#define DQ_DIO449_CHANS_MAX         (DQ_DIO449_LINES +DQDIO449_TSTV+ 2)  // expected longest channel list
#define DQ_DIO449_INFOSZ            DQ_MAX_INFO_SIZE    // maximum size of information structure
#define DQ_DIO449_BASE              BUS_FREQUENCY       // 66MHz base frequency
#define DQ_DIO449_BASE_30MHZ        (30720000)  // on-layer PLL frequency
#define DQ_DIO449_ADC_CLOCK_FACTOR  (16.0)      // value to multiply upon to get ADC pacer divider straight
                                                // external ADC pacer clocks must be multiplied by this factor
#define DQ_DIO449_MAXCVFRQ          (5120)      // maximum (and default) ADC conversion rate
#define DQ_DIO449_MINCVFRQ          (1)         // This is CL rate, the whole channel list (3*16) is scanned at this rate

#define DQ_DIO449_SPAN              (430.4)     // nominal p-p ADC voltage range before clipping
#define DQ_DIO449_OFFSET            (215.2)     // span / 2.0
#define DQ_DIO449_STEP              (DQ_DIO449_SPAN / 65535.0)     // span / ((2^16)-1)

#define DQ_DIO449_STEP_10           (DQ_DIO449_STEP/10.0)
#define DQ_DIO449_STEP_5            (DQ_DIO449_STEP/5.0)
#define DQ_DIO449_STEP_2            (DQ_DIO449_STEP/2.0)

#define DQ_DIO449_OFFSET_10         (DQ_DIO449_OFFSET/10.0)
#define DQ_DIO449_OFFSET_5          (DQ_DIO449_OFFSET/5.0)
#define DQ_DIO449_OFFSET_2          (DQ_DIO449_OFFSET/2.0)

// gains and ac/dc mode are combined with ADC channel number to make channel list entry
// example: cl[N] = DQ_LNCL_CHANGAIN(DQL_CHAN449_ADCCHAN_START + N, DQ_DIO449_GAIN1 | DQ_DIO449_MODE_DC);
#define DQ_DIO449_GAINS             (4)         // number of gain ranges
#define DQ_DIO449_GAIN1             (0)         // gain of  1, max input voltage range = +-215.20V
#define DQ_DIO449_GAIN2             (1)         // gain of  2, max input voltage range = +-107.60V
#define DQ_DIO449_GAIN5             (2)         // gain of  5, max input voltage range = +- 43.04V
#define DQ_DIO449_GAIN10            (3)         // gain of 10, max input voltage range = +- 21.52V

#define DQ_DIO449_MODE_DC           (4)         // AC/DC flag to combine with channel list
#define DQ_DIO449_MODE_AC           (0)         //                 "

#define DQ_DIO449_GET_MODE_DC       (2)         // bit position of DC/AC mode indicator in mode_gain[] returned by
                                                // DqAdv449GetModeGainLevels(), 1 = DC, 0 = AC, mask = (1L<<DQ_DIO449_GET_MODE_DC)

// constants and helper macros for building/reading DIO-449 channel lists
#define DQL_CHAN449_ADCCHAN_START   (0x40)      // channels this value and above are ADC channels
#define DQ_DIO449_GET_PGAGAIN(E)    (((E) & 0x300)>>8)  // pull out 2-bit PGA gain seting, DQ_DIO449_GAINn
#define DQ_DIO449_GET_CL_ACDC(E)    (((E) & 0x400)>>10) // pull out AC/DC setting, TRUE =DC
#define DQ_DIO449_LNCL_G_DAC(D)     (((D) & 0xff)<<8)   // set DAC value in DqAdv449SetGDacs()


#define DQ_DIO449_MAX_LOW           (150.0)     // a more practical max low threshold would be 130
#define DQ_DIO449_MAX_HIGH          (150.0)     // a more practical max high threshold would be 140

// defines for DqAdv449ReadAdc()
#define DQDIO449_PORT0_IND          (0)         // channel number to use to read debounced dio port0 as an ADC channel
#define DQDIO449_PORT1_IND          (1)         // channel number to use to read debounced dio port1 as an ADC channel
#define DQDIO449_PORT0_IN           (2)         // channel number to use to read dio port0 as an ADC channel
#define DQDIO449_PORT1_IN           (3)         // channel number to use to read dio port1 as an ADC channel
#define DQDIO449_PORT0_CSLH         (4)         // to read port0 state change low to high as an ADC channel
#define DQDIO449_PORT1_CSLH         (5)         // to read port1 state change low to high as an ADC channel
#define DQDIO449_PORT0_CSHL         (6)         // to read port0 state change high to low as an ADC channel
#define DQDIO449_PORT1_CSHL         (7)         // to read port1 state change high to low as an ADC channel
#define DQDIO449_TSTV               (8)         // read timestamp
#define DQDIO449_BDATA_VALUE(B)     ((B)&0xffff)// get 16-bit ADC data from bData
#define DQDIO449_BDATA_GAIN(B)      (((B)>>18)&3)   // get 2-bit PGA gain range code from bData
#define DQDIO449_BDATA_DC_FLAG      (1L<<20)    // use to isolate DC/AC indicator bit from bData. TRUE=DC

// define for DqAdv449SetGMux() parameter 'gme4'
#define DQDIO449_DISABLE_PDOWN_V    (1L<<12)    // 1= Turns OFF the power source for the open circuit detector, 0= ON

// ioctls
#define DQL_IOCTL449_SET_LEVELS     (0x6)       // sets low- and high- levels
#define DQL_IOCTL449_SET_DBREGS     (0x7)       // sets debouncer registers

// UEIPAC only IOCTLs
#define DQL_IOCTL449_CFG_DI_CHANGE  (0x8)       // configure DI change event port and edge
#define DQL_IOCTL449_WAIT_DI_CHANGE (0x9)       // Wait for a DI change event to occur

#define DQDIO449_SETPARAM_SET       (1)         // set parameters
#define DQDIO449_SET_ACDC           (2)
#define DQDIO449_SET_GMUX           (3)
#define DQDIO449_SET_GDACS          (4)
#define DQDIO449_SET_AVERAGING_MODE (5)         //  internal parameters to DqAdv449SetAveragingMode()
#define DQDIO449_AVG_MODE_UNCHANGED (0xFFFF)    //                     "
#define DQ_DIO449_DCMODE_AVG        (1L<<15)    //                     "
#define DQ_DIO449_DCMODE_NO_AVG     (0L<<15)    //                     "

#define DQDIO449_SET_AVERAGING_MODE_DCMODE_NO_AVG   (FALSE) // faster - define for DqAdv449SetAveragingMode() *dcmode
#define DQDIO449_SET_AVERAGING_MODE_DCMODE_AVG      (TRUE)  // slower -   "     "            "                   "
                                    // set DqAdv449SetAveragingMode() dcmode pointer to NULL to leave dcmode setting unchanged

#define DQDIO449_GETPARAM_GET       (1)         // get parameters
#define DQDIO449_GET_MODE_GAIN      (2)
#define DQDIO449_GET_MEM_BLOCK      (3)
#define DQDIO449_GET_AC_STATS       (4)

// level check - used internally by DqAdv449SetLevels()
#define DQDIO449_SET_LEV_ACV_MAX_G3 (18.8)
#define DQDIO449_SET_LEV_ACV_MAX_G2 (37.5)
#define DQDIO449_SET_LEV_ACV_MAX_G1 (75.0)
#define DQDIO449_SET_LEV_DCV_MAX_G3 (18.8)
#define DQDIO449_SET_LEV_DCV_MAX_G2 (37.5)
#define DQDIO449_SET_LEV_DCV_MAX_G1 (75.0)


#define DQ_DIO449_DEFLT_DC_DEBOUNCE (6)         // 0.6mS , default DC DIO-449 debounce setting in 100 microsecond units
#define DQ_DIO449_DEFLT_AC_DEBOUNCE (90)        // 9.0mS , default AC DIO-449 debounce setting in 100 microsecond units

// Event data for 449 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];     // data to follow
} EV449_ID, *pEV449_ID;

#define DqAdv449ConfigEvents_PARAMSZ    (4)     // maximum number of uint32 parameters after pEV449_ID

typedef enum {
    EV449_CLEAR = 0x1000,           // clear all events
    EV449_DI_CHANGE = 0x101,         // digital input change of state
    EV449_PERIODIC = 0x102          // periodic event (optionally period is reset every time DI_CHANGE event occurs)
} event449_t;

#define EV449_PERI_RESET        (1L<<0) // reset periodic event start upon CoS event

// Upper part of the configuration word -
#define DQ_DIO449_MODESCAN          (DQ_FIFO_MODESCAN)  // single scan update mod (no buffer)
#define DQ_DIO449_MODEFIFO          (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO (simplified buffer)
#define DQ_DIO449_MODECONT          (DQ_FIFO_MODECONT)  // continuous acquisition (buffered)

// Output FIFO to read data
#define DQ_DIO449_FIFO_GET_DATA     DQ_FIFO_GET_DATA

// Input FIFO to read data
#define DQ_DIO449_FIFO_SET_DATA     DQ_FIFO_SET_DATA
#define D449_GET_G_DAC(D)           ((D)>> 8)   // extract dl DAC value in DqAdv449SetGDacs()


#define DQ_DIO449_NAMELEN           (10)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names for 449 */
typedef struct {
    char cname[DQ_DIO449_LINES][DQ_DIO449_NAMELEN];
} DQCNAMES_449_, *pDQCNAMES_449_;


typedef struct {
    char chlst[DQ_DIO449_CHAN*2];   /* channel list */
    uint32 cfg[DQ_DIO449_PORTS+1];  /* control word - as it should be written */
    uint32 val[DQ_DIO449_CHAN];     /* initial settings in shutdown mode */
    uint32 cvclk;                   /* CV clock */
    uint32 clclk;                   /* CL clock */
    uint32 trig;                    /* trigger */
} DQOPMODEPRM_449_, *pDQOPMODEPRM_449_;

typedef struct {
    uint32 cfg;                     /* control word - as it should be written */
    uint32 val[DQ_DIO449_PORTS];    /* settings in shutdown mode */
} DQSDOWNPRM_449_, *pDQSDOWNPRM_449_;

typedef struct {
    uint32 acdc[DQ_DIO449_PORTS];   // control words - as they should be written 0x2024/8
    uint16 v_low[DQ_DIO449_LINES];  /* low logic level for each port */
    uint16 v_high[DQ_DIO449_LINES]; /* ditto high logic level */
    uint16 gain_deb[DQ_DIO449_LINES];    // gain and debounce settings - bits 1,0=gain, bits 14..2=debounce
} DQINITPRM_449_, *pDQINITPRM_449_;
typedef struct {
    uint32 avg[DQ_DIO449_PORTS];    // avg control words - as they should be written 0x2008/C
    uint32 res[DQ_DIO449_PORTS];
} DQINITPRM2_449_, *pDQINITPRM2_449_;

typedef struct {
    int16 offset[DQ_DIO449_LINES][DQ_DIO449_GAINS];  //
    uint16 gain[DQ_DIO449_LINES][DQ_DIO449_GAINS];   //
    uint16 res[DQ_DIO449_LINES];    // ac adjust
} DQCALSET_449_, *pDQCALSET_449_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_449_ calset;
    DQOPMODEPRM_449_ opmodeprm;
    DQINITPRM_449_ initprm;
    DQSDOWNPRM_449_ sdownprm;
    DQCNAMES_449_ cname;
    DQPRMFLAGS eeflags;
    DQINITPRM2_449_ initprm2;
} DEVEEPROM_449_, *pDEVEEPROM_449_;


/* structure for SETPARAM data (Write) */
typedef struct {
    uint32 cfgmask;                 // What parameters to set
    uint32 cfg;                     // 00 Set configuration
    uint32 reserved0;
    uint32 reserved1;
    uint32 reserved2;
} DQDIO449DATAOUT, *pDQDIO449DATAOUT;

#pragma pack()


#define DQ_DIO462_CHAN              (12)        // how many relays
#define DQ_DIO462_CH_MASK           (0xf)       // to bitwise isolate DQ_DIO462_CHAN
#define DQ_DIO462_INFOSZ            (DQ_MAX_INFO_SIZE)   // maximum size of information structure
#define DQ_DIO462_BASE              (BUS_FREQUENCY)  // 66MHz base frequency
#define DQ_DIO462_ADC_CHAN_CHAN     (5)         // number of ADC CHANnels per relay CHANnel
#define DQ_DIO462_ADC_CHANS         (DQ_DIO462_CHAN*DQ_DIO462_ADC_CHAN_CHAN)  // =60 total # of ADC CHANnelS
#define DQ_DIO462_ADC_CHAN_MASK     (0x07)      // mask to isolate DQ_DIO462_ADC_CHAN_CHAN
#define DQ_DIO462_MAXCVFRQ          (100000.0)

//Each DIO462 channel has these 5 AI channels, aka ADC subchannels
#define DQ_DIO462_SUBCH_V_NO        (0)         // Vno, DC voltage on N.O. contact, can read DC voltage when relay is OFF
#define DQ_DIO462_SUBCH_I_AC        (1)         // Iac, AC current on common
#define DQ_DIO462_SUBCH_I_DC        (2)         // Idc, DC current on common
#define DQ_DIO462_SUBCH_V_NC        (3)         // Vnc, DC voltage on N.C. contact, can read DC voltage when relay is ON.
                                                // On DIO-463, may be used as a general purpose ADC input, referenced to the
                                                // COM terminal of the relay
#define DQ_DIO462_SUBCH_THERM       (4)         // ADC internal IC temperature, degrees C

#define DQ_DIO462_DISABLE_BREAKER   (5)         // value used by DqAdv462SetLimit() to disable breaker function
                                                // or disable unused channels
#define DQ_DIO462_UNDER_LIMIT_OFFS  (0x10)      // value used by DqAdv462SetLimit() to access underlimit settings

// DIO46x channel list helper macro. Combines the channel and ADC subchannel numbers for the channel list
// used by DqAdv462ReadADC()
#define DQ_DIO462_MAKE_CL(CH,SUBCH) ((((CH)&DQ_DIO462_CH_MASK)<<3)|((SUBCH)& DQ_DIO462_ADC_CHAN_MASK))
#define DQ_DIO462_GET_R_CH(CLE)     (((CLE)>>3)&DQ_DIO462_CH_MASK)      // get channel number from combined channel and subchannel

#define DQ_DIO462_CL_MASK           (0x7f)      // mask to isolate DQ_DIO462 channel list entry
#define DQ_DIO462_CL_UNCALFLAG      (0x80)      // add to DqAdv462ReadADC() channel list entry to get uncalibrated
                                                // data for calibration or diagnostic purposes

#define DQ_DIO462_ISO_DC_NUM        (4)         // number of DC-DC converters to power isolated side
#define DQ_DIO462_DEF_GAIN_CAL      (0x8000)    // default value for digital gain calibration of ADC channels
#define DQ_DIO462_DEF_OFFSET_CAL    (0)         // default value for digital offset calibration of ADC channels

// DIO462 ADC scaling and gain defines for DAQLib
#define DQ_DIO462_ISH               (0.02)      // ohms
#define DQ_DIO462_ADC_VREF          (3.0)
#define DQ_DIO462_I_SCALER          (1.0/DQ_DIO462_ISH)
#define DQ_DIO462_IAC_ADCGAIN       (1.0)
#define DQ_DIO462_IAC_BGAIN         (19.21)     // RJ/RK+1
#define DQ_DIO462_IAC_SPAN          ((DQ_DIO462_ADC_VREF)/DQ_DIO462_IAC_ADCGAIN)
#define DQ_DIO462_IAC_STEP          (DQ_DIO462_IAC_SPAN/(double)0xffff)
#define DQ_DIO462_IAC_OFFSET        ((DQ_DIO462_IAC_SPAN/2.0)+(DQ_DIO462_IAC_STEP/2.0))
#define DQ_DIO462_IAC_SCALER        ((DQ_DIO462_I_SCALER)/DQ_DIO462_IAC_BGAIN)
#define DQ_DIO462_IDC_ADCGAIN       (8.0)
#define DQ_DIO462_IDC_SPAN          ((DQ_DIO462_ADC_VREF)/DQ_DIO462_IDC_ADCGAIN)
#define DQ_DIO462_IDC_STEP          (DQ_DIO462_IDC_SPAN/(double)0xffff)
#define DQ_DIO462_IDC_OFFSET        ((DQ_DIO462_IDC_SPAN/2.0)+(DQ_DIO462_IDC_STEP/2.0))
#define DQ_DIO462_IDC_SCALER        (-DQ_DIO462_I_SCALER)
#define DQ_DIO462_V_ADCGAIN         (1.0)
#define DQ_DIO462_V_SPAN            (DQ_DIO462_ADC_VREF/DQ_DIO462_V_ADCGAIN)
#define DQ_DIO462_V_STEP            (DQ_DIO462_V_SPAN/(double)0xffff)
#define DQ_DIO462_V_OFFSET          ((DQ_DIO462_V_SPAN/2.0)+(DQ_DIO462_V_STEP/2.0))
#define DQ_DIO462_V_SCALER          (101.0)     // (RF+RE)/RE
#define DQ_DIO462_T_SLOPE           ((0.0000935)/DQ_DIO462_V_STEP)    // 2.04 ADC counts per deg C or K, ADC subchannel 4
#define DQ_DIO462_T_OFFSET          (273.0)     // deg kelvin to deg C
#define DQ_DIO462_ADC_EOC           (1L<<18)
#define DQ_DIO462_ADC_SIG           (1L<<16)
#define DQ_DIO462_ADC_MSB           (1L<<15)
#define DQ_L462_MAX_P_DCVOLT        (151.5)     // DQ_DIO462_V_SCALER * DQ_DIO462_ADC_VREF
#define DQ_L462_MAX_N_DCVOLT        (-30.0)     // V
#define DQ_L462_MAX_N_DCSPAN        (-DQ_DIO462_V_SPAN/2.0)
#define DQ_L462_MAX_ACCURRENT       (3.0)       // A
#define DQ_L462_MAX_P_DCCURRENT     (3.0)
#define DQ_L462_MAX_N_DCCURRENT     (-3.0)

// constant definitions
// for LCR/IER/IMR/ISR/ICR - see cli2.h
#define DQL_LCR_462_LED             (1L<<1)     // Enable (turn-on)/ Disable (turn-off) status LED
#define DQL_LCR_462_DCEN            (1L<<0)     // DC power to layer

#define DQDIO462_SETPARAM_SET       (0x10)      // set parameters command, arg[0] in DQIOCTL_SETPARAM
#define DQDIO462_SETPARAM_LIMITS    (0x11)      // set limits
#define DQDIO462_GETPARAM_GET       (0x10)      // get parameters


#define DQ_DIO462_ADC0_CFG_G1       (0xB080)    // Vno
#define DQ_DIO462_ADC1_CFG_G1       (0xB880)    // Iac gain=1
#define DQ_DIO462_ADC1_CFG_G8       (0xB882)    // Iac gain=8
#define DQ_DIO462_ADC2_CFG_G1       (0xB180)    // Idc gain=1
#define DQ_DIO462_ADC2_CFG_G8       (0xB182)    // Idc gain=8
#define DQ_DIO462_ADC3_CFG_G1       (0xB980)    // Vnc
#define DQ_DIO462_ADC4_CFG          (0xB0C0)    // temperature
#define DQ_DIO462_ADC_SETTLE_1      (0x10)      // 1x conversion time in 10msec increments
#define DQ_DIO462_ADC0_CFG_G1_2X    (0xB088)    // Vno
#define DQ_DIO462_ADC1_CFG_G1_2X    (0xB888)    // Iac gain=1, must match DQ_DIO462_IAC_ADCGAIN
#define DQ_DIO462_ADC1_CFG_G8_2X    (0xB88b)    // Iac gain=8
#define DQ_DIO462_ADC2_CFG_G1_2X    (0xB188)    // Idc gain=1
#define DQ_DIO462_ADC2_CFG_G2_2X    (0xB189)    // Idc gain=2
#define DQ_DIO462_ADC2_CFG_G4_2X    (0xB18a)    // Idc gain=4
#define DQ_DIO462_ADC2_CFG_G8_2X    (0xB18b)    // Idc gain=8, must match DQ_DIO462_IDC_ADCGAIN
#define DQ_DIO462_ADC3_CFG_G1_2X    (0xB988)    // Vnc
#define DQ_DIO462_ADC_SETTLE_1_2X   (0x8)       // 2x conversion time in 10msec increments


#define DQ_DIO462_DCDCCFG_MAX       (0x5f)
#define DQ_DIO462_DCDCCFG_MIN       (0x1E)

#define DQ_DIO462_DCDCCFG           (0x5f)
#define DQ_DIO462_DCDCX_START       (0x3)
#define DQ_DIO462_DCDCX_WIDTH       (0xb)

#define DQ_DIO462_DCDCX_CH_SP       (DQ_DIO462_DCDCCFG/4)        // channel spacing
#define DQ_DIO462_DCDCX_0           (DQ_DIO462_DCDCX_START+(0*DQ_DIO462_DCDCX_CH_SP)+((DQ_DIO462_DCDCX_START+DQ_DIO462_DCDCX_WIDTH+(0*DQ_DIO462_DCDCX_CH_SP))<<16))  // ch 1,4,5
#define DQ_DIO462_DCDCX_1           (DQ_DIO462_DCDCX_START+(1*DQ_DIO462_DCDCX_CH_SP)+((DQ_DIO462_DCDCX_START+DQ_DIO462_DCDCX_WIDTH+(1*DQ_DIO462_DCDCX_CH_SP))<<16))
#define DQ_DIO462_DCDCX_2           (DQ_DIO462_DCDCX_START+(2*DQ_DIO462_DCDCX_CH_SP)+((DQ_DIO462_DCDCX_START+DQ_DIO462_DCDCX_WIDTH+(2*DQ_DIO462_DCDCX_CH_SP))<<16))
#define DQ_DIO462_DCDCX_3           (DQ_DIO462_DCDCX_START+(3*DQ_DIO462_DCDCX_CH_SP)+((DQ_DIO462_DCDCX_START+DQ_DIO462_DCDCX_WIDTH+(3*DQ_DIO462_DCDCX_CH_SP))<<16))
#define DQ_DIO462_DCDCX(N)          (DQ_DIO462_DCDCX_START+((N)*DQ_DIO462_DCDCX_CH_SP)+((DQ_DIO462_DCDCX_START+DQ_DIO462_DCDCX_WIDTH+((N)*DQ_DIO462_DCDCX_CH_SP))<<16))


#define DQ_DIO462_DFLT_RDCNT        (3)

// ----------------- calibration (over/under current limits) ------

#define DQ_L462_MAXCURRENT          (3.0)       // Max current limit, AMPS
#define DQ_L462_MINCURRENT          (-3.0)      // Minimum current limit, AMPS (actual current is 0.01 to 2A)

#define DQ_L462_MAXRAW              (0x0FFFF)   // Max current limit, raw value
#define DQ_L462_MINRAW              (0x0)       // Minimum current limit, raw value



#define DQ_L462_NAMELEN             (20)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_DIO462_CHAN][DQ_L462_NAMELEN];
} DQCNAMES_462_, *pDQCNAMES_462_;


/* specific device structure - calibration values */
typedef struct {                    // Current value (hex) of the calibration shunt from internal monitor:
    uint16 offs [DQ_DIO462_CHAN][DQ_DIO462_ADC_CHAN_CHAN];
    uint16 gain [DQ_DIO462_CHAN][DQ_DIO462_ADC_CHAN_CHAN];
} DQCALSET_462_, *pDQCALSET_462_;


typedef struct {
    uint32 oclimit[DQ_DIO462_CHAN]; // over-current limit
    uint32 uclimit[DQ_DIO462_CHAN]; // under-current limit
    int32  validation[DQ_DIO462_CHAN];          // which ADC channel is used for over/under limit
    uint32 dcdccfg;
    uint32 dcdcx[DQ_DIO462_ISO_DC_NUM];
    int32  rdcnt;
    uint32 adc_cfg[DQ_DIO462_ADC_CHAN_CHAN];
    uint32 discfg;
} DQOPMODEPRM_462_, *pDQOPMODEPRM_462_;


typedef struct {
    uint32 val;                     /* line states in init mode */
} DQINITPRM_462_, *pDQINITPRM_462_;

typedef struct {
    uint32 val;                     /* line states in shutdown mode */
} DQSDOWNPRM_462_, *pDQSDOWNPRM_462_;


/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_462_ calset;
    DQOPMODEPRM_462_ opmodeprm;
    DQINITPRM_462_ initprm;
    DQSDOWNPRM_462_ sdownprm;
    DQCNAMES_462_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_462_, *pDEVEEPROM_462_;


/* structure for GETPARAM data */
typedef struct {
    int32 cfg;                      // Current disconnection mode
    int32 portout;                  // Current value written to the output port
    int32 dissts;                   // disable status
    int32 portocs;                  // Over-current interrupt status
    int32 portucs;                  // Under-current interrupt status
    int32 adcsts;                   // Reports combined status of the ADC subsystem
    int32 adccfg[DQ_DIO462_ADC_CHAN_CHAN];
    int32 rdcnt;                    // Current value of the consecutive read counter setting
} DQDIO462DATAIN, *pDQDIO462DATAIN;

/* structure for SETPARAM data (WRITE)*/
typedef struct {
    int32 cfgmask;                  // What parameters to set
    int32 cfg;                      // Set disconnection mode
    int32 portocm;                  // Set over-current interrupt mask
    int32 portucm;                  // Set under-current interrupt mask
    int32 rdcnt;                    // Set number of "failed" samples prior breaker engagement
    int32 adccfg[DQ_DIO462_ADC_CHAN_CHAN];  // "User" ADC conversion control words for ADC inputs
    int32 dcdccfg;                  // dc-dc frequency selector
    int32 dcdcx[DQ_DIO462_ISO_DC_NUM];     // dc-dc pw-phase selectors
} DQDIO462DATAOUT, *pDQDIO462DATAOUT;

// bit defines for the contents of DQDIO462DATAOUT.cfgmask
#define DQDIO462_CFGSET             (1L<<0)     // =1 if "cfg" contains valid data
#define DQDIO462_PORTOCMSET         (1L<<3)     // =1 if "portocm" contains valid data
#define DQDIO462_PORTUCMSET         (1L<<4)     // =1 if "portucm" contains valid data
#define DQDIO462_RDCNTSET           (1L<<5)     // =1 if "rdcnt" contains valid data
#define DQDIO462_ADCCFG0SET         (1L<<7)     // =1 if "adccfg[0]" contains valid data
#define DQDIO462_ADCCFG1SET         (1L<<8)     // =1 if "adccfg[1]" contains valid data
#define DQDIO462_ADCCFG2SET         (1L<<9)     // =1 if "adccfg[2]" contains valid data
#define DQDIO462_ADCCFG3SET         (1L<<10)    // =1 if "adccfg[3]" contains valid data
#define DQDIO462_ADCCFG4SET         (1L<<11)    // =1 if "adccfg[4]" contains valid data
#define DQDIO462_DCDCCFGSET         (1L<<12)    // =1 if "dcdccfg" contains valid data
#define DQDIO462_DCDCXSET           (1L<<13)    // =1 if "dcdcx[0]..[3]" contains valid data


#define DQ_L500_BAUD_110            (0UL << 28)
#define DQ_L500_BAUD_300            (1UL << 28)
#define DQ_L500_BAUD_600            (2UL << 28)
#define DQ_L500_BAUD_1200           (3UL << 28)
#define DQ_L500_BAUD_2400           (4UL << 28)
#define DQ_L500_BAUD_4800           (5UL << 28)
#define DQ_L500_BAUD_9600           (6UL << 28)
#define DQ_L500_BAUD_14400          (7UL << 28)
#define DQ_L500_BAUD_19200          (8UL << 28)
#define DQ_L500_BAUD_28800          (9UL << 28)
#define DQ_L500_BAUD_38400          (10UL << 28)
#define DQ_L500_BAUD_57600          (11UL << 28)
#define DQ_L500_BAUD_115200         (12UL << 28)

#define DQ_L500_WIDTH_5             (0UL << 26)
#define DQ_L500_WIDTH_6             (1UL << 26)
#define DQ_L500_WIDTH_7             (2UL << 26)
#define DQ_L500_WIDTH_8             (3UL << 26)

#define DQ_L500_PARITY_EVEN         (0UL << 24)
#define DQ_L500_PARITY_ODD          (1UL << 24)
#define DQ_L500_PARITY_NONE         (2UL << 24)

#define DQ_L500_STOP_1              (0UL << 22)
#define DQ_L500_STOP_1_5            (1UL << 22)
#define DQ_L500_STOP_2              (2UL << 22)

#define DQL_IOCTL500_SET_MSG_TIMER  (1)         // set timer interval
#define DQL_IOCTL500_SET_MSG_TERM   (2)         // set msg terminator (null terminated char)
#define DQL_IOCTL500_SET_MSG_LEN    (3)         // set msg len
#define DQ_L501_CHAN                (4)
#define DQ_L508_CHAN                (8)
#define DQ_L501_INFOSZ              (DQ_MAX_INFO_SIZE) // maximum size of information structure
#define DQ_L501_BASE_66             (66000000)  // 66MHz base frequency
#define DQ_L501_BASE_24             (24000000)  // 24MHz base frequency
#define DQ_L501_BASE_29             (29454545)  // 29MHz base frequency - SL-501
#define DQ_L501_BASE_29_508         (29464286)  // 29MHz base frequency - SL-508 option 892 replaces 24.0MHz with 29.4MHz
#define DQ_L501_BASE_CUSTOM         (0)         // PLL is in use, only '501 uses PLL
#define DQ_L501_MFIFO_1             (1000000)   // 1MHz base frequency for the major FIFO
#define DQ_L501_MAXCLFRQ            (2000)
#define DQ_L501_MAXCVFRQ            (2000)
#define DQ_L501_FIFOSZ              (2048)
#define DQ_L508_FIFOSZ              (1024)
#define DQ_L508_MAJORSZ             (1024)
#define DQ_L508_SWFIFOSZ            (2048)

// fifo size helper macros
#define L50x_FIFOSZ(MODEL)          (((MODEL) == 0x501)?(DQ_L501_FIFOSZ):(DQ_L508_FIFOSZ))
#define L50x_FIFOSZSW(MODEL)        (((MODEL) == 0x501)?(DQ_L508_SWFIFOSZ):(DQ_L508_SWFIFOSZ))

#define DQ_L501_REPEAT_SUPPORTED    (0xf)       // frame repeat feature support for logics minor > 0xf

#define DQ_SL501_MSG_NORM           (0)         // normal message
#define DQ_SL501_MSG_BREAK          (1)         // break received
#define DQ_SL501_MSG_ERR_FRM        (2)         // framing error
#define DQ_SL501_MSG_ERR_PAR        (3)         // parity error
#define DQ_SL501_MSG_ERR_TO         (4)         // timeout

// DqAdv501RecvMessage(,,,,,,errorcode,) returns the following 501 specific error code:
#define DQ_SL501_RECV_MSG_ERR_TO    (DQ_SL501_MSG_ERR_TO <<4)  // timeout

// configuration constants - shifts in the configuration word
#define DQ_CL_OFS                   (8L)
#define DQ_SL501_MODE_SH            (0 + DQ_CL_OFS)     // 2 bits mode of operation
#define DQ_SL501_PARITY_SH          (2 + DQ_CL_OFS)     // 3 bits parity type
#define DQ_SL501_STOP_SH            (5 + DQ_CL_OFS)     // 2 bits stop bits
#define DQ_SL501_WIDTH_SH           (7 + DQ_CL_OFS)     // 2 bits character width
#define DQ_SL501_OPER_SH            (9 + DQ_CL_OFS)     // 1 bit loopback
#define DQ_SL501_RESRVD1_SH         (10 + DQ_CL_OFS)    // 1 bit reserved (232 only)
#define DQ_SL501_RESRVD2_SH         (11 + DQ_CL_OFS)    // 1 bit reserved (232 only)
#define DQ_SL501_BAUD_SH            (12 + DQ_CL_OFS)    // 4 bits baud rate
#define DQ_SL501_ERROR_SH           (16 + DQ_CL_OFS)    // 1 bit error (parity/framing) enable
#define DQ_SL501_BREAK_SH           (17 + DQ_CL_OFS)    // 1 bit break enable
#define DQ_SL501_TX485AD_SH         (18 + DQ_CL_OFS)    // 1 bit disable TX in 485 mode when there is nothing to send
#define DQ_SL501_RXTE_SH            (19 + DQ_CL_OFS)    // 1 bit RX termination
#define DQ_SL501_TXTE_SH            (20 + DQ_CL_OFS)    // 1 bit TX termination
#define DQ_SL501_BAUD_PLL_SH        (21 + DQ_CL_OFS)    // 1 bit (available in logic revision 0x01021006 or higher) '501 only


#define DQ_SL501_FSTE_SH            DQ_SL501_TX485AD_SH // 1 bit failsafe termination <deprecated>

// mode of operation
#define DQ_SL501_MODE_232           (0L)
#define DQ_SL501_MODE_485F          (1L)
#define DQ_SL501_MODE_485H          (2L)        // RS-422 allows only one-way (simplex) communications

// parity type
#define DQ_SL501_PARITY_NONE        (0L)
#define DQ_SL501_PARITY_EVEN        (1L)
#define DQ_SL501_PARITY_ODD         (2L)
#define DQ_SL501_PARITY_SPACE       (3L)
#define DQ_SL501_PARITY_MARK        (4L)

// number of stop bits
#define DQ_SL501_STOP_1             (0L)
#define DQ_SL501_STOP_1_5           (1L)
#define DQ_SL501_STOP_2             (2L)

// character width
#define DQ_SL501_WIDTH_8            (0L)
#define DQ_SL501_WIDTH_7            (1L)
#define DQ_SL501_WIDTH_6            (2L)
#define DQ_SL501_WIDTH_5            (3L)

// loopback enabled
#define DQ_SL501_OPER_NORM          (0L)
#define DQ_SL501_OPER_LOOP          (1L)

// RTS/DTS enabled - 232 mode
#define DQ_SL501_RTS                (1L)
#define DQ_SL501_DTS                (1L)

// baud rate
#define DQ_SL501_BAUD_57600         (0L)
#define DQ_SL501_BAUD_DEFAULT       (DQ_SL501_BAUD_57600)

#define DQ_SL501_BAUD_300           (1L)
#define DQ_SL501_BAUD_600           (2L)
#define DQ_SL501_BAUD_1200          (3L)
#define DQ_SL501_BAUD_2400          (4L)
#define DQ_SL501_BAUD_4800          (5L)
#define DQ_SL501_BAUD_9600          (6L)
#define DQ_SL501_BAUD_19200         (7L)
#define DQ_SL501_BAUD_38400         (8L)
#define DQ_SL501_BAUD_56000         (9L)

#define DQ_SL501_BAUD_115200        (10L)
#define DQ_SL501_BAUD_128000        (11L)
#define DQ_SL501_BAUD_250000        (12L)
#define DQ_SL501_BAUD_256000        (13L)
#define DQ_SL501_BAUD_1000000       (14L)
#define DQ_SL501_BAUD_CUST          (15L)       // if a custom rate is selected then actual baud rate

// error (parity/framing) enable
#define DQ_SL501_ERROR              (1L)

// break enable
#define DQ_SL501_BREAK              (1L)

// termination types
#define DQ_SL501_TERM_FS            (1L)
#define DQ_SL501_TERM_RX            (1L)
#define DQ_SL501_TERM_TX            (1L)

// extended configuration bits, 'ext_flags' parameter for DqAdv501SetChannelCfgExt()
#define DQ_SL501_SUPRESS_HD_ECHO    (1L<<1)     // suppress echo in half-duplex mode, requires logic 02.10.5A or newer
#define DQ_SL501_TIMEOUT_DIV1       (1L<<6)     // timeout divider clock selector - valid when CFG_TOE=1
#define DQ_SL501_TIMEOUT_DIV0       (1L<<5)     // 00 = 1mS, 01 = 100us, 10 = 10us, 11 = 1us (available in logics >= 2.10.22)
#define DQ_SL501_USE_8x_CLK         (1L<<7)     // use 8x baud clock mode instead of 16x UART clock (501 only, gets you up to 4Mbaud)
#define DQ_SL501_ADD_TS_ON_IDLE     (1L<<8)     // add 11-bit timestamp before string of data if T/O period ended

// DMAP configuration
#define DQ_SL501_VMAP_STAT          (1L<<9)     // OR this value to channel number to add parity and
                                                // framing status in front of the DMAP data.

// Additional bits in the VMap mode FIFO when DQ_SL501_ADD_TS_ON_IDLE is selected
// and characters are delivered back in 16-bit words
#define DQ_SL501_SRXF_TS            (0x1L<<15)  // The byte contains timestamp
#define DQ_SL501_SRXF_PE            (0x1L<<10)  // Parity error was detected with current data sample
#define DQ_SL501_SRXF_FE            (0x1L<<9)   // Framing error was detected with current data sample, all following data may be corrupt
#define DQ_SL501_SRXF_BI            (0x1L<<8)   // Break indicator for current data

// ----------------------------------------------------------------------
// ioctls
#define DQL_IOCTL501_READ_CHNL      (0x07L)     // read a channel message
#define DQL_IOCTL501_WRITE_CHNL     (0x08L)     // write a channel message
#define DQL_IOCTL501_SETCHNL_CFG    (0x09L)     // set channel config
#define DQL_IOCTL501_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL501_STOP           (0x0BL)     // immediate mode stop
#define DQL_IOCTL501_BREAK          (0x0CL)     // immediate mode stop
#define DQL_IOCTL501_CHANGE         (0x0DL)     // change parameters on the fly/clear FIFOs
#define DQL_IOCTL501_STATUS         (0x0FL)     // get interface status

#define DQL_IOCTL501_READ_CFIFO     (0x1001L)   // direct read from a channel FIFO
#define DQL_IOCTL501_FLOW_CONTROL   (0x1002L)   // set/get flow control
#define DQL_IOCTL501_SETCHNL_CFGEXT (0x1003L)   // set extended channel config
#define DQL_IOCTL501_WRITE_CFIFO    (0x1004L)   // direct write to a channel FIFO

// ----------------------------------------------------------------------
// setparam_501()
#define DQL_IOCTL501_SETBAUD        (0x01L)     // sets a custom baud rate
#define DQL_IOCTL501_SETBAUD_8X     (0x80000000) // flag used internally by DQL_IOCTL501_SETBAUD command for 501-804 support
#define DQL_IOCTL501_SETTXWM        (0x02L)     // sets the TX watermark
#define DQL_IOCTL501_SETRXWM        (0x03L)     // sets the RX watermark
#define DQL_IOCTL501_SETTIMEOUT     (0x04L)     // set the RX timeout (hardware)
#define DQL_IOCTL501_SET_TS         (0x05L)     // set the termination string/char
#define DQL_IOCTL501_SET_TL         (0x06L)     // set the termination length ( < max_msg)
#define DQL_IOCTL501_SETRXWM_DIRECT (0x07L)     // sets the TX watermark for non-message mode
#define DQL_IOCTL501_SETBASECLOCK   (0x0CL)     // set the internal base clock, e.g. 66MHz, 24MHz
#define DQL_IOCTL501_SETCHARDLY     (0x0DL)     // set character delay
#define DQL_IOCTL501_SETFRAMEDLY    (0x0EL)     // set frame delay
#define DQL_IOCTL501_SETBREAKCHAR   (0x0FL)     // set char to be inserted into Rx stream when break is detected

// ----------------------------------------------------------------------
// for DQL_IOCTL501_CHANGE: uint32 arg[1] - action, [0] configuration
#define DQL_IOCTL501_CHANGE_FINCLEAR (0x1)      // clear input FIFO (can be combined with FOUTCLEAR)
#define DQL_IOCTL501_CHANGE_FOUTCLEAR (0x2)     // clear output FIFO (can be combined with FINCLEAR)
#define DQL_IOCTL501_CHANGE_FINFOUT (0x3)       // both
#define DQL_IOCTL501_CHANGE_SETCHCFG (0x4)      // wait for Tx FIFO to clear and change configuration
#define DQL_IOCTL501_CHANGE_PARITY  (0x8)       // wait for Tx FIFO to clear and change parity
#define DQL_IOCTL501_CHANGE_PAUSE   (0x9)       // pause I/O and clear FIFO
#define DQL_IOCTL501_CHANGE_RESUME  (0xA)       // resume I/O

// ----------------------------------------------------------------------
// constants for DqAdv501FlowControl()  -> DQL_IOCTL501_FLOW_CONTROL:
//
//defines for uint32 cts_cfg
#define DQL_IOCTL501_CTS_NO_CHANGE  (1)         // make no change to the flow control setting, most usefull when reading the cts inputs
#define DQL_IOCTL501_CTS_IGNORE     (2)         // default setting, the cts input is ignored by the transmitter, transmitter always transmits
#define DQL_IOCTL501_CTS_AUTOFLOW   (3)         // turns transmit flow control ON, transmitter is controlled by the CTS input

//defines for uint32 rts_cfg
#define DQL_IOCTL501_RTS_NO_CHANGE  (1)         // make no change to the flow control setting, most usefull when reading the cts inputs
#define DQL_IOCTL501_RTS_PIN_LOW    (2)         // set RTS pin low, may be used to disable other RS-232 devices
#define DQL_IOCTL501_RTS_PIN_HIGH   (3)         // default setting, provides a high level normally used to enable other RS-232 devices
#define DQL_IOCTL501_RTS_AUTOFLOW_NORMAL_TIMING (4) // flow control enabled with normal timing, provides a high level that goes low when watermark reached
#define DQL_IOCTL501_RTS_AUTOFLOW_GATED_TIMING  (5) // same flow control action as normal timing except that timing is changed for use with gated transmitters

// ----------------------------------------------------------------------
// Character delay mode
#define DQ_SL501_DELAYMODE_DISABLED (0)         // disabled
#define DQ_SL501_DELAYMODE_INTERNAL (1)         // internal per channel clock
#define DQ_SL501_DELAYMODE_TMR01    (2)         // TMR1 for char and TMR0 for frame
#define DQ_SL501_DELAYMODE_SYNC02   (3)         // SYNC2 for char and SYNC0 for frame

// for frame delay only, vmap only
#define DQ_SL501_FRAMEDELAY_DISABLED    (0)     // disabled
#define DQ_SL501_FRAMEDELAY_FIXEDLEN    (1)     // fixed length
#define DQ_SL501_FRAMEDELAY_VMAP_LEN    (2)     // frame size is determined by the amount of VMap data
#define DQ_SL501_FRAMEDELAY_ZERO_CHAR   (3)     // frame ends upon zero character (ASCIIZ string)
#define DQ_SL501_FRAMEDELAY_VARLEN      (8)     // the data structure is [size][B1]..[Bsize][size][B1]..[Bsize]...
                                                // Frame delay bit is added at the beginning of each frame.

#define DQ_SL501_FRAMEDELAY_REPEAT  (0x10)      // "repeat" mode - repeat last placed frame if not updated on time

// Additional channel numbers for VMap
#define DQ_SL501_PARITY9_DISABLE    (DQ_SL501_FRAMEDELAY_DISABLED)    // use of bit 9 as address bit instead of parity disabled
#define DQ_SL501_PARITY9_ENABLED    (4)         // use of bit 9 as address bit instead of parity enabled

#define DQ_SL501_PARITY9            (1L<<8)     // set parity bit to 1 in FIFO write with PBS operation
#define DQ_SL501_MIXED_PARITY       (1L<<9)     // parity information is mixed in the data
#define DQ_SL501_SEND_NOREPLY       (1L<<10)    // do not wait for the reply on the send message command


#define DQMSG_501_SZ                (DQ_MAX_MSG_SIZE - sizeof(DQMSG_501) - 2)

#define DQCFG_501(OPER, MODE, BAUD, WIDTH, STOP, PARITY) (OPER << DQ_SL501_OPER_SH | MODE << DQ_SL501_MODE_SH | BAUD << DQ_SL501_BAUD_SH | WIDTH << DQ_SL501_WIDTH_SH | STOP  << DQ_SL501_STOP_SH | PARITY << DQ_SL501_PARITY_SH)

#pragma pack(1)
typedef struct {
    uint8   chnl;                   // |7-4 = event flags or error code|3-0 = channel|
    uint8 data[DQ_FLEX_ARRAY];      // n - 8bit samples
} DQMSG_501, *pDQMSG_501;

typedef struct {
    uint32 tstamp;
    uint16 msglen;
    uint8  chnl;
    uint8  data[DQ_FLEX_ARRAY];
} DQMSG_501_L, *pDQMSG_501_L;

// Event data for 501 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 avail;                   // number of bytes available
    uint8 data[DQ_FLEX_ARRAY];      // data to follow (one character takes one byte)
} EV501_ID, *pEV501_ID;

#define DqAdv501ConfigEvents_PARAMSZ (7)        // maximum number of uint32 parameters after pEV501_ID

typedef enum {
    EV501_CLEAR = 0x1000,           // clear all events

    EV501_TO = 0x101,               // no activity on the bus over certain pre-programmed time (+ all accumulated data)

    EV501_IN_FIFO,                  // input FIFO above watermark (data included) (cannot be used together with EV501_RX)
    EV501_RX,                       // data received with check for length and terminator (+ data)

    EV501_OUT_FIFO,                 // output FIFO below watermark (cannot be used together with EV501_TX)
    EV501_TX,                       // data transmission completed

    EV501_BUS_ERROR,                // bus or protocol errors
    EV501_RX_OVERFLOW,              // RX FIFO overflow - cleared
    EV501_RX_UNXP,                  // unexpected RX data (most likely receiveing error)
    EV501_TX_UNXP,                  // unexpected TX data (most likely transmitting error)

    EV501_TO_TS,                    // timeout event happens once upon bus idle. Returns timestamp. Logic 11.08+ is required.
                                    // note: timeout must be set as a time of the last character plus selected idle time
                                    // event is not compatible with EV501_TO and EV501_TO event is returned
    EV501_ON_PATTERN                // Event returned on receiving a certain pattern (up to 6 characters long)
                                    // returns data ending with the pattern
} event501_t;


#define EV501_FIFO_DATA             (1L<<0)    // send FIFO data upon TO or RX interrupt
#define EV501_ACC_DATA              (1L<<1)    // accumulate data to send predefined length only

// Definitions for EV501_ON_PATTERN configuration
#define EV501_PTCFG_MFEN   (1L<<15) // =1 - enable pattern detector message FIFO
                                    // if this FIFO is enabled data is read from this 512-char FIFO rather than the secondary one
#define EV501_PTCFG_BSIZE1 (1L<<13) // Select number of bits in each character
#define EV501_PTCFG_BSIZE0 (1L<<12) // '00' - 5 bits; '01' - 6 bits; '10' - 7 bits; '11' - 8 bits
#define EV501_PTCFG_EM4    (1L<<11) // =1 - enable end-of-message fourth character (PTP2[7:0]) in detector
#define EV501_PTCFG_EM3    (1L<<10) // =1 - enable end-of-message third character (PTP2[15:8]) in detector
#define EV501_PTCFG_EM2    (1L<<9)  // =1 - enable end-of-message second character (PTP2[23:16]) in detector
#define EV501_PTCFG_EM1    (1L<<8)  // =1 - enable end-of-message first character (PTP2[31:24]) in detector
#define EV501_PTCFG_SM8    (1L<<7)  // =1 - enable eighth character (PTP1[7:0]) in detector
#define EV501_PTCFG_SM7    (1L<<6)  // =1 - enable seventh character (PTP1[15:8]) in detector
#define EV501_PTCFG_SM6    (1L<<5)  // =1 - enable sixth character (PTP1[23:16]) in detector
#define EV501_PTCFG_SM5    (1L<<4)  // =1 - enable fifth character (PTP1[31:24]) in detector
#define EV501_PTCFG_SM4    (1L<<3)  // =1 - enable fourth character (PTP0[7:0]) in detector
#define EV501_PTCFG_SM3    (1L<<2)  // =1 - enable third character (PTP0[15:8]) in detector
#define EV501_PTCFG_SM2    (1L<<1)  // =1 - enable second character (PTP0[23:16]) in detector
#define EV501_PTCFG_SM1    (1L<<0)  // =1 - enable first character (PTP0[31:24]) in detector


#define EV501_PTCFG_MM(S,E)     ((((S)&0xff)<<0)|(((E)&0xf)<<8)|PTCFG_BSIZE0|PTCFG_BSIZE1)       // start/end mask
#define EV501_PTCFG_STR_U32(S)  htonl(((((uint8)S[0]&0xff)<<0)|(((uint8)S[1]&0xff)<<8)|(((uint8)S[2]&0xff)<<16)|(((uint8)S[3]&0xff)<<24)))

typedef struct {
    uint32 wm_level;                // watermark level; send an event if above this level regardless of pattern found
    uint32 ptrn_cfg;                // pattern detector configuration, bits EV501_PTCFG_...
    uint32 start_ch0;               // characters 1,2,3,4 of the start pattern
    uint32 start_ch1;               // characters 5,6,7,8 of the start pattern
    uint32 term_ch0;                // characters 1,2,3,4 of the termination pattern
} EV501_PTCFG, *pEV501_PTCFG;

// Upper part of the configuration word - AI-201 specific
#define DQ_L501_MODESCAN            (DQ_FIFO_MODESCAN)  // single scan update mode
#define DQ_L501_MODEFIFO            (DQ_FIFO_MODEFIFO)  // continuous acquisition with FIFO
#define DQ_L501_MODECONT            (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_L501_ID_STANDARD         (0x0L<<18)  // Standard format
#define DQ_L501_ID_EXTENDED         (0x1L<<18)  // Extended format

// Output FIFO to read data
#define DQ_L501_FIFO_GET_DATA       (DQ_FIFO_GET_DATA)

// Input FIFO to read data
#define DQ_L501_FIFO_SET_DATA       (DQ_FIFO_SET_DATA)

// PLL defines - logic revision 0x01021006 or higher
#define DQ_C3PLL_MIN_FREQ_501       (16000000)  // min freq for 1 Mbaud
#define DQ_C3PLL_MAX_FREQ_501       (32000000)  // max PLL baud is DQ_C3PLL_MAX_FREQ_501/16

// default PLL loop filter values
#define DQ_C3PLL_CFG_24MHZ_VCO_POST (0)
#define DQ_C3PLL_CFG_24MHZ_R        (19)
#define DQ_C3PLL_CFG_24MHZ_C        (0)
#define DQ_C3PLL_CFG_24MHZ_I        (1)


#define DQ_L501_NAMELEN             (32)        // maximum length of the channel name (trailing 0 isn't included)
#define DQ_L508_NAMELEN             (24)        // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_L501_CHAN][DQ_L501_NAMELEN];
} DQCNAMES_501_, *pDQCNAMES_501_;

typedef struct {
    char cname[DQ_L508_CHAN][DQ_L508_NAMELEN];
} DQCNAMES_508_, *pDQCNAMES_508_;

typedef struct {
    uint32 chlst[DQ_L508_CHAN*2];   // channel list for I/O - uncompressed
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    uint16 hyst[2];                 // hysteresis DACs A and B
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_501_, *pDQOPMODEPRM_501_;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_501_, *pDQINITPRM_501_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_501_, *pDQSDOWNPRM_501_;

// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_501_ opmodeprm;
    DQINITPRM_501_ initprm;
    DQSDOWNPRM_501_ sdownprm;
    DQCNAMES_508_ cname;            // 508 names are 192 in length while 501 ones are 128 bytes
    DQPRMFLAGS eeflags;
} DEVEEPROM_501_, *pDEVEEPROM_501_;


#define DQ_L503_CHAN                (4)
#define DQ_L503_INFOSZ              (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_L503_BASE                (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_L503_MAXCLFRQ            (2000)
#define DQ_L503_MAXCVFRQ            (2000)

#define DQ_L503_RX_FIFOSZ           (1024)      // This is secondary RX FIFO size
#define DQ_L503_TX_FIFOSZ           (512)       // This is secondary TX FIFO size
#define DQ_L503_FIFO_RQ             (10000)     // secondary FIFO checks per second
#define DQ_L503_TO_RQ               (10)        // sec. FIFO timer checks per second (for DA0 interrupts)
#define DQ_L503_SWFIFOSZ            (2048)
#define DQ_L503_FILTER_SZ           (32)        // max number of receive filter pairs per channel

#define DQ_L503_RX_FIFO_MSGSZ32     (4)         // default watermark - one message - each message 4*uint32
#define DQ_L503_RX_FIFO_MSGSZ       (16)        // size of each message in bytes
#define DQ_L503_RX_FIFO_MAXMSG      (90)        // maximum number of CAN messages in one aEvent packet

#define DQ_CAN503_RATE_10K          (0 << 8)
#define DQ_CAN503_RATE_20K          (1 << 8)
#define DQ_CAN503_RATE_50K          (2 << 8)
#define DQ_CAN503_RATE_100K         (3 << 8)
#define DQ_CAN503_RATE_125K         (4 << 8)
#define DQ_CAN503_RATE_250K         (5 << 8)
#define DQ_CAN503_RATE_500K         (6 << 8)
#define DQ_CAN503_RATE_800K         (7 << 8)
#define DQ_CAN503_RATE_1M           (8 << 8)    // MAX spec speed = default, low speed spec default =  125K

#define DQ_CAN503_RATE_10K_Baud     (10000)
#define DQ_CAN503_RATE_20K_Baud     (20000)
#define DQ_CAN503_RATE_50K_Baud     (50000)
#define DQ_CAN503_RATE_100K_Baud    (100000)
#define DQ_CAN503_RATE_125K_Baud    (125000)
#define DQ_CAN503_RATE_250K_Baud    (250000)
#define DQ_CAN503_RATE_500K_Baud    (500000)
#define DQ_CAN503_RATE_800K_Baud    (800000)
#define DQ_CAN503_RATE_1M_Baud      (1000000)   // MAX spec speed = default, low speed spec default =  125K

#define DQ_L503_MAX_PACKET_BITS     (120)

#define DQ_CAN503_MODE_BASIC        (0 << 12)   // CAN 2.0a - basicCAN (11 bit identifier)
#define DQ_CAN503_MODE_XTEND        (1 << 12)   // CAN 2.0b - extended (29 bit identifier)

#define DQ_CAN503_OPER_NORMAL       (0 << 13)   // normal
#define DQ_CAN503_OPER_LISTEN       (1 << 13)   // passive listen only

#define DQ_CAN503_ERR_NONE          (0)         // no error
#define DQ_CAN503_ERR_WARN          (1)         // error warning limit (as per spec) has been reached
#define DQ_CAN503_ERR_AE            (2)         // bus arbitration error
#define DQ_CAN503_ERR_BE            (3)         // bus error w/ 4 sub types: form, stuff, bit, other
#define DQ_CAN503_ERR_OR            (4)         // overrun
#define DQ_CAN503_ERR_TO            (5)         // write or read timeout
#define DQ_CAN503_ERR_RESET         (6)         // forced entered reset mode (bus-off)
#define DQ_CAN503_ERR_PASS          (7)         // error-passive status (one step from bus-off)

#define DQ_CAN503_RTR_FLAG          (0x40000000)// Or this flag with CAN frame ID to send a remote CAN frame (RTR bit is 1)


// retrieve timestamp along with the data in VMap mode
#define DQ_CAN503_VMAP_TIMESTAMP    (1L<<8)
#define DQ_CAN503_VMAP_STAT         (1L<<9)     // add status to the data

// various ioctl type functions
#define DQL_IOCTL503_SET_MASK       (0x1)       // sets ac/am, 8 bytes total
#define DQL_IOCTL503_SET_RATE       (0x2)       // sets the channel speed via BTR0/BTR1 format (see sja1000 specs)
#define DQL_IOCTL503_SET_OPER_MODE  (0x3)       // sets the channel mode, passive or listen
#define DQL_IOCTL503_SETTXWM        (0x4)       // sets the TX watermark
#define DQL_IOCTL503_SETRXWM        (0x5)       // sets the RX watermark
#define DQL_IOCTL503_SETTXDND       (0x6)       // sets TX do-not-disturb delay - minimum time between packets
#define DQL_IOCTL503_SETFFRQST      (0x7)       // sets number of secondary FIFO processings per second
#define DQL_IOCTL503_SETERRHDL      (0x8)       // sets error interrupt handling for the channel
#define DQL_IOCTL503_SET_FILTER     (0x0A)      // set label filter

#define DQL_IOCTL503_RESET_CHNL     (0x4)       // reset a channel, can be done after errors
#define DQL_IOCTL503_READ_CHNL      (0x5)       // read a channel message
#define DQL_IOCTL503_WRITE_CHNL     (0x6)       // write a channel message
#define DQL_IOCTL503_SETCHNL_CFG    (0x7)       // set channel config word
#define DQL_IOCTL503_START          (0x8)       // immediate mode start
#define DQL_IOCTL503_STOP           (0x9)       // immediate mode stop
#define DQL_IOCTL503_STATUS         (0x0FL)     // get interface status

#define DQL_IOCTL501_READ_CFIFO     (0x1001L)   // direct read from a channel FIFO
#define DQL_IOCTL503_WRITE_CFIFO    (0x1002L)   // direct write to a channel FIFO

#define DQ_L503_SEC_FIFO_SUPPORTED  (0xf)       // minor version of logic (>= 0xf) that supports secondary RX FIFO

//AI:
// 11.3B is the original logic that handles IRQ. However it fails in the case when:
// 1. Write happens on channel X
// 2. Write happens on channel Y
// 3. Read happens on channel X
// 4. Read happens on channel Y <- read returns with bus error
// This mode is temporarily disabled
#define DQ_L503_SJA1000_INT_MINOR   (0x11)      // minor version of the logic with supported interrupts
#define DQ_L503_SJA1000_INT_BUILD   (0x3B)      // build version of the logic with supported interrupts
// uncomment to allow interrupt-based chip I/O
//#define DQ_L503_SJA1000_INT_MINOR   (0xff)      // minor version of the logic with supported interrupts
//#define DQ_L503_SJA1000_INT_BUILD   (0xff)      // build version of the logic with supported interrupts

#define DQ_L503_CAN_IRQ_DELAY_LOGIC_VER   (0x02152D)  // logic version that delays CAN IRQ until SJA1000 ISR is updated

// for DQL_IOCTL503_SETERRHDL
#define DQ_L503_ALERR_INHIBIT       (0x1)       // inhibit handling of arbitration lost error
#define DQ_L503_BEERR_INHIBIT       (0x2)       // inhibit handling of bus error
#define DQ_L503_RST_ON_ERRPAS       (0x4)       // reset and reenable controller on error passive
#define DQ_L503_RST_ON_BUSOFF       (0x8)       // reset and reenable SJA1000 if it took itself off the bus


// bus error register values
// 7..6 = error code
// 5 = direction
// 4..0 = segment
#define DQ_CAN503_EC_BIT            (0x00)      // bit error
#define DQ_CAN503_EC_FORM           (0x40)      // form error
#define DQ_CAN503_EC_STUFF          (0x80)      // stuff error
#define DQ_CAN503_EC_OTHER          (0xC0)      // other

#define DQ_CAN503_DIR_RX            (0x20)      // receive error
#define DQ_CAN503_DIR_TX            (0x0)       // trasmit error

#define DQ_CAN503_BE_SOF            (0x3)       // start of frame
#define DQ_CAN503_BE_ID_28_21       (0x2)       // ID.28 to ID.21
#define DQ_CAN503_BE_ID_20_18       (0x6)       // ID.20 to ID.18
#define DQ_CAN503_BE_SRTR           (0x4)       // bit SRTR
#define DQ_CAN503_BE_IDE            (0x5)       // bit IDE
#define DQ_CAN503_BE_ID_17_13       (0x7)       // ID.17 to ID.13
#define DQ_CAN503_BE_ID_12_5        (0xf)       // ID.12 to ID.5
#define DQ_CAN503_BE_ID_4_0         (0xe)       // ID.4 to ID.0
#define DQ_CAN503_BE_RTR            (0xc)       // bit RTR
#define DQ_CAN503_BE_DLC            (0xb)       // data length code
#define DQ_CAN503_BE_DF             (0xa)       // data
#define DQ_CAN503_BE_CRC_SEQ        (0x8)       // CRC sequence
#define DQ_CAN503_BE_CRC_DEL        (0x18)      // CRC delimiter
#define DQ_CAN503_BE_ACK_SLT        (0x19)      // ack slot
#define DQ_CAN503_BE_ACK_DEL        (0x1a)      // ack delimiter
#define DQ_CAN503_BE_EOF            (0x1a)      // end of frame
#define DQ_CAN503_BE_IM             (0x12)      // intermission
#define DQ_CAN503_BE_AEF            (0x11)      // active error flag
#define DQ_CAN503_BE_PEF            (0x16)      // passive error flag
#define DQ_CAN503_BE_TDB            (0x13)      // tolerate dominat bits
#define DQ_CAN503_BE_ERR_DEL        (0x17)      // error delimiter
#define DQ_CAN503_BE_OL             (0x1c)      // overload flag

#define DQ_CAN503_BC_TX0            (0x0A)      //
#define DQ_CAN503_PC_TX0            (0x10)      //

#define ICR_SECFIFO_RD32            (4)         // second RX FIFO contains 4 32-bit words per message
#define ICR_SECFIFO_RD              (16)        // second RX FIFO contains 16 bytes per message

#define ICR_SECFIFO_WR32            (4)         // second TX FIFO contains 4 32-bit words per message
#define ICR_SECFIFO_WR              (16)        // second TX FIFO contains 16 bytes per message


// Additional channel numbers for VMap
#define DQ_SL503_SEND_NOREPLY       (1L<<10)    // do not wait for the reply on the send message command

#define DQ_L503_MODESCAN            (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_L503_MODEFIFO            (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO
#define DQ_L503_MODECONT            (DQ_FIFO_MODECONT)  // continuous acquisition

// Output FIFO to read data
#define DQ_L503_FIFO_GET_DATA       (DQ_FIFO_GET_DATA)

// Input FIFO to read data
#define DQ_L503_FIFO_SET_DATA       (DQ_FIFO_SET_DATA)

// Frame type (PeliCAN mode)
#define CAN_EFF(D)                  (((D)&0x80)>>7) // Check header, return 1 if Extended Format in use
#define CAN_LEN(D)                  ( (((D)&0x0f)>8) ? 8 : ((D)&0x0f) ) // Return number of data bytes
#define CAN_RTR(D)                  (((D)&0x40)>>6) // Return 1 if remote transmit request bit is set

// required minimal space left in the buffer to copy data
#define DQ503_MINSZ_SECRX(DT, CHANNEL)  ( ((pDEVOBJ_503)DT->devobj)->chnls[CHANNEL].mode == DQ503_BASIC ? 13 : 14)

#define DQ_L503_NAMELEN             (32)        // maximum length of the channel name (trailing 0 isn't included)


#pragma pack(1)

// channel names
typedef struct {
    char cname[DQ_L503_CHAN][DQ_L503_NAMELEN];
} DQCNAMES_503_, *pDQCNAMES_503_;

// sja1000 config set per channel for runtime
typedef struct {
    uint8 bt0, bt1, ocr;            // registers
    uint8 ac0, ac1, ac2, ac3;       // mask in basic only 0 is used
    uint8 am0, am1, am2, am3;
    uint8 oper;                     // 0 = normal, 1 = listen
    uint8 mode;                     // 0 = basic, 1 = xtend
    uint8 en;                       // 0 = nothing, 1 = in, 2 = out, 3 = both
    uint32 dnd;                     // 0 = use calculated DND, otherwise use this one
} DQCHNLSET_503_, *pDQCHNLSET_503_;

typedef struct {
    uint32 chlst[DQ_L503_CHAN*2];   // channel list for I/O - uncompressed
    uint32 sslst[DQ_L503_CHAN*2];   // subsystem list for I/O (matches DqCmdSetChannelList)
    uint32 ac[DQ_L503_CHAN];        // accept codes
    uint32 am[DQ_L503_CHAN];        // accept masks

    uint32 conf;                    // control word (to feed to config_io)
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    uint32 trig;                    // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_503_, *pDQOPMODEPRM_503_;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_503_, *pDQINITPRM_503_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_503_, *pDQSDOWNPRM_503_;


// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_503_ opmodeprm;
    DQINITPRM_503_ initprm;
    DQSDOWNPRM_503_ sdownprm;
    DQCNAMES_503_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_503_, *pDEVEEPROM_503_;

#pragma pack()

// Event data for CAN-503 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 avail;                   // number of messages available (including just sent messages)
    uint8 data[DQ_FLEX_ARRAY];      // data to follow (one character takes one byte)
} EV503_ID, *pEV503_ID;

typedef enum {
    EV503_CLEAR = 0x1000,           // clear all events

    EV503_RX_PERIODIC = 0x101,      // periodic event (+ all accumulated data)

    // FIFO events
    EV503_IN_FIFO,                  // input FIFO above watermark (data included)
    EV503_OUT_FIFO,                 // output FIFO below watermark

    // Bus errors
    EV503_ERROR_BUS,                // bus or protocol errors
    EV503_ERROR_WARNING,            // bus warning level has been reached
    EV503_ERROR_PASSIVE,            // bus in passive state
    EV503_ERROR_BUSOFF,             // chip is taken off the bus

    // Firmware errors
    EV503_RX_OVERFLOW,              // RX FIFO overflow - cleared
    EV503_RX_UNXP,                  // unexpected RX error (most likely receiving error)
    EV503_TX_UNXP                   // unexpected TX error (most likely transmitting error)
} event503_t;

#define DqAdv503ConfigEvents_PARAMSZ (7)        // maximum number of uint32 parameters after pEV503_ID

// Internal flags to make easier to store events subscription per channel
#define EV503_ON_RX_PER     (1L<<0)     //
#define EV503_ON_RX         (1L<<1)     //
#define EV503_ON_TX         (1L<<2)     //
#define EV503_ON_BUS        (1L<<3)     //
#define EV503_ON_WARN       (1L<<4)     //
#define EV503_ON_PASS       (1L<<5)     //
#define EV503_ON_OFF        (1L<<6)     //
#define EV503_ON_OVFL       (1L<<7)     //
#define EV503_ON_RXERR      (1L<<8)     //
#define EV503_ON_TXERR      (1L<<9)     //
#define EV503_ON_CHIPERR    (1L<<30)    // any chip level (bus) errors

#define EV503_ON_ERROR      (EV503_ON_BUS|EV503_ON_WARN|EV503_ON_PASS|EV503_ON_OFF|EV503_ON_RXERR|EV503_ON_TXERR)


#define EV503_FIFO_DATA             (1L<<0)     // send FIFO data upon TO or RX interrupt
#define EV503_ACC_DATA              (1L<<1)     // accumulate data to send predefined length only

// used as helper structure
#pragma pack(1)
typedef struct {
    uint8 chnl;
    uint32 id;
    uint8 data[DQ_FLEX_ARRAY];
} DQMSG_503, *pDQMSG_503;

typedef struct {
    uint32 tstamp;
    uint8  msglen;
    uint8  chnl;
    uint32 id;
    uint8  data[DQ_FLEX_ARRAY];
} DQMSG_503_L, *pDQMSG_503_L;

#pragma pack()

#define DQ_L504_CHAN                (4)
#define DQ_L504_INFOSZ              (DQ_MAX_INFO_SIZE) // maximum size of information structure
#define DQ_L504_BASE_66             (66000000)  // 66MHz base frequency
#define DQ_L504_MAXCLFRQ            (2000)
#define DQ_L504_MAXCVFRQ            (2000)
#define DQ_L504_FIFOSZ              (2048)
#define DQ_L504_HDLC_FRAME_SZ       (4096)
#define DQ_L504_HDLC_TRX_SZ         (8692)      // Maximum transfer size in one command - 6 fragmented 1518 frames
                                                // plus 180 bytes of control data per transaction
#define DQL_LCR504_LED              (1L<<1)     // LED control in LCR

#define DQL_L504_MIN_HDLC_BAUD      9600
#define DQL_L504_MAX_HDLC_BAUD      4000000
#define DQL_L504_MIN_ASYNC_BAUD     2400
#define DQL_L504_MAX_ASYNC_BAUD     2000000
#define DQL_L504_MIN_SYNC_BAUD      2400
#define DQL_L504_MAX_SYNC_BAUD      4000000

#define SL504_CLK_FACTOR            (16)
#define SL504_CY22150_BASE          (16500000)     // 16.5MHz is used as a PLL clock (14.142857MHz in logics below 10.7a)

#define SL504_PCR_506_MASK          (0x3FC0)
#define SL504_PCR_506_MODE_OFF      (0x2A80)
#define SL504_PCR_506_MODE_232      (0x2B80)
#define SL504_PCR_506_MODE_422TERM  (0x2E80)
#define SL504_PCR_506_MODE_485      (0x2EC0)
#define SL504_PCR_506_MODE_VDOT36   (0x2F80)
#define SL504_PCR_506_MODE_449      (0x3E80)
#define SL504_PCR_506_MODE_530      (0x3EC0)
#define SL504_PCR_506_MODE_VDOT35   (0x3F80)
#define SL504_PCR_506_MODE_530A     (0x3FC0)

#define SL504_PCR_506_MODE_SE_LOOP  (0x3B80)    // single-ended loopbak mode
#define SL504_PCR_506_MODE_DF_LOOP  (0x3BC0)    // differential loopback mode

// ----------------------------------------------------------------------
// ioctls
#define DQL_IOCTL504_READ_CHNL      (0x07L)     // read a channel message
#define DQL_IOCTL504_WRITE_CHNL     (0x08L)     // write a channel message
#define DQL_IOCTL504_SETCHNL_CFG    (0x09L)     // set channel config
#define DQL_IOCTL504_START          (0x0AL)     // start/stop layer by channels
#define DQL_IOCTL504_WRITE_FRAMES   (0x0BL)     // write multiple frames in one packet
#define DQL_IOCTL504_ABORT          (0x0CL)     // terminate transmission
#define DQL_IOCTL504_READ_FRAMES    (0x0DL)     // read multiple frames in one packet
#define DQL_IOCTL504_STATUS         (0x0FL)     // get interface status

// for DQL_IOCTL504_READ_CHNL and DQL_IOCTL504_WRITE_CHNL
#define DQL_IOCTL504_RC_FRAME_SE    (1L<<1L)    // First frame of single-frame sequence
#define DQL_IOCTL504_RC_FRAME_S     (2L<<1L)    // First frame of multi-frame sequence
#define DQL_IOCTL504_RC_FRAME_C     (3L<<1L)    // Tell to continue sending frames
#define DQL_IOCTL504_RC_FRAME_E     (4L<<1L)    // Last frame (or only frame) of frame sequence
#define DQL_IOCTL504_RC_FRAMEMASK   (7L<<1L)    // Mask

// defines for SL504_SETCFG
// <protocol>
#define SL504_PROT_HDLC         1   // HDLC protocol support
#define SL504_PROT_ASYNC        2   // Asynchronous mode (character-based, for debug uses; 1200 baud sustained or 230kbaud bursts )
#define SL504_PROT_SYNC         3   // <reserved> Bit-synchronous, external sync, no framing or synchronization
#define SL504_PROT_ISOCHRONOUS  4   // <reserved> isochronous mode
#define SL504_PROT_NINEBIT      5   // <reserved> 9th bit address mode
#define SL504_PROT_RESV0        6   // <reserved>
#define SL504_PROT_BIMONOSYNC   7   // <reserved> monosync or bisync mode
#define SL504_PROT_T_BISYNC     8   // <reserved> transparent bisync mode
#define SL504_PROT_S_MONOSYNC  10   // <reserved> slaved monosync mode

// <modeflags>
#define SL504_HDLC_LOOP         (1L<<0) // <reserved> HDLC loop mode
#define SL504_USE_CTS           (1L<<4) // CTS input controls transmission
#define SL504_USE_DCD           (1L<<5) // DCD input enables receiver

#define SL504_INHIBIT_TX        (1L<<6) // Do not enable transmitter
#define SL504_INHIBIT_RX        (1L<<7) // Do not enable receiver

#define SL504_MODE_NOTXONIDLE   (1L<<8) // SL-504-801 only: turn off Tx driver when not transmitting for 2-wire RS-422/485

// <physical>
#define SL504_PHY_MODE_MSK      0xF // Mask to differentiate between PHY modes and flags

#define SL504_PHY_RS232         1   // RS-232 (see comment for SL504_PROT_ASYNC)
#define SL504_PHY_RS485         2   // RS-485 up to 4Mbit
#define SL504_PHY_RS422         3   // RS-422 multidrop
#define SL504_PHY_V35           4   // balanced current data and clock and unbalanced voltage DCD and CTS

#define SL504_PHY_TERM          0x40    // enable termination in RS-485 and RS-422 modes
#define SL504_PHY_LOOP          0x80    // enable loopback in the selected mode
#define SL504_PHY_NOECHO        0x100   // suppress echo in RS-422/423 modes

// <hdlc_flags>
#define SL504_HDLC_ABORT_7        (0L<<0)   // send 0x7f as an abort symbol
#define SL504_HDLC_ABORT_15       (1L<<0)   // send 0x7fff as an abort symbol
#define SL504_HDLC_FINISH_UNDER   (2L<<0)   // in underrun condition close the frame by adding CRC to it
#define SL504_HDLC_FLAGS_UNDER    (3L<<0)   // in underrun condition start sending flags
#define SL504_HDLC_SHARED_ZEROES  (1L<<6)   // send idle flags with shared zeroes

#define SL504_HDLC_TCLK_INT       (1L<<8)   // <reserved> use internal clock for Tx
#define SL504_HDLC_RCLK_INT       (1L<<9)   // <reserved> use internal clock for Rx

// <hdlc_encod>
#define SL504_HDLC_NRZ            (0L<<0)   // NRZ encoding
#define SL504_HDLC_NRZB           (1L<<0)   // inverted NRZ encoding
#define SL504_HDLC_NRZI           (2L<<0)   // NRZI encoding
#define SL504_HDLC_NRZI_MARK      (3L<<0)   // NRZI encoding, invert state for 1
#define SL504_HDLC_NRZI_SPACE     (4L<<0)   // NRZI encoding, invert state for 0
#define SL504_HDLC_BIPHASE_MARK   (5L<<0)   // biphase mark encoding, used with DPLL
#define SL504_HDLC_BIPHASE_SPACE  (6L<<0)   // biphase space encoding, used with DPLL
#define SL504_HDLC_BIPHASE_LEVEL  (7L<<0)   // biphase level encoding, used with DPLL
#define SL504_HDLC_BIPHASE_DIFF   (8L<<0)   // differential biphase encoding, used with DPLL

// <hdlc_clk_src>
#define SL504_HDLC_FLAG_RXC_RXCPIN  (1L<<0)    // RxClk from RxC pin (default)
#define SL504_HDLC_FLAG_RXC_DPLL    (2L<<0)    // RxClk from DPLL
#define SL504_HDLC_FLAG_RXC_BRG     (3L<<0)    // RxClk from BRG0

#define SL504_HDLC_FLAG_TXC_BRG     (1L<<2)    // TxClk from BRG0 (default)
#define SL504_HDLC_FLAG_TXC_DPLL    (2L<<2)    // TxClk from DPLL
#define SL504_HDLC_FLAG_TXC_RXCPIN  (3L<<2)    // TxClk from RxC pin

#define SL504_HDLC_FLAG_DPLL_DIV8   (1L<<4)    // DPLL divider 8
#define SL504_HDLC_FLAG_DPLL_DIV16  (2L<<4)    // DPLL divider 16

#define SL504_HDLC_FLAG_DPLL_SRCBRG (1L<<6)    // DPLL input from BRG1

// <hdlc_crc_mode>
#define SL504_HDLC_CRC_NONE       (0L<<0)   // CRC is not check neither for transmit nor receive
#define SL504_HDLC_CRC_USER       (1L<<0)   // User is responsible for inserting and checking CRC
#define SL504_HDLC_CRC_16_CCITT   (2L<<0)   // 16-bit CCITT CRC is used (x^16+x^12+x^5+1)
#define SL504_HDLC_CRC_16         (3L<<0)   // 16-bit polynomial CRC is used (x^16+x^15+x^2+1)
#define SL504_HDLC_CRC_32         (4L<<0)   // 32-bit Eth CRC is used
                                            // (x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1)

// <hdlc_flt_mode>
#define SL504_HDLC_FLT_NONE       (0L<<0)   // No filtering
#define SL504_HDLC_FLT_A_16       (1L<<0)   // +16 bits into RxFIFO if Addr matches or B/C as 2 bytes
#define SL504_HDLC_FLT_A_24       (2L<<1)   // +24 bits into RxFIFO if Addr matches or B/C as 3 bytes
#define SL504_HDLC_FLT_A_32       (6L<<1)   // +32 bits into RxFIFO if Addr matches or B/C as 4 bytes
#define SL504_HDLC_FLT_EA_LS      (7L<<1)   // Places bytes while LS==0, then byte with LS==1 then 16 bits
                                            // as 2 bytes into RxFIFO if EA matches or B/C
#define SL504_HDLC_FLT_EA_24      (3L<<1)   // Places 24 bits as 3 bytes into RxFIFO if EA matches or B/C
#define SL504_HDLC_FLT_EA_MS      (11L<<1)  // Places bytes while MS==0, then byte with MS==1 then 8 bits
                                            // as 1 byte into RxFIFO if Ext Addr matches or B/C
#define SL504_HDLC_FLT_EA_MS16    (15L<<1)  // Places bytes while MS==0, then byte with MS==1 then 16 bits
                                            // as 2 bytes into RxFIFO if Ext Addr matches or B/C

// <hdlc_prmbl_sz>
#define SL504_HDLC_PRMBSZ_8       (0L<<0)   // 8-bit preamble is used
#define SL504_HDLC_PRMBSZ_16      (1L<<0)   // 16-bit preamble is used
#define SL504_HDLC_PRMBSZ_32      (2L<<0)   // 32-bit preamble is used
#define SL504_HDLC_PRMBSZ_64      (3L<<0)   // 64-bit preamble is used

// <hdlc_preamble>
#define SL504_HDLC_PRMB_NONE      (0L<<0)   // no preamble
#define SL504_HDLC_PRMB_ZERO      (1L<<0)   // all zeroes
#define SL504_HDLC_PRMB_ONE       (2L<<0)   // all ones
#define SL504_HDLC_PRMB_FLAG      (3L<<0)   // all flags
#define SL504_HDLC_PRMB_10        (4L<<0)   // alternating 1 and 0
#define SL504_HDLC_PRMB_01        (5L<<0)   // alternating 0 and 1

// <hdlc_idle_ch>
#define SL504_HDLC_IDLE_FLAG      (0L<<0)   // continuous flags
#define SL504_HDLC_IDLE_ZERO      (1L<<0)   // continuous zeroes
#define SL504_HDLC_IDLE_ONE       (2L<<0)   // continuous ones
#define SL504_HDLC_IDLE_MARK      (3L<<0)   // idle chars are marks
#define SL504_HDLC_IDLE_SPACE     (4L<<0)   // idle chars are spaces
#define SL504_HDLC_IDLE_MS        (5L<<0)   // alternating Mark and Space
#define SL504_HDLC_IDLE_01        (6L<<0)   // alternating 0 and 1

// <async_parity> parity type
#define DQ_SL504_PARITY_NONE      (0L<<0)   // none (parity field is not
                                            // populated)
#define DQ_SL504_PARITY_EVEN      (1L<<0)   // =1 if sum of data bits is even
#define DQ_SL504_PARITY_ODD       (2L<<0)   // =1 if sum of data bits is odd
#define DQ_SL504_PARITY_SPACE     (3L<<0)   // always space (constant 0)
#define DQ_SL504_PARITY_MARK      (4L<<0)   // always mark (constant 1)

// low level error flags
#define DQ_SL504_ERR_RXOVERUN     (1L<<16)  // SL-504 recoverd from an RXFIFO overun (frame was lost)

// Channel configuration -- AI: for the library to work properly all fields must be uint32
#pragma pack(1)
typedef struct {

    // always set the signaling protocol, rx/tx mode flags, and physical interface
    uint32 protocol;        // protocol as defined by SL504_PROT constants (e.g. SL504_PROT_HDLC)
    uint32 modeflags;       // additional flags for rx/tx mode selection
    uint32 physical;        // physical interface as SL504_PHY (e.g. SL504_PHY_RS485)

    // HDLC or RawSync modes are controlled by this section (SL504_PROT_HDLC)
    uint32 hdlc_flags;      // additional sync mode flags as SL504_HDLC (e.g. SL504_HDLC_FINISH_UNDER)
    uint32 hdlc_encod;      // encoding type for NRZ, MII, etc. as SL504_HDLC_NRZ_/_BIPHASE_
    uint32 hdlc_baud;       // RxC or TxC clock rate in baud (not bits per second)
    uint32 hdlc_clk_src;    // select clock to synchronize Tx from as SL504_HDLC_FLAG_TXC/RXC|DPLL
    uint32 hdlc_crc_mode;   // no, user, or CRC-16/32/CCITT as SL504_HDLC_CRC
    uint32 hdlc_flt_mode;   // HDLC address filter as SL504_HDLC_FLT (e.g. SL504_HDLC_FLT_NONE)
    uint32 hdlc_filter;     // HDLC address filter as 8-bit value; set to -1 (broadcast) to disable
    uint32 hdlc_preamble;   // preamble as SL504_HDLC_PRMB (e.g. SL504_HDLC_PRMB_NONE)
    uint32 hdlc_prmbl_sz;   // size of preamble as SL504_HDLC_PRMBSZ (e.g. SL504_HDLC_PRMBSZ_32)
    uint32 hdlc_idle_ch;    // idle character as SL504_HDLC_IDLE (e.g. SL504_HDLC_IDLE_ONE), default is 0x7E

    // Asynchronous mode is controlled by this section. Note: use for debug uses only (non-DMA, read often!)
    uint32 async_baud;      // baud rate up to 1200 baud. Configurable up to 230k for non-DMA bursts.
    uint32 async_char_sz;   // 5 to 8 bits before parity bit, 9th bit is after parity
    uint32 async_start;     // number of start bits (=0 is default means 1 bit)
    uint32 async_stop;      // number of stop bits (=0 is default means 1 bit)
    uint32 async_parity;    // parity used
    uint32 async_msglen;    // watermark level defines message length
    uint32 async_tout;      // timeout forces to transmit everything accumulated (in ms)

} SL504_SETCFG, *pSL504_SETCFG;


// DMA buffer entry for linked list mode
// With buffer control block enabled it is 16 bytes long
typedef struct _DMABUFFERENTRY
{
    // linked list entry
    uint32 phys_addr;   // 4b @0x0  32-bit flat physical address of data buffer on the bus
    uint16 bcount;      // 2b @0x4  buffer size/data count
    uint16 xstatus;     // 2b @0x6  TCB/RSB control/status field
    uint16 xcc;         // 2b @0x8  TCB/RSB character count field
    uint16 reserved;    // 2b @0xA padding required by Z16C32
    uint32 link_next;   // 4b @0xC 32-bit flat link to next buffer entry
                        //    16 bytes total

} DMABUFFERENTRY, *pDMABUFFERENTRY;

// Interface status
typedef struct {
    int cts;        // number of CTS transitions
    int dcd;        // number of DCD transitions
    int tx;         // bytes transmitted
    int ftx;        // frames transmitted
    int rx;         // bytes received
    int frx;        // frames received
    int frm_err;    // frame errors
    int ovr_err;    // overrun errors (Rx)
    int und_err;    // underrun error (Tx)
    int prt_err;    // parity errors
    int tx_abort;   // Tx frame aborts
    int rx_abort;   // Rx frame aborts
    int short_err;  // Rx frames too short to be valid
    int long_err;   // Rx frames too long (>4096) to be valid
    int lines;      // current line state
    int err_stat;   // most recent error status
    int brk;        // number of breaks
    int exithunt;   // ditto exited hunt mode
    int rxidle;     // ditto idle
    int rsv3;
    int rsv4;
    int rsv5;
    int rsv6;
    int rsv7;

    // there are a few important registers to return for debug purposes
    uint16 tdmr;    // Tranmit DMA status reguster
    uint16 rdmr;    // Receive DMA status reguster
    uint16 ccsr;    // Channel commmand/status register
    uint16 tcsr;    // Transmit commmand/status register
    uint16 rcsr;    // Receive commmand/status register
    uint16 rsv10;
    uint16 rsv11;
    uint16 rsv12;

} SL504_INT_STAT, *pSL504_INT_STAT;

// Status bits
#define Z16_FRAME_ERR       (1L<<0) // frame error in the last frame/character
#define Z16_PARITY_ERR      (1L<<1) // parity error in the last frame/characted
#define Z16_BREAK           (1L<<2) // break recevied

// Event data for 504 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 avail;                   // number of bytes available
    uint8 data[DQ_FLEX_ARRAY];                   // data to follow (one character takes one byte)
} EV504_ID, *pEV504_ID;

#define DqAdv504ConfigEvents_PARAMSZ (7)        // maximum number of uint32 parameters after pEV504_ID

typedef enum {
    EV504_CLEAR = 0x1000,           // clear all events

    EV504_TO = 0x101,               // no activity on the bus over certain pre-programmed time (+ all accumulated data)

    EV504_IN_FIFO,                  // input FIFO watermark (+ data) cannot be used together with EV504_RX
    EV504_IN_FRAME,                 // HDLC frame received + data (may be more than one packet)

    EV504_OUT_FIFO,                 // output FIFO below watermark
    EV504_OUT_FRAME,                // HDLC data transmission completed

    EV504_BUS_ERROR                 // bus or protocol errors
} event504_t;

#define EV504_FIFO_DATA             (1L<<0)     // send FIFO data upon TO or RX interrupt
#define EV504_ACC_DATA              (1L<<1)     // accumulate data to send predefined length only

#pragma pack()

// Upper part of the configuration word - AI-201 specific
// Output FIFO to send data
#define DQ_L504_FIFO_GET_DATA       (DQ_FIFO_GET_DATA)

// Input FIFO to receive data
#define DQ_L504_FIFO_SET_DATA       (DQ_FIFO_SET_DATA)


#define DQ_L504_NAMELEN             (32)        // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_L504_CHAN][DQ_L504_NAMELEN];
} DQCNAMES_504_, *pDQCNAMES_504_;

typedef struct {
    uint32 chlst[DQ_L504_CHAN*2];   // channel list for I/O - uncompressed
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    uint16 hyst[2];                 // hysteresis DACs A and B
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_504_, *pDQOPMODEPRM_504_;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_504_, *pDQINITPRM_504_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_504_, *pDQSDOWNPRM_504_;


#define DQ_L504_MAX_DMA_TRAN    16      // maximum number of frames to read/write in one block not to hold DMA for too long
#define DQ_L504_DMA_N           128     // number of DMA buffers

// structure for temporarily storage of Z16C32 registers
typedef struct {
    uint16 exar;           // Exar SP506 configuration
    uint16 ccar;           // Z16C32 registers with the same names
    uint16 dcar;
    uint16 tcsr;
    uint16 rcsr;
    uint16 tmr;
    uint16 rmr;
    uint16 cmr;
    uint16 mbre;
    uint16 ccsr;

    // store ROC bits
    uint16 tdmr_roc;
    uint16 rdmr_roc;

    // stored configuration
    uint16 loopback_ccar;
    uint16 idlemode;
    uint16 rx_enabled;      // TRUE = rx is enabled
    uint16 rx_overflow;     // TRUE = rx is overflown
    uint16 rx_rcc_underrun; // TRUE = rx RCC is underrun
    uint16 tx_enabled;      // TRUE = tx is enabled
    uint16 tx_act_async;    // TRUE = tx is active in ASYNC
    uint16 enable_rx_on_tx_done; // in devobj for reenterability
    uint16 tx_idle_sent;    // TRUE = tx buffer is done

    // DMA buffers/vars Rx
    //DMABUFFERENTRY RxBuf[DQ_L504_DMA_N];  // DMA entries for Rx - moved to PSRAM
    uint16 rx_num_bufs;                   // number of buffers allocated = DQ_L504_DMA_N
    uint16 rx_num_data;                   // number of buffers with data = 0 @ rx reset
    uint16 rx_has_data;                   // Rx received some data = 0 @ rx reset, >0 to read frame
    uint16 rx_count;                      // Buffer filled = 0 @ rx reset
    uint16 rx_head;                       // Head of the ring = 0 @ rx reset
    uint16 rx_rcc_cnt;                    // Start count for Rx RCC size calculation
    uint16 rx_last_rsb;                   // last RSB


    // DMA buffers/vars Tx
    //DMABUFFERENTRY TxBuf[DQ_L504_DMA_N];  // DMA entries for Tx - moved to PSRAM
    uint16 tx_num_bufs;                   // number of buffers allocated = DQ_L504_DMA_N
    uint16 tx_num_data;                   // number of buffers with data = 0 @ rx reset
    uint16 tx_has_data;                   // Tx has data to transmit = 0 @ rx reset, >0 to start transmission
    uint16 tx_count;                      // Buffer filled = 0 @ rx reset
    uint16 tx_head;                       // Head of the ring = 0 @ rx reset
    uint16 tx_start_from;                 // Tail of the ring = 0 @ rx reset

    // Interrupts
    uint16 isr_overflow;                  // Rx overflow flag

} Z16CFG, *pZ16CFG;

// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_504_ opmodeprm;
    DQINITPRM_504_ initprm;
    DQSDOWNPRM_504_ sdownprm;
    DQCNAMES_504_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_504_, *pDEVEEPROM_504_;

#define DQ_L514_CHAN                (4)
#define DQ_L514_NAMELEN             (16)        // maximum length of the channel name (trailing 0 isn't included)

#define DQ_L514_INFOSZ              (DQ_MAX_INFO_SIZE)      // maximum size of information structure
#define DQ_L514_BASE                (66000000)  // 66MHz base frequency
#define DQ_L514_MAXCLFRQ            (2500000)
#define DQ_L514_MAXCVFRQ            (2500000)

#define DQ_L514_MAXBAUDRATE         (DQ_L514_MAXCLFRQ)
#define DQ_L514_MINBAUDRATE         (300)

#define DQ_L514_FIFOSZ_RX           (2048)
#define DQ_L514_FIFOSZ_TX           (1024)

#define DQ_L514_MAXWAIT             (20)        // max delay on the bus for read/write = 2us per read/write
#define DQ_L514_MAXCLSIZE           (65536)     // maximum amount of EC memory accessible by the EC host

#define DQL_L514_SYNCD              (DQL_LCR_SYNCD)   // debug mode on
#define DQL_L514_LED                (1L<<1)     // switch LED on

#define EC514_PERIODIC_us           (100*1000)  // 10ms

#define DQ_L514_CALDACS             (4)

#define DQ_L514_MAXPLLFRQ           (20000000.0)  // maximum clock rate from PLL
#define DQ_L514_MINPLLFRQ           (300.0)     // minimum clock rate from PLL
#define DQ_L514_SNAP_FREQ                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           (24000000.0)     // default PLL rate to program

// IOCTLs
#define DQL_IOCTL514_CFG            (0x1001)    // configure operations
#define DQL_IOCTL514_STATUS         (0x1002)    // get status
#define DQL_IOCTL514_ENABLE         (0x1003)    // enable channels
#define DQL_IOCTL514_RDFRAME        (0x1004)    // read data frame (up to 8192 bytes)
#define DQL_IOCTL514_WRFRAME        (0x1005)    // write data frame (up to 8192 bytes)
#define DQL_IOCTL514_SETPLL         (0x1006)    // write data frame (up to 8192 bytes)

// Errors for L514_SET_CFG
#define DQ_L514_ERR_PLL_NOT_LOCKED  (-1)        // PLL wasn't obtained

// For L514_SET_CFG <flags>

// For L514_SET_CFG <ch_cfg>
#define L514CFG_MASTER_TS           (1L<<8)     // add timestamp to the master data
#define L514CFG_OUTPUTS_TERMN       (1L<<7)     // enable termination on outputs
#define L514CFG_INPUTS_TERMN        (1L<<6)     // enable termination on inputs
#define L514CFG_SLAVE_DATA_EN       (1L<<5)     // enable line drive Tx
#define L514CFG_MASTER_CLK_EN       (1L<<4)     // enable line drive Rx
#define L514CFG_SLAVE_Tprm          (1L<<3)     // enable slave T parameters (0 = use defaults)
#define L514CFG_MASTER_Tprm         (1L<<2)     // program master T parameters (0 = use defaults)
#define L514CFG_SLAVE_EN            (1L<<1)     // enable slave for the channel
#define L514CFG_MASTER_EN           (1L<<0)     // enable master for the channel

// For L514_SET_CFG <clk_source>
#define L514CFG_CLK_BASE            (0L<<0)     // use system 66MHz clock and divide it
#define L514CFG_CLK_PLL             (1L<<0)     // use layer PLL as a clock source

// For L514_SET_CFG <m_trigger> and <s_trigger>
#define L514CFG_TRIG_IMM            (0L<<0)     // Start immediately after enable, transmit when the data is in the buffer
#define L514CFG_TRIG_GLOBAL         (1L<<0)     // wait for the global trigger to start

// Configuration structure
typedef struct {
    uint32 ch_cfg;                  // channel configuration
    uint32 flags;                   // tells what part of the following data is valid

    uint32 clk_source;              // clock source for master
    uint32 baud_rate;               // baud rate for master (100Hz..8MHz)

    // Master SSI setting (sends clocks, receives data)
    uint32 m_word_sz;               // master word size (2..32 bits)
    uint32 m_debounce;              // debouncing settings (0=bypass, 1..15 = 4..18 15ns clocks)
    uint32 m_trigger;               // Tx trigger source
    uint32 m_Tv;                    // Tv, master
    uint32 m_Tp;                    // Tp, master
    uint32 m_Tm;                    // Tm, master

    // Slave SSI setting (sends data upon receiving clocks)
    uint32 s_word_sz;               // master clock size
    uint32 s_debounce;              // debouncing settings
    uint32 s_trigger;               // Tx trigger source
    uint32 s_Tv;                    // Tv, master
    uint32 s_Tp;                    // Tp, master
    uint32 s_Tm;                    // Tm, master

} L514_CONFIG, *pL514_CONFIG;

// Status structure
typedef struct {
    uint32 ch_status;               // channel status
    uint32 flags;                   // additional flags
} L514_STATUS, *pL514_STATUS;

// Bits 31..16 are sticky and cleared after read
// Bits 15..0 are static, read return current value
#define SL514_GSTS_TXERR3           (1L<<31)    // =1 - corresponding Slave TX timing
#define SL514_GSTS_TXERR2           (1L<<30)    // error was detected (master clock arrived
#define SL514_GSTS_TXERR1           (1L<<29)    // too early)
#define SL514_GSTS_TXERR0           (1L<<28)    //
#define SL514_GSTS_RXERR3           (1L<<27)    // =1 - corresponding Master RX timing
#define SL514_GSTS_RXERR2           (1L<<26)    // error was detected (slave drives
#define SL514_GSTS_RXERR1           (1L<<25)    // RX data high during the monoflop time)
#define SL514_GSTS_RXERR0           (1L<<24)    //
#define SL514_GSTS_TXFE3            (1L<<23)    // =1 - corresponding Slave TX FIFO is
#define SL514_GSTS_TXFE2            (1L<<22)    // was empty
#define SL514_GSTS_TXFE1            (1L<<21)    //
#define SL514_GSTS_TXFE0            (1L<<20)    //
#define SL514_GSTS_RXFF3            (1L<<19)    // =1 - corresponding Master RX FIFO is
#define SL514_GSTS_RXFF2            (1L<<18)    // was full
#define SL514_GSTS_RXFF1            (1L<<17)    //
#define SL514_GSTS_RXFF0            (1L<<16)    //
#define SL514_GSTS_TXBSY3           (1L<<15)    // =1 - corresponding Slave channel is busy
#define SL514_GSTS_TXBSY2           (1L<<14)    // sending data
#define SL514_GSTS_TXBSY1           (1L<<13)    //
#define SL514_GSTS_TXBSY0           (1L<<12)    //
#define SL514_GSTS_RXBSY3           (1L<<11)    // =1 - corresponding Master channel is busy
#define SL514_GSTS_RXBSY2           (1L<<10)    // receiving data
#define SL514_GSTS_RXBSY1           (1L<<9)     //
#define SL514_GSTS_RXBSY0           (1L<<8)     //
#define SL514_GSTS_TXFHF3           (1L<<7)     // =1 - corresponding Slave TX FIFO is
#define SL514_GSTS_TXFHF2           (1L<<6)     // below watermark
#define SL514_GSTS_TXFHF1           (1L<<5)     //
#define SL514_GSTS_TXFHF0           (1L<<4)     //
#define SL514_GSTS_RXFHF3           (1L<<3)     // =1 - corresponding Master RX FIFO is
#define SL514_GSTS_RXFHF2           (1L<<2)     // above watermark
#define SL514_GSTS_RXFHF1           (1L<<1)     //
#define SL514_GSTS_RXFHF0           (1L<<0)     //
// Bits 31..16 are sticky and cleared after read
#define SL514_CSTS_TXERR            (1L<<19)    // =1 - Slave TX timing error was detected (master clock arrived too early)
#define SL514_CSTS_RXERR            (1L<<18)    // =1 - Master RX timing error was detected
                                                // (slave drives RX data high during the
                                                // monoflop time or slave drives RX data low
                                                // when first master clock falling edge should be
                                                // issued, in latter case Master SSI will wait for
                                                // slave to drive RX data high before issuing a
                                                // master clock)
#define SL514_CSTS_TXFE             (1L<<17)    // =1 - Slave TX FIFO was empty
#define SL514_CSTS_RXFF             (1L<<16)    // =1 - Master RX FIFO is was full
// Bits 15..0 are static, read return current value
#define SL514_CSTS_TXBSY            (1L<<3)     // =1 - Slave channel is busy sending data
#define SL514_CSTS_RXBSY            (1L<<2)     // =1 - Master channel is busy receiving data
#define SL514_CSTS_TXFHF            (1L<<1)     // =1 - Slave TX FIFO is below watermark
#define SL514_CSTS_RXFHF            (1L<<0)     // =1 - Master RX FIFO is above watermark
/* channel names */
typedef struct {
    char cname[DQ_L514_CHAN][DQ_L514_NAMELEN];
} DQCNAMES_514, *pDQCNAMES_514;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_L514_CALDACS];    /* four calibration DAQs */
} DQCALSET_514, *pDQCALSET_514;


/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    int val;                        // <reserved>
} DQOPMODEPRM_514, *pDQOPMODEPRM_514;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_514, *pDQINITPRM_514;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_514, *pDQSDOWNPRM_514;


#define DQ_L534_CHAN                (4)
#define DQ_L534_NAMELEN             (16)        // maximum length of the channel name (trailing 0 isn't included)

#define DQ_L534_INFOSZ              (DQ_MAX_INFO_SIZE)      // maximum size of information structure
#define DQ_L534_BASE                (66000000)  // 66MHz base frequency
#define DQ_L534_MAXCLFRQ            (1000000)
#define DQ_L534_MAXCVFRQ            (1000000)

#define DQ_L534_MAXBAUDRATE         (DQ_L534_MAXCLFRQ)
#define DQ_L534_MINBAUDRATE         (100000)

#define DQ_L534_FIFOSZ_RX           (4096)
#define DQ_L534_FIFOSZ_TX           (2048)

#define DQ_L534_CH_FIFOSZ_MRX       (1024)      // master Rx
#define DQ_L534_CH_FIFOSZ_SRX       (512)       // slave Rx
#define DQ_L534_CH_FIFOSZ_MTX       (1024)      // master Tx
#define DQ_L534_CH_FIFOSZ_STX       (512)       // slave Tx

#define DQ_L534_MAXWAIT             (20)        // max delay on the bus for read/write = 2us per read/write
#define DQ_L534_MAXCLSIZE           (65536)     // maximum amount of EC memory accessible by the EC host

#define DQ_L534_MAX_MSG_LEN         (255)       // maximum message length in bytes

#define DQL_L534_SYNCD              (DQL_LCR_SYNCD) // debug mode on
#define DQL_L534_LED                (1L<<1)     // switch LED on

#define EC534_PERIODIC_us           (100*1000)  // 10ms

#define DQ_L534_CALDACS             (4)         // dummy to maintain structure

#define DQ_L534_MAXPLLFRQ           (20000000.0)// maximum clock rate from PLL
#define DQ_L534_MINPLLFRQ           (300.0)     // minimum clock rate from PLL
#define DQ_L534_SNAP_FREQ           (24000000.0)// default PLL rate to program

// IOCTLs
#define DQL_IOCTL534_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL534_CFG            (0x1001)    // configure operations
#define DQL_IOCTL534_STATUS         (0x1002)    // get status
#define DQL_IOCTL534_ENABLE         (0x1003)    // enable channels
#define DQL_IOCTL534_MRDFRAME       (0x1004)    // read data frame (up to 4096 bytes)
#define DQL_IOCTL534_MWRFRAME       (0x1005)    // write data frame (up to 2048 bytes)
#define DQL_IOCTL534_SRDFRAME       (0x1006)    // read data frame (up to 512 bytes)
#define DQL_IOCTL534_SWRFRAME       (0x1007)    // write data frame (up to 1024 bytes)
#define DQL_IOCTL534_SETPLL         (0x1008)    // program PLL on 60x base
#define DQL_IOCTL534_BUSCON         (0x1009)    // bus control
#define DQL_IOCTL534_FLUSH          (0x100A)    // flush FIFOs

// Errors for L534_SET_CFG
#define DQ_L534_ERR_PLL_NOT_LOCKED  (-1)        // PLL wasn't obtained

#pragma pack(1)

// custom timing parameters
typedef struct {
    uint32 mctidle;     // time interval before IDLE is detected
    uint32 mctstart;    // SDA low to SCL low for START condition
    uint32 mctstop;     //SCL high to SDA high for STOP condition
    uint32 mctdbnc;     // debounce time
    uint32 mctsudat;    // T su;dat
    uint32 mcthigh;     // T high
} MCTPARAM, *pMCTPARAM;

// For L534_SET_CFG <flags>
typedef struct {    // all members must be of uint32 size
    uint32 flags;       // select active parameters to set/change
    uint32 clock;       // clock frequency, 100k, 400k and 1Mbit are supported; 0 = custom parameters
    float ttl_level;    // set line voltage (3.3V and 5.1V for now)
    uint32 tx_lines;    // enable termination and loopback
    MCTPARAM mctprm;    // custom timing parameters

    // Master configuration
    uint32 master_cfg;              // master configuration bitset
    uint32 master_idle_delay;       // delay in MM mode before acquiring bus in 15ns increments
    uint32 master_byte_delay;       // delay between bytes sent by master in 1us resolution
    uint32 master_max_sync_delay;   // maximum delay in uS slave could delay clock
    uint32 master_datasz_unfifo;    // <reserved>
    uint32 master_to_cfg;           // Maximum timeout delay in uS before releasing bus (0 == default)
    uint32 master_wait_bm_fifo_ms;  // Maximum wait for BM FIFO to receive all expected words, ms
    uint32 master_xdcp_device_type; // XDCP protocol device type - select upper 4 bits <reserved>

    // Slave configuration
    uint32 slave_cfg;               // slave configuration bitset
    uint32 slave_addr;              // select 7/10 slave address and 10-bit address mode
    uint32 slave_data;              // data to reply when slave Tx FIFO is empty
    uint32 slave_sync_dly;          // length of ACK in 15.15ns clocks (acknowledge cycle stretch)
    uint32 slave_ack_dly;           // 12-bit how long we wait for master ACK (in clocks)
    uint32 slave_max_ack;           // Slave RX max count register (# of words per /ACK)
    uint32 slave_tx_reg_size;       // in unFIFO mode the size of bytes to transmit to master, 1..4

} I2C534CFG, *pI2C534CFG;

// <flags> definitions for channel
#define DQ_L534CFG_CLOCK        (1L<<31)    // select clock, default is 400kHz
#define DQ_L534CFG_TTL_LEVEL    (1L<<30)    // voltage level - clock and level can be selected w/o reprogramming channel
#define DQ_L534CFG_MASTER_VALID (1L<<29)    // master configuration is valid
#define DQ_L534CFG_SLAVE_VALID  (1L<<28)    // slave configuration is valid
#define DQ_L534CFG_TERM_LOOP    (1L<<27)    // set termination and loopback
#define DQ_L534CFG_SDATA_ADDR   (1L<<26)    // set slave address and register-based data
#define DQ_L534CFG_CLEAR        (1L<<25)    // clear configurations stored from the previous calls

// clocks
#define DQ_L534CFG_CLOCK_CUST   0           // custom clock rate 2kHz..100kHz
#define DQ_L534CFG_CLOCK_100k   100000      // 100kbaud
#define DQ_L534CFG_CLOCK_400k   400000      // 400kbaud
#define DQ_L534CFG_CLOCK_1M     1000000     // 1Mbaud

// ttl level
#define DQ_L534CFG_TTL_LEVEL_3_3V ((float)3.3)
#define DQ_L534CFG_TTL_LEVEL_5V   ((float)5.0)

// for TX lines
#define DQ_L534CFG_RL_TERMIN    (1L<<0)     // enable termination relay (at the connector,
                                            // user may want to select its own termination depends on line capacitance
                                            // and baud rate
#define DQ_L534CFG_RL_LOOPBK    (1L<<1)     // enable loopback relay (at the connector)
#define DQ_L534CFG_FPGA_LOOPBK  (1L<<2)     // enable loopback on FPGA (internal to I2C core)

// for Master configuration
#define DQ_L534MCFG_SECURE_SHELL (1L<<31)   // enable secure shell operations
#define DQ_L534MCFG_MMASTER      (1L<<30)   // enable multi-master mode
#define DQ_L534MCFG_CLK_SYNC     (1L<<29)   // allow clock synchronization (stretching) by slave
#define DQ_L534MCFG_BYTE_DELAY   (1L<<28)   // enable byte to byte delay (extra delay after ACK)
#define DQ_L534MCFG_LONG_IDLE_DLY (1L<<26)  // allow to wait programmed time until taking over the bus in multi-master mode
#define DQ_L534MCFG_FIFO_EN      (1L<<25)   // use device-wide FIFO to write data to all channels (channel is selected in data
                                            // word, timestamp is available in this mode exclusively)
#define DQ_L534MCFG_CRC_CHECK    (1L<<24)   // force CRC check in non-DQ_L534MCFG_SECURE_SHELL configuration
#define DQ_L534MCFG_XDCP         (1L<<23)   // set XDCP device ID <reserved>
#define DQ_L534MCFG_RAWMODE      (1L<<22)   // select Master into raw mode operation


// for Slave configuration
#define DQ_L534SCFG_ENABLE_BM   (1L<<31)    // set slave into BM mode (done automatically in secure shell master mode)
#define DQ_L534SCFG_SCKSYN_AD   (1L<<30)    // =1 allows clock stretching during address ACK cycle (12-bit # of clocks in slave_sync_dly)
#define DQ_L534SCFG_SCKSYN_TX   (1L<<29)    // =1 allows clock stretching during data TX ACK cycle (12-bit # of clocks in slave_sync_dly)
#define DQ_L534SCFG_SCKSYN_RX   (1L<<28)    // =1 allows clock stretching during data RX ACK cycle (12-bit # of clocks in slave_sync_dly)
#define DQ_L534SCFG_ACKLEN      (1L<<27)    // =1 set 12-bit master ACK length (12-bit # of clocks in slave_ack_dly)
#define DQ_L534SCFG_ACK_BM      (1L<<26)    // allow acknowledge generation in BM mode
#define DQ_L534SCFG_10BIT       (1L<<25)    // slave address is 10 bit
#define DQ_L534SCFG_MAXACK      (1L<<24)    // enable <slave_max_ack> # of words per /ACK
#define DQ_L534SCFG_SLAVE_UNFIFO (1L<<23)   // do not use FIFO mode for slave
#define DQ_L534SCFG_FIFO_SRXDO  (1L<<22)    // suppress bus conditions in RX FIFO, preserve data only


typedef struct {    // all members must be of uint32 size
    uint32 hw_stat;     // HW status as reported by the hardware
    uint32 pin_stat;    // HW status with accumulated "sticky" bits
    uint32 drv_stat;    // status as reported by the driver
} I2C534STS, *pI2C534STS;


typedef struct {    // all members must be of uint32 size
    uint32 command;         // address and I2C command
    int data_size;          // number of data words to send for WRITE and WRRD command or data words to receive for READ command
    int wrrd_rx_size;       // number of bytes to read for WRRD command
    int fifo_sz;            // filled automatically - set to zero - number of data words to be written to the internal FIFO
    int transmitted;        // number of bytes accepted in the FIFO (I2C is a byte-oriented protocol)
    int available;          // number of bytes still available to write in the transmission FIFO
    int crc_stat;           // status flags of operation
    char* data8;            // pointer to the data words to send (or retrieved data on RX command)
} I2C534_CMD, *pI2C534_CMD;

#pragma pack()

// For DQL_IOCTL534_STATUS
#define DQL_IOCTL534_STATUS_CLR         (1L<<30)    // clear "sticky" status bits

// For DQL_IOCTL534_WRFRAME
#define DQL_IOCTL534_WRFRAME_CRC        (0x3A)   // Write master command (and data) with CRC envelope
#define DQL_IOCTL534_WR_NFRAME_CRC      (0x79)   // Write multiple frames with CRC envelope
#define DQL_IOCTL534_WRFRAME_DIRECT     (0xB6)   // Write master command (and data) directly into CLOWR
#define DQL_IOCTL534_WRFRAME_FIFO       (0x75)   // Write master command into TX FDR
#define DQL_IOCTL534_WRFRAME_CLO        (0x69)   // Write master command into CLO (allows setting delay between channels)

#define DQL_IOCTL534_RDFRAME_CRC        (0x4c)   // Read master data for RX in CRC envelope
#define DQL_IOCTL534_RDFRAME_BM_CRC     (0xca)   // Read BM data (master should be in DQ_L534MCFG_SECURE_SHELL mode)
#define DQL_IOCTL534_RDFRAME_FIFO       (0xad)   // Read data from master or slave RX FDR
#define DQL_IOCTL534_RDFRAME_CLO        (0xb9)   // Read master command from CLI

// For #define DQL_IOCTL534_WRFRAME_CRC
// Define I2C master command on the bus
#define DQ_L534_CMD_A_BIT         (L534_I2C_CMD_A_BIT<<20)   // Address mode bit: 0 == 7-bit/1 == 10-bit
#define DQ_L534_CMD_N_BIT         (L534_I2C_CMD_N_BIT<<20)   // Address ignore NACK bit. 1 == ignore /ACK (I2C violation)
#define DQ_L534_CMD_P_BIT         (L534_I2C_CMD_P_BIT<<20)   // NO-STOP (do not issue STOP); next valid command with START must follow; ignored for I2C_CMD_STP command
#define DQ_L534_CMD_B_BIT_MASK    (DQ_L534_CMD_A_BIT|DQ_L534_CMD_N_BIT|DQ_L534_CMD_P_BIT)

#define DQ_L534_CMD_TDELAY        (1<<28)     // Insert NOP command for delay sequence
#define DQ_L534_CMD_STOP          (2<<28)     // STOP - issue a stop condition once bus is available
#define DQ_L534_CMD_ST_WRITE      (3<<28)     // START+WRITE (including write multiple)
#define DQ_L534_CMD_ST_READ       (4<<28)     // START+READ (including read multiple)
#define DQ_L534_CMD_ST_WRRD       (5<<28)     // START+WRITE+RESTART+READ (including read multiple)
// Note: For the next two command, there is always one byte written after the first address byte
#define DQ_L534_CMD_XDCP_READ     (6<<28)     // START+WRITE+READ (for Renesas XDCP protocol - ex. X9119)
#define DQ_L534_CMD_XDCP_WRITE    (7<<28)     // START+WRITE+WRITE (for Renesas XDCP protocol - ex. X9259)

#define DQ_L534_CMD_MASK          (0xf<<28)   // Mask to isolate command from the rest of the command word

// bits [24..22]: command and  -A, N and P bits
// bits [ 9.. 0]: address (DQ_L534_CMD_ADDR10(N))
// This translates directly into CLOWR command words
#define DQ_L534_CMD_MASK_USR      (0x01c003ff)

// bits [24..22]: command and  -A, N and P bits
// bits [19..16]: the 4-bit XDCP identifier (bits 7..4 of the first byte to slave)
// bits [11.. 8]: the lower nibble of first byte from master to slave (XDCP adress)
// bits [ 7.. 0]: the second byte from master to slave occupies (XDCP control byte) L534_XDCP_CLO_BYTE2
#define DQ_L534_CMD_MASK_XDCP     (0x01cf0fff)

#define DQ_L534_CMD_XDCP_RD(B2,B1)  (DQ_L534_CMD_ST_READ|
#define DQ_L534_CMD_XDCP_WR(N)

// Define I2C address on the bus (master->slave)
#define DQ_L534_CMD_ADDR7(N)     (((N)&0x7f))                       // 7 bit address
#define DQ_L534_CMD_ADDR10(N)    (((N)&0x3ff)|DQ_L534_CMD_A_BIT)    // 10 bit address

// Flags for DQL_IOCTL534_WRFRAME_CRC
#define DQ_L534_MSENDCRC_WAIT_FOR_BM      (1L<<1) // wait until bus monitor receives full transmission
#define DQ_L534_MSENDCRC_DOUBLECHECK_CRC  (1L<<2) // double-check CRC
#define DQ_L534_MSENDCRC_WAIT_FOR_RX      (1L<<3) // with RX command wait for slave to transmit data
#define DQ_L534_MSENDCRC_IGNORE_CRC       (1L<<4) // do not calculate CRC

// For DQL_IOCTL534_FLUSH
#define DQL_IOCTL534_FLUSH_SRX      (1L<<31)    // =1 - Flush slave RX FIFO
#define DQL_IOCTL534_FLUSH_STX      (1L<<30)    // =1 - Flush slave TX FIFO
#define DQL_IOCTL534_FLUSH_MRX      (1L<<29)    // =1 - Flush master RX FIFO
#define DQL_IOCTL534_FLUSH_MTX      (1L<<28)    // =1 - Flush master TX FIFO
#define DQL_IOCTL534_FLUSH_MRST     (1L<<27)    // Reset master module
#define DQL_IOCTL534_FLUSH_SRST     (1L<<26)    // Reset slave module

#define DQL_IOCTL534_FLUSH_ALL      (0xFC000000)

#define L534_MAX_WAIT_TO_CLOWR_mS  50           // default max wait to receive all bytes in BM FIFO in secure shell mode

// For DQL_IOCTL534_BUSCON
#define DQL_IOCTL534_BUSCON_DCDC      (1L<<31)    // on/off/voltage for DC/DC
#define DQL_IOCTL534_BUSCON_LBENTERM  (1L<<30)    // control LBEN and termination

// For DQL_IOCTL534_BUSCON_LBENTERM
#define DQ_L534_BUSCON_LBEN            (1L<<9)     // enable select local loopback (relay)
#define DQ_L534_BUSCON_TERMEN          (1L<<8)     // enable additional 1.5kOhm pull-up (relay in parallel with 1.5k fixed pull-up)

// Event data for I2C-534 layer
typedef struct {
    uint32 port;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 avail;                   // amount of data still available
    uint32 size;                    // size of the following data in bytes
    uint8 data[DQ_FLEX_ARRAY];      // data to follow, data depends on event type
} EV534_ID, *pEV534_ID;

//
// Event                Data[0]         Data[1]         Event content
// EV534_CLEAR          -
// EV534_PERIODIC       t/o divider                     amount of data in each port master and slave Rx and Tx FIFO, and status. <data> is uint32
//                                                      [0]=master Tx, [1]=master Rx, [2]=slave Tx, [3]=slave Rx, [4]=hw_stat, [5]=pin_stat, [6]=drv_stat
//
// EV534_S_IN_FIFO      Rx wm size      Rx max size     Rx FIFO data upon reaching watermark, up to Rx max size. <data> is uint16
// EV534_S_OUT_FIFO     Tx wm size                      number of bytes remaining in Tx FIFO stored in <avail>
// EV534_M_IN_FIFO      Rx wm size      Rx max size     Rx FIFO data upon reaching watermark, up to Rx max size. <data> is uint16
// EV534_M_OUT_FIFO     Tx wm size                      number of bytes remaining in Tx FIFO stored in <avail>
//
// EV534_S_DATA_SENT    -
// EV534_S_DATA_READY   -                               Rx data upon receiving data. <data> is uint16
//                                                      note this requires SLAVE_UNFIFO mode or DQ_L534SCFG_MAXACK to be set
//
// EV534_M_DRDY         -                               number of bytes remaining in Rx FIFO stored in <avail>
//
// EV534_ARBLOST_ERR    -
// EV534_ACK_ERR        -
typedef enum {
    EV534_CLEAR = 0x1000,      // clear all events

    EV534_PERIODIC = 0x101,    // periodic event, returns status and number of sample in RX/TX FIFOs
                               // this is enabled per channel, but all channels will use the same divider

    // Tx or Rx events
    EV534_S_IN_FIFO,           // input slave RX FIFO watermark reached or full <returns # bytes and data for up to selected size in event parameters>
    EV534_S_OUT_FIFO,          // output slave FIFO underrun or half-empty <returns # bytes>
    EV534_M_IN_FIFO,           // input master RX FIFO watermark reached or full <returns # bytes and data for up to selected size in event parameters>
    EV534_M_OUT_FIFO,          // output master underrun or half-empty <returns # bytes>
    EV534_S_DATA_SENT,         // inform user of data been sent <returns # sent and # bytes in the FIFO>
    EV534_S_DATA_READY,        // must use DQ_L534SCFG_SLAVE_UNFIFO or DQ_L534SCFG_MAXACK in slave_cfg
                               // inform user of data received <returns # bytes in the FIFO and data for up to selected size in event parameters >
    //EV534_S_DRDY,              // data word received slave
    EV534_M_DRDY,              // data word received master

    // Errors
    EV534_ARBLOST_ERR,         // arbitration lost error
    EV534_ACK_ERR              // acknowledge error
} event534_t;

#define DqAdv534ConfigEvents_PARAMSZ (2)        // maximum number of uint32 parameters after pEV534_ID


// Bit enabling DC/DC on per-channel basis
#define DQ_L534_CFGDCDC_EN3 (1L<<6)
#define DQ_L534_CFGDCDC_EN2 (1L<<4)
#define DQ_L534_CFGDCDC_EN1 (1L<<2)
#define DQ_L534_CFGDCDC_EN0 (1L<<0)


#define L534_I2C_CRC_WIDTH          16         // Number of bits in CRC polynomial
#define L534_I2C_CRC_DATA_WIDTH     8          // Number of bits in CRC data
#define L534_I2C_CRC16_INIT         0xFFFF     // Initial value for the CRC-16 calculator -  THIS NEEDS CHANGING
#define L534_I2C_M_BUF_AWIDTH       7          // # of address witdth for master data storage

// IER/IMR/ISR/ICR
#define IR_CH3IRQ               (1L<<3)    // I2C channel 3 IRQ
#define IR_CH2IRQ               (1L<<2)    // I2C channel 2 IRQ
#define IR_CH1IRQ               (1L<<1)    // I2C channel 1 IRQ
#define IR_CH0IRQ               (1L<<0)    // I2C channel 0 IRQ

// Input channel list data format
#define L534_I2C_CLI_CH_NUM(N)   ((N)<<28)      // Channel# 0..3 (4..15 reserved)
#define L534_I2C_CLI_TIMESTAMP   (1L<<27)       // 1 - bits 23..0 contain timestamp
#define L534_I2C_CLI_STOP        (1L<<26)       // STOP received; end of data
#define L534_I2C_CLI_RESTART     (1L<<25)       // RESTART received; end of data
#define L534_I2C_CLI_START       (1L<<24)       // START received
#define L534_I2C_CLI_DW1(N)      (((N)&0xfff)<<12)    // Data word 0 from I2C slave - see I2C_BM_xx_xx for the description
#define L534_I2C_CLI_DW0(N)      ((N)&0xfff)    // Data word 0 from I2C slave - see I2C_BM_xx_xx for the description
#define L534_I2C_CLI_TS(N)       ((N)&0xffffff) // Timestamp datar_clo_ready

// Output channel list data format
#define L534_I2C_CLO_CH_NUM(N)   ((N)<<28)    // Channel# 0..3 (4..15 reserved)
#define L534_I2C_CLO_FLAGS(N)    (((N)&7)<<25)  // Flags - define how to decode bits 24..0 000 - TX data; 010 - Master command; 011 - XDCP; 100 - CRC; 110 Time delay

// Master command format (I2C_CLO_FLAGSI2C_CLO_FLAGS_MCMD)
#define L534_I2C_CLO_CMD_M(N)    (((N)&0x1f)<<20)    // Master Command; see I2C_CMD_xx bits
#define L534_I2C_CLO_CNT_M(N)    (((N)&0xff)<<12)    // Byte count 0..255 corresponds to 1..256 bytes to read/write from/to I2C slave
#define L534_I2C_CLO_ADDR_M(N)   ((N)&0x7f)          // I2C slave address 7/10 bit

// Master TX data format (I2C_CLO_FLAGSI2C_CLO_FLAGS_TXD)
#define L534_I2C_CLO_DW2_LSB(N)     (((N)&0xff)<<16)  // TX data words 2/1/0 8-bit I2C Master TX data; unused data words should
#define L534_I2C_CLO_DW1_LSB(N)     (((N)&0xff)<<8)   // TX data words 2/1/0 8-bit I2C Master TX data; unused data words should
#define L534_I2C_CLO_DW0_LSB(N)     (((N)&0xff)<<0)   // TX data words 2/1/0 8-bit I2C Master TX data; unused data words should

// Master CRC format (I2C_CLO_FLAGSI2C_CLO_FLAGS_CRC)
#define L534_I2C_CLO_CRC(N)      ((N)&0xffff)    // CRC data to

// Master time delay format(I2C_CLO_FLAGSI2C_CLO_FLAGS_TDLY)
// Bits 24..16 are reserved
#define L534_I2C_CLO_TDLY(N)     ((N)&0xffff)     // Time delay in uS

// Master command format for XDCP (I2C_CLO_FLAGSI2C_CLO_FLAGS_MCMD)
#define L534_XDCP_CLO_CMD_M(N) (((N)&0x1f)<<20) // Master Command, only (I2C_CMD_A_BIT | I2C_CMD_RD) is valid, N and P bits can be used
#define L534_XDCP_CLO_ID_M(N)  (((N)&0xf)<<16)  // 4-bit identifier (bits 7..4 of the first byte to slave)
#define L534_XDCP_CLO_CNT_M(N)  (((N)&0xf)<<12) // Byte count 0..15 corresponds to 1..16 bytes to read/write from/to X-digipot slave
#define L534_XDCP_CLO_BYTE2(N)  ((N)&0xff)      // Bits 7..0 of the XDCP second byte from master to the slave
#define L534_XDCP_CLO_BYTE1(N)  (((N)&0xf)<<8)  // Bits 3..1 of the first byte from master to slave and bits,
                                                // Format: {byte1[3],byte1[2],byte1[1],use L534_XDCP_CLO_BYTE1_RD ,byte2[7..0]}
#define L534_XDCP_CLO_BYTE1_RD  (1L<<8)         // Read bit (byte1[0])


// I2C command flags
#define L534_I2C_CLO_FLAGS_TXD   0   // Flags - TX data
#define I2C_CLO_FLAGS_MDRD       1   // Flags - delayed master read command
#define L534_I2C_CLO_FLAGS_MCMD  2   // Flags - Master command
#define L534_I2C_CLO_FLAGS_XDCP  3   // Flags - Master XDCP read command
#define L534_I2C_CLO_FLAGS_CRC   4   // Flags - CRC
#define L534_I2C_CLO_FLAGS_TDLY  6   // Flags - Time delay

#define L534_I2C_VALID_ACK       0              // Acknowledge is 0 on I2C
#define L534_I2C_NO_ACK          1              // NACK I2C

#define L534_I2C_CMD_X_BIT       (1L<<5)   // X - Renesas XDCP mode (non-I2C, 10-bit addr + RD should be selected)
#define L534_I2C_CMD_WIDTH       6         // Number of bits in I2C command to the Master module

// Three command behavior bits (translate to bits [24..22] in CLOWR
#define L534_I2C_CMD_A_BIT       (1L<<4)     // Address mode bit. 0 = 7-bit/1 = 10-bit
#define L534_I2C_CMD_N_BIT       (1L<<3)     // Address ignore NACK bit. ignore /ACK (I2C vioaltion)
#define L534_I2C_CMD_P_BIT       (1L<<2)     // NO-STOP (do not issue STOP); next valid command with
                                             // START must follow; ignored for I2C_CMD_STP command
// Commands (bits [21..20] in CLOWR)
#define L534_I2C_CMD_NOP         (0<<0)      // NOP - ignore command
#define L534_I2C_CMD_STP         (1<<0)      // STOP - issue a stop condition once bus is available
#define L534_I2C_CMD_WR          (2<<0)      // START + WRITE (including write multiple)
#define L534_I2C_CMD_RD          (3<<0)      // START + READ (including read multiple)

#define L534_I2C_CMD_ONLY_MASK   (3)    // Command mask - remove upper bits

#define L534_I2C_10BIT_CODE      0x1e   // First 5 bits of first byte of the 10-bit address
#define L534_I2C_ADDR_BYTE1      0      // First address byte (only in 7-bit mode)
#define L534_I2C_ADDR_BYTE2      1      // Second address byte in 10-bit mode
#define L534_I2C_ADDR_BYTE3      2      // Third address byte in 10-bit RD mode
#define L534_I2C_DATA_STOP       8        // 8 bits for data plus "STOP" bit
#define L534_I2C_DATA_(N)     ((N)&0xff)    // LSB

// Slave FIFO data format - 16-bit values represent all bus conditions
// reported by the slave bus monitor
#define L534_I2C_BM_CODE(N)     (((N)&0xf)<<8)        // 4-bit code; represent I2C bus condition
#define L534_I2C_BM_DATA(N)     ((N)&0xff)   // 8-bit address/data  (10-bit address will have 2/3 entries)

// bits [11:8] in BM and slave RX FIFO data) data and bus conditions
#define L534_I2C_BM_CODE_START   1     // 1 - START
#define L534_I2C_BM_CODE_RESTART 2     // 2 - ReSTART
#define L534_I2C_BM_CODE_STOP    3     // 3 - STOP
#define L534_I2C_BM_CODE_AACK    4     // 4 - Address + ACK
#define L534_I2C_BM_CODE_ANACK   5     // 5 - Address + /ACK
#define L534_I2C_BM_CODE_DACK    6     // 6 - Data + ACK
#define L534_I2C_BM_CODE_DNACK   7     // 7 - Data + /ACK
#define L534_I2C_BM_CODE_DDONE   8     // 8 - All data received + /ACK
#define L534_I2C_BM_CODE_SCERR   9     // 9 - Clock stretching error

 // I2C speed selector values
#define L534_I2C_SPEED_100K      0    // Speed code for 100KHz timing
#define L534_I2C_SPEED_400K      1    // Speed code for 400KHz timing
#define L534_I2C_SPEED_1M        2    // Speed code for 1MHz timing

// Report status of the I2C master and slave module. "Sticky" bits are cleared
// after each read.
// Sticky bits 31..16
#define SL534_CH_STS_ACKERR  (1L<<30)   // =1 - master ack error has occurred
#define SL534_CH_STS_PIERR   (1L<<29)   // =1 - PHY idle wait timeout error
#define SL534_CH_STS_PTOERR  (1L<<28)   // =1 - PHY command wait while bus is active timeout error

#define SL534_CH_STS_CSERR   (1L<<27)   // =1 - slave clock syncronization error
#define SL534_CH_STS_MDONE   (1L<<26)   // =1 - master completes execution of the last command
#define SL534_CH_STS_MSCH    (1L<<25)   // =1 - master command or data sequence received
#define SL534_CH_STS_MCRCERR (1L<<24)   // =1 - error in CLO-->master CRC) data/command ignored

#define SL534_CH_STS_MCLOERR (1L<<23)   // =1 - error in CLO-->master sequence
#define SL534_CH_STS_MMERR   (1L<<22)   // =1 - multi-master arbitration was lost
#define SL534_CH_STS_STXDONE (1L<<21)   // =1 - slave TX data sent (non-continuous mode)
#define SL534_CH_STS_SRXDTR  (1L<<20)   // =1 - slave RX data ready (non-continuous mode)

#define SL534_CH_STS_SRXFFS  (1L<<19)   // =1 - slave RX FIFO was full
#define SL534_CH_STS_STXFES  (1L<<18)   // =1 - slave TX FIFO was empty
#define SL534_CH_STS_RXFFS   (1L<<17)   // =1 - master RX FIFO was full
#define SL534_CH_STS_TXFES   (1L<<16)   // =1 - master TX FIFO was empty

    // Static bits 15..0
#define SL534_CH_STS_BBSY    (1L<<15)   // =1 when bus is busy
#define SL534_CH_STS_CSWAIT  (1L<<14)   // =1 indicates that master waits for the slave to release SCL
#define SL534_CH_STS_MCLORDY (1L<<13)   // =1 when channel can accept writes to SL534_CH_CLOWR
#define SL534_CH_STS_MWAIT   (1L<<12)   // =1 - master waiting for command/data release (write to the SL534_CH_RBGO)

#define SL534_CH_STS_CLOMWT  (1L<<11)   // =1 when output channel list SM waits for the master to become available
#define SL534_CH_STS_SRXFHF  (1L<<10)   // =1 - slave RX FIFO is above watermark
#define SL534_CH_STS_SRXFF   (1L<<9)    // =1 - slave RX FIFO is full
#define SL534_CH_STS_STXFHF  (1L<<8)    // =1 - slave TX FIFO is below watermark

#define SL534_CH_STS_STXFE   (1L<<7)    // =1 - slave TX FIFO is empty
#define SL534_CH_STS_SBSY    (1L<<6)    // =1 when slave state machine is busy
#define SL534_CH_STS_EMAS    (1L<<5)    // =1 when external master owns the bus
#define SL534_CH_STS_MBSY    (1L<<4)    // =1 when master state machine is busy

#define SL534_CH_STS_RXFHF   (1L<<3)    // =1 - master RX FIFO is above watermark
#define SL534_CH_STS_RXFF    (1L<<2)    // =1 - master RX FIFO is full
#define SL534_CH_STS_TXFHF   (1L<<1)    // =1 - master TX FIFO is below watermark
#define SL534_CH_STS_TXFE    (1L<<0)    // =1 - master TX FIFO is empty


//            SL534_CH_STS2   = 16'h08,    // R    Channel status register 2
// Additional status bits. "Sticky" bits are cleared after each read.
//            SL534_CH_STS2_M = 16'h28,    // R    Channel mirror status 2 register - read will not clear sticky bits
// Sticky bits 31..16
#define SL534_CH_STS2_MRXFFS (1L<<16)   // =1 - master RX FIFO was full
// Static bits 15..0
#define SL534_CH_STS2_MRXFHF (1L<<1)    // =1 - master RX FIFO is above watermark
#define SL534_CH_STS2_MRXFF  (1L<<0)    // =1 - master RX FIFO is full


//#define SL534_CH_SADDR = 0x08,    // W    Slave address register
// Slave address register and 7/10 bit mode selector. Default address is 7-bit 0x40
#define SL534_CH_SADDR_10B  (1L<<10)       // Set to 1 for 10-bit mode
#define SL534_CH_SADDR_(N)   ((N)&0x3ff)    //

//#define SL534_CH_I2CSTS= 0x0C,    // R    Status of each I2C pin register
// Return current status of the I2C pins, unlatched
#define SL534_CH_I2CSTS_SDAM (1L<<3)    // Master SDA current value
#define SL534_CH_I2CSTS_SCLM (1L<<2)    // Master SCL current value
#define SL534_CH_I2CSTS_SDAS (1L<<1)    // Slave SDA current value
#define SL534_CH_I2CSTS_SCLS (1L<<0)    // Slave SCL current value

// Master FIFO Raw Command Format
// Notice that in majority of these macros parameter B is not used and needs to be set to zero
// This is done for the future expansion of the functionality in I2C RAW mode
//
#define I2C_MRAW_2NUS_WIDTH  5        // Number of bits for 2^n delay command (5 = (1<<31)  max delay)

#define I2C_MRAW_PHY_TX1(B)      ((1<<8)|((B)&0xff))   // PHY: Set SDA to 1 for one clock (use B = 0)
#define I2C_MRAW_PHY_TX0(B)      ((2<<8)|((B)&0xff))   // PHY: Set SDA to 0 for one clock (use B = 0)
#define I2C_MRAW_PHY_RX(B)       ((3<<8)|((B)&0xff))   // PHY: Set SDA to 1 for one clock, return SDA at the falling edge of the clock (use B = 0)
#define I2C_MRAW_PHY_START(B)    ((4<<8)|((B)&0xff))   // PHY: START condition on the bus (use B = 0)
#define I2C_MRAW_PHY_STOP(B)     ((5<<8)|((B)&0xff))   // PHY: STOP condition on the bus (use B = 0)
#define I2C_MRAW_PHY_RELEASE(B)  ((6<<8)|((B)&0xff))   // PHY: Release bus without creating START or STOP conditions (use B = 0)
#define I2C_MRAW_DLY_2NUS(B)     ((7<<8)|((B)&0xff))   // MASTER: Delay execution for 2^n uS (n is in 5 LSBs, B = 0..31)
#define I2C_MRAW_DLY_NX8US(B)    ((8<<8)|((B)&0xff))   // MASTER: Delay execution for n*8uS (n is in 8 LSBs, B = 0..255)
#define I2C_MRAW_BYTE_SEND(B)    ((9<<8)|((B)&0xff))   // MASTER: Transmit data to the I2C bus (ddd is in 8 LSBs B = 0..255)
#define I2C_MRAW_BYTE_RECEIVE(B) ((10<<8)|((B)&0xff))  // MASTER: Read byte of data from the I2C bus and save to the RX FIFO (B = 0)
#define I2C_MRAW_ACK_WAIT(B)     ((11<<8)|((B)&0xff))  // MASTER: Wait for the ACK, NACK ends sequence (B = 0)
#define I2C_MRAW_SEQ_END(B)      ((0<<8)|((B)&0xff))   // MASTER: Last command in the sequence, write starts execution (B = 0)

#define SL534_MIN_Tsudat_ns     4700
#define SL534_MIN_Tidle_ns      4700
#define SL534_MIN_Tstop_ns      4000
#define SL534_MIN_Tstart_ns     4700
#define SL534_BITtime_100k_ns  10000
#define SL534_MIN_DataSetUp_ns   250
#define SL534_MIN_ThighD_ns     3800
#define SL534_MIN_Thddat_ns     5000

#define SL534_CLOCK_PERIOD_INT  15
#define SL534_SIM_DB_COUNT      100/SL534_CLOCK_PERIOD_INT

//#define SL534_CH_MCTIDLE    0xA0    // W    Custom Timing Mode master bus idle time interval register
                                         // SL534_CH_MCT_D_MSB..SL534_CH_MCT_D_LSB - tBUF, bus IDLE timeout
#define SL534_CH_MCT_D_(N) ((N)&0xffff)  // 16-bit timing parameter, in 66MHz clocks


//#define SL534_CH_MCTSTRT    0xA4    // W    Custom Timing Mode master START hold delay register
                                    // SL534_CH_MCT_D_MSB..SL534_CH_MCT_D_LSB - tHD,STA START hold delay

//#define SL534_CH_MCTSTOP    0xA8    // W    Custom Timing Mode master STOP hold delay register
                                    // SL534_CH_MCT_D_MSB..SL534_CH_MCT_D_LSB - tHD,STO, STOP hold delay

//#define SL534_CH_MCTMISC    0xAC    // W    Custom Timing Mode master bit time/glitch settings
#define SL534_CH_MCTMISC_G_(N)   (((N)&0xff)<<24)  // 8-bit glitch removing debouncer (in 66MHz)
                                                   // tDEBOUNCE = MCTMISC_G * 15.15nS, MCTMISC_G>=4
                                                   // Bits 23..16 are reserved, write with 0s
                                                   // SL534_CH_MCT_D_MSB..SL534_CH_MCT_D_LSB - bit time, 1/fSCL

//#define SL534_CH_MCTDATA    0xB0    // W    Custom Timing Mode master data timing register
#define SL534_CH_MCTDATA_TH_(N) (((N)&0xffff)<<16)  // tHD,DAT, data hold time
                                                    // SL534_CH_MCT_D_MSB..SL534_CH_MCT_D_LSB - tSU,DAT, data setup time

//#define SL534_CH_MCTCLK     0xB4    // W    Custom Timing Mode master clock timing register
#define SL534_CH_MCTCLK_TRMSB(N)      (((N)&0xffff)<<16)  // clock/data rise (Tr) time
                                                        // SL534_CH_MCT_D_MSB..SL534_CH_MCT_D_LSB - tHIGH, clock high time interval
/* channel names */
typedef struct {
    char cname[DQ_L534_CHAN][DQ_L534_NAMELEN];
} DQCNAMES_534, *pDQCNAMES_534;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_L534_CALDACS];    /* four calibration DAQs */
} DQCALSET_534, *pDQCALSET_534;


/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    int val;                        // <reserved>
} DQOPMODEPRM_534, *pDQOPMODEPRM_534;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_534, *pDQINITPRM_534;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_534, *pDQSDOWNPRM_534;



#define DQ_L550_CHAN                (1)
#define DQ_L550_INFOSZ              DQ_MAX_INFO_SIZE    // maximum size of information structure
#define DQ_L550_BASE                (66000000)  // 66MHz base frequency

// ioctls
#define DQIOCTL_SET550CFG           (0x08)      // enable and set configuration of wireless card
#define DQ_CAR550_WIRELESS_EN_DIS   (0)         // sub-command for DQIOCTL_SET550CFG, disable/enable card
#define DQ_CAR550_WIRELESS_RESET    (1)         //     "                            , reset/un-reset card


#define DQ_L550_NAMELEN             (32)        // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_L550_CHAN][DQ_L550_NAMELEN];
} DQCNAMES_550_, *pDQCNAMES_550_;

typedef struct {
    uint32 mask;                    // change-of-state mask
} DQOPMODEPRM_550_, *pDQOPMODEPRM_550_;

typedef struct {
    uint32 val;                     // wireless power state at powerup
} DQINITPRM_550_, *pDQINITPRM_550_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_550_, *pDQSDOWNPRM_550_;

#define DQ_L553_CHAN                (2)         // 2 I/O chips
#define DQ_L553_CHANMASK            (0x01)      //
#define DQ_L553_CHAN_TX             (2)         // 2 transmitters maximum
#define DQ_L553_CHAN_RX             (2)         // 2 receviers maximum
#define DQ_L553_INFOSZ              (DQ_MAX_INFO_SIZE)      // maximum size of information structure
#define DQ_L553_BASE                (66000000)  // 66MHz base frequency
#define DQ_L553_BC_BASE             (1000000.0) // bus controller base clock
#define DQ_L553_MAXCLFRQ            (2000)
#define DQ_L553_MAXCVFRQ            (2000)

#define DQ_L553_TERMADDR            (32)        // number of terminals per channel
#define DQ_L553_SUBADDR             (32)        // number of subaddresses per channel

#define DQ_L553_MAX_MSG             (64)        // command + delays + data + status

#define DQ_L553_MAX_WORDS           (32)        // maximum number of words in 1553 message
#define DQ_L553_MAXBM_WORDS         (DQ_L553_MAX_WORDS+4)   // maximum number of uint32 words in 1553 message
#define DQ_L553_MAXRT_WORDS         (DQ_L553_MAX_WORDS+7)   // maximum number of uint16 words in RT Rx data


#define DQ_L553_BROADADDR           (0x1f)      // broadcast address
#define DQ_L553_MODEADDR            (0)         // address for mode command

#define DQ_L553_INTCLKUS            (100)       // Internal clock in uS for the scheduler
#define DQ_L553_MAXDLYCNT           (65535)     // Maximum value for the delay counter

#define DQL_LCR553_LED              (1L<<1)     // switch LED on
#define DQL_LCR533_SYNCD            (1L<<3)     // =1 - switch SYNC bus to debug mode (driven via SL_553_SYNCSEL/SL553_PORT_DBGSEL)

#define DQL_L553_MJ_SIZE            (256)       // number of descriptors in the major frame
#define DQL_L553_MN_SIZE            (128)       // number of descriptors in the major frame

// special channels
#define DQ_L553_CH_MASK             (0x0f)     // regular channel mask
#define DQ_L553_CH_CMDMASK          (0xf0)     // special channel mask

// FIFO sizes
#define DQ_L553_TXFIFOSIZE          (256)       // Tx FIFO size (in uint32s)
#define DQ_L553_RXFIFOSIZE          (1024)      // Rx FIFO size (in uint32s)
#define DQ_L553_LBLFILTSIZE         (256)       // Size of label filter
#define DQ_L553_SCHEDSIZE           (256)       // Size of scheduler table
#define DQ_L553_SCHEDDATASZ         (256)       // Size of scheduler data table
#define DQ_L553_MD_FIFOSZ           (19)        // Depth of the mode command FIFO
#define DQ_L553_A708_FIFO           (2048)      // FIFO size for ARINC-708 version (option -708)
#define DQ_L553_A708_TSTAMP_SZ      (2)         // 2*uint16s - timestamp size
#define DQ_L553_BM_MAXMSG           (255)       // maximum number of messages in one packet

// Limits of channel filter programming
#define DQ_L553_RTLISTSZ            (360)       // max number of RT entries
#define DQ_L553_A708_FRMSZ          (100)       // standard 1600 (100 16-bit words) frame size
#define DQ_L553_AWXPD_FRMSZ         (125)       // standard 2000 (125 16-bit words) frame size

#define DQ_L533_WXPD_ENABLE_PARTFRAMES    (1L<<31)    // used in reading WXPD FIFO, allow to receive exact requested regardless of TX frame size

// ioctls
#define DQL_IOCTL553_SETMODE        (0x01L)     // sets mode of operation
#define DQL_IOCTL553_SETTXWM        (0x02L)     // sets the TX watermark
#define DQL_IOCTL553_SETRXWM        (0x03L)     // sets the RX watermark
#define DQL_IOCTL553_SETTIMEOUT     (0x04L)     // set the RX timeout (hardware)
#define DQL_IOCTL553_READ_FIFO      (0x05L)     // read a channel FIFO
#define DQL_IOCTL553_WRITE_FIFO     (0x06L)     // write a channel FIFO
#define DQL_IOCTL553_TRIGGER        (0x07L)     // set trigger conditions
#define DQL_IOCTL553_CONTROL        (0x08L)     // control 1553 parameters without restarting
#define DQL_IOCTL553_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL553_BIT            (0x0BL)     // perform built-in test
#define DQL_IOCTL553_RESERVED       (0x0CL)     // reserved
#define DQL_IOCTL553_FILTER         (0x0DL)     // set filter
#define DQL_IOCTL553_SETCLK         (0x0EL)     // set timebase control
#define DQL_IOCTL553_STATUS         (0x0FL)     // get interface status
#define DQL_IOCTL553_BM_CFG         (0x1002L)   // set BM configuration
#define DQL_IOCTL553_RT_CFG         (0x1003L)   // set RT configuration
#define DQL_IOCTL553_BC_CFG         (0x1004L)   // set BC configuration
#define DQL_IOCTL553_READ_RT        (0x1005L)   // read from RT terminal
#define DQL_IOCTL553_WRITE_RT       (0x1006L)   // write to RT terminal
#define DQL_IOCTL553_READ_RAM       (0x1007L)   // read from RT terminal
#define DQL_IOCTL553_WRITE_RAM      (0x1008L)   // write to RT terminal
#define DQL_IOCTL553_WRITE_MD       (0x1009L)   // write BC major or minor frame descriptors
#define DQL_IOCTL553_READ_MD        (0x100AL)   // read BC major or minor frame drescriptors
#define DQL_IOCTL553_WRITE_BCCB     (0x100BL)   // write BCCB
#define DQL_IOCTL553_READ_BCCB      (0x100CL)   // read BCCB
#define DQL_IOCTL553_STATUS_BC      (0x100DL)   // write BC minor frame descriptors
#define DQL_IOCTL553_CONTROL_BC     (0x100EL)   // control specific BC parameters
#define DQL_IOCTL553_RT_VALID       (0x100FL)   // program RT validation table directly
#define DQL_IOCTL553_DBGSEL         (0x1101L)   // program debugging signals on SYNC connector

// for DQL_IOCTL553_START
#define DQL_IOCTL553_ENMASK(N)      (((N)&3)<<20)   // enable a separate channel
#define DQL_IOCTL553_GETMASK(N)     (((N)>>20)&3)   // get channel mask

// for DQCMD_EVENT
#define DQEVENT553_READ_RT          (0x1005L)   // read from RT terminal
#define DQEVENT553_WRITE_RT         (0x1006L)   // write to RT terminal
#define DQEVENT553_WRITE_MD         (0x1009L)   // write BC major or minor frame descriptors
#define DQEVENT553_READ_MD          (0x100AL)   // read BC major or minor frame drescriptors
#define DQEVENT553_WRITE_BCCB       (0x100BL)   // write BCCB
#define DQEVENT553_READ_BCCB        (0x100CL)   // read BCCB
#define DQEVENT553_STATUS_BC        (0x100DL)   // write BC minor frame descriptors
#define DQEVENT553_CONTROL_BC       (0x100EL)   // control specific BC parameters

// for DQIOCTL_SETPARAM
#define DQL_IOCTL553_SETPARAM_READREG       (1)
#define DQL_IOCTL553_SETPARAM_WRITEREG      (2)
#define DQL_IOCTL553_SETPARAM_READABS       (3)
#define DQL_IOCTL553_SETPARAM_WRITEABS      (4)

// for DQL_IOCTL553_WRITE_MD/DQL_IOCTL553_READ_MD
#define DQL_IOCTL553_MAJORD         (1)         // read or write major descriptor
#define DQL_IOCTL553_MINORD         (2)         // read or write minor descriptor

#define DQL_IOCTL553_MNBLOCK0       (1)         // write block 0
#define DQL_IOCTL553_MNBLOCK1       (2)         // write block 1

// for DQL_IOCTL553_CONTROL_BC
#define DQL_IOCTL553_MJ_SWAP        (1)         // initiate swap of major frame entries
#define DQL_IOCTL553_MN_SWAP        (2)         // initiate swap of minor frame halves
#define DQL_IOCTL553_DEBUG_START    (3)         // start debugging
#define DQL_IOCTL553_DEBUG_STOP     (4)         // stop debugging
#define DQL_IOCTL553_DEBUG_STEP_MJ  (5)         // one MaJor step
#define DQL_IOCTL553_DEBUG_STEP_MN  (6)         // one MiNor step
#define DQL_IOCTL553_DEBUG_GOTO     (7)         // execute to
#define DQL_IOCTL553_MJMN_CLEAR     (8)         // clear major and minor tables

// for DQL_IOCTL553_SETCFG
#define DQ_L553_MODE_BM             (1L<<0)     // bus monitor mode
#define DQ_L553_MODE_RT             (1L<<1)     // remote terminal mode
#define DQ_L553_MODE_BC             (1L<<2)     // bus controller mode
#define DQ_L553_MODE_A708           (1L<<3)     // ARINC-708 mode

// for DQL_IOCTL553_RT_CFG
#define DQ_L553_RT_LSTN_A           (1L<<0)     // listen bus A
#define DQ_L553_RT_LSTN_B           (1L<<1)     // listen bus B
#define DQ_L553_RT_TX_A             (1L<<2)     // enable transmission on bus A if received from A
#define DQ_L553_RT_TX_B             (1L<<3)     // enable transmission on bus B if received from B
#define DQ_L553_RT_RX_TSCMD         (1L<<28)    // Add timestamps to RT data (7 additional words)
#define DQ_L553_RT_RX_CMD           (1L<<29)    // Add command/status information to RT data (4 additional words)
#define DQ_L553_RT_DEFER_EN         (1L<<30)    // Defer enabling of RTs until enabled in realtime using VMap
#define DQ_L553_RT_LIST_ADD         (1L<<31)    // add to RTSA list

#define DQ_L553_RT_INH_RX           (1L<<12)    // Inhibit Rx packets <reserved>
#define DQ_L553_RT_INH_TX           (1L<<13)    // Inhibit Tx packets <reserved>
#define DQ_L553_RT_INH_MODE         (1L<<14)    // Inhibit Mode commands <reserved>
#define DQ_L553_RT_LB_EN            (1L<<15)    // Use this RT/SA as a loopback pair - with DqAdv553ConfigRT()
#define DQ_L553_RT_INH_BCSTREP      (1L<<16)    // Inhibit replication of broadcast messages

// for DQL_IOCTL553_BM_CFG
#define DQ_L553_BM_LSTN_A           (1L<<0)     // listen bus A
#define DQ_L553_BM_LSTN_B           (1L<<1)     // listen bus B
#define DQ_L553_BM_TX_A             (1L<<2)     // enable transmission on bus A
#define DQ_L553_BM_TX_B             (1L<<3)     // enable transmission on bus B

#define DQ_L553_A708_TX_BE          (1L<<4)     // enable bit-swap (bitwise big-endian) on ARINC-708 TX data
#define DQ_L553_A708_RX_BE          (1L<<5)     // enable bit-swap (bitwise big-endian) on ARINC-708 RX data
#define DQ_L553_A708_WXPD           (1L<<6)     // Enable WXPD mode of operation

#define DQ_L553_STORE_TS            (1L<<17)    // Store timestamp information
#define DQ_L553_STORE_FLAGS         (1L<<18)    // Store bus flags/status information
#define DQ_L553_STORE_SPUR          (1L<<19)    // Store all data - do not follow protocol
#define DQ_L553_BCNR_LCMEE          (1L<<20)    // do not store last illegal/undefined command
#define DQ_L553_BM_LIST_ADD         (1L<<31)    // add to RTSA list

//
// for the terminal list in ConfigRT
#define DQ_L553_BM_SADDR(N)         (((N)&0x1f)<<0)  // sub-address
#define DQ_L553_BM_SADDR_SEL        (1L<<5)     // Sub-address field is valid
#define DQ_L553_BM_RT(N)            (((N)&0x1f)<<DQ_L553_RT_RT_SHR)     // RT number (bits 6 to 10)
#define DQ_L553_BM_RT_SEL           (1L<<11)    // RT field is valid
#define DQ_L553_BM_INH_RX           (1L<<12)    // Inhibit Rx packets
#define DQ_L553_BM_INH_TX           (1L<<13)    // Inhibit Tx packets


#define DQ_L553_BM_AS_MASK          (1L<<31)    // if first word in the list has this bit set the rest of the list
                                                // is going to be 66 words for each RT/SA/RorT what to enable
                                                // [0] = R RT0
                                                // [1] = T RT0
                                                // [2] = R RT1
                                                // [3] = T RT1
                                                // ...
                                                // [64] = R MODE CODES
                                                // [65] = T MODE CODES

// flags
#define DQ_L553_DISCONNECT          (0L<<0)     // disconnect from the bus (default)
#define DQ_L553_TRANSFORMER         (2L<<0)     // transformer-coupled (54.9 Ohm in series)
#define DQ_L553_COUPLE_DIRECTLY     (3L<<0)     // direct-coupling (0 Ohm in series)
#define DQ_L553_TERMINATE35         (1L<<2)     // enable terminating 34.8Ohm resistor
#define DQ_L553_FORCE_A             (1L<<4)     // make I/O compliant with MIL-1553A standard (default is MIL-1553B)

// for DQL_IOCTL553_WRITE_RT and DQL_IOCTL553_READ_RT
#define DQ_L553_RT_SADDR(N)         (((N)&0x1f)<<0) // sub-address  (bits 0 to 4)
#define DQ_L553_RT_SADDR_SEL        (1L<<5)         // Sub-address field is valid
#define DQ_L553_RT_RT(N)            (((N)&0x1f)<<DQ_L553_RT_RT_SHR) // RT number (bits 6 to 10)
#define DQ_L553_RT_RT_SEL           (1L<<11)        // RT field is valid
#define DQ_L553_RT_SET_STATUS       (1L<<12)        // Set status bits
#define DQ_L553_RT_SET_BLK1         (1L<<13)        // Use Block 1 to write data
#define DQ_L553_RT_TX_SIZE(N)       (((N)&0x1f)<<16)   // Data size
#define DQ_L553_RT_TX_CMDSTS        (1L<<21)          // return command and status as well (CMD+STS), 2 uint16s
#define DQ_L553_RT_TX_TSCMD         (1L<<22)          // return command and status as well (CMD+STS+TXCMD+TXSTS+MISC+TSMSB+TSLSB)

// Macros for DqAdv553WriteRT
#define DQ_L553_RT_TX_STS_NUM       (0)
#define DQ_L553_RT_TX_VECTOR_NUM    (1)
#define DQ_L553_RT_TX(RT,SA,SIZE)   (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(SA)|DQ_L553_RT_SADDR_SEL|DQ_L553_RT_TX_SIZE(SIZE))
#define DQ_L553_RT_TX_BLK(RT,SA,SIZE,BLK)   (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(SA)|DQ_L553_RT_SADDR_SEL|DQ_L553_RT_TX_SIZE(SIZE)|((BLK)?DQ_L553_RT_SET_BLK1:0))
#define DQ_L553_RT_TX_STS(RT)       (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_TX_STS_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2))
#define DQ_L553_RT_TX_VECTOR(RT)    (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_TX_VECTOR_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2))

// Macros for DqAdv553ReadRT
#define DQ_L553_RT_RX_DATA_RDY_NUM  (0)
#define DQ_L553_RT_RX_DATA_SENT_NUM (1)
#define DQ_L553_RT_RX_PORT_STS_NUM  (2)
#define DQ_L553_RT_RX_SYNC_NUM      (3)
#define DQ_L553_RT_RX_MODE_NUM      (4)

#define DQ_L553_RT_RX(RT,SA,SIZE)   (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(SA)|DQ_L553_RT_SADDR_SEL|DQ_L553_RT_TX_SIZE(SIZE))
#define DQ_L553_RT_RX_BLK(RT,SA,SIZE,BLK)   (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(SA)|DQ_L553_RT_SADDR_SEL|DQ_L553_RT_TX_SIZE(SIZE)|((BLK)?DQ_L553_RT_SET_BLK1:0))
#define DQ_L553_RT_RX_DATA_RDY(RT, BLK)     (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_RX_DATA_RDY_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2)|((BLK)?DQ_L553_RT_SET_BLK1:0))
#define DQ_L553_RT_RX_DATA_SENT(RT, BLK)    (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_RX_DATA_SENT_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2)|((BLK)?DQ_L553_RT_SET_BLK1:0))
#define DQ_L553_RT_RX_PORT_STS(RT)  (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_RX_PORT_STS_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2))
#define DQ_L553_RT_RX_SYNC(RT)      (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_RX_SYNC_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2))
#define DQ_L553_RT_RX_MODE(RT)      (DQ_L553_RT_RT(RT)|DQ_L553_RT_RT_SEL|DQ_L553_RT_SADDR(DQ_L553_RT_RX_MODE_NUM)|DQ_L553_RT_SET_STATUS|DQ_L553_RT_TX_SIZE(2))

#define DQ_L553_RT_RT_SHR           (6)         // shift-right to extract remote terminal number


// Internal flags stored in rt_mode_flags and rt_mode_dis controlling behavior
#define SL553_RT_DEFERRED           (1L<<1)     // =1 to defer enabling of RT upon call to enable_rt_553()
#define SL553_RT_DIS_MD_RST         (1L<<2)     // =1 to disable reset mode command handling

// for DQL_IOCTL553_STATUS
#define DQ_L553_RT_STS0             (1L<<12)    // Last command (hi) and status (low) word
#define DQ_L553_RT_STS1             (2L<<12)    // Last SYNC (hi) and Transmitter (low) shutdown Last Transmitter shutdown/Override word
#define DQ_L553_RT_STS2             (3L<<12)    // 32-bit timestamdp when SYNC or SYNC+DW are received
#define DQ_L553_RT_CHSTAT           (4L<<12)    // Channel status, RT/SA ignored
#define DQ_L553_RT_BERRORS          (5L<<12)    // Bus errors, RT/SA ignored
#define DQ_L553_RT_DATA_RDY         (6L<<12)    // RT status that data has been received (BC->RT)
#define DQ_L553_RT_DATA_SENT        (7L<<12)    // RT status that data has been send (BC<-RT)
#define DQ_L553_RT_STS3             (8L<<12)    // 32-bit timestamdp when last command was received

#define DQ_L553_RT_STATMASK         (0xfL<<12)    // status mask
#define DQ_L553_RT_CLEARCMD         (1L<<20)    // clear STS0/STS1 after read

// for DQL_IOCTL553_CONTROL
#define DQ_L553_SET_TX_BLOCK        (1L<<0)     // select with block to use for Tx - 0 or 1 per RT
#define DQ_L553_SET_RX_BLOCK        (1L<<1)     // select with block to use for Rx - 0 or 1 per RT
#define DQ_L553_SET_RT_ENABLE       (1L<<2)     // dynamically enable/disable remote terminals - 0 or 1 per RT
#define DQ_L553_SET_VALID_ENTRY     (1L<<3)     // hand-program validation entry
#define DQ_L553_SET_RT_RTIMING      (1L<<4)     // set RT response timing

typedef struct {
    uint32 rt_tx_block;             // flags for each RT, use block 1 if bit is set RT->BC command
    uint32 rt_rx_block;             // flags for each RT, use block 1 if bit is set BC->RT command
    uint32 rt_enabled;              // flags for each RT, enabled if bit is set
    uint32 rt;                      // RT
    uint32 sa;                      // SA
    uint32 control_entry;           // Validation entry
    uint32 rt_r_timing;             // Defines rt response timing: SL553_RESPONSE(DGAP,BCLATE,BCEARLY,TRTRT,TBCRT,TRTBC,TMODE)
} DQ553Control, *pDQ553Control;

typedef struct {
    uint32 sync_mask;           // which SYNC lines to enable for debugging (output)
    uint32 syncsel;             // flags for SYNCSEL register
    uint32 dbgsel0;             // flags for DBGSEL regiser ch 0
    uint32 dbgsel1;             // flags for DBGSEL regiser ch 1
} DQ553DbgSel, *pDQ553DbgSel;


// for DQL_IOCTL553_RT_VALID
// Following bits to be added to the rt/sa list (set RT/SA with DQ_L553_RT_SA(RT,SA)
#define DQ_L553_RTVAL_WRITE         (0)         // write passed value
#define DQ_L553_RTVAL_OR_WRITE      (1L<<16)    // read value from the validation table and OR it with the new one, write back
#define DQ_L553_RTVAL_AND_WRITE     (2L<<16)    // read value from the validation table and AND it with the new one, write back

#define DQ_L553_RTVAL_CLEARALL      (1L<<0)     // clear all validation table before writing to it

// memory controller access delay constants
#define DQ_L553_READMEM_CYCLES      (200)       // maximum delay time to complete memory operation
#define DQ_L553_READMEM_ONE_SA      (25)        // maximum delay for a single SA data read/write
#define DQ_L553_READMEM_nS          (200)       // we should never wait more that 40uS because 38uS is the longest memory-access cycle
#define DQ_L553_READFIFO            (100)       // we should never wait more than 100ns for timestamp and flags to appear in FIFO

// For read and write FIFO in VMap ------------------------------------------------
//
//  15  14  13  12  11  10  09  08  07  06  05  04  03  02  01  00
//  STS *  BLK  CH  *   | Remote Terminal |  *  | Sub-Address    |
//
// Flags to tell that this is special channel - status (read) or control (write)
#define DQ_L553_RTS_RT_STS          (1L<<15)    // Return terminal status, specify which in RT/SA field
#define DQ_L553_RTS_RT_CTL          (1L<<15)    // Write control word specified in RT/SA field

#define DQ_L553_RTS_CHAN_NUM        (1L<<12)    // Channel number 0 or 1
#define DQ_L553_RTS_RT_BLK1         (1L<<13)    // Use Block 1 to retrieve Data Ready/Sent status and to control were to write
#define DQ_L553_RTS_XCODE           (1L<<14)    // Access to specific functions, bus monitor for example
#define DQ_L553_RTS_STATUS          (1L<<11)    // Return internal statuses

#define DQ_L553_RTS_CHAN_NUM_SHR    (12)        // shift-right to extract channel number
#define DQ_L553_RTS_BLK1_SHR        (13)        // shift-right for block 1 data status
#define DQ_L553_RTS_SA_SHR          (0)         // shift-right to extract sub-address
#define DQ_L553_RTS_RT_SHR          (6)         // shift-right to extract remote terminal number
#define DQ_L553_RTS_STATUS_SHR      (11)        // status, not the data status is requested
#define DQ_L553_RTS_RT_STS_SHR      (15)        // shift-right to extract status request flag
#define DQ_L553_RTS_RT_CTL_SHR      (15)        // shift-right to extract write channel control number
#define DQ_L553_SA_MASK             (0x1f)      // Subaddress mask
#define DQ_L553_RT_MASK             (0x1f)      // Remote terminal mask
#define DQ_L553_DSIZE_MASK          (0x1f)      // Data size mask
#define DQ_L553_RTS_RQ_MASK         (0x3f)      // [0..5] - instead of subsystem

#define DQ_L553_RTS_SADDR(N)        (((N)&0x1f)<<DQ_L553_RTS_SA_SHR)        // sub-address
#define DQ_L553_RTS_RT(N)           (((N)&0x1f)<<DQ_L553_RTS_RT_SHR)        // RT number
#define DQ_L553_RTS_CH(CH)          (((CH)&1)<<DQ_L553_RTS_CHAN_NUM_SHR)    // channel encoded
#define DQ_L553_RTS_BLK(C)          (((C)&1)<<DQ_L553_RTS_BLK1_SHR)         // block encoded

// ---------------------------------------------------------------------------
// These constants are used in VMap to select what status channels to read and
// what control words to write. Use DQ_SS0IN subsystem for this purpose
#define DQ_L553_STATUS_STSF(CH, RT, STS) (DQ_L553_RTS_RT_STS|DQ_L553_RTS_STATUS|DQ_L553_RTS_RT(RT)|DQ_L553_RTS_CH(CH)|STS)

// If status is requested, the type of status information is encoded in Sub-Address field for read
// The size of the returned status depends on number of bits set
// Bits are processed from LSB up and should be combined in <STS>
#define DQ_L553_RTS_STS0            (1L<<0)     // Last command (hi) and status (low) by RT
#define DQ_L553_RTS_STS1            (1L<<1)     // Last SYNC (hi) and Tx shutdown (low) by RT
#define DQ_L553_RTS_STS2            (1L<<2)     // 32-bit timestamp when SYNC or SYNC+DW occurs
#define DQ_L553_RTS_CHSTAT          (1L<<3)     // Channel status, RT/SA ignored
#define DQ_L553_RTS_BERRORS         (1L<<4)     // Bus errors, RT/SA ignored

// Following constants are used in VMap to select competion status of each channel (per RT and block)
// Use DQ_SS0IN sybsystem when defined
#define DQ_L553_STATUS_DATA(CH, RT, BLK, RQ) (DQ_L553_RTS_RT_STS|DQ_L553_RTS_RT(RT)|DQ_L553_RTS_BLK(BLK)|(((CH)&1)<<DQ_L553_RTS_CHAN_NUM_SHR)|RQ)

// These are special status bits telling whether transmit or receive has happened
// They are 32-bit, each bit for the subaddress, combine in <RQ> field
// For receive <BLK> doesn't matter, it is always zero
#define DQ_L553_RTS_DATAREADY       (1L<<0)     // Data ready status for this terminal
#define DQ_L553_RTS_DATASENT        (1L<<1)     // Data sent status for active block
#define DQ_L553_RTS_BMDATA          (1L<<2)     // Bus monitor data
#define DQ_L553_RTS_MODECMD         (1L<<3)     // Mode commands from the FIFO (2*uint32: STS0+STS2)

// Control requests are similar to status requests but should use DQ_SS0OUT subsystem in VMap
#define DQ_L553_CONTROL_CFG(CH, RT, RQ) ((((CH)&1)<<DQ_L553_RTS_CHAN_NUM_SHR)|DQ_L553_RTS_RT_CTL|DQ_L553_RTS_RT(RT)|RQ)

// Specify RT and SA for the VMap+ channel
#define DQ_L553_RT(RT)              (DQ_L553_BM_RT((RT))|DQ_L553_BM_RT_SEL)
#define DQ_L553_RT_SA(RT, SA)       (DQ_L553_BM_RT((RT))|DQ_L553_BM_RT_SEL|DQ_L553_BM_SADDR((SA))|DQ_L553_BM_SADDR_SEL)
#define DQ_L553_CH_RT_SA(CH,RT,SA)  ((((CH)&1)<<DQ_L553_RTS_CHAN_NUM_SHR)|(DQ_L553_BM_RT((RT))|DQ_L553_BM_RT_SEL)|(DQ_L553_BM_SADDR((SA))|DQ_L553_BM_SADDR_SEL))

// For <RQ> you can combine the following flags in VMap entry - but you must follow the same order!
#define DQ_L553_RTS_CFG0            (1L<<0)     // Bits to control status
#define DQ_L553_RTS_CFG1            (1L<<1)     // Vector (hi) and BIT (low) words
#define DQ_L553_RTS_TX_BLK          (1L<<2)     // Set Tx block per RT (0 or 1)
#define DQ_L553_RTS_RTEN            (1L<<3)     // Enable/disable terminals mask
#define DQ_L553_RTS_RX_BLK          (1L<<4)     // Set Tx block per RT (0 or 1)

// CFG0 data definition (use when DQ_L553_RTS_CFG0 flag is selected) 32-bits
#define DQ_SL553_RTS_CFG0_RSTD      (1L<<6)     // =1 if reset RT command should be disabled
#define DQ_SL553_RTS_CFG0_TF        (1L<<5)     // =1 if terminal should always set TF bit in status word
#define DQ_SL553_RTS_CFG0_SF        (1L<<4)     // =1 if terminal should always set SF bit in status word

#define DQ_SL553_RTS_CFG0_BSY       (1L<<3)     // =1 if terminal should always set BUSY bit in status word
#define DQ_SL553_RTS_CFG0_BSRD      (1L<<2)     // =1 if broadcast commands are not allowed
#define DQ_SL553_RTS_CFG0_SR        (1L<<1)     // =1 if SR bit should be set in the status word
#define DQ_SL553_RTS_CFG0_DBCE      (1L<<0)     // =1 if DBC command is allowed for the current RT

// CFG1 data definition (use when DQ_L553_RTF_CFG1 flag is selected) 32-bits
#define DQ_SL553_RTS_CFG1(HI, LO)   (((HI)<<16)|((LO)&0xffff))

// Macro to access data in VMap+
#define DQ_L553_DATA(CH, RT, SA, BLK) (DQ_L553_RTS_RT(RT)|DQ_L553_RTS_SADDR(SA)|DQ_L553_RTS_BLK(BLK)|(((CH)&1)<<DQ_L553_RTS_CHAN_NUM_SHR))


// -------------------------------------------------------------------------------------
// Upper part of the configuration word - 553 specific
#define DQ_L553_MODESCAN            (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_L553_MODEFIFO            (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO
#define DQ_L553_MODECONT            (DQ_FIFO_MODECONT)  // continuous acquisition

// for DQL_IOCTL553_READ_FIFO
#define DQ_L553_READFIFO_ALL        (0x100)     // causes to read everything in the FIFO (backdoor)

#define DQ_L553_BMSTATUS_OVER       (0x80)      // BM FIFO overrun


// Output FIFO to read data
#define DQ_L553_FIFO_GET_DATA       (DQ_FIFO_GET_DATA)

// Input FIFO to read data
#define DQ_L553_FIFO_SET_DATA       (DQ_FIFO_SET_DATA)

#pragma pack(1)
typedef struct {
    uint16 flags0;      // FLAGS0 word in the BC control block
    uint16 flags1;      // FLAGS1 word in the BC control block
    uint16 flags2;      // Delay in us before command execution (bit15 is enable)
    uint16 rsv3;
    uint16 cmd1;        // First 1553 command word
    uint16 cmd2;        // Second 1553 command word/mode data word
    uint16 sts1_or;     // "OR" mask for the first status word
    uint16 sts1_and;    // "AND" mask for the first status word
    uint16 sts1_val;    // Compare "VALUE" for the first status word
    uint16 sts2_or;     // "OR" mask for the second status word
    uint16 sts2_and;    // "AND" mask for the second status word
    uint16 sts2_val;    // Compare "VALUE" for the second status word
    uint16 rsv12;
    uint16 rsv13;
    uint16 rsv14;
    uint16 rsv15;
    uint16 rx_data_tmin[32]; // RX data or minimum compare values for TX
    uint16 tmax[32];        // maximum compare values for TX
    // 80 uint16s total
} BCCB_Control, *pBCCB_Control;

typedef struct {
    uint16 sts1;        // First status reply from the RT
    uint16 sts2;        // Second status reply from the RT
    uint16 tsmsb;       // Timestamp of last access to the RT, 16 MSBs
    uint16 tslsb;       // Timestamp of last access to the RT, 16 LSBs
    uint16 rsv84;
    uint16 rsv85;
    uint16 errsts0;     // error status 0
    uint16 errsts1;     // error status 1
    uint16 rx_data[32]; // transmit data
    // 40 uint16s total
} BCCB_Status, *pBCCB_Status;

// BCCB representation in the PSRAM
typedef struct {
    BCCB_Control control;
    BCCB_Status status;
} BCCB_Block, *pBCCB_Block;

// 1553 BM Message
typedef struct {
    uint8 channel;      // channel
    uint8 stat;         // status
    uint16 size;        // size of the following data, uint32s
    uint32 data[DQ_FLEX_ARRAY];      // variable size data (RT/SA information is embedded)
} DQBM553Message, *pDQBM553Message;

// Temporary data storage for the message - *** MUST *** mirror DQBM553Message before <data>
typedef struct {
    uint8 channel;      // channel
    uint8 stat;         // status
    uint16 size;        // size of the following data, uint32s (in uint8s for WXPD data)
    uint32 data[DQ_L553_MAXBM_WORDS];   // variable size data (RT/SA information is embedded)
    uint32 wxpd[DQ_L553_AWXPD_FRMSZ/sizeof(uint16) + DQ_L553_AWXPD_FRMSZ%sizeof(uint16) - DQ_L553_MAXBM_WORDS]; // padding for larger BM data from A708-WXPD
    uint32 timestamp;   // timestamp from START sync
} DQBM553MessageStor, *pDQBM553MessageStor;

typedef struct {
    uint8 channel;      // channel
    uint8 rt;           // remote terminal address
    uint8 sa;           // sub-address
    uint8 size;         // data size (for validation)
} DQBM553RTSAEntry, *pDQBM553RTSAEntry;

typedef struct {
    uint8 channel;      // channel
    uint8 rt;           // remote terminal address
    uint8 sa;           // sub-address
    uint8 size;         // size of the following data, bytes
    uint32 data[4];     // filter data
} DQBM553Filter, *pDQBM553Filter;

typedef struct {
    uint8 channel;      // channel
    uint8 rt;           // remote terminal address
    uint8 sa;           // sub-address
    uint8 size;         // size of the following data, bytes
    uint32 data[4];     // trigger data
} DQBM553Trigger, *pDQBM553Trigger;


// Flags
#define DQ_L553_TRIGOUT_EN          (1)     // output trigger is defined
#define DQ_L553_TRIGIN_EN           (2)     // input trigger is defined

// Output trigger (uses INT0/ch0, INT1/ch1 in the logic)
#define DQ_L553_TRIGOUT_PERIODIC    (1)     // Trigger out upon periodic event along with EV553_RT_PERIODIC
                                            // trig_in_prm[0] = pule length in 15.15ns counts, should be less than period

#define DQ_L553_TRIGOUT_RTSA        (2)     // Trigger out upon RTSA command
                                            // See SL553_PORT_CFG1 for the parameter word in trig_in_prm[0]

#define DQ_L553_TRIGOUT_DBGCOND     (3)     // Trigger out upon selecting debug condition
                                            // See SL553_PORT_DDBG sources
                                            // trig_out_prm[0] = SYNCx line to use DQL_ISOS_SRC_SYNC0 .. 3
                                            // pT->trig_out_prm[1] = debug trigger group to use and debug mode SL553_PORT_DBGSIGSEL()
    // SYNC lines to use
    #define DQL_ISOS_SRC_SYNC0      (0xC)  //   SYNC line 0
    #define DQL_ISOS_SRC_SYNC1      (0xD)  //   SYNC line 1
    #define DQL_ISOS_SRC_SYNC2      (0xE)  //   SYNC line 2
    #define DQL_ISOS_SRC_SYNC3      (0xF)  //   SYNC line 3

#define DQ_L553_TRIGOUT_LEVEL       (4)     // set trigger line at a pre-defined level (zero or one)
                                            // pT->trig_out_mode contains the level (0) or (1) of 0x1x where x is any INTx source

// Input trigger should be wired EXT0/ch0, EXT1/ch1
#define DQ_L553_TRIGIN_FIFO         (1)     // Clock LP FIFO output upon rising edge on the input trigger


typedef struct {
    uint32 channel;         // channel
    uint32 rtsa;            // RT/SA if any
    uint32 flags;           // enable/disable flags

    uint32 trig_in;         // what to do upon trig-in
    uint32 trig_in_src;     // source for trig in (Ext0/1 or SYNCx)
    uint32 trig_in_mode;    // mode of op upon input trigger
    uint32 trig_in_prm[DQ_L553_MAXBM_WORDS];    // enough to set a trigger for the whole command/data message

    uint32 trig_out;        // when to generate trig-out
    uint32 trig_out_dest;   // source for trig in (Ext0/1 or SYNCx)
    uint32 trig_out_mode;   // mode of output trigger
    uint32 trig_out_prm[DQ_L553_MAXBM_WORDS];

} DQ553ExtTrigger, *pDQ553ExtTrigger;

#pragma pack()

#define SL553_VALID_W(RMIN,RMAX,TMIN,TMAX,FLAGS) ((((RMIN)&0x1f)<<0)|(((RMAX)&0x1f)<<5)|(((TMIN)&0x1f)<<10)|(((TMAX)&0x1f)<<15)|((FLAGS)&0xfff00000))

#define SL553_MODE_ENABLE           (1)

#define MEMORY_553_VALIDATION       (0)
#define MEMORY_553_DATA_0           (1)
#define MEMORY_553_DATA_1           (2)
#define MEMORY_553_DATA_READY       (3)
#define MEMORY_553_DATA_SENT        (4)
#define MEMORY_553_DATA_XCNG        (5)

#define MEMORY_553_MAJOR            (6)
#define MEMORY_553_MINOR            (7)

// TX FIFO bit structure
#define SL553_TXFW_PAR              (1L<<31)    // parity
#define SL553_TXFW_WT               (1L<<30)    // word is command or status
#define SL553_TXFW_DLY              (1L<<29)    // insert uS delay
#define SL553_TXFW_BUSA             (1L<<28)    // bus selector (1 = bus A)
#define SL553_TXFW_BUSB             (0L<<28)    // bus selector (0 = bus B)
#define SL553_TXFW_WORD(DLY, DATA)  ((((DLY)&0xfff)<<16) | ((DATA)&0xf000ffff))  // insert delay in 15ns and command
#define SL553_TXFW_ERR_WORD(CODE,DLY,DATA)  (SL553_TXFW_WORD((DLY), (DATA))|UEI1553_ERR_CODE(CODE))
#define SL553_TXFW_uSDLY(uS)        (SL553_TXFW_DLY|((uS)&0xfffffff))           // insert delay in uS

// SL553_TX_COMMAND: Remote Terminal, Transmit(1)/Receive(0), Sub-Address, Word Count
#define SL553_TX_COMMAND(RT, TR, SA, WC) (SL553_TXFW_WT|(((RT)&31)<<11)|(((TR)&1)<<10)|(((SA)&31)<<5)|(((WC)&31)<<0))

// Extract parts of the command
#define SL553_CMD_GET_TS(C)         (((C)>>16)&0x3fff)  // timestamp from BM data
#define SL553_CMD_GET_RT(C)         (((C)>>11)&31)      // RT from command
#define SL553_CMD_GET_SA(C)         (((C)>>5)&31)       // SA from command
#define SL553_CMD_GET_TR(C)         (((C)>>10)&1)       // Transmit or receive
#define SL553_CMD_GET_WC(C)         ((C)&31)            // Word count
#define SL553_CMD_GET_WC0(C)        ( (0==((C)&31))?32:((C)&31) )            // Word count (corrected 0 = 32)

// UEI 1553 RX/TX data format, note that
// ARINC-708 mode is selected when SL553_PORT_BCCFG_A708 = 1 and
// NOCRC (should be set for ARINC-708) is selected when SL553_PORT_BT1_NOCRC = 1
#define UEI1553_PE                  (1<<31)     // RX - when =1, parity error was detected
                                                // TX - when 1 - introduce wrong parity on the bus
#define UEI1553_TYPE                (1<<30)     // Defines payload type: SYNC1553_CONTROL(1)/SYNC1553_DATA(0)
#define UEI1553_DLYUS               (1<<29)     // If set instructs FIFO to start delay with bits [28:0] containing delay counter in 1uS
#define UEI1553_GAP12               (1<<28)     // Data gap code, 13-bit. Reflects actual data gap
#define UEI1553_GAP0                (1<<16)     // in 66MHz clocks, max value is 0x1F00 for TX, 0x1FFF for RX
#define UEI1553_D15                 (1<<15)     // 16 pit payload, data, command or status
#define UEI1553_D0                  (1<<0)      //
#define UEI1553_DLY28               (1<<28)     // Delay code, in uS, valid when DLYUS=1
#define UEI1553_DLY0                (1<<0)

#define UEI1553_GAP_708D            (0xD)       // bits [29..26] 16-bit data
#define UEI1553_GAP_708CS           (0xE)       // bits [29..26] start of A-708 SYNC bit received (data ignored)
#define UEI1553_GAP_708DS           (0xF)       // bits [29..26] end of A-708 SYNC bit received (data ignored)

#define UEI1553_GAP_GET708(N)       (((N)&0xf)>>26)     // type of A-708 word received
#define UEI1553_GAP_GET(N)          (((N)&0x1fff)>>16)  // inter-word gap
#define UEI1553_ERR_CODE(N)         (((N)&0xf)<<25)     // insert error code

#define SL553_TXFW_708_WORD(CODE,DLY,DATA)  (SL553_TXFW_WORD((DLY), (DATA))|UEI1553_ERR_CODE(CODE))


// Special combination DLYUS=1 and PE=1 is used to introduce code errors into the bit stream
// in this case upper four GAP[12:9] are used to set possible error conditions :
#define UEI1553_ERR_NE              (0x0)       // no error
#define UEI1553_ERR_SPE             (0x1)       // manchester code error during the SYNC bit (only negative output changes)
#define UEI1553_ERR_SNE             (0x2)       // manchester code error during the SYNC bit (only positive output changes)
#define UEI1553_ERR_DPE             (0x3)       // manchester code error during the data bit (bit 7) (only negative output changes)
#define UEI1553_ERR_DNE             (0x4)       // manchester code error during the data bit (bit 7) (only positive output changes)
#define UEI1553_ERR_TMB             (0x5)       // too many bits (one extra bit)
#define UEI1553_ERR_TFB             (0x6)       // too few bits (one less bit)
#define UEI1553_ERR_SED             (0x7)       // delay SYNC edge by 1/4 of the clock
#define UEI1553_ERR_DED             (0x8)       // delay data bit edge edge by 1/4 of the clock

// Following 3 error codes allow sending of ARINC-708 data SL553_PORT_BT1_NOCRC should be set to 1
#define UEI1553_ERR_708_DATA        (0xf)       // Send data only (no SYNC)in ARINC-708 mode
#define UEI1553_ERR_708_CSYNC       (0xe)       // Issue Command SYNC bit only
#define UEI1553_ERR_708_DSYNC       (0xd)       // Issue Data SYNC bit only

// UEI1553_ERR_708_DATA also uses ERRFLAGS:
#define UEI1553_ERRF_RDLEN      (1L<<24) //(RDLEN=1 - reduced data length,
                                                 //  TX: only first DATALEN MSBs of the DATA1553 transmitted,
                                                 //  RX: only DATALEN MSBs in the received data are valid)

#define UEI1553_ERRF_DLEN(N)    (N) // Number of data bits in reduced RX/TX. Note, that WXPD SYNC can be emulated by transmitting 8 0's
#define UEI1553_ERRF_DLEN_WXPD  (8) // 8 0's indicate WXPD SYNC



//#define SL553_TX_COMMAND(RT,TR,SA,WC) ((uint16)(SL553_TXFW_WT|(((RT)&31)<<11)|(((TR)&1)<<10)|(((SA)&31)<<5)|(((WC)&31)<<0)))
#define SL553_TRANSMIT              (1)
#define SL553_RECEIVE               (0)


#define SL553_TX_DATA(D)            ((D)&0xffff)

// SL553_TX_STATUS: Remote Terminal, MessageError, Instrumentation, ServiceRequest, BroadCast, Busy, SubSystem, DynBus, TerminalFlag
#define SL553_TX_STATUS(RT,ME,I,SR,BC,BSY,SS,DBA,TF) (SL553_TXFW_WT|(((RT)&31)<<11)|(((ME)&1)<<10)|(((I)&1)<<9)|(((SR)&1)<<8)|(((BC)&1)<<4)|(((BSY)&1)<<3)|(((SS)&1)<<2)|(((DBA)&1)<<1)|(((TF)&1)<<0))

#define DQ_SL553_ABS_MEM_ADDR(MODE, BLK, CH, RT, SA) ((((MODE)&1)<<18)|(((BLK)&1)<<17)|(((CH)&1)<<16)|(((RT)&0x1f)<<11)|(((SA)&0x1f)<<6))

//-----------------------------------------------------------------------------------------
// Bit desctiption for the major frame descriptor table in FPGA memory
#define SL553_MJF_DESC_BCCB_A(N)    (((N)&0xf)<<10)       // BCCB address base, 4 bit
#define SL553_MJF_DESC_LINK         (1L<<9)     // =1 - do not wait for minor clock to execute this entry
#define SL553_MJF_DESC_EN           (1L<<8)     // =1 - enable current frame, if this bit =0 descriptor is ignored
                                                // and next entry is processed, until end of the descriptor table is
                                                // reached. Descriptor may be temporary disabled in order to replace
                                                // data inside of the minor frame and/or minor frame descriptors
#define SL553_MJF_DESC_OT           (1L<<7)     // Execute once flag - if set, entry will be executed once and then
                                                // it will be automatically disabled. May be used for the minor frame
                                                // filled with aperiodic messages
#define SL553_MJF_DESC_IRQ          (1L<<6)     // Issue IRQ upon completion of the minor frame execution
#define SL553_MJF_DESC_EN_SWAP      (1L<<5)     // Enable entry if disabled or disable if enabled upon SWAP request;
                                                // SWAP request allows simultaneous change of the sequence in the
                                                // major frame descriptor table at the beginning of the major frame
                                                // cycle
#define SL553_MJF_DESC_ED           (1L<<4)     // Status bit =1 if entry was executed at least once
#define SL553_MJF_DESC_MRF(N)       ((N)&0xf)   // minor frame ID
#define SL553_MJF_BCCB_SEGM(N)      (((N)&0x7f)<<10)    // minor frame BCCB base address (segment, normally equal to minor frame ID)

//-----------------------------------------------------------------------------------------
// Bit desctiption for the minor frame descriptor table in FPGA memory
#define SL553_MNF_DESC_BCCB_A(N)    (((N)&0xff)<<10)   // BCCB address offset, 8 bit
#define SL553_MNF_DESC_EN           (1L<<8)     // =1 - enable current entry, if this bit =0 descriptor is ignored
                                                // and next entry is processed, until end of the descriptor table is
                                                // reached.
#define SL553_MNF_DESC_OT           (1L<<7)     // Execute once flag - if set, entry will be executed once and then
                                                // it will be automatically disabled. Maybe used for the aperiodic
                                                // messages, enable flag is not cleared if error was detected during
                                                // the execution of the entry
#define SL553_MNF_DESC_CB           (1L<<6)     // Status bit, report currently active 1553 bus for this entry (=0:bus A)
#define SL553_MNF_DESC_RR           (1L<<5)     // Status bit, =1 if 1553 RT that was in error state responded with status
#define SL553_MNF_DESC_ED           (1L<<4)     // Status bit, =1 if entry was executed at least once
#define SL553_MNF_DESC_ERR          (1L<<3)     // Status bit, =1 if entry was executed with error
#define SL553_MNF_DESC_ERRC2        (1L<<2)     // Error counter, counts number of retry attempts, if number of retries
#define SL553_MNF_DESC_ERRC0        (1L<<0)     // is above specified in the control block, error bit is set
                                                // Successfull execution of the 1553 command sequence clears this counter

#define SL553_MNF_BLOCK1            (1L<<1)     // block 1 of a minor frame
#define SL553_MNF_BLOCK0            (1L<<0)     // ditto block 0
#define SL553_MNF_BCCB_OFFS(N)      (((N)&0x7f)<<10)   // minor frame BCCB address (offset, normally equal to minor frame entry index)

// Event data for 553 layer
typedef struct {
    uint32 chan;        // channel information
    uint32 evtype;      // type of the event
    uint32 rtsa;        // rtsa information
    uint32 cmd;         // command and status
    uint32 sts;         // applicable status register
    uint32 tstamp;      // timestamp of event
    uint32 size;        // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];      // data to follow
} EV553_ID, *pEV553_ID;

#define DqAdv553ConfigEvents_PARAMSZ    (7)   // maximum number of uint32 parameters after pEV553_ID

// Types of event
typedef enum {
    EV553_CLEAR = 0x1000,        // clear all events

    // bus or RT controller event
    EV553_NO_ACTIVITY = 0x101,  // no activity on the bus over certain (programmed) time
    EV553_IN_FIFO,      // send data accumulated in BM FIFO
    EV553_OUT_FIFO,     // output FIFO underrun or half-empty
    EV553_BUS_ERROR,    // bus or protocol errors, including RT-RT errors
    EV553_FSM_ERROR,    // state machine error or MC error
    EV553_BUS_CHANGED,  // warning - bus was changed

    // mode commands received
    EV553_MD_SHUTDOWN,  // transmitter shutdown or override related event
    EV553_MD_SYNCHRONIZE,   // synchronize event
    EV553_MD_RESET,     // reset condition
    EV553_MD_MISC,      // misc mode commands like ITF

    // receive or transmit (specify RT/SA combination)
    EV553_RX,           // data recevieved
    EV553_TX,           // data transmitted

    EV553_BCST_RX,      // data recevieved (broadcast)
    EV553_BCST_TX,      // data transmitted (broadcast)

    EV553_MD,           // mode command received (by code)

    // bus controller events
    EV553_BC_ERROR,     // one of bus controllers errors
    EV553_BC_BUS,       // bus error: bus not idle, transaction took too long
    EV553_BC_IRQ,       // user-requested interrupt from the BC frame
    EV553_BC_OVERRUN,   // BC overrun event (major or minor frame)
    EV553_BC_CMD_ERR,   // one or more command has failed or an RT is dead
    EV553_BC_HEARTBEAT, // Minor frame started

    // custom configuration events
    EV553_RT_CUST_LUT,   // set look-up table for RT/SA
    EV553_RT_CUST_LUT1,  // reserved LUT1
    EV553_RT_CUST_LUT2,  // reserved LUT2
    EV553_RT_CUST_LUT3,  // reserved LUT3

    // update on the current activity
    EV553_RT_PERIODIC,   // update which RT/SA received and sent data (not available in BC mode)
    EV553_BC_PERIODIC,   // <reserved> update which BCCBs are executed (not available in TR mode)

    // event on external trigger
    EV553_TRIG_EXT0,    // transition on trig-in ch 0 line
    EV553_TRIG_EXT1     // transition on trig-in ch 1 line

} event553_t;

// #define SL553_SYNCSEL   (0x2028) // W       SYNC line driver selector
// Use LCR_553_DBG_EN bit to connect all four SYNC lines to the debug sources

#define SL553_SYNCSEL_SYNC(D,C,B,A) ((((D)&0xff)<<24)|(((C)&0xff)<<16)|(((B)&0xff)<<8)|(((A)&0xff)<<0))

#define SL553_SYNCSEL_1uS_DLY     (0x80)     // Add to the debug source to stretch pulse to 1uS

#define SL553_SYNCSEL_MCDNABLKL   (0x1C)  // =1 during DNA block read/write access
#define SL553_SYNCSEL_MCDNARD     (0x1B)  // Stored DNA read memory request (from DNA bus)
#define SL553_SYNCSEL_MCDNAWR     (0x1A)  // Stored DNA write memory request (from DNA bus)
#define SL553_SYNCSEL_CH1RMREQ    (0x19)  // RT =1 when memory read is requested, should stay at 1 until data comes and memory released
#define SL553_SYNCSEL_CH1RMRDY    (0x18)  // RT =1 when "mem_value" buffer is ready (data ready for RT)
#define SL553_SYNCSEL_CH1RMDNE    (0x17)  // RT Strobe, asserted once write to the memory is completed
#define SL553_SYNCSEL_CH0RMREQ    (0x16)  // RT =1 when memory read is requested, should stay at 1 until data comes and memory released
#define SL553_SYNCSEL_CH0RMRDY    (0x15)  // RT =1 when "mem_value" buffer is ready
#define SL553_SYNCSEL_CH0RMDNE    (0x14)  // RT Strobe, asserted once write to the memory is completed
#define SL553_SYNCSEL_CH1BMREQ    (0x13)  // BC =1 when memory read is requested, should stay at 1 until data comes and memory released
#define SL553_SYNCSEL_CH1BMACC    (0x12)  // BC =1 when memory request is accepted by the memory controller
#define SL553_SYNCSEL_CH1BMRDY    (0x11)  // BC =1 when "mem_value" buffer is ready
#define SL553_SYNCSEL_CH1BMDNE    (0x10)  // BC Strobe, asserted once write to the memory is completed
#define SL553_SYNCSEL_CH0BMREQ    (0xF)   // BC =1 when memory read is requested, should stay at 1 until data comes and memory released
#define SL553_SYNCSEL_CH0BMACC    (0xE)   // BC =1 when memory request is accepted by the memory controller
#define SL553_SYNCSEL_CH0BMRDY    (0xD)   // BC =1 when "mem_value" buffer is ready
#define SL553_SYNCSEL_CH0BMDNE    (0xC)   // BC Strobe, asserted once write to the memory is completed
#define SL553_SYNCSEL_CH1DBG3     (0xB)   // Channel 1 debug source 3
#define SL553_SYNCSEL_CH1DBG2     (0xA)   // Channel 1 debug source 2
#define SL553_SYNCSEL_CH1DBG1     (0x9)   // Channel 1 debug source 1
#define SL553_SYNCSEL_CH1DBG0     (0x8)   // Channel 1 debug source 0
#define SL553_SYNCSEL_CH0DBG3     (0x7)   // Channel 0 debug source 3
#define SL553_SYNCSEL_CH0DBG2     (0x6)   // Channel 0 debug source 2
#define SL553_SYNCSEL_CH0DBG1     (0x5)   // Channel 0 debug source 1
#define SL553_SYNCSEL_CH0DBG0     (0x4)   // Channel 0 debug source 0
#define SL553_SYNCSEL_ONE         (0x2)   // Assigned 1
#define SL553_SYNCSEL_ZERO        (0x1)   // Assigned 0
#define SL553_SYNCSEL_HIGHZ       (0x0)   // High-Z

#define SL553_PORT_BCCFG_BCEARLY(N) (((N)&0x1f))
#define SL553_PORT_BCCFG_BCLATE(N)  (((N)&0x1f)<<8)
#define SL553_PORT_BCCFG_BCIDLE(N)  (((N)&0xff)<<16)

#define SL553_BCCFG_BCEARLY         (3)         // early response limit 3us
#define SL553_BCCFG_BCEARLY_RED     (1)         // early response limit 2us for 11.8C logic
#define SL553_BCCFG_BCLATE          (20)        // late response limit 20us
#define SL553_BCCFG_BCIDLE          (20)        // minimum idle between packets 48us
// Set status bits for RT to reply with
// bits 12-14 available from logic 11.56
#define SL553_RT_CFG0_ME     (1L<<14)    // =1 if terminal should always set ME bit in status word
#define SL553_RT_CFG0_INST   (1L<<13)    // =1 if terminal should always set INST bit in status word
#define SL553_RT_CFG0_DBA    (1L<<12)    // =1 if terminal should always set DBA bit in status word

#define SL553_RT_CFG0_M0DIST (1L<<11)  // =1 if "00000" SA should not be decoded as a mode command for TX RT in RT-RT transfer
#define SL553_RT_CFG0_M1DIST (1L<<10)  // =1 if "11111" SA should not be decoded as a mode command for TX RT in RT-RT transfer
#define SL553_RT_CFG0_M0DIS  (1L<<9)   // =1 if "00000" SA should not be decoded as a mode command
#define SL553_RT_CFG0_M1DIS  (1L<<8)   // =1 if "11111" SA should not be decoded as a mode command

#define SL553_RT_CFG0_M1553A (1L<<7)   // =1 if comply with MIL1553A mode (note - quick 6us response is requred - set in error injection flags)
                                       // only TA can be used in status (BUSY, SR, SF and TF are added to the status if set)
#define SL553_RT_CFG0_RSTD   (1L<<6)   // =1 if reset RT command should be disabled
#define SL553_RT_CFG0_TF     (1L<<5)   // =1 if terminal should always set TF bit in status word
#define SL553_RT_CFG0_SF     (1L<<4)   // =1 if terminal should always set SF bit in status word
#define SL553_RT_CFG0_BSY    (1L<<3)   // =1 if terminal should always set BUSY bit in status word
#define SL553_RT_CFG0_BSRD   (1L<<2)   // =1 if broadcast RX commands are disabled (for MIL1553A)
#define SL553_RT_CFG0_SR     (1L<<1)   // =1 if SR bit should be set in the status word
#define SL553_RT_CFG0_DBCE   (1L<<0)   // =1 if DBC command is allowed for the current RT
//    SL553_PORT_CFG1    (0x04)          // W    Additional configuration regiser
#define SL553_PORT_CFG1_TMODE  (1L<<16)        // output produces debug trigger strobe (otherwise clocks LP FIFO)
                                               // CH0 is wired to ISO_EXT0, CH1 is wired to ISO_EXT1
#define SL553_PORT_CFG1_DLY(N) (((N)&0xf)<<12) // delay in us prior to fire trigger - after 1553 bus goes into the idle state
#define SL553_PORT_CFG1_MD     (1L<<11)        // =1 - Mode command causes trigger for low priority FIFO (0-RX/TX command)
#define SL553_PORT_CFG1_W_RN   (1L<<10)        // =1 - WR bit should be set (0-cleared) for the trigger (1 == transmit)
#define SL553_PORT_CFG1_SA(N) (((N)&0x1f)<<5)  // SA to cause the trigger
#define SL553_PORT_CFG1_RT(N) (((N)&0x1f)<<0)  // RT to cause the trigger
//    SL553_PORT_RTR    (0x3C)        // W    Response timing register
//  Sets bus timing limits for the different transfer types
#define SL553_PORT_RTR_DGP1    (1L<<31) //    Allowed gap between data words
#define SL553_PORT_RTR_DGP0    (1L<<30) //    0 = no gap (default), 1/2/3 - 0.5/1.0/1.5uS

#define SL553_PORT_RTR_WD13    (1L<<29) //    Watchdog for the bus activity, 100uS resolution
#define SL553_PORT_RTR_WD0     (1L<<16) //    1638.4mS max time, watchdog generates IRQ and sets status

#define SL553_PORT_RTR_RXT3    (1L<<15) //    Maximum timeout after RX command (RT-RT)
#define SL553_PORT_RTR_RXT0    (1L<<12) //    0..15 correspons to 50-66uS

#define SL553_PORT_RTR_RR3     (1L<<11) //    Terminal response time to the RX command,
#define SL553_PORT_RTR_RR0     (1L<<8)  //    in uS, default 6uS

#define SL553_PORT_RTR_TR3     (1L<<7)  //    Terminal response time to the TX command,
#define SL553_PORT_RTR_TR0     (1L<<4)  //    in uS, default 6uS

#define SL553_PORT_RTR_MR3     (1L<<3)  //    Terminal response time to the Mode command,
#define SL553_PORT_RTR_MR0     (1L<<0)  //    in uS, default 6uS

// parameters for response timing
#define SL553_RESPONSE_DGAP     0   // Allowed gap between data words
#define SL553_RESPONSE_WDOG     0   // Watchdog for the bus activity, 100uS resolution

//#define SL553_RESPONSE_BCEARLY  3
#define SL553_RESPONSE_TRTRT    6   // Terminal response time to the RT-RT command
#define SL553_RESPONSE_TBCRT    5   // Terminal response time to the RX command
#define SL553_RESPONSE_TRTBC    6   // Terminal response time to the TX command
#define SL553_RESPONSE_TMODE    6   // Terminal response time to the Mode command

#define SL553_RESPONSE(DGAP,WDOG,TRTRT,TBCRT,TRTBC,TMODE) \
( (((DGAP)&3)<<30)|(((WDOG)&0x3fff)<<16)|(((TRTRT)&0xf)<<12)|(((TBCRT)&0xf)<<8)|(((TRTBC)&0xf)<<4)|(((TMODE)&0xf)<<0) )
// SL553_PORT_DBGSEL     =             16'h58,
// W       Mux configuration for the debug outputs
// (can be routed to the SYNC bus). This register allows to route many available sources
// to the four debug outputs that can be routed to the SYNC bus, there are five "sets"
// of sources
#define SL553_PORT_DBGSEL_SRCENC    0 //  0x00  1553 encoder (SL553_PORT_EDBG)
#define SL553_PORT_DBGSEL_SRCDEC    1 //  0x20  1553 decoder (SL553_PORT_DDBG)
#define SL553_PORT_DBGSEL_SRCRT     2 //  0x40  RT (SL553_PORT_RDBG)
#define SL553_PORT_DBGSEL_SRCBM     3 //  0x60  BM (SL553_PORT_MDBG)
#define SL553_PORT_DBGSEL_SRCBC     4 //  0x80  BC (SL553_PORT_BDBG)

// Select type of the source and source itself
#define SL553_PORT_DBGSIGSEL(TYPE,SRC)   (((TYPE)<<5)|((SRC)&0x1f))

// use SL553_PORT_DBGSIGSEL as a source for each line
#define SL553_PORT_DBGSEL_SYNC(D,C,B,A) ((((D)&0xff)<<24)|(((C)&0xff)<<16)|(((B)&0xff)<<8)|(((A)&0xff)<<0))

// Encoder debug selector (source SL553_PORT_DBGSEL_SRCENC) 0x00
#define SL553_PORT_EDBG_LPDE    (5)  // Input: LP FIFO data enable strobe (1-clock wide) BUS WRITER
#define SL553_PORT_EDBG_HPDE    (4)  // Input: HP FIFO data enable strobe (1-clock wide) RT WRITES delays and commands
#define SL553_PORT_EDBG_LPFR    (3)  // Output: =1 if FIFO may be written at the moment, clears one clock after "xx_data_out_en"
#define SL553_PORT_EDBG_HPFR    (2)  // Output: =1 if FIFO may be written at the moment, clears one clock after "xx_data_out_en"
#define SL553_PORT_EDBG_EBSY    (1)  // Output: =1 if data is currently been transmitted or FIFO not empty - ENCODING IN PROCESS
#define SL553_PORT_EDBG_EPSE    (0)  // Output: =1 if output state machine is in "pause" state

// Decoder debug selector (source SL553_PORT_DBGSEL_SRCDEC) 0x20
#define SL553_PORT_DDBG_DARQ    (0x1F)  // =1 if data arrived and latched in r_da_data = COMPLETE DECODING DATA FOR RT bus A
#define SL553_PORT_DDBG_DBRQ    (0x1E)  // =1 if data arrived and latched in r_db_data bus B
#define SL553_PORT_DDBG_DACL    (0x1D)  // =1 when da_data_req should be cleared = RT RECEIVES DATA
#define SL553_PORT_DDBG_DBCL    (0x1C)  // =1 when db_data_req should be cleared
#define SL553_PORT_DDBG_DARE    (0x1B)  // =1 if data arrived before previous was processed = OVERRUN
#define SL553_PORT_DDBG_DBRE    (0x1A)  // =1 if data arrived before previous was processed
#define SL553_PORT_DDBG_DABE    (0x19)  // Data error was detected on bus A
#define SL553_PORT_DDBG_DBBE    (0x18)  // Data error was detected on bus B
#define SL553_PORT_DDBG_DAIE    (0x17)  // Bit timing error was detected on bus A
#define SL553_PORT_DDBG_DBIE    (0x16)  // Bit timing error was detected on bus B
#define SL553_PORT_DDBG_DABY    (0x15)  // =1 if decoder A is busy receiving
#define SL553_PORT_DDBG_DBBY    (0x14)  // =1 if decoder B is busy receiving
// .. decoder low-level errors - for the bus monitor
#define SL553_PORT_DDBG_MAIA    (0x13)  // =1 when Bus A is in IDLE state = FOR RT AND BM
#define SL553_PORT_DDBG_MAIB    (0x12)  // =1 when Bus B is in IDLE state
#define SL553_PORT_DDBG_MARQ    (0x11)  // =1 if data arrived and latched in r_da_data = BM COMPLETES DECODING
#define SL553_PORT_DDBG_MBRQ    (0x10)  // =1 if data arrived and latched in r_db_data
#define SL553_PORT_DDBG_MACL    (0xF)   // =1 when da_data_req should be cleared = BM RECEIVES DATA
#define SL553_PORT_DDBG_MBCL    (0xE)   // =1 when db_data_req should be cleared
#define SL553_PORT_DDBG_MAPE    (0xD)   // decoder A =1 if parity error was detected ---- DECODER ERRORS IN BM ----vvvv
#define SL553_PORT_DDBG_MBPE    (0xC)   // decoder B =1 if parity error was detected
#define SL553_PORT_DDBG_MADE    (0xB)   // decoder A =1 if error detected during data bits reception
#define SL553_PORT_DDBG_MBDE    (0xA)   // decoder B =1 if error detected during data bits reception
#define SL553_PORT_DDBG_MASE    (0x9)   // decoder A =1 if error detected during SYNC bit reception
#define SL553_PORT_DDBG_MBSE    (0x8)   // decoder B =1 if error detected during SYNC bit reception
#define SL553_PORT_DDBG_MATE    (0x7)   // decoder A =1 if invalid combination is detected (in_pos <> !in_neg) ~ 150nS after zero crossing
#define SL553_PORT_DDBG_MBTE    (0x6)   // decoder B =1 if invalid combination is detected (in_pos <> !in_neg) ~ 150nS after zero crossing

// For the decoder R1
#define SL553_PORT_DDBG_MAST    (0x5)   // decoder A =1 if edge-edge timing is invalid for the SYNC bit
#define SL553_PORT_DDBG_MBST    (0x4)   // decoder B =1 if edge-edge timing is invalid for the SYNC bit
#define SL553_PORT_DDBG_MADT    (0x3)   // decoder A =1 if edge-edge timing is invalid for the data bit
#define SL553_PORT_DDBG_MBDT    (0x2)   // decoder B =1 if edge-edge timing is invalid for the data bit
#define SL553_PORT_DDBG_MATO    (0x1)   // decoder A =1 if timeout is detected while waiting for the edge on in_pos/in_neg
#define SL553_PORT_DDBG_MBTO    (0x0)   // decoder B =1 if timeout is detected while waiting for the edge on in_pos/in_neg

// For the decoder R2
#define SL553_PORT_DDBG_DAPE    (0x5)   // decoder A restored "in_pos" (from R2 decoder only)
#define SL553_PORT_DDBG_DBPE    (0x4)   // decoder B restored "in_pos" (from R2 decoder only)
#define SL553_PORT_DDBG_DAIS    (0x3)   // Decoder A 1-clock wide strobe when idle is detected by the stuck input
#define SL553_PORT_DDBG_DBIS    (0x2)   // Decoder B 1-clock wide strobe when idle is detected by the stuck input
#define SL553_PORT_DDBG_DAIZ    (0x1)   // Decoder A 1-clock wide strobe when idle is detected by the zero on the bus
#define SL553_PORT_DDBG_DBIZ    (0x0)   // Decoder B 1-clock wide strobe when idle is detected by the zero on the bus

// RT debug selector (source SL553_PORT_DBGSEL_SRCRT) 0x40
#define SL553_PORT_RDBG_RTCB    (0x7)     // Current bus of the RT state machine (0=bus A)
#define SL553_PORT_RDBG_RTWC    (0x6)     // =1 - RT state machine waits for command
#define SL553_PORT_RDBG_RRTC    (0x5)     // =1 - Reset remote terminal command received and accepted
#define SL553_PORT_RDBG_ILCM    (0x4)     // =1 - Illegal command
#define SL553_PORT_RDBG_MERR    (0x3)     // =1 - Message error
#define SL553_PORT_RDBG_TMDW    (0x2)     // =1 - Too many words were detected in RX message
#define SL553_PORT_RDBG_TFDW    (0x1)     // =1 - Too few words were detected inm RX message
#define SL553_PORT_RDBG_RTTR    (0x0)     // Trigger strobe output from RT

// BM debug selector (source SL553_PORT_DBGSEL_SRCBM) 0x60
#define SL553_PORT_MDBG_BMBA    (0x8)     // =1 when current bus that drives BM is BUS_A (NOTE: inverted)
#define SL553_PORT_MDBG_BMFF    (0x7)     // =1 when RX FIFO is full
#define SL553_PORT_MDBG_BMHF    (0x6)     // =1 when #of samples in the RX FIFO is above watermark
#define SL553_PORT_MDBG_BMDW    (0x5)     // =1 if BM is waiting for the data from the decoder = IDLE
#define SL553_PORT_MDBG_BMMP    (0x4)     // =1 if BM is receiving 1553 message
#define SL553_PORT_MDBG_BMCW    (0x3)     // =1 if BM is writing command to the RX FIFO ---- phases of BM transaction ----vvvv
#define SL553_PORT_MDBG_BMWF    (0x2)     // =1 if BM is writing data to the RX FIFO
#define SL553_PORT_MDBG_BMTW    (0x1)     // =1 if BM is writing timestamp to the RX FIFO
#define SL553_PORT_MDBG_BMIW    (0x0)     // =1 if BM is writing idle token to the RX FIFO

// BC debug selector (source SL553_PORT_DBGSEL_SRCBC) 0x80
#define SL553_PORT_BDBG_BWRC    (0x19)    // =1 if BC state machine waits for the minor frame clock
#define SL553_PORT_BDBG_BWMC    (0x18)    // =1 if BC state machine waits for the major frame clock

// Communication with 1553 encoder
#define SL553_PORT_BDBG_HPFW    (0x17)    // "enc_hp_data" is ready for the encoder strobe (1-clock wide)
#define SL553_PORT_BDBG_ENEA    (0x16)    // Enable encoder A from the state machine
#define SL553_PORT_BDBG_ENEB    (0x15)    // Enable encoder B from the state machine

// Communication with 1553 decoder
#define SL553_PORT_BDBG_DABY    (0x14)    // =1 if decoder A is busy receiving
#define SL553_PORT_BDBG_DBBY    (0x13)    // =1 if decoder B is busy receiving
#define SL553_PORT_BDBG_BARQ    (0x12)    // =1 if data arrived and latched in dec_pdcda
#define SL553_PORT_BDBG_BBRQ    (0x11)    // =1 if data arrived and latched in dec_pdcdb
#define SL553_PORT_BDBG_DARE    (0x10)    // =1 if data arrived before previous data was processed
#define SL553_PORT_BDBG_DBRE    (0xF)     // =1 if data arrived before previous data was processed
#define SL553_PORT_BDBG_DNBR    (0xE)     // Bus where last valid command was received
#define SL553_PORT_BDBG_BBIA    (0xD)     // =1 if bus is currently is in idle state
#define SL553_PORT_BDBG_BBIB    (0xC)     // =1 if bus is currently is in idle state
#define SL553_PORT_BDBG_CBER    (0xB)     // =1 - Decoder detected bus/bit timing error on currently processed by RT bus
#define SL553_PORT_BDBG_BCCB    (0xA)     // Bus (BUS1553_A/BUS1553_B) that is currently processed by the main state machine
#define SL553_PORT_BDBG_DACL    (0x9)     // =1 when dec_pdcda_req should be cleared from BC SM
#define SL553_PORT_BDBG_DBCL    (0x8)     // =1 when dec_pdcdb_req should be cleared from BC SM

// Bus controller additional settings
#define SL553_PORT_BDBG_WRBS    (0x7)     // Status bit for PSTS - response received on the wrong bus
#define SL553_PORT_BDBG_INRT    (0x6)     // Status bit for PSTS - response received from incorrect RT
#define SL553_PORT_BDBG_TMDW    (0x5)     // Status bit for PSTS - too many words received from RT
#define SL553_PORT_BDBG_TFDW    (0x4)     // Status bit for PSTS - few many words received from RT
#define SL553_PORT_BDBG_BMAS    (0x3)     // =1 while bus is driven by the data that was sent by the BC
#define SL553_PORT_BDBG_BCTO    (0x2)     // Maximum 1553 access time exceeded
#define SL553_PORT_BDBG_BADI    (0x1)     // Bus activity is detected while in wait for clock (idle) state
#define SL553_PORT_BDBG_M708    (0x0)     // =1 if BC is configured to work in ARINC-708 mode

// Memory access bits - validation memory (0x3000-0x30FC in RT section of the FPGA)
#define SL553_MEMVAL_LB_EN          (1L<<30)    // =1 to loopback this Rx to Tx
#define SL553_MEMVAL_ERRI           (1L<<29)    // =1 inject error into the 1553 traffic based on the error
                                                // inject error into the traffic for this RT/SA. Code is in bits 0..9
#define SL553_MEMVAL_MD_TX_DW       (1L<<28)    // =1 when mode data word is expected and T/R_N bit set to 1

#define SL553_MEMVAL_MD_RX_DW       (1L<<27)    // =1 when mode data word is expected and T/R_N bit set to 0
#define SL553_MEMVAL_MD_IRQ_EN      (1L<<26)    // Issue IRQ when corresponding mode command received
#define SL553_MEMVAL_MD_TX_EN       (1L<<25)    // Enable corresponding mode command with T/R_N bit set to 1
#define SL553_MEMVAL_MD_RX_EN       (1L<<24)    // Enable corresponding mode command with T/R_N bit set to 0

#define SL553_MEMVAL_TX_IRQ_EN      (1L<<23)    // Enable TX IRQ on the selected subaddress
#define SL553_MEMVAL_RX_IRQ_EN      (1L<<22)    // Enable RX IRQ on the selected subaddress
#define SL553_MEMVAL_TX_EN          (1L<<21)    // Enable TX on the selected subaddress
#define SL553_MEMVAL_RX_EN          (1L<<20)    // Enable RX on the selected subaddress

#define SL553_MEMVAL_TX_WCMAX_MSB   (1L<<19)    // Maximum word count for the TX
#define SL553_MEMVAL_TX_WCMAX_LSB   (1L<<15)    // 0=32; 1-31=1-31
#define SL553_MEMVAL_TX_WCMIN_MSB   (1L<<14)    // Minimum word count for the TX
#define SL553_MEMVAL_TX_WCMIN_LSB   (1L<<10)    // 0=32; 1-31=1-31
#define SL553_MEMVAL_RX_WCMAX_MSB   (1L<<9)     // Maximum word count for the RX
#define SL553_MEMVAL_RX_WCMAX_LSB   (1L<<5)     // 0=32; 1-31=1-31
#define SL553_MEMVAL_RX_WCMIN_MSB   (1L<<4)     // Minimum word count for the RX
#define SL553_MEMVAL_RX_WCMIN_LSB   (1L<<0)     // 0=32; 1-31=1-31


// code provided in the bits 9-0. Note that when ERRI is set
// RX word count control is disabled
#define SL553_MEMVAL_ERR_BSYDE    (1L<<10) // Do not suppress data reply when busy bit is set (logic 14.44+)
#define SL553_MEMVAL_ERR_INHB     (1L<<9)  // Inhibit bus B (ignore RX, no TX)
#define SL553_MEMVAL_ERR_INHA     (1L<<8)  // Inhibit bus A (ignore RX, no TX)
#define SL553_MEMVAL_ERR_ER       (1L<<7)  // Inject early response (set 1/2 normal response time)
#define SL553_MEMVAL_ERR_LR       (1L<<6)  // Inject Late response (set 2x normal response time )
#define SL553_MEMVAL_ERR_NR       (1L<<5)  // Inject No response (suppress TX)
#define SL553_MEMVAL_ERR_WB       (1L<<4)  // Inject Response on the wrong bus
#define SL553_MEMVAL_ERR_TMW      (1L<<3)  // Inject Too many words (add one word)
#define SL553_MEMVAL_ERR_TFW      (1L<<2)  // Inject Too few words (subtract one word)
#define SL553_MEMVAL_ERR_DPE      (1L<<1)  // Inject Data parity error
#define SL553_MEMVAL_ERR_SPE      (1L<<0)  // Inject status parity error


// Valid RT and Mode commands for command word
#define CMD1553_MD_DBC              (0x0)       // T    Dynamic bus control
#define CMD1553_MD_SYNC             (0x1)       // T    Synchronize
#define CMD1553_MD_TST              (0x2)       // T    Transmit status word
#define CMD1553_MD_IST              (0x3)       // T    Initialize self-test
#define CMD1553_MD_TXD              (0x4)       // T    Transmitter shutdown (on opposite bus)
#define CMD1553_MD_OTXD             (0x5)       // T    Override transmitter shutdown (on opposite bus)
#define CMD1553_MD_ITFB             (0x6)       // T    Inhibit terminal flag bit
#define CMD1553_MD_OITFB            (0x7)       // T    Override inhibit terminal flag bit
#define CMD1553_MD_RRT              (0x8)       // T    Reset remote terminal
#define CMD1553_MD_TVW              (0x10)      // T+D  Transmit vector word
#define CMD1553_MD_SYNCD            (0x11)      // R+D  Synchronize with data word
#define CMD1553_MD_TLCW             (0x12)      // T+D  Transmit last command word
#define CMD1553_MD_TBIT             (0x13)      // T+D  Transmit BIT word
#define CMD1553_MD_STXD             (0x14)      // R+D  Selected transmitter shutdown
#define CMD1553_MD_OSTXD            (0x15)      // R+D  Override selected transmitter shutdown

#define CMD1553_RT_TX               (0x20)      // T+D    Transmit command
#define CMD1553_RT_RX               (0x21)      // R+D    Receive command
#define CMD1553_RT_RT               (0x22)      // R+T+D  RT-RT command
#define CMD1553_BROADCAST           (0x80)      // Broadcast modifyer

//    BC1553_BCB_FLAGS0        =    0,
// This word is used to set execution parameters for the current 1553 command sequence
#define BC1553_BCB_FLAGS0_IRQ       (1L<<15)    // =1 if interrupt should be requested immediately
                                                // upon completion of the execution of the current entry
#define BC1553_BCB_FLAGS0_BEN       (1L<<14)    // =1 - enable communication with RTs on Bus B
#define BC1553_BCB_FLAGS0_AEN       (1L<<13)    // =1 - enable communication with RTs on Bus A
#define BC1553_BCB_FLAGS0_EXW       (1L<<12)    // =1 - allow extended wait for response from the RT
                                                // (double maximum response time)
#define BC1553_BCB_FLAGS0_RSV11     (1L<<11)    // Reserved
#define BC1553_BCB_FLAGS0_RSV10     (1L<<10)    // Reserved
#define BC1553_BCB_FLAGS0_RSV9      (1L<<9)     // Reserved
#define BC1553_BCB_FLAGS0_SBUS      (1L<<8)     // Select "Start Bus" - bus that will be initially
                                                // used to communicate with RT (0=Bus A)
#define BC1553_BCB_FLAGS0_DTC       (1L<<7)     // =1 - check returned value of the data from RT
                                                // (compare with MIN and MAX value)
#define BC1553_BCB_FLAGS0_MDC       (1L<<6)     // =1 - check returned value of the mode data word
                                                // (apply AND/OR masks and compare with VAL value
#define BC1553_BCB_FLAGS0_STS2      (1L<<5)     // =1 - check returned value of the 2nd status word
                                                // (apply AND/OR masks and compare with VAL value
#define BC1553_BCB_FLAGS0_STS1      (1L<<4)     // =1 - check returned value of the first status word
                                                // (apply AND/OR masks and compare with VAL value
#define BC1553_BCB_FLAGS0_TT(N)     ((N)&0xf)   // Transfer type - selects one of the available
                                                // 1553 sequences (unlisted combinations are reserved):
                                                // and if used - will result in "Entry Error Flag"
// Transfer types
#define BC1553_BCB_TT_BCRT_1E       (1)         // 1 - BC-RT ("1e" sequence of the BC state machine)
#define BC1553_BCB_TT_RTBC_2B       (2)         // 2 - RT-BC ("2b" sequence of the BC state machine)
#define BC1553_BCB_TT_RTRT_3A       (3)         // 3 - RT-RT ("3a" sequence of the BC state machine)
#define BC1553_BCB_TT_MD_1A         (4)         // 4 - MODE W/O Data (TX) ("1a" sequence of the BC state machine)
#define BC1553_BCB_TT_MDTX_2A       (5)         // 5 - MODE W Data (TX) ("2a" sequence of the BC state machine)
#define BC1553_BCB_TT_MDRX_1C       (6)         // 6 - MODE W Data (RX) ("1c" sequence of the BC state machine)
#define BC1553_BCB_TT_BBCRT_1F      (7)         // 7 - Broadcast BC-RT ("1f" sequence of the BC state machine)
#define BC1553_BCB_TT_BRTRT_3B      (8)         // 8 - Broadcast RT-RT ("3b" sequence of the BC state machine)
#define BC1553_BCB_TT_BMD_1B        (9)         // 9 - Broadcast MODE W/O Data (TX) ("1b" sequence of the BC state machine)
#define BC1553_BCB_TT_BMDRX_1D      (10)        // 10 - Broabcast MODE W Data (TX) ("1d" sequence of the BC state machine)


//    BC1553_BCB_FLAGS1        =    1,
#define BC1553_BCB_FLAGS1_RSF       (1L<<15)    // Retry once within the same BCCB entry
#define BC1553_BCB_FLAGS1_IRT       (1L<<14)    // Retry on incorrect RT# in status
#define BC1553_BCB_FLAGS1_RUS       (1L<<13)    // Retry on unexpected status reception
#define BC1553_BCB_FLAGS1_RUD       (1L<<12)    // Retry on unexpected data reception
#define BC1553_BCB_FLAGS1_RWB       (1L<<11)    // Retry on wrong bus response
#define BC1553_BCB_FLAGS1_RIS       (1L<<10)    // Retry on illegal bits set in status
#define BC1553_BCB_FLAGS1_RBB       (1L<<9)     // Retry on busy bit in status
#define BC1553_BCB_FLAGS1_RTE       (1L<<8)     // Retry on bus timing error
#define BC1553_BCB_FLAGS1_RWC       (1L<<7)     // Retry on word count
#define BC1553_BCB_FLAGS1_RE        (1L<<6)     // Reenable command transmission on succesfull status reply
#define BC1553_BCB_FLAGS1_RNR       (1L<<5)     // Retry on no-response
#define BC1553_BCB_FLAGS1_ERE       (1L<<4)     // Enable re-transmit on alternative bus each retry
#define BC1553_BCB_FLAGS1_ESR       (1L<<3)     // Enable periodic status request command when retry
                                                // count reached maximum allowable limit
#define BC1553_BCB_FLAGS1_ERRC(N)   ((N)&7)     // Specify maximum number of retry attempts

// BC1553_BCB_FLAGS2
#define BC1553_BCB_FLAGS2_ENABLE    (1L<<15)    // Enable counter delay
#define BC1553_BCB_FLAGS2_DELAY(N)  ((N)&0x7fff)// Delay before executing BCCB

//    BC1553_BCB_ERRSTS0        =    86,
// Holds status of the entry processing, written by the BC state machine
#define BC1553_BCB_ERRSTS0_CB       (1L<<15)    // Status : Current bus (0 = Bus A)
#define BC1553_BCB_ERRSTS0_RSV14    (1L<<14)    // Reserved, use as needed
#define BC1553_BCB_ERRSTS0_PD       (1L<<13)    // Error : descriptor is permanently disabled
#define BC1553_BCB_ERRSTS0_S1B      (1L<<12)    // Warning : Status 1 RT responded with BUSY
#define BC1553_BCB_ERRSTS0_S2B      (1L<<11)    // Warning : Status 2 RT responded with BUSY
#define BC1553_BCB_ERRSTS0_BNR      (1L<<10)    // Error : No response from bus
#define BC1553_BCB_ERRSTS0_RCR      (1L<<9)     // Error : Retry count reached (clear to re-start)
#define BC1553_BCB_ERRSTS0_WBR      (1L<<8)     // Error : Response received on the wrong bus (also will set WBR bit in PORT_STS)
#define BC1553_BCB_ERRSTS0_IRT      (1L<<7)     // Error : Incorrect RT responded (also will set IRT bit in PORT_STS)
#define BC1553_BCB_ERRSTS0_LR       (1L<<6)     // Warning : Late response
#define BC1553_BCB_ERRSTS0_ER       (1L<<5)     // Error : Early response
#define BC1553_BCB_ERRSTS0_S2F      (1L<<4)     // Error : Status 2 compare failed
#define BC1553_BCB_ERRSTS0_S1F      (1L<<3)     // Error : Status 1 compare failed
#define BC1553_BCB_ERRSTS0_DCF      (1L<<2)     // Error : Data compare failed
#define BC1553_BCB_ERRSTS0_TFW      (1L<<1)     // Error : Too few words received (also will set TFW bit in PORT_STS)
#define BC1553_BCB_ERRSTS0_TMW      (1L<<0)     // Error : Too many words received (also will set TMW bit in PORT_STS)


//    BC1553_BCB_ERRSTS1        =    87,
// Holds Last Error Source code - position in the BC state machine that raises an error
#define BC1553_BCB_ERRSTS1_0000     (0x00)      // No error
#define BC1553_BCB_ERRSTS1_0001     (0x01)      // Reserved
#define BC1553_BCB_ERRSTS1_0002     (0x02)      // BC_MNR_MEM_WAIT - memory timeout
#define BC1553_BCB_ERRSTS1_0003     (0x03)      // BC_MNR_STS1_CHECK - wrong RT responded
#define BC1553_BCB_ERRSTS1_0004     (0x04)      // BC_MNR_STATE_PROCEED - both buses A/B are enabled or disabled
#define BC1553_BCB_ERRSTS1_0005     (0x05)      // BC_MNR_CMD1_PUT - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_0006     (0x06)      // BC_MNR_CMD1_WAIT - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_0007     (0x07)      // BC_MNR_CMD2_PUT - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_0008     (0x08)      // BC_MNR_CMD2_WAIT - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_0009     (0x09)      // BC_MNR_DATA_BCRT_NEXT - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_000A     (0x0A)      // BC_MNR_STS1_WAIT - Data received while waiting for the status
#define BC1553_BCB_ERRSTS1_000B     (0x0B)      // BC_MNR_STS1_WAIT - Data/command received on the wrong bus
#define BC1553_BCB_ERRSTS1_000C     (0x0C)      // BC_MNR_STS1_WAIT - Bus timing error
#define BC1553_BCB_ERRSTS1_000D     (0x0D)      // BC_MNR_STS1_VALID - RT in Error State Replied with status
#define BC1553_BCB_ERRSTS1_000E     (0x0E)      // BC_MNR_STS1_VALID - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_000F     (0x0F)      // BC_MNR_DATA_RTBC_WAIT - Status received while waiting for the data
#define BC1553_BCB_ERRSTS1_0010     (0x10)      // BC_MNR_DATA_RTBC_WAIT - Data/command received on the wrong bus
#define BC1553_BCB_ERRSTS1_0011     (0x11)      // BC_MNR_DATA_RTBC_WAIT - Bus timing error
#define BC1553_BCB_ERRSTS1_0012     (0x12)      // BC_MNR_DATA_RTBC_CHECK - For the Mode with data - verification failed against expected value
#define BC1553_BCB_ERRSTS1_0013     (0x13)      // BC_MNR_DATA_RTBC_CHECK - For the MIN/MAX verification - verification failed
#define BC1553_BCB_ERRSTS1_0014     (0x14)      // BC_MNR_DATA_RTBC_CHECK - more then 32 data words received
#define BC1553_BCB_ERRSTS1_0015     (0x15)      // BC_MNR_DATA_RTBC_IDLE - too many data words received
#define BC1553_BCB_ERRSTS1_0016     (0x16)      // BC_MNR_DATA_RTBC_IDLE - too few data words received
#define BC1553_BCB_ERRSTS1_0017     (0x17)      // BC_MNR_DATA_RTBC_VALIDATED - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_0018     (0x18)      // BC_MNR_STS2_WAIT - Data received while waiting for the status
#define BC1553_BCB_ERRSTS1_0019     (0x19)      // BC_MNR_STS2_WAIT - Data/command received on the wrong bus
#define BC1553_BCB_ERRSTS1_001A     (0x1A)      // BC_MNR_STS2_WAIT - Bus timing error
#define BC1553_BCB_ERRSTS1_001B     (0x1B)      // BC_MNR_STS2_VALID - Illegal value in the BC transfer type field
#define BC1553_BCB_ERRSTS1_001C     (0x1C)      // BC_MNR_CMD1_PUT - Bus not in idle state
#define BC1553_BCB_ERRSTS1_001D     (0x1D)      // BC_MNR_STS1_IDLE_WAIT - Data/command received on the wrong bus
#define BC1553_BCB_ERRSTS1_001E     (0x1E)      // BC_MNR_MEM_WAIT - Memory timeout detected
#define BC1553_BCB_ERRSTS1_001F     (0x1F)      // BC_MNR_STS1_WAIT - RT did not reply within late response timeout period
#define BC1553_BCB_ERRSTS1_0020     (0x20)      // BC_MNR_STS1_WAIT - RT reply too early
#define BC1553_BCB_ERRSTS1_0021     (0x21)      // BC_MNR_STS1_WAIT - RT reply too late
#define BC1553_BCB_ERRSTS1_0022     (0x22)      // BC_MNR_STS1_INVALID - recovery disabled on invalid bits in status 1
#define BC1553_BCB_ERRSTS1_0023     (0x23)      // BC_MNR_STS1_INVALID - recovery disabled on busy bit in status 1
#define BC1553_BCB_ERRSTS1_0024     (0x24)      // BC_MNR_STS1_INVALID - non-recoverable bits in status 1
#define BC1553_BCB_ERRSTS1_0025     (0x25)      // BC_MNR_STS2_INVALID - recovery disabled on invalid bits in status 2
#define BC1553_BCB_ERRSTS1_0026     (0x26)      // BC_MNR_STS2_INVALID - recovery disabled on busy bit in status 2
#define BC1553_BCB_ERRSTS1_0027     (0x27)      // BC_MNR_STS2_INVALID - non-recoverable bits in status 2
#define BC1553_BCB_ERRSTS1_0028     (0x28)      // BC_MNR_STS2_WAIT - no response
#define BC1553_BCB_ERRSTS1_0029     (0x29)      // BC_MNR_STS2_WAIT - early response
#define BC1553_BCB_ERRSTS1_002A     (0x2A)      // BC_MNR_STS2_CHECK - wrong RT responded
#define BC1553_BCB_ERRSTS1_002B     (0x2B)      // BC_MNR_CMD1_PUT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_002C     (0x2C)      // BC_MNR_CMD2_PUT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_002D     (0x2D)      // BC_MNR_DATA_BCRT_PUT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_002E     (0x2E)      // BC_MNR_STS1_IDLE_WAIT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_002F     (0x2F)      // BC_MNR_STS1_WAIT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0030     (0x30)      // BC_MNR_DATA_RTBC_WAIT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0031     (0x31)      // BC_MNR_STS2_WAIT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0032     (0x32)      // BC_MNR_BUS_IDLE_WAIT - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0033     (0x33)      // BC_MNR_BUS_IDLE_OK - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0034     (0x34)      // BC_MNR_BUS_IDLE_ENC_DONE - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0035     (0x35)      // BC_MNR_DESC_START - maximum 1553 access time exceeded
#define BC1553_BCB_ERRSTS1_0036     (0x36)      // BC_MNR_MEM_REQUEST - memory timeout detected
#define BC1553_BCB_ERRSTS1_0037     (0x37)      // BC_MNR_STS1_WAIT - data/command received on the wrong bus

// Bits [11:8] provide additional info and ORed with bits [15:12] and [7:0]
#define BC1553_BCB_ERRSTS1_0100     (0x100)     // BC_MNR_ERR_UNEXP_DATA - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0200     (0x200)     // BC_MNR_ERR_UNEXP_STS - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0300     (0x300)     // BC_MNR_ERR_WRONG_BUS - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0400     (0x400)     // BC_MNR_ERR_MEM_TO - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0500     (0x500)     // BC_MNR_BUS_ERROR - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0600     (0x600)     // BC_MNR_ERR_NO_RESPONSE - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0700     (0x700)     // BC_MNR_ERR_BAD_CMD - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0800     (0x800)     // BC_MNR_ERR_TOO_MANY - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0900     (0x900)     // BC_MNR_ERR_TOO_FEW - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0A00     (0xA00)     // BC_MNR_RECOVERY_CHECK - Recovery disabled, entry will be disabled permanently
#define BC1553_BCB_ERRSTS1_0B00     (0xB00)     // BC_MNR_BUS_IDLE_CHECK - Bus is not in idle state
#define BC1553_BCB_ERRSTS1_0C00     (0xC00)     // BC_MNR_ERR_WRONG_RT - Response received from the incorrect RT
#define BC1553_BCB_ERRSTS1_0D00     (0xD00)     // BC_MNR_TO_ERROR - Maximum 1553 access time exceeded

// Bits [15:12] provide global error flags and when set - ORed with rest of the error bits
#define BC1553_BCB_ERRSTS1_8000     (0x8000)    // BC_MNR_STATE_DISABLED - entry permanently disabled due to previous error

//  Report current execution status of the bus controller (0x21A4)
#define SL553_PORT_BCSTS_BSY        (1L<<31)    // =1 if BC not in IDLE or WAIT_CLOCK states
#define SL553_PORT_BCSTS_RSV30      (1L<<30)    // Reserved
#define SL553_PORT_BCSTS_RSV29      (1L<<29)    // Reserved
#define SL553_PORT_BCSTS_RSV28      (1L<<28)    // Reserved
#define SL553_PORT_BCSTS_MRF3       (1L<<27)    // Reports ID for the currently processed
#define SL553_PORT_BCSTS_MRF0       (1L<<24)    // minor frame
#define SL553_PORT_BCSTS_DSC7       (1L<<23)    // Reports ID for the currently processed
#define SL553_PORT_BCSTS_DSC0       (1L<<16)    // descriptor minor frame
                                                // 12-0 are sticky bits) auto-cleared
#define SL553_PORT_BCSTS_BIR        (1L<<12)    // Response received from incorrect RT
#define SL553_PORT_BCSTS_BTO        (1L<<11)    // Maximum 1553 access time exceeded
#define SL553_PORT_BCSTS_BAD        (1L<<10)    // Bus activity is detected while in wait for clock (idle) state
#define SL553_PORT_BCSTS_BWB        (1L<<9)     // Response received on the wrong bus
#define SL553_PORT_BCSTS_BCO        (1L<<8)     // BC overrun - major/minor frame clock called in non-idle state
#define SL553_PORT_BCSTS_HBT        (1L<<7)     // Heartbeat - set to one at the beginning of each minor frame
#define SL553_PORT_BCSTS_MTD        (1L<<6)     // Memory access timeout was detected (hardware error)
#define SL553_PORT_BCSTS_RTR        (1L<<5)     // At least one RT in "dead" state replied with valid status
#define SL553_PORT_BCSTS_MF         (1L<<4)     // At least one Mode command w/o data word failed
#define SL553_PORT_BCSTS_MRBF       (1L<<3)     // At least one Mode TX command with data word failed
#define SL553_PORT_BCSTS_MBRF       (1L<<2)     // At least one Mode RX command with data word failed
#define SL553_PORT_BCSTS_RBF        (1L<<1)     // At least one RT->BC transmission failed
#define SL553_PORT_BCSTS_BRF        (1L<<0)     // At least one BC->RT transmission failed

#define SL553_PORT_BCSTS_MRF(S)     (((S)&0xf000000)>>24)  // processed minor frame
#define SL553_PORT_BCSTS_DSC(S)     (((S)&0xff0000)>>16)   // processed descriptor in minor frame

#define SL553_PORT_BCSWAP_MNF(MASK) ((MASK)&0xffff)  // set minor frame types to swap on the following cycle

// The following are helper macros to extract information from pEv553->data[0] and ->data[1] of EV553_BC_IRQ event
// For pEv553->data[0] (content of SL553_PORT_BCISRC register)
#define SL553_BCISRC_GET_MN_REC_N(N)      ((0x0000ff &(N))>>0)   // Reports record # inside of the minor frame descriptor table when interrupt was requested
#define SL553_BCISRC_GET_MJ_REC_N(N)      ((0x00ff00 &(N))>>8)   // Reports record # inside of the major frame descriptor table when interrupt was requested
#define SL553_BCISRC_GET_MN_ID_N(N)       ((0xff0000 &(N))>>16)  //  Reports ID for the minor frame that was processed when interrupt was requested

// For pEv553->data[1] (content of SL553_PORT_BCERR register)
#define SL553_BCERR_GET_MN_REC_N(N)      ((0x0000ff &(N))>>0)    // Reports record # inside of the minor frame descriptor table when error was requested
#define SL553_BCERR_GET_MJ_REC_N(N)      ((0x00ff00 &(N))>>8)    // Reports record # inside of the major frame descriptor table when error was requested
#define SL553_BCERR_GET_ERR_CODE(N)      ((0xffff0000 &(N))>>16)  // A copy of error code from BCCB BC1553_BCB_ERRSTS1


//    SL553_PORT_BCGT   (0x21D0)  // R/W: write - GOTO selection
#define SL553_PORT_BCGT_CMD(N)          (((N)&0xf)<<28) // command
#define SL553_PORT_BCGT_CMD_BCB_NORET   (0L<<28)// goto after BCCB - no return (continue)
#define SL553_PORT_BCGT_CMD_MNF_NORET   (1L<<28)// goto after minor frame - no return (continue)
#define SL553_PORT_BCGT_CMD_BCB_BCB     (2L<<28)// goto after BCCB - return after BCCB
#define SL553_PORT_BCGT_CMD_MNF_BCB     (3L<<28)// goto after minor frame - return after BCCB
#define SL553_PORT_BCGT_CMD_BCB_MNF     (4L<<28)// goto after BCCB - return after minor frame
#define SL553_PORT_BCGT_CMD_MNF_MNF     (5L<<28)// goto after minor frame - return after minor frame

#define SL553_PORT_BCGT_MNFD(N)     (((N)&0xff)<<8) // minor frame descriptor index for the GOTO command
#define SL553_PORT_BCGT_MJFD(N)     (((N)&0xff)<<0) // major frame descriptor index for the GOTO command

//    SL553_PORT_BCPOS  (0x21D4)  // R/W: read - current MN/MJ index and stored GOTO position
#define SL553_PORT_BCPOS_GP         (1L<<31)    // =1 if return from GOTO is pending
#define SL553_PORT_BCPOS_GET_GMNFD(N)   (((N)>>24)&0xff)    // returns stored MN return-to GOTO command position
#define SL553_PORT_BCPOS_GET_GMJFD(N)   (((N)>>16)&0xff)    // returns stored MJ return-to GOTO command position
#define SL553_PORT_BCPOS_CUR_BLOCK(N)   (((N)>>15)&0x1)     // returns current MN block
#define SL553_PORT_BCPOS_CUR_MNFD(N)    (((N)>>8)&0x7f)     // returns current MN position (top bit is block)
#define SL553_PORT_BCPOS_CUR_MJFD(N)    (((N)>>0)&0xff)     // returns current MJ position

// Status request
#define DQ_SL553_BC_DATA            (1L<<12)    // BCCB data (write data/read status)
#define DQ_SL553_BC_STATUS          (2L<<12)    // BCCB (read status/write control)
#define DQ_SL553_BC_BC_STATUS       (3L<<12)    // BC status word
#define DQ_SL553_BC_BUSMON          (4L<<12)    // Bus monitor access (write)
#define DQ_SL553_BC_MN_DESC         (5L<<12)    // MN descriptor (read/write)
#define DQ_SL553_BC_MJ_DESC         (6L<<12)    // MJ descriptor (read/write)
#define DQ_SL553_BC_TYPE            (0x7<<12)   // mask

// VMap for BC operations
#define DQ_SL553_BC_VMAP_DATA       (1L)        // BCCB data (write BCCB_Control data/read BCCB_Status)
#define DQ_SL553_BC_VMAP_STATUS     (2L)        // BCCB (read status)
#define DQ_SL553_BC_VMAP_CONTROL    (2L)        // BCCB (write control)
#define DQ_SL553_BC_VMAP_BUSMON     (4L)        // Bus monitor access (write)
#define DQ_SL553_BC_VMAP_MN_DESC    (5L)        // MN descriptor (read/write)
#define DQ_SL553_BC_VMAP_MJ_DESC    (6L)        // MJ descriptor (read/write)

#define DQ_SL553_BC_VMAP(CH, TYPE, MN, BLK, IDX)    ((((TYPE)&0x7)<<13)|(((CH)&1)<<12)|(((MN)&0xf)<<8)|(((BLK)&0x1)<<7)|((IDX)&0x7f))
#define DQ_SL553_BC_GET_MN(N)       (((N)>>8)&0xf)  // get MN field
#define DQ_SL553_BC_GET_IDX(N)      (((N))&0xff)    // get IDX field
#define DQ_SL553_BC_GET_TYPE(N)     (((N)>>13)&0x7) // get request type
#define DQ_SL553_BC_GET_CHAN(N)     (((N)>>12)&0x1) // get channel number
#define DQ_SL553_BC_GET_MNBLK(N)    (((N)>>7)&0x1)  // get MN block number

#define SL553_CMDWORD_RT(C)         (((C)&0xf800)>>11)
#define SL553_CMDWORD_TR(C)         (((C)&0x0400)>>10)
#define SL553_CMDWORD_SA(C)         (((C)&0x03e0)>>5)
#define SL553_CMDWORD_WC(C)         (((C)&0x01f)>>0)

// For DQ_SL553_BC_STATUS use the followin modifiers in MN field
#define DQ_SL553_BC_STATUS_RQ(STS_TYPE, INDEX)    ((DQ_SL553_BC_STATUS)|(((STS_TYPE)&0xf)<<8)|((INDEX)&0xff))

#define DQ_SL553_BC_STATUS_BC       (1)         // return status of BC controllers (register 0x21A4)
#define DQ_SL553_BC_STATUS_MJ       (2)         // return status of MJ frame descriptor (index in IDX)
#define DQ_SL553_BC_STATUS_ISRC     (3)         // return interrupt sources included IDs when interrupt was requested
#define DQ_SL553_BC_STATUS_ERR      (4)         // return error source and frame IDs
#define DQ_SL553_BC_STATUS_PORT     (5)         // port status - overlaps with RT status (port status is one for BC, RT and BM)
#define DQ_SL553_BC_STATUS_BCPOS    (6)         // current MJ and MN position and GOTO status

#define DQ_L553_NAMELEN             (32)        // maximum length of the channel name (trailing 0 isn't included)

#define SL553_MEMVAL_TXEN           (1L<<21)    // SL553_MEMVAL_TX_EN
#define SL553_MEMVAL_RXEN           (1L<<20)    // SL553_MEMVAL_RX_EN

#define DQ_SL553_MEMVAL_RT          (SL553_MEMVAL_TXEN|SL553_MEMVAL_RXEN)

#pragma pack(1)
// channel names
typedef struct {
    char cname[DQ_L553_CHAN][DQ_L553_NAMELEN];
} DQCNAMES_553_, *pDQCNAMES_553_;

typedef struct {
    uint32 rxchlst[DQ_L553_CHAN_RX]; // channel list Rx
    uint32 txchlst[DQ_L553_CHAN_TX]; // channel list Tx
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_553_, *pDQOPMODEPRM_553_;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_553_, *pDQINITPRM_553_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_553_, *pDQSDOWNPRM_553_;

// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_553_ opmodeprm;
    DQINITPRM_553_ initprm;
    DQSDOWNPRM_553_ sdownprm;
    DQCNAMES_553_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_553_, *pDEVEEPROM_553_;

#pragma pack()


typedef enum _tSL553CommandType
{
    SL553CmdBCRT = 1,               // Remote terminal to receive data from bus controller
    SL553CmdRTBC,                   // Remote terminal to transmit data to bus controller
    SL553CmdRTRT,                   // One remote terminal to transmit data to another remote terminal
    SL553CmdModeTxNoData,           // Status word
    SL553CmdModeTxWithData,         // Remote terminal to transmit data and/or status word to bus controller
    SL553CmdModeRxWithData,         // Remote terminal to receive data for mode command from bus controller
    SL553CmdBCRTBroadcast,          // Remote terminal to receive broadcast data from bus controller
    SL553CmdRTRTBroadcast,          // One remote terminal to broadcast data to other remote terminal
    SL553CmdModeTxNoDataBroadcast,  // Mode command without data, remote terminals should not reply
    SL553CmdModeRxWithDataBroadcast // Mode command with data, remote terminals should receive data
} tSL553CommandType;

#define LUT553_ENTRIES  (16)

#define LUT553_FLAG_LUT_BY_CMD    (1L<<1) // compare for exact received command instead of look up for all statuses

typedef struct {
    uint32  flags;                      // behavior modifiers
    uint32  size;                       // Number of entries in the table
    uint8   rt[LUT553_ENTRIES];         // RT
    uint8   sa[LUT553_ENTRIES];         // SA
    uint8   wc[LUT553_ENTRIES];         // word count
    uint8   word[LUT553_ENTRIES];       // Word to check
    uint16  r_data[LUT553_ENTRIES];     // first BC-RT words to compare
    uint16  t_data[LUT553_ENTRIES][DQ_L553_MAX_WORDS]; // RT-BC words to replace with when BC-RT data matches r_data[]
} SL553CUST_LUT, *pSL553CUST_LUT;

#define DQ_L553_FILTSZ  (66)      // size of the filter list for simple RT/SA setup with DQ_L553_BM_AS_MASK bit set

#define DQ_AR566_CHAN               (6)         // 6 I/O chips
#define DQ_AR512_CHAN               (12)        // 12 Input only channels
#define DQ_AR566_CHAN_TX            (6)         // 6 transmitters maximum
#define DQ_AR566_CHAN_RX            (12)        // 12 receviers maximum
#define DQ_AR512_CHAN_TX            (0)         // 0 transmitters maximum
#define DQ_AR512_CHAN_RX            (12)        // 12 receviers maximum
#define DQ_AR566_INFOSZ             (DQ_MAX_INFO_SIZE)    // maximum size of information structure
#define DQ_AR566_BASE               (66000000)  // 66MHz base frequency
#define DQ_AR566_MAXCLFRQ           (2000)
#define DQ_AR566_MAXCVFRQ           (2000)

#define DQ_AR566_INTCLKUS           (100)       // Internal clock in uS for the scheduler
#define DQ_AR566_MAXDLYCNT          (65535)     // Maximum value for the delay counter

#define DQL_LCR516_SYNCD            DQL_LCR_SYNCD   // debug mode on
#define DQL_LCR566_LED              (1L<<1)         // switch LED on


// special channels
#define DQ_AR566_CH_MASK            0x0f        // regular channel mask
#define DQ_AR566_CH_CMDMASK         0xf0        // special channel mask
#define DQ_AR566_CH_RXFIFOAVL       0x20        // RX FIFO size available
#define DQ_AR566_CH_TXFIFOAVL       0x30        // TX FIFO size available
#define DQ_AR566_CH_SCHED           0x40        // scheduler table
#define DQ_AR566_CH_SCHDATA         0x50        // scheduler data
#define DQ_AR566_CH_FILTER          0x60        // filter table
#define DQ_AR566_CH_LASTDATA        0x70        // last data table


// FIFO sizes
#define AR566_TXFIFOSIZE            256         // Tx FIFO size
#define AR566_RXFIFOSIZE            256         // Rx FIFO size
#define AR566_LBLFILTSIZE           256         // Size of label filter
#define AR566_SCHEDSIZE             256         // Size of scheduler table
#define AR516_SCHEDSIZE             256         // Size of scheduler table
#define AR566_SCHEDDATASZ           256         // Size of scheduler data table
#define AR516_SCHEDDATASZ           256         // Size of scheduler data table

#define AR516_TXFIFOSIZE2k          2048        // Tx FIFO size (logic 14.62+)
#define AR516_RXFIFOSIZE2k          2048        // Rx FIFO size (logic 14.62+)

// User exposed channels
#define DQ_AR516_CHAN_TX            (16)
#define DQ_AR516_CHAN_RX            (24)
#define DQ_AR524_CHAN_TX            (0)
#define DQ_AR524_CHAN_RX            (24)

// Size of arrays to store channel configuration (user channel numbering)
#define DQ_AR516_TX_CHAN_INT        (16)
#define DQ_AR516_RX_CHAN_INT        (24)
#define DQ_AR516_RX_CHAN_BLK        (12)    // number of blocks of two Rx channels

// Logical channels: 0..15 for TX and 0..31 for RX
#define DQ_AR516_TX_CHAN_LOG        (16)
#define DQ_AR516_RX_CHAN_LOG        (32)
#define DQ_AR516_RX_CHAN0_LOG       (16)    // Block 0
#define DQ_AR516_RX_CHAN1_LOG       (16)    // Block 1

// For minor/major scheduler
#define DQ_AR516_MN_FRAMES          16          // Number of available minor frames
#define DQ_AR516_FRM_MASK(N)       (1L<<(N))    // Mask for the minor frame
//configuration settting for reset minor frame counters
#define DQ_AR516_RESETCOUNTER_ON_MAJORFRAME 0
#define DQ_AR516_RESETCOUNTER_AFTER_MAJORFRAME 1
#define DQ_AR516_FRM_CLK_CONFIG(N,setting)  ((1L << N) << (((setting) == DQ_AR516_RESETCOUNTER_ON_MAJORFRAME) ? 0 : 16)) // N = minor frame number

#pragma pack(1)

typedef struct {
    uint8   chnl;                   // channel
    uint32  data;                   // 1 - 32-bit samples
} DQMSG_566, *pDQMSG_566;

typedef struct {
    uint32 tstamp;                  // timestamp
    uint8  chnl;                    // channel
    uint32 data;                    // 1 - 32-bit samples
} DQMSG_566_L, *pDQMSG_566_L;

#pragma pack()

// for DQL_IOCTL566_SETCFG when ss = DQ_SS0OUT
#define DQ_AR_ENABLE_DIO0           (1L<<0)     // switch on DIO0
#define DQ_AR_ENABLE_DIO1           (1L<<1)     // switch on DIO1
#define DQ_AR_ENABLE_DIO2           (1L<<2)     // switch on DIO2

// for DQL_IOCTL566_FILTER
#define DQ_AR_SETFILTER_PUT         (1L<<0)     // change label entries
#define DQ_AR_SETFILTER_GET         (1L<<1)     // retrieve stored entries
#define DQ_AR_SETFILTER_FILL_TABLE  (1L<<4)     // fill scheduler table with provided data

#define DQ_AR_SETSCHED_PUT          (1L<<0)     // change scheduler entries
#define DQ_AR_SETSCHED_GET          (1L<<1)     // retrieve stored scheduler entries
#define DQ_AR_SETSCHED_DATA_ONLY    (1L<<2)     // access scheduler data only
#define DQ_AR_SETSCHED_FILL_TABLE   (1L<<4)     // fill scheduler table with provided data


#define DQ_AR_RXCTR_NDO             (1L<<8)     // copy only new data into the FIFO
#define DQ_AR_RXCTR_TRIG            (1L<<9)     // trigger scheduled entry with the same index for execution

// for DQL_IOCTL566_SETCHNL_CFG
//  a. rate control
#define DQ_AR_RATEHIGH              (1L<<0)
#define DQ_AR_RATELOW               (0)

//    b. Parity control
#define DQ_AR_PARITYODD             (1L<<1)     // odd parity
#define DQ_AR_PARITYEVEN            (1L<<2)     // even parity
#define DQ_AR_PARITYOFF             (0)         // no parity check/generation in hardware

//    c. SDI filtering
#define DQ_AR_SDI_ENABLED           (1L<<3)     // SDI filtering is enabled
#define DQ_AR_SDI_DISABLED          (0)         // SDI filtering is disabled

//    d. Extra Tx bit (reserved)
#define DQ_AR_XBIT_ENABLED          (1L<<4)     // enable extra transmission bit (N/A)
#define DQ_AR_XBIT_DISABLED         (0)

//    e. Few data bits (reserved)
#define DQ_AR_FEW_ENABLED           (1L<<5)     // transmit one too few data bits is enabled (N/A)
#define DQ_AR_FEW_DISABLED          (0)

//    f. Short gap Tx (reserved)
#define DQ_AR_SHORTGAP_ENABLED      (1L<<6)     // enable to transmit short gap (N/A)
#define DQ_AR_SHORTGAP_DISABLED     (0)

//    g. Rx Timestamp enabled
#define DQ_AR_TIMESTAMP_ENABLED     (1L<<7)     // write data packet into the receive FIFO along with the timestamp (older settings, use DQ_AR_ADD_TIMESTAMP instead)
#define DQ_AR_TIMESTAMP_DISABLED    (0)

//    h. Tx Slow slew rate enabled
#define DQ_AR_SLOWSLEW_ENABLED      (1L<<8)     // enable slow slew rate
#define DQ_AR_SLOWSLEW_DISABLED     (0)

//    i. SDI mask
#define DQ_AR_SDIMASK0              (1L<<9)
#define DQ_AR_SDIMASK1              (1L<<10)
#define DQ_AR_SDIMASKOFFSET         (9)

//    j. for Rx FIFO control (Rx only)
#define DQ_AR_LB_CHECK_PARITY       (1L<<12)    // include parity check into loopback comparo
#define DQ_AR_ADD_TIMESTAMP         (1L<<13)    // add timestamp into FIFO data

//    k. frame counter mode (Rx only)
#define DQ_FRCNT_COUNT_ALL          (0L<<14)    // count all frames
#define DQ_FRCNT_COUNT_GOOD         (1L<<14)    // only correcty received frames
#define DQ_FRCNT_COUNT_FIFO         (2L<<14)    // only placed into the FIFO
#define DQ_FRCNT_COUNT_TRIGGER      (3L<<14)    // count frames that triggered scheduler
#define DQ_FRCNT_COUNT_PAR_ERR      (4L<<14)    // count frames with parity error
#define DQ_FRCNT_COUNT_OFFSET       (14)

//    l. control zero label and FIFO priority behavior
#define DQ_AR_ALLOW_ZERO_LBL        (1L<<15)    // allow scheduler to output zero labels
#define DQ_AR_ALLOW_FIFO_HIGH       (1L<<16)    // set FIFO priority higher than scheduler

#define DQ_AR_IGNORE_BAD_DATA       (1L<<19)    // ignore data with parity errors
#define DQ_AR_TXFIFO_DELAY          (1L<<20)    // Tx FIFO data contains delay
                                                // FIFO data is structured as <N_words|delay><wordN>..<word0><N_words|delay>... 516-024 only

// for use in DQL_IOCTL566_CHANGE/DQL_IOCTL566_CHANGE_CHIPCFG case
// use this bit in <chan_mask> to apply changes for TXn or RXn only
#define DQ_AR_CHANGE_TX             (1L<<30)  // apply new settings to TX
#define DQ_AR_CHANGE_RX             (1L<<29)  // apply new settings to RX

// for DQL_IOCTL566_SCHED
#define DQ_AR_SCHED_PSDISABLED      (0)         // prescaler disabled
#define DQ_AR_SCHED_PS100us         (1L<<20)    // prescaler 100uS
#define DQ_AR_SCHED_PSTB0           (2L<<20)    // use timebase 0
#define DQ_AR_SCHED_PSTB1           (3L<<20)    // use timebase 1

#define DQ_AR_FIFO_TXREADY          (1L<<20)    // FIFO is paced by TX ready (alias for DQ_AR_FIFO_PSTB0)
#define DQ_AR_FIFO_PSTB0            (1L<<20)    // FIFO is paced by TX ready
#define DQ_AR_FIFO_PSTB1            (3L<<20)    // FIFO is paced by prescaler

#define DQ_AR_MASTER                (1L<<17)    // master entry. Master entry can be followed by multiple slave
#define DQ_AR_RECYCLE               (1L<<16)    // send this entry every time counter expires and then reload the counter (transmit packets periodically)

// for DQL_IOCTL566_WRITE_CHNL
#define DQ_AR_TxPRIORITY_HIGH       (1L<<0)     // high priority (preempt scheduler)
#define DQ_AR_TxPRIORITY_LOW        (1L<<1)     // low priority (send as scheduler permits)
#define DQ_AR_Tx_BLOCKING           (1L<<2)     // immediate return from the function

// for DQL_IOCTL566_READ_CHNL
#define DQ_AR_Rx_LATEST             (1L<<0)     // latest data from the interface
#define DQ_AR_Rx_FIFO               (1L<<1)     // sample from the FIFO, queued
#define DQ_AR_Rx_BLOCKING           (1L<<2)     // immediate return if no data

//
// for DQL_IOCTL566_STATUS - always, bits are cleared upon return, thus next request returns
// only error accumulated between these calls
//
// +0 - EISR bits:
//          [11..0]  - parity error for Rx11..Rx0
//          [17..12] - scheduler overrun error for Tx5..Tx0 (cannot output one or more entries on time)
//          [29..18] - loopback error for Rx11..Rx0 (loopback should be enabled)
//
// + if DQ_AR_STATUS_GET_TOTAL
//   4 bytes - frame count for requested channel
//
// + if DQ_AR_STATUS_GET_FRM_CTR:
//   48 bytes (12*4) frame counts for Rx0..Rx12
//
// + if DQ_AR_STATUS_GET_FRM_ERR:
//   48 bytes (12*4) number of loopback errors for Rx0..Rx12
//
// + if DQ_AR_STATUS_GET_FRM_MIS:
//   48 bytes (12*4) number of missed frames for Rx0..Rx12
//
#define DQ_AR_STATUS_CLEAR_ERROR    (1L<<0)     // clear sticky error flags (all channels together AR566_EISR)
#define DQ_AR_STATUS_CLEAR_COUNT    (1L<<1)     // clear Rx packet counter (for the channel)
#define DQ_AR_STATUS_GET_TOTAL      (1L<<2)     // get total number of packets received (for the channel)
#define DQ_AR_STATUS_GET_FRM_CTR    (1L<<3)     // get frame counter for Rx0..Rx12
#define DQ_AR_STATUS_GET_FRM_ERR    (1L<<4)     // get number of loopback errors for Rx0..Rx23
#define DQ_AR_STATUS_GET_FRM_MIS    (1L<<5)     // get number of missed frames for Rx0..Rx23
#define DQ_AR_STATUS_GET_FIFO_CNT   (1L<<6)     // get current levels in receive FIFOs Rx0..Rx23

// for DQL_IOCTL566_SETCHNL_CFG
#define DQ_AR_ENABLE_Tx             (1L<<8)     // enable transmit operations (Tx)
#define DQ_AR_ENABLE_Rx             (1L<<9)     // enable receive operations (Rx)
#define DQ_AR_ENABLE_SCHEDULER      (1L<<10)    // enable scheduler (Tx)
#define DQ_AR_ENABLE_LOOPBACK       (1L<<11)    // loopback validation of transmitted packets is enabled (Tx)
#define DQ_AR_ENABLE_FILTER         (1L<<12)    // enable receive operations (Rx)
#define DQ_AR_ENABLE_RxFIFO         (1L<<13)    // enable receive FIFO (Rx)
#define DQ_AR_ENABLE_TxFIFO         (1L<<14)    // enable transmit FIFO (Tx)
#define DQ_AR_LOGIC_LOOPBACK        (1L<<15)    // for internal logic tests (internal to HI-3282)
#define DQ_AR_SCHED_FRAMECLK        (1L<<16)    // switch scheduler into "frame clock" mode
#define DQ_AR_SCHED_SLAVETD         (1L<<17)    // allow slave entries to use "delay" field
#define DQ_AR_SCHED_MJMN            (1L<<18)    // tell scheduler to switch into major/minor clock mode

// for DQL_IOCTL566_SETCLK
#define DQ_AR_SCHEDULER_RATE        (0)
#define DQ_AR_FIFO_RATE             (1)

// ----------------------------------------------------------------------
// for DQL_IOCTL566_CHANGE: uint32 arg[1] - action, [0] configuration
#define DQL_IOCTL566_CHANGE_FINCLEAR  (0x1)     // clear input FIFO (can be combined with FOUTCLEAR)
#define DQL_IOCTL566_CHANGE_FOUTCLEAR (0x2)     // clear output FIFO (can be combined with FINCLEAR)
#define DQL_IOCTL566_CHANGE_FINFOUT   (0x3)     // both
#define DQL_IOCTL566_CHANGE_WORDLEN   (0x4)     // switch to a non-standard word for AR-516 (logics 14.C8+)
#define DQL_IOCTL566_CHANGE_PAUSE     (0x9)     // pause I/O and clear FIFO
#define DQL_IOCTL566_CHANGE_RESUME    (0xA)     // resume I/O
#define DQL_IOCTL566_CHANGE_CHIPCFG   (0xB)     // change HI-3282 chip configuration register

#define DQL_IOCTL566_CHANGE_3282_CLK  (0xC)     // change HI-3282 chip clock; base is 66MHz, default value is 32 = 2Mhz/2 = 1Mhz
                                                // possible range is [25..50]. Requires logic 11.48+
                                                // HI3282 default baud rate is 1Mhz which give at high speed=100kbaud+/-1% and
                                                // at low speed 12..14.5kbaud. Change in the frequency changes rate proportionally
#define DQL_IOCTL566_CHANGE_PAUSE_TX     (0xD)     // pause I/O and clear FIFO TX
#define DQL_IOCTL566_CHANGE_RESUME_TX    (0xE)     // resume I/O TX
#define DQL_IOCTL566_CHANGE_FRAME_RESET  (0xF)     // set frame reset functionality AR-516 (logics 14.CE+)

#define DQL_IOCTL566_CHANGE_3282_MIN   (25)     // minimum divider (66Mhz/25/2 = 1.32Mhz)
#define DQL_IOCTL566_CHANGE_3282_MAX   (55)     // maximum divider (66Mhz/50/2 = 0.66Mhz)



// 516 only
#define DQL_IOCTL516_CHANGE_RATE_MIN   (10000)  // minimum rate 10k baud
#define DQL_IOCTL516_CHANGE_RATE_MAX   (200000) // maximum rate 200k baud

// ----------------------------------------------------------------------
// for DQL_IOCTL566_SETTXPAGE: uint32 arg[1] - action, [0] configuration
#define DQ_AR_SETTXPAGE_IMMEDIATE     (0L<<0)   // change active scheduler block immediately
#define DQ_AR_SETTXPAGE_ONMF          (1L<<0)   // change active scheduler block on major frame clock

// ----------------------------------------------------------------------
// for DQL_IOCTL566_DIOCTRL: uint32 arg[1] - action, [0] configuration
#define DQL_IOCTL566_DIOCTRL_LBL_PULSE  (0x1)   // Pulse on selected label

#define DQL_L566_LBL_PULSE_EN       (1)     // enable pulse on a label
#define DQL_L566_LBL_PULSE_DIS      (0)     // disable pulse on a label
#define DQL_L566_LBL_DIO(N)         (((N)&1)<<2)    // state of DIO line when pulse is disabled
#define DQL_L566_LBL_CONT           (1L<<14) // Pulse repeatability (0=one-time,1=repeatable)
#define DQL_L566_LBL_POL            (1L<<13) // Pulse polarity (0=negative, 1=positive)

// ioctls

#define DQL_IOCTL566_SETCFG         (0x01L)     // sets a custom configuration
#define DQL_IOCTL566_READ_FIFO      (0x05L)     // read a channel FIFO
#define DQL_IOCTL566_WRITE_FIFO     (0x06L)     // write a channel FIFO
#define DQL_IOCTL566_READ_CHNL      (0x07L)     // read a channel packet
#define DQL_IOCTL566_WRITE_CHNL     (0x08L)     // write a channel packet
#define DQL_IOCTL566_SETCHNL_MODE   (0x09L)     // set channel config
#define DQL_IOCTL566_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL566_STOP           (0x0BL)     // immediate mode stop
#define DQL_IOCTL566_SCHED          (0x0CL)     // set shceduler
#define DQL_IOCTL566_FILTER         (0x0DL)     // set filter
#define DQL_IOCTL566_SETCLK         (0x0EL)     // set timebase control
#define DQL_IOCTL566_STATUS         (0x0FL)     // get interface status
#define DQL_IOCTL566_SETCHNL_CFG    (0x1001L)   // set channel configuration
#define DQL_IOCTL566_CHANGE         (0x1002L)   // change parameter or flush fifos
#define DQL_IOCTL566_SETTXPAGE      (0x1003L)   // select what TX page for scheduler data to use (516 only)
#define DQL_IOCTL566_SETMRFDLY      (0x1004L)   // select delay and 100us timebase divider for major frame mode (516 only)
#define DQL_IOCTL566_ENDISTX        (0x1005L)   // enable or disable transmitters on the fly (516 only)
#define DQL_IOCTL566_DIOCTRL        (0x1006L)   // enable or disable DIO pulse or settings
#define DQL_IOCTL566_SETTXWM        (0x1007L)     // sets the TX watermark
#define DQL_IOCTL566_SETRXWM        (0x1008L)     // sets the RX watermark
#define DQL_IOCTL566_SETTIMEOUT     (0x1009L)     // set the RX timeout (hardware)


// Event data for 566 layer
typedef struct {
    uint32 chan;        // channel information
    uint32 evtype;      // type of the event
    uint32 sts;         // applicable status register
    uint32 tstamp;      // timestamp of event
    uint32 size;        // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];      // data to follow
} EV566_ID, *pEV566_ID;

#define DqAdv566ConfigEvents_PARAMSZ    (7)   // maximum number of uint32 parameters after pEV553_ID

// Types of event
#define AR566_EVENT_PRM_MAX     2
//
// Event                566     516     Data[0]         Data[1]         Event content
// EV566_CLEAR          +       +       -               -
//
// EV566_NO_ACTIVITY    -       +       rx max size     timeout         Rx FIFO data upon bus is idle for timeout period
// EV566_IN_FIFO        +       +       rx wm size                      Rx FIFO data upon reaching watermark
// EV566_OUT_FIFO       +       +       tx wm size                      no data
// EV566_LABEL          -       +       rx max size
// EV566_BLK_CHANGE
//
// EV566_LOOPBACK_ERR   +       +       rx max size                     Rx FIFO data
// EV566_PARITY_ERR     +       +       -               -
// EV566_SCHED_ERR      -       -       -               -
//
// EV566_PERIODIC       +       +       rx max size     t/o divider     Rx FIFO data if exists
// EV566_TRIG_EXT0      +       -       -               -
//
typedef enum {
    EV566_CLEAR = 0x1000,        // clear all events

    // Tx or Rx events
    EV566_NO_ACTIVITY = 0x101,  // no activity on the bus over certain (programmed) time <AR-516 only>
    EV566_IN_FIFO,      // input FIFO watermark reached
    EV566_OUT_FIFO,     // output FIFO underrun or half-empty
    EV566_LABEL,        // event when a certain label is received <AR-516 only, logic 02.14.38+>
    EV566_BLK_CHANGE,    // event on active block change, use for double-buffering <reserved>

    // Errors
    EV566_LOOPBACK_ERR, // loopback error
    EV566_PARITY_ERR,   // parity error
    EV566_SCHED_ERR,    // scheduler overrun error

    // Events on timer or external trigger
    EV566_PERIODIC,     // periodic event
    EV566_TRIG_EXT0     // transition on trig-in ch 0 line <AR-566 only>

} event566_t;


//-----------------------------------------------------------------------------------------
//    #define AR566_EIER    (0x2018L)  //    R/W  Error Interrupt Enable Register
//    #define AR566_EISR    (0x201CL)  //    R    Error Interrupt Status register
//    #define AR566_EICR    (0x201CL)  //    W    Error Interrupt Clear register
#define AR566_ILE11                 (1L<<29)    //
#define AR566_ILE10                 (1L<<28)    //
#define AR566_ILE9                  (1L<<27)    // Loopback error interrupts for the
#define AR566_ILE8                  (1L<<26)    // corresponding receivers are generated
#define AR566_ILE7                  (1L<<25)    // when ARINC-429 data is received with an error
#define AR566_ILE6                  (1L<<24)    // or a packet is completely missing
#define AR566_ILE5                  (1L<<23)    //
#define AR566_ILE4                  (1L<<22)    //
#define AR566_ILE3                  (1L<<21)    //
#define AR566_ILE2                  (1L<<20)    //
#define AR566_ILE1                  (1L<<19)    //
#define AR566_ILE0                  (1L<<18)    //

#define AR566_ISO5                  (1L<<17)     // Scheduler overflow interrupts
#define AR566_ISO4                  (1L<<16)     // Note, that these flags are sticke and scheduler
#define AR566_ISO3                  (1L<<15)     // command should be re-written to clear it
#define AR566_ISO2                  (1L<<14)     //
#define AR566_ISO1                  (1L<<13)     //
#define AR566_ISO0                  (1L<<12)     //

#define AR566_IPE11                 (1L<<11)    //
#define AR566_IPE10                 (1L<<10)    //
#define AR566_IPE9                  (1L<<9)     // Parity error interrupts for the
#define AR566_IPE8                  (1L<<8)     // corresponding receivers are generated
#define AR566_IPE7                  (1L<<7)     // when ARINC-429 data is received with parity
#define AR566_IPE6                  (1L<<6)     // error regardless of acceptance criteria
#define AR566_IPE5                  (1L<<5)     //
#define AR566_IPE4                  (1L<<4)     //
#define AR566_IPE3                  (1L<<3)     //
#define AR566_IPE2                  (1L<<2)     //
#define AR566_IPE1                  (1L<<1)     //
#define AR566_IPE0                  (1L<<0)     //

#define DQ_AR_ALL_ERROR_FLASG       (0x1FFFFFFF)// all error flags from AR566_EISR

//-----------------------------------------------------------------------------------------
//    #define AR566_TXSCCS    (0x0C00L)  //    R/W    TX Scheduler Command/Status Area Start (256 Entries)
//    #define AR566_TXSCCE    (0x0FFCL)  //        TX Scheduler Command/Status Area End
// Following bits are status-only (read-only) bits
#define AR566_TXSCC_ERR0            (1L<<31)    // Error flag - used when entry is created
#define AR566_TXSCC_ECO             (1L<<24)    // Entry was executed (outputted to ARINC) at least once
                                                // since it was enabled
#define AR566_TXSCC_ME              (1L<<23)    // Entry is currently marked for the execution (output)
#define AR566_TXSCC_EO              (1L<<22)    // Execution overrun flag, set if entry scheduled for the
                                                // execution (ME is already set) but internal "execution
                                                // complete" flag was not set
                                                // NOTE: ECO and EO flags are "sticky" - they will not be
                                                // cleared until one of the following occur:
                                                //  - Entry is disabled (PS=00)
                                                //  - Entry is re-written, even with the same configuration
// Following bits are R/W
#define AR566_TXSCC_PS1             (1L<<21)    // Prescaler selector and entry enable bits :
#define AR566_TXSCC_PS0             (1L<<20)    // 00 - entry disabled and skipped during the entry processing
                                                // 01 - if MA=1: use 100uS clock for the TD field
                                                //      if MA=0: enable slave entry
                                                // 10 - if MA=1: use Prescaler 0 clock for the TD field
                                                // 11 - if MA=1: use Prescaler 1 clock for the TD field
#define AR566_TXSCC_PS_DISABLED     (0)
#define AR566_TXSCC_PS_100US        (1)
#define AR566_TXSCC_PS_PS0          (2)
#define AR566_TXSCC_PS_PS1          (3)
#define AR566_TXSCC_RSV1            (1L<<19)    // Reserved bit, should be written with 0
#define AR566_TXSCC_RSV0            (1L<<18)    // Reserved bit, should be written with 0
#define AR566_TXSCC_MA              (1L<<17)    // Master(=1)/Slave(=0) bit. Master bit indicates that
                                                // following RC and TD fields are valid and should be used
                                                // for the entry scheduling. Slave (=0) bit indicates that
                                                // entry should be processed in a same way as a preceeding
                                                // master entry, that is, every time, when preceeding
                                                // master entry is scheduled for the execution, all following
                                                // enabled slave entries are scheduled for the execution also
#define AR566_TXSCC_RC              (1L<<16)    // Recycle bit, if set (=1) will re-schedule entry for the
                                                // execution every time, when timout that is set by TD15:TD0
                                                // expires, valid for the master entries only (MA=1)
#define AR566_TXSCC_TD15            (1L<<15)    // Bits 15:0 define time delay in the ticks of the selected
#define AR566_TXSCC_TD0             (1L<<0)     // timebase (100uS, prescalers 0 and 1)
#define AR566_TXSCC_TD(N)           ((N)&0xffff)  // For 516/524 in MJ/MN mode this field is defines what minor
                                                // frame this entry belongs

//-----------------------------------------------------------------------------------------
//    #define AR566_RXLAFS    (0x3000L)  //    R/W    RX Label Acceptance Filter (255 entries) Area Start
//    #define AR566_RXLAFE    (0x33FCL)  //        RX Label Acceptance Filter Area End
//  Label filter works as follows:
//  every time when data is received from the ARINC bus following verification takes place:
//        - if enabled (first entry <> 0), label array is scanned and compared with
//        received data label field (bits 7:0 of the 32-bit data from ARINC IC)
//        - if label matches - then data is copied to the output FIFO with one exclusion:
//          for the labels with ND bit =1 only new data will be copied to the output FIFO
//           copy of the last data saved in "last data" memory and accessible in #define AR566_RXLD
//        area
//        - filter entries filled with 0x0 are ignored except for the first entry
//        - RX0 (first receiver in every ARINC block) has additional functionality
//          available via label acceptance filter: if #define AR566_RXCR_TMEN bit is set and
//          label is enabled (<>0), bit #define AR566_RXLAF_TR is used as a "trigger" flag, if it
//          set to one and data is received for the entry, corresponding entry with the same
//          index in the time scheduler will be marked for the execution (master-entry only)
//          When this mode of the operation is enabled, "last data" mode is disabled and all
//          received data that matches label filter will be copied into the output FIFO

// 14.38+ (AR-516)
#define AR566_RXLAF_DTE  (1L<<11)   // =1 - trigger DOutX, if this bit is set, dout pin will issue
                                    // a pulse that as programmed in AR5x6_DIOxCFG (set label to 0x0). This bit
                                    // is only valid for the RX1 of the ARINC Block 1-3
#define AR566_RXLAF_IE   (1L<<10)   // =1 - issue interrupt upon receiving matching label, complete
                                    // ARINC word that caused IRQ is captured in AR566_RXx_ILW

#define AR566_RXLAF_TR              (1L<<9)     // =1 - "trigger enabled" for the RX0 only
#define AR566_RXLAF_ND              (1L<<8)     // =1 - copy "new data" only to the output FIFO NDO
#define AR566_RXLAF_D7              (1L<<7)     // 8-bit label
#define AR566_RXLAF_D0              (1L<<0)     //


//-----------------------------------------------------------------------------------------
// Data in the FIFO in loopback error mode
//
// uint32 Expected TX frame
// uint32 Received TX frame (0xffffffff if missed)
// uint32 Timestamp
// uint32 missing and mismatch counters
// uint32 Flags
//
// missing and mismatch counters
#define AR566_RXFDR_CEC_S           (16)        // Missing (Error) frame counter offset - 16 bit: bits 31:16
#define AR566_RXFDR_CMC_S           (0)         // Mismatch Error Counter offset -  16 bit: bits 15:0
// Flags
#define AR566_RXFDR_CEC             (1L<<11)    // =1 - missing frame detected
#define AR566_RXFDR_CMC             (1L<<10)    // =1 - mismatch error detected
#define AR566_RXFDR_SRC1            (1L<<9)     // TX Source [9..8]
#define AR566_RXFDR_SRC0            (1L<<8)     // 0 - scheduler, 1- FIFO, 2 - HPR, 3 - LPR
#define AR566_RXFDR_SC_S            (0)         // Scheduler address -  8 bit
//
#define AR566_RXFDR_SRC_SCH         (0)         // Source field value - scheduler
#define AR566_RXFDR_SRC_FF          (1)         // Source field value - TX FIFO
#define AR566_RXFDR_SRC_HPR         (2)         // Source field value - High Priority Register
#define AR566_RXFDR_SRC_LPR         (3)         // Source field value - Low Priority Register

//- definition of used variables ---------------------------------

// Upper part of the configuration word - AI-201 specific
#define DQ_AR566_MODESCAN           (DQ_FIFO_MODESCAN)  // single scan update mod
#define DQ_AR566_MODEFIFO           (DQ_FIFO_MODEFIFO)  // continuous acquisitione with FIFO
#define DQ_AR566_MODECONT           (DQ_FIFO_MODECONT)  // continuous acquisition

#define DQ_AR566_ID_STANDARD        (0x0L<<18)  // Standard format
#define DQ_AR566_ID_EXTENDED        (0x1L<<18)  // Extendend format

// Output FIFO to read data
#define DQ_AR566_FIFO_GET_DATA      DQ_FIFO_GET_DATA

// Input FIFO to read data
#define DQ_AR566_FIFO_SET_DATA      DQ_FIFO_SET_DATA
#pragma pack(1)

#define DQ_AR566_NAMELEN            (32)        // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_AR512_CHAN][DQ_AR566_NAMELEN];
} DQCNAMES_566_, *pDQCNAMES_566_;

typedef struct {
    uint32 rxchlst[DQ_AR566_CHAN_RX]; // channel list Rx
    uint32 txchlst[DQ_AR566_CHAN_TX]; // channel list Tx
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_566_, *pDQOPMODEPRM_566_;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_566_, *pDQINITPRM_566_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_566_, *pDQSDOWNPRM_566_;

// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_566_ opmodeprm;
    DQINITPRM_566_ initprm;
    DQSDOWNPRM_566_ sdownprm;
    DQCNAMES_566_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_566_, *pDEVEEPROM_566_;



#define DQ_AR516_NAMELEN            (16)        // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_AR524_CHAN_RX][DQ_AR516_NAMELEN];
} DQCNAMES_516_, *pDQCNAMES_516_;

typedef struct {
    uint32 rxchlst[DQ_AR516_CHAN_RX]; // channel list Rx
    uint32 txchlst[DQ_AR516_CHAN_TX]; // channel list Tx
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_516_, *pDQOPMODEPRM_516_;

typedef struct {
    uint32 val;                     // TX and DIO line states in init mode
} DQINITPRM_516_, *pDQINITPRM_516_;

typedef struct {
    uint32 val;                     // TX and DIO line states in shutdown mode
} DQSDOWNPRM_516_, *pDQSDOWNPRM_516_;

// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQOPMODEPRM_516_ opmodeprm;
    DQINITPRM_516_ initprm;
    DQSDOWNPRM_516_ sdownprm;
    DQCNAMES_516_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_516_, *pDEVEEPROM_516_;

// -----------------------------------------------------------------------------------------

#define DQ_PL_601_CHAN              (8)         // 601 working channels
#define DQ_PL_601_CHANSVC           (8)         // total channels including service
#define DQ_PL_602_CHAN              (4)         // 602 working channels
#define DQ_PL_602_CHANSVC           (4)         // total channels including service
#define DQ_PL_601_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_PL_601_BASE              (BUS_FREQUENCY)     // 66MHz base frequency
#define DQ_PL_601_BASE_DOUBLE       (BUS_FREQUENCY<<1)  // 132MHz base frequency


#define DQ_PL_601_LISTSZ             (350)       // max number of uint32 output entries

#define DQ_CT602_OPTION_GPSS        0x804       // option for general-purpose syncrhnous serial option
#define DQ_CT602_OPTION_M272        0x808       // option for PIM/PRF/M272 interface option

// Maximum working frequencies
#define DQ_PL_601_MAXCLFRQ          (50000)
#define DQ_PL_601_MAXCVFRQ          (50000)

// helper macros
#define DQ_PL601_CHNLTYPE_MASK      (0xf0)      // extract channel type from channel entry
#define DQ_PL601_CHNLNUM_MASK       (0x0f)      // extract channel number from channel entry

// special channels used to specify that we wish to read/write other
// registers than default capture/compare register
#define DQ_PL601_CHNLTYPE_STATUS    (0x10)      // Reads channel STR register instead of CR
#define DQ_PL601_CHNLTYPE_CRH       (0x20)      // Reads channel CRH register
#define DQ_PL601_CHNLTYPE_CRL       (0x30)      // Reads channel CRL register
#define DQ_PL601_CHNLTYPE_CR0       (0x40)      // Writes channel CR0 register
#define DQ_PL601_CHNLTYPE_CR1       (0x50)      // Writes channel CR1 register
#define DQ_PL601_CHNLTYPE_SHADOW    (0x60)      // Reads shadow CR/CRL/CRH/timestamp registers
#define DQ_PL601_CHNLTYPE_TSTAMP    (0x70)      // Request timestamp for this channel into the FIFO
#define DQ_PL601_CHNLTYPE_SDRH      (0x80)      // Request channel shadow CRH register
#define DQ_PL601_CHNLTYPE_SDRL      (0x90)      // Request channel shadow CRL register
#define DQ_PL601_CHNLTYPE_SDRT      (0xA0)      // Request channel shadow timestamp


// start modes
#define DQ_PL601_SMAUTO             (0L)        // CTR_EN bit is automatically set when entering operation mode, counter starts immediately
#define DQ_PL601_SMHARD             (1L)        // hardware on gate line
#define DQ_PL601_SMSOFT             (2L)        // software CTR_EN bit

// sample width configuration (PWM only)
#define DQ_PL601_SW8                (1L)
#define DQ_PL601_SW16               (2L)
#define DQ_PL601_SW32               (4L)

// ioctls
#define DQL_IOCTL601_SET_GPSS       (7L)     // set channel config
#define DQL_IOCTL601_READCHNL       (8L)
#define DQL_IOCTL601_WRITECHNL      (9L)

// top level IOCTL that causes prog_601 or snap_601 to execute without
// switching to operation mode. They are used for asynchronous operations
#define DQL_IOCTL601_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL601_STOP           (0x0BL)     // immediate mode stop
#define DQL_IOCTL601_READ_FIFO      (0x0CL)     // read FIFO

// top level IOCTLs for CT-602 events
#define DQL_IOCTL602_EVENTS         (0x0DL)     // set events, intentionally the same value as DQL_IOCTL650_EVENTS
#define DQL_IOCTL602_STATUS         (0x0FL)     // get event status, intentionally the same value as DQL_IOCTL650_STATUS

// M272/PIM/PRF mode
#define DQL_IOCTL602_M272           (0x1001)    // IOCTL to use CT-602 layer in PIM/PRF/M272 mode
#define DQL_IOCTL602_M272_CFG       (0x1)       // sub-IOCTL - configure operations
#define DQL_IOCTL602_M272_START     (0x2)       // sub-IOCTL - start receiving data
#define DQL_IOCTL602_M272_STOP      (0x3)       // sub-IOCTL - stop receiving data
#define DQL_IOCTL602_M272_RDFRAME   (0x4)       // sub-IOCTL - read data frame (up to 8192 bytes)
#define DQL_IOCTL602_M272_WRFRAME   (0x5)       // sub-IOCTL - write data frame (up to 8192 bytes)

// for DQL_IOCTL602_M272_RDFRAME
#define DQL_M272_CHNL_M272          (0x0)       // M272 channel
#define DQL_M272_CHNL_PXX           (0x1)       // PMI/PRF channel

// Pattern generator mode
#define DQL_IOCTL602_PGEN           (0x1002)    // IOCTL to use CT-602 in pattern generation mode
#define DQL_IOCTL602_PGEN_CFG       (0x1)       // sub-IOCTL - configure operations
#define DQL_IOCTL602_PGEN_WRFIFO    (0x5)       // sub-IOCTL - write FIFO

// getparam_601/2 commands
#define DQL_IOCTL601_GET_REG        (3L)

// setparam_601/2 commands
#define DQL_IOCTL601_SETCHNL_CFG    (1L)
#define DQL_IOCTL601_SET_REG        (2L)
#define DQL_IOCTL601_CTR_EN         (4L)        // software start
#define DQL_IOCTL601_CTR_DIS        (5L)        // software stop
#define DQL_IOCTL601_ENALL          (6L)
#define DQL_IOCTL601_DISALL         (7L)
#define DQL_IOCTL601_CTR_CLR        (10L)       // 0x0a
#define DQL_IOCTL601_SET_WM         (11L)       // 0x0b
#define DQL_IOCTL601_ADDITIONAL     (12L)       // 0x0c
#define DQL_IOCTL602_SET_TERMIN     (13L)       // 0x0d // set input and output termination. (deprecated, use DQL_IOCTL601_MODIFY_IOR_REG)
#define DQL_IOCTL602_SETPWM_WM      (14L)       // 602 command to output pulse train while performing measurement
#define DQL_IOCTL602_REEN_PWM_WM    (15L)       // 602 command to enable or re-enable DQL_IOCTL602_SETPWM_WM
#define DQL_IOCTL601_MODIFY_IOR_REG (16L)       // 601/602 command to modify selected bits in the gpior register

#define DQ_602_BUFFERS_ON           (3)         // 'buffer' parameter for DqAdv602ConfigDo to turn both buffers on
#define DQ_602_BUFFERS_OFF          (0)         // 'buffer' parameter for DqAdv602ConfigDo to turn both buffers off
#define DQ_602_BUFFER_CLK_ON        (1)         // 'buffer' parameter for DqAdv602ConfigDo to turn clkout buffer on only
#define DQ_602_BUFFER_TRIG_ON       (2)         // 'buffer' parameter for DqAdv602ConfigDo to turn trigout buffer on only

#define DQ_602_ENABLE_CLK_DIO_ON    (2)         // 'enables' parameter for DqAdv602ConfigDo to enable DIO to clkout pin only
#define DQ_602_ENABLE_TRIG_DIO_ON   (1)         // 'enables' parameter for DqAdv602ConfigDo to enable DIO to trigout pin only
#define DQ_602_ENABLE_BOTH_DIO_ON   (3)         // 'enables' parameter for DqAdv602ConfigDo to enable DIO to both pins
#define DQ_602_ENABLE_BOTH_DIO_OFF  (0)         // 'enables' parameter for DqAdv602ConfigDo to restore normal C/T function to both pins


#define DQ_L601_FIFOSZ              (512)       // size of CT-601 and CT-602 fifos (alway was 512 32-bit words)

// for DQCMD_EVENT
#define DQEVENT601_READ_CTR         (0x1005L)   // read counter
#define DQEVENT601_WRITE_CTR        (0x1006L)   // write counter
#define DQEVENT601_STATUS_CTR       (0x1007L)   // get status
#define DQEVENT601_CONTROL_CTR      (0x1008L)   // control counter

// Event data for 601 layer
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 count;                   // counter register (CR)
    uint32 cr0;                     // CR0 (W) or CRL (R) register
    uint32 cr1;                     // CR1 (W) or CRH (R) register
    uint32 sts;                     // applicable status register
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 data[DQ_FLEX_ARRAY];                  // data to follow
} EV601_ID, *pEV601_ID;

#define DqAdv601ConfigEvents_PARAMSZ    7       // maximum number of uint32 parameters after pEV601_ID

// Types of event
typedef enum {
    EV601_CLEAR = 0x100,            // clear all events

    // counter event
    EV601_COUNT_COMPLETE,           // Event when programmed count is reached (end-mode)
    EV601_CR0_LESSTHEN,             // Count is less than CR0
    EV601_CR0_EXCEEDED,             // Count exceeded CR0
    EV601_CR1_EXCEEDED,             // Count exceeded CR1
    EV601_DATA_AVAILABLE,           // Data available in CRH/CRL (half)period calculated
    EV601_INP_TRANSITION,           // Input line transition detected
    EV601_GATE_TRANSITION,          // Gate line transition detected

    // GPSS
    EV601_GPSS_FRMERR,              // GPSS frame received with an error
    EV601_GPSS_FRMRX,               // GPSS frame received
    EV601_GPSS_FRMTX                // GPSS frame transmitted

} event601_t;

#define VR608_ADCDATA_A(N)          ((N)>>16)    // data for channel A
#define VR608_ADCDATA_B(N)          ((N)&0xfffc) // data for channel B
#define VR608_ADCDATA_CH(N)         ((N)&0x3)    // channel number in the data



// for DQL_IOCTL602_EVENTS
#define DQL_IOCTL602_IRQ_EN         (1L<<0)     // Enable IRQs
#define DQL_IOCTL602_EVT_EN         (0)         // Enable events without IRQs

// TRIGOUT configuation structure
typedef struct {
    uint32 event_cfg;               // event configuration bitfield
    uint32 event_prm;               // event parameters
    uint32 event_val;               // parametric-dependent value
    uint32 event_sub0_dly;          // subevent 0 delay
    uint32 event_sub1_dly;          // subevent 1 delay
} TR602_CFG, *pTR602_CFG;

// Interrupt enable/mask/status clear bits in CLI IER/IMR/ICR/ISR
// used by CTU0-CTU7 counters
#define DQ_ICR_CTU7                 (1L<<7)     // CTU7 interrupt
#define DQ_ICR_CTU6                 (1L<<6)     // CTU6 interrupt
#define DQ_ICR_CTU5                 (1L<<5)     // CTU5 interrupt
#define DQ_ICR_CTU4                 (1L<<4)     // CTU4 interrupt
#define DQ_ICR_CTU3                 (1L<<3)     // CTU3 interrupt
#define DQ_ICR_CTU2                 (1L<<2)     // CTU2 interrupt
#define DQ_ICR_CTU1                 (1L<<1)     // CTU1 interrupt
#define DQ_ICR_CTU0                 (1L<<0)     // CTU0 interrupt

// Counter 0-7 base addresses
#define DQ_CLI_CTU0S                (0x2000)    // CTU 0 start
#define DQ_CLI_CTU0E                (0x207C)    // CTU 0 end
#define DQ_CLI_CTU1S                (0x2080)    // CTU 1 start
#define DQ_CLI_CTU1E                (0x20FC)    // CTU 1 end
#define DQ_CLI_CTU2S                (0x2100)    // CTU 2 start
#define DQ_CLI_CTU2E                (0x217C)    // CTU 2 end
#define DQ_CLI_CTU3S                (0x2180)    // CTU 3 start
#define DQ_CLI_CTU3E                (0x21FC)    // CTU 3 end
#define DQ_CLI_CTU4S                (0x2200)    // CTU 4 start
#define DQ_CLI_CTU4E                (0x227C)    // CTU 4 end
#define DQ_CLI_CTU5S                (0x2280)    // CTU 5 start
#define DQ_CLI_CTU5E                (0x22FC)    // CTU 5 end
#define DQ_CLI_CTU6S                (0x2300)    // CTU 6 start
#define DQ_CLI_CTU6E                (0x237C)    // CTU 6 end
#define DQ_CLI_CTU7S                (0x2380)    // CTU 7 start
#define DQ_CLI_CTU7E                (0x23FC)    // CTU 7 end

// Individual register addresses within single CTU (counter-timer unit)
// Actual access address is calculated as <device base>+CLI_CTUxS+CTU_xx
// These are also the register offsets used by DqAdv601GetRegister() and DqAdv601SetRegister()
#define DQ_CTU_STR                  (0x00)      // (RO) Status Register
#define DQ_CTU_CTR                  (0x00)      // (WO) ConTrol Register
#define DQ_CTU_CCR                  (0x04)      // (RW) Counter Control Register
#define DQ_CTU_PS                   (0x08)      // (RW) PreScaler
#define DQ_CTU_CR                   (0x0C)      // (RO) Count Register
#define DQ_CTU_LR                   (0x0C)      // (WO) Load Register
#define DQ_CTU_IDBC                 (0x10)      // (WO) Input DeBouncing register for the Clock
#define DQ_CTU_CTR_RD               (0x10)      // (RO) Current value of CTR register (CT-602, optionally on CT-601)
#define DQ_CTU_IDBG                 (0x14)      // (WO) Input DeBouncing register for the Gate
#define DQ_CTU_CRR                  (0x14)      // (RO) Number of pulses after last error detection
#define DQ_CTU_PC                   (0x18)      // (RW) Period Counter
#define DQ_CTU_FLEN                 (0x18)      // (WO) Frame length in GPSS mode
#define DQ_CTU_CRH                  (0x1C)      // (RO) Capture Register High
#define DQ_CTU_CR0                  (0x1C)      // (WO) Compare Register 0
#define DQ_CTU_CRL                  (0x20)      // (RO) Capture Register Low
#define DQ_CTU_CR1                  (0x20)      // (WO) Compare Register 1
#define DQ_CTU_TBR                  (0x24)      // (WO) TimeBase Register
#define DQ_CTU_GPSS                 (0x24)      // (WO) TBR alias for GPSS mode
#define DQ_CTU_FCNTI                (0x28)      // (RO) input Fifo CouNT register (actual # samps in fifo)
#define DQ_CTU_FDTIEOF              (0x28)      // (WO) like FDTI but sets EOF for GPSS mode
#define DQ_CTU_IFWR                 (0x2C)      // (WO) Input Fifo WateRmark
#define DQ_CTU_FDTI                 (0x30)      // (WO) Input Fifo DaTa register
#define DQ_CTU_RXCFGF               (0x30)      // (RO) GPSS information on received frame length
#define DQ_CTU_FCNTO                (0x34)      // (RO) Output Fifo Count register
#define DQ_CTU_TXCFGF               (0x34)      // (WO) Data word length for GPSS Tx
#define DQ_CTU_OFWR                 (0x38)      // (WO) Output Fifo WateRmark
#define DQ_CTU_FDTO                 (0x3C)      // (RO) Fifo Data Output register
#define DQ_CTU_ISR                  (0x40)      // (RO) Interrupt Status Register
#define DQ_CTU_IER                  (0x40)      // (WO) Interrupt Enable Register
#define DQ_CTU_ICR                  (0x44)      // (WO) Interrupt Clear Register
#define DQ_CTU_RXCFGFM              (0x44)      // (RO) Mirror of RXCFGF FIFO w/o removing data from the FIFO
#define DQ_CTU_FDDO                 (0x48)      // (WO) Output DATA FIFO data register
#define DQ_CTU_TEST0                (0x4C)      // (RO) Test register 0

// Shadow data registers are used to store results of the measurement and associated
// layer timestamp. CTU_SDR0/CTU_SDR1 are used to keep measured value (see below)
// CTU_SDR1 is used for the timestamp. Please note that first end-mode condition
// stores value to all three registers and they remain latched until timestamp is
// read from the CTU_SDR2, at that moment next end-mode condition will latch another
// set of values to these three registers
// Valid combinations:
// For CM_ECT/CM_TECT modes CTU_CR will be stored to CTU_SDR0 for CM_HP/CM_THP/CM_NP/
// CM_TNP/CM_TPPM/CM_TTPPM modes CTU_CRL/CTU_CRH will be stored in CTU_SDR0/CTU_SDR1.
// In all other modes shadow registers are undefined.
#define DQ_CTU_SDRL                 (0x50)      // (RO) Shadow data register SDR0 (CR/CRL)
#define DQ_CTU_SDRH                 (0x54)      // (RO) Shadow data register SDR1 (CRH)
#define DQ_CTU_SDRT                 (0x58)      // (RO) Shadow data register SDR2 (Timestamp)
#define DQ_CTU_PLLCFG               (0x5C)      // (WO) PLL configuration register
#define DQ_CTU_PLLSTS               (0x5C)      // (RO) PLL status register

// CT-602 Event generator registers
#define DQ_602_EVT_STEP             (0x0080)    // Address increment from event to event
#define DQ_602_EVT0_BASE            (0x2060)    // Base address for the event 0
#define DQ_602_EVT1_BASE            (0x21E0)    // Base address for the event 1
#define DQ_602_EVT2_BASE            (0x2160)    // Base address for the event 2
#define DQ_602_EVT3_BASE            (0x21E0)    // Base address for the event 3
#define DQ_602_EVT_BASE(CH)         ((DQ_602_EVT0_BASE+((CH)*DQ_602_EVT_STEP)))

// offsets from EVTn_BASE
#define DQ_602_EVT_CFG              EVTMOD_CFG         // R/W  Event configuration register
#define DQ_602_EVT_EMP0             EVTMOD_EMP0        // W    Event mode parameters register 0
                                                       // R    Software reset for period counter
#define DQ_602_EVT_EMP1             EVTMOD_EMP1        // W    Event mode parameters register 1
                                                       // R    Software event source
#define DQ_602_EVT_DLY0             EVTMOD_DLY0        // W    Subevent 0 time delay register
#define DQ_602_EVT_DLY1             EVTMOD_DLY1        // W    Subevent 1 time delay register
#define DQ_602_EVT_STS              EVTMOD_STS         // R    Event status register
#define DQ_602_EVT_SDNADC           EVTMOD_SDNADC      // R    DNA data/timestamp capture register


// EVT_CFG                          (0x00)        // R/W    Event configuration register
// Select source for the event, year/day/hour/minute/seconds/microseconds inclusion/
// exclusion, clock source, event pulse length, one-shot/repeat mode and other
// settings

// EVT_CFG Event (TRIGOUT source) configuration register sources
#define CT602_EVT_CPT               (31)        // Counter complete current operation (end-mode detected)
#define CT602_EVT_CR0L              (30)        // Current value of CR < CR0
#define CT602_EVT_CR0GE             (29)        // Current value of CR >= CR0
#define CT602_EVT_CR1               (28)        // Current value of CR >= CR1
#define CT602_EVT_LHI               (27)        // Low-high transition was detected on the input pin
#define CT602_EVT_LHG               (26)        // Low-high transition was detected on the gate pin
#define CT602_EVT_HLI               (25)        // High-low transition was detected on the input pin
#define CT602_EVT_HLG               (24)        // High-low transition was detected on the gate pin
#define CT602_EVT_CRH               (23)        // Data is available in CRH
#define CT602_EVT_CRL               (22)        // Data is available in CRL
#define CT602_EVT_IFE               (21)        // Input FIFO is empty
#define CT602_EVT_IFH               (20)        // Input FIFO is below watermark
#define CT602_EVT_OFH               (19)        // Output FIFO is above watermark
#define CT602_EVT_FF                (18)        // Output FIFO is full
#define CT602_EVT_WCTR              (17)        // write CTR
#define CT602_EVT_WCCR              (16)        // write CCR
#define CT602_EVT_WCR0              (15)        // write CR0
#define CT602_EVT_WCR1              (14)        // write CR1
#define CT602_EVT_CRLD              (13)        // Load/reload CR register (from internal CT-602 state machine)
#define CT602_EVT_STRT              (12)        // Start counting (from internal CT-602 state machine)
#define CT602_EVT_SYNC3             (11)        // SYNC line3
#define CT602_EVT_SYNC2             (10)        // SYNC line2
#define CT602_EVT_SYNC1             (9)         // SYNC line1
#define CT602_EVT_SYNC0             (8)         // SYNC line0
#define CT602_EVT_IPC               (4)         // Internal period counter
#define CT602_EVT_SWF               (1)         // Software only
#define CT602_EVT_DIS               (0)         // No active source - event is in disabled

// Define CL entry - channel and register
#define DQ_CTU_REGADDR(CLE)         (0x2000|CLE)

// STR Bit description
// Status register is used to report current operational status of the counter
// timer unit via dedicated bits for every status condition reported.

#define DQ_STR_EN       31  //  When read as 1 indicates that CR is enabled in
                            //  CT0_CTR DQ_CTR_EN bit.
#define DQ_STR_BUSY     30  //  When read as 1 indicates that CR is counting or 0
                            //  is current counting operation is complete.
#define DQ_STR_CR0L     29  //  When read as 1 indicates that current value of CR < CR0
#define DQ_STR_CR0GE    28  //  When read as 1 indicates that current value of CR >= CR0

#define DQ_STR_CR1      27  //  When read as 1 indicates that current value of CR >= CR1
#define DQ_STR_IN0      26  //  Report current value of direct input pin
#define DQ_STR_GT0      25  //  Report current value of direct gate pin
#define DQ_STR_IN1      24  //  Report current value of de-bounced input pin

#define DQ_STR_GT1      23  //  Report current value of de-bounced gate pin
#define DQ_STR_IHL      22  //  When read as 1 indicates that 1-0 transition was detected
                            //  on the input pin since last read from CTx_STR
#define DQ_STR_ILH      21  //  When read as 1 indicates that 0-1 transition was detected
                            //  on the input pin since last read from CTx_STR
#define DQ_STR_GHL      20  //  When read as 1 indicates that 1-0 transition was detected
                            //  on the gate pin since last read from CTx_STR

#define DQ_STR_GLH      19  //  When read as 1 indicates that 0-1 transition was detected
                            //  on the gate pin since last read from CTx_STR
#define DQ_STR_OU       18  //  Report current value of output pin
#define DQ_STR_IRQ      17  //  Read as 1 if interrupt was requested
#define DQ_STR_CRH      16  //  Report 1 if data is available in CRH

#define DQ_STR_CRL      15  //  Report 1 if data is available in CRL
#define DQ_STR_IFE      14  //  Report 1 if input FIFO is empty
#define DQ_STR_IFH      13  //  Report 1 if input FIFO is at least half full
#define DQ_STR_IFF      12  //  Report 1 if input FIFO is full

#define DQ_STR_OFE      11  //  Report 1 if output FIFO is empty
#define DQ_STR_OFH      10  //  Report 1 if output FIFO is at least half full
#define DQ_STR_OFF      9   //  Report 1 if output FIFO is full
#define DQ_STR_GT       8   //  Report 1 if global trigger
#define DQ_STR_GPSSB    7   //  GPSS is enabled and busy


// CTR Bit description     (0x00)      // (WO) ConTrol Register
// DQ_CTU_CTR - CTU Control register is used to set and control operation mode of the counter
// timer via specific bits and bit field. Note, that generic interrupt mask/enable
// /control/status is reported via layer IER (0x1C), IMR(0x20), ISR/ICR (0x24)
// registers layer-specific bits described later in the section while status conditions
// which leads to the interrupt request are enabled/disabled via CTUx_CTR register.

#define DQ_CTR_EN       31  //  Enable (1)/Disable (0) counter register. When disabled, CR along with
                            //  pre-scaler and de-bouncer circuitry freezes it's current operation
                            //  which may be re-enabled by writing one to the DQ_CTR_EN bit.
#define DQ_CTR_IFE      30  //  Input FIFO enable (1) disable(0). Depending on the operation mode,
                            //  when enabled, fetches one or two 32-bit word from the input FIFO
                            //  to the CR0/CR1 at the same time when counter register reloaded with LR value
#define DQ_CTR_IFS      29  //  Input FIFO transfer size. Used only when DQ_CTR_IFE = 1. 0 - 1 word, 1- 2 words
                            //  Defines one or two words will be loaded into
                            //  CR0/CR1 every time when "end-of-count" condition is detected
#define DQ_CTR_IIE      28  //  Enable (1)/Disable (0) inversion of the input pin.
                            //  Value of the pin is inverted right at the input before debouncing circuitry
#define DQ_CTR_GIE      27  //  Enable (1)/Disable (0) inversion of the gate pin
                            //  Value of the pin is inverted right at the input before debouncing circuitry
#define DQ_CTR_OIE      26  //  Enable (1)/Disable (0) inversion of the output pin. When enabled - output
                            //  pin polarity is inverted at the last stage of creating the output signal
#define DQ_CTR_OU       25  //  Current value of the output pin in GPIO mode (valid if DQ_CTR_EN bit = 0)
#define DQ_CTR_OFE      24  //  Output FIFO enable (1) disable(0). Depending on the operation mode, when
                            //  enabled, copies one or two 32-bit words from the CR or CRH/CRL into the
                            //  output FIFO when counter reaches end of the count condition
#define DQ_CTR_CLFI     23  //  If this bit is set during write to CTR all input path will be cleared
                            //  (CRH/CRL and input FIFO), FIFO will contain 0 samples and CRH/CRL will be set to 0
#define DQ_CTR_CLFO     22  //  If this bit is set during write to CTR all output path will be cleared
                            //  (CR0, CR1, LR  and output FIFO), FIFO will contain 0 samples and all
                            //  registers affected will be set to 0
#define DQ_CTR_CLR      21  //  If this bit is set during write to CTR CTUx will be reset to
                            //  the default state, all registers/FIFO will be cleared

#define DQ_CTR_GPIO     20  // enable clkout as GPIO when CTR_EN = 0 , CTR_OU controls state

#define DQ_CTR_GTSE     19  //  Enable (1)/Disable(0) global start trigger (from the SYNC interface) of the layer

#define DQ_CTR_GTPE     18  //  Enable (1)/Disable(0) global stop trigger (from the SYNC interface) of the layer

#define DQ_CTR_OFTSE    16  // =1 - add timestamp to output FIFO, if this flag is set timestamp will be
                            // copied into output FIFO in addition to one or two data words as defined
                            // by the EM_xx in CCR. Only EM_PC in CM_TPPM, CM_NP, CM_TTPPM, CM_TNP
                            // result in two data words (CRL/CRH), all other modes copy one data word
                            // to the output FIFO (CR or CRH)
#define DQ_CTR_TOIE     15  // (CT-602 only). Enable (1)/Disable (0) inversion of the TRIGOUT pin.
                            // When enabled - output pin polarity is inverted at the last stage of creating the output
#define DQ_CTR_GPSSE    14  // Enable GPSS

// ----------------------------------------------------------------------------------------------------------

// CCR Bit description   (DQ_CTU_CCR) (0x04)      // (RW) Counter Control Register
// CTU Counter Control register is used to set current mode for the counter and pre-scaler.
#define DQ_CCR_RE       31  // Enable re-load of the CR by the value loaded in LR when it reaches end of the count.
                            // End of the count is limited by one of the combinations of DQ_CCR_EC2/1/0 bits
#define DQ_CCR_EC2      30  // Set end of the count mode:(0)000 - end, when reaches CR0 (CR=CR0)
#define DQ_CCR_EC1      29  // (1)001 - end, when reaches CR1 (CR=CR1)
#define DQ_CCR_EC0      28  // (2)010 - end, when reaches 0xFFFFFFFF
                            // (3)011 - end, when X periods of the signal is captured. X is defined via CTx_PC
                            // (4)100 - end, when time-base counter reaches 0
#define DQ_CCR_CRM3     27  // Set counter mode:
#define DQ_CCR_CRM2     26  // (0x0)0000 - counter (CR acts as a standard count-up counter, internal clock used as a PS source)
#define DQ_CCR_CRM1     25  // (0x1)0001 - tppm - CRH = TimeIntervalCounter, CRL = PulseNumberCounter
#define DQ_CCR_CRM0     24  // (0x8)1000 - counter (CR acts as a standard count-up counter, debounced CLKIN clock used as a PS source)
                            // (0x9)1001 - capture half period mode (CR captures half period of the input signal
                            //             starting from the rising edge of the de-glitched input and copies it into CRH).
                            // (0xA)1010 - capture full period (CR captures length of the full period, copies positive part
                            //             of the period into CRH and negative (low) into CRL,
                            //             if CTx_PC > 0 - continue this process increasing CRH/CRL for the
                            //             length of positive/negative part of every period
                            // (0xB)1011 - quadrature encoder mode
                            // (0x4)0100 - same as 0x0 but with trigger
                            // (0x5)0101 - same as 0x1 but with trigger
                            // (0xC)1100 - same as 0x8 but with trigger
                            // (0xD)1101 - same as 0x9 but with trigger
                            // (0xE)1110  - same as 0xA but with trigger
                            // Note, that all modes, except mode 0 are using debounced CLKIN pin as a clock
                            // source for the pre-scaler. Trigger source (HW/SW) is selected using DQ_CCR_TRS bit
#define DQ_CCR_PSG      23  // Enable(1)/Disable(0)  hardware gate on the prescaler. If enabled, GATE input,
                            // when positive, enables pre-scaler counter. Note, that DQ_CTR_EN bit in CTR may be
                            // effectively used as a software gate, when DQ_CCR_PSG = 0.
#define DQ_CCR_TRS      22  // Select Hardware(1)/Software(0) trigger source for the triggered modes.
                            // Hardware-triggered modes will start at low-high transition on the GATE input.
                            // In software trigger mode DQ_CTR_EN bit in CTR should be used as a trigger
                            // (DQ_CTR_EN will be cleared at the end of the counting operation if DQ_CCR_TRS bit
                            // is cleared and triggered mode is selected)
#define DQ_CCR_ENC      21  // This bit compliments DQ_CCR_TRS bit and also works only in a triggered mode -
                            // if set (1) enables auto-clear of the DQ_CTR_EN bit at the end of the current operation.

#define DQ_CCR_TBS      18  // Select clock source for time-base register
#define DQ_CCR_PSS      15  // Select clock source for the prescaler register
#define DQ_CCR_MM2X     14  // Double-resolution for the capture modes (132MHz resolution) logics 0xE08+
#define DQ_CCR_PCSPT    13  // =1 - use Period Counter as a stop trigger, can be used to output
                            // pre-defined number of pulses, only valid in CM_CT/CM_TCT/CM_RTCT
                            // CM_ECT/CM_TECT modes, if this bit is set CTU_PC should be written
                            // with value that should be equal to the number of pulses that timer
                            //  should output prior to stop minus one.
                            // When desired number of pulses is outputted
                            // - in CM_CT/CM_ECT mode CTR_EN is cleared and re-enabling
                            //   CTR_EN will restart counter
                            // - in CM_TCT/CM_RTCT/CM_TECT trigger condition is cleared
                            //   and low->high transition on the gate will restart counter
                            // Limitations: CTU_CR1 should be >= 5 for the CM_CT/CM_TCT/CM_RTCT
                            // and for the CM_ECT/CM_TECT value loaded to CTU_CR0 should
                            // correspond to >75.75nS based on expected external frequency
#define DQ_CCR_MMCOE     12 // (available in logics 0x01021076 or later)
                            // =1 - enable main counter during measurement modes (MMCO mode), if enabled main counter
                            // can be used to supply continuous pulse train to the output pin, it always uses EM_CR1
                            // end-mode condition and starts when CTR_EN is set to 1 while CCR_MMCOE=1
                            // NOTE: in MMCO mode prescaler is always set to use 66MHz internal clock and bypassed when PS=0;
                            // GATE input still can be used if CCR_PSG=1. Both CR0 and CR1 should be programmed for
                            // proper operation, one-shot mode can be set using CCR_MMCOOS bit.
#define DQ_CCR_MMCOOS    11 // (available in logics 0x01021076 or later)
                            // Works with CCR_MMCOE bit, if CCR_MMCOOS is set CCR_MMCOE bit will be cleared on the next clock
                            // after CR register reaches CR1 value. This feature can allow use of the counter output in
                            // software-controlled one-shot mode during period measurement operation.
                            // Next write to CCR with CCR_MMCOE will re-enable CR counter
#define DQ_CCR_VR_PS0     9 // bits 10..9 - number of pulses to skip before first index tooth detection


#define DQ_TBR_EN                   (31)        // TimeBase Register - enable timebase bit


// CCR timebase clock source
// should be kept identical to QDU_xxx
#define CT_TBS_66M        (0)   // (0)000 - 66Mhz
#define CT_TBS_TRIG       (1)   // (1)001 - debounced TRIGIN pin
#define CT_TBS_SYNC0      (4)   // (4)100 - SYNC0 1ine
#define CT_TBS_SYNC1      (5)   // (5)101 - SYNC1 line
#define CT_TBS_SYNC2      (6)   // (6)110 - SYNC2 1ine
#define CT_TBS_SYNC3      (7)   // (7)111 - SYNC3 line
#define CT_TBS_SYNCMAX    (7)   //

#define DQ_PC_FLEN(N)       (((N)&0xffff)<<16)    // Frame length in words
#define DQ_PC_FSLEN(N)      (((N)&0xffff)-1)      // Frame Sync pulse length depends on TBR_FSTYPE

#define DQ_PC_GETFLEN(N)    (((N)>>16)&0xffff)    // Get frame length in words from PC reg
#define DQ_PC_GETFSLEN(N)   (((N)&0xffff)+1)      // Get frame Sync pulse length from PC reg



//      TX connections (+1 means next channel)
//      --------------
// CLKIN <- serial clock
// GATE <- external trigger
// CLKIN+1 <- acknowledge (optional)
// CLKOUT -> serial data
// TRIGOUT -> frame sync
// CLKOUT+1 -> serial clock (optional)
//
//      RX connections (+1 means next channel)
//      --------------
// CLKIN <- serial data
// GATE <- frame sync
// CLKOUT -> serial clock
// TRIGOUT -> acknowledge
// CLKIN+1 <- serial clock (external, optional)
// GATE+1 <- external trigger (optional)
//

// TX parameters: a channel can be TX or RX
// ---
// Data rate (300-16M)
// Data word length
// Enable clock on channel+1 (generates clock)
// Enable acknowledge on channel+1 (generate acknowledge)
// Enable and program debouncer on frame sync (out, delays FS)
// Enable and program debouncer on data (out, delays data)
// Active clock edge
// Data encoding and polarity
// Trigger mode and polarity
// Frame sync type, size and polarity
//
// RX parameters
// ---
// Data rate
// Data word length
// Enable clock on channel+1 (external input clock)
// Enable trigger on channel+1 (external gate)
// Enable and program debouncer on frame sync (in, delays FS)
// Enable and program debouncer on data (in, delays data)
// Active clock edge
// Data encoding and polarity
// Trigger mode and polarity
// Frame sync type, size and polarity


// GPSS channel configuration
typedef struct {
    uint32 mode;        // TX or RX
    uint32 flags;       // mode modification flags, like Rx timestamp
    uint32 baud;        // baud rate
    uint32 word_len;    // data word length in bits, 1=variable
    uint32 frame_len;   // length of the frame in entries, (0 == variable)
    uint32 en_clock1;   // enable clock on channel+1
    uint32 en_ack1;     // enable acknowledge on channel+1
    uint32 dbc_fs;      // debouncer value for frame sync (0 == disabled)
    uint32 dbc_data;    // debouncer value for data (0 == disabled)
    uint32 clk_edge;    // clock edge, positive or negative
    uint32 data_mode;   // data encoding and polarity
    uint32 trig_mode;   // trigger mode and polarity
    uint32 fs_mode;     // frame sync type and polarity
    uint32 fs_len;      // length of frame sync signal
    uint32 frame_clk;   // frame clock in Hz (0 == disabled)
    uint32 wordlen_prg; // <reserved>
    int wordlen_shift;  // number of bits to shift Tx word to the left

} CT602_GPSS_CFG, *pCT602_GPSS_CFG;

// <mode>
#define CT602_MODE_CT   (0) // counter mode <reserved>
#define CT602_MODE_RX   (1) // channel is Rx
#define CT602_MODE_TX   (2) // channel is Tx
#define CT602_MODE_C1   (4) // channel is used as (C+1) channel for pins, do not program as a standard counter

// <flags>
#define CT602_FLAG_TSTAMP   (1) // add timestamp to the received data by the end of the frame

// <word_len>
#define CT602_WORD_LEN(N)   ((N)-1) // 3..32 bits in the word
#define CT602_WORD_LEN_VAR  (1)     // word length variable
// if variable word length is selected the word length can be up to 27 bit
// 5 bits [31..27] are used for the word length size
#define CT602_WORD_VARWORD(L,D)  (((L)<<27)|((D)&0x7ffffff))     // word length variable
#define CT602_WORD_GETLEN(W)     ((W)>>27)

// <en_clock1>
#define CT602_CLK1_EN       (1)     // enable clock out (Tx) or external clock in (Rx) on channel+1

// <en_ack1>
#define CT602_ACK1_POS      (0)     // acknowledge is positive
#define CT602_ACK1_NEG      (1)     // acknowledge is negative
#define CT602_ACK1_EN       (1<<4)  // enable ack out (Rx) or ack in (Tx) on channel+1

// <dbc_fs>
#define CT602_DBC_FS(N)     (N)     // enable (if >0) debouncer on frame sync (in for Rx, out for Tx)

// <dbc_data>
#define CT602_DBC_DATA(N)   (N)     // enable (if >0) debouncer on data (in for Rx, out for Tx)

// <clk_edge>
#define CT602_CLK_EDGE_NEG  (0)     // negative edge clocks in data (falling)
#define CT602_CLK_EDGE_POS  (1)     // positive edge clocks in data (rising)

// <data_mode>
#define CT602_DATA_POS      (0)     // data is positive
#define CT602_DATA_NEG      (1)     // data is negative

#define CT602_DATA_NRZ      (2<<4)     // data in NRZ format
#define CT602_DATA_NRZI     (3<<4)     // data in NRZI format

// <trig_mode>
#define CT602_TRIG_POS      (0)     // trigger is positive
#define CT602_TRIG_NEG      (1)     // trigger is negative

#define CT602_TRIG_LEVEL    (0)     // trigger is level sensitive
#define CT602_TRIG_EDGE     (2)     // trigger is edge-sensitive

#define CT602_TRIG_INTERNAL (0)     // trigger is internal
#define CT602_TRIG_EXTERNAL (4)     // trigger is external

#define CT602_TRIG_ONE_WORD (0<<8)  // TX:one word per trigger, RX:one frame per trigger
#define CT602_TRIG_IN_FIFO  (1<<8)  // TX only: output FIFO per trigger
#define CT602_TRIG_NOTRIG   (1<<8)  // RX only: trigger is always enabled
#define CT602_TRIG_ASSERTED (2<<8)  // TX/RX:until trigger active (level only, full words transmitted)
#define CT602_TRIG_FFE      (3<<8)  // TX:one frame per trigger or FIFO empty

// <fs_mode>
#define CT602_FS_POS        (0)     // frame sync is positive
#define CT602_FS_NEG        (1)     // frame sync is negative
#define CT602_FS_EVERYWORD  (4)     // every word output has its frame sync

#define CT602_FS_BITS       (1<<8)  // frame sync length is in bits
#define CT602_FS_WORDS      (2<<8)  // frame sync is in words
#define CT602_FS_FRAME      (3<<8)  // frame sync is asserted for the whole frame


#define CT602_READCHNL_CONT (1L<<31)    // there is a continuation to this frame, read more of it

// TBR bits - GPSS related
#define DQ_GPSS_TXWFSEN    (1L<<26)    // =1 - issue frame sync in bits for every transmitted word
#define DQ_GPSS_TXFCLKEN   (1L<<25)    // =1 - use timer em_cr0 end-mode event as a TX Frame clock
#define DQ_GPSS_EVTEN      (1L<<24)    // =1 - use event module for timeout IRQ
//
#define DQ_GPSS_FRMDBDIS   (1L<<23)    // =1 - disable debouncer on frame sync
#define DQ_GPSS_DTDBDIS    (1L<<22)    // =1 - disable debouncer on data
#define DQ_GPSS_DIR        (1L<<21)    // Direction (0-RX, 1-TX)
#define DQ_GPSS_ACKPOL     (1L<<20)    // Acknowledge polarity (0-positive)
//
#define DQ_GPSS_ACKEN      (1L<<19)    // Enable acknowledge (1-enable)
#define DQ_GPSS_CLKEDGE    (1L<<18)    // Active clock edge (0-falling, 1-rising)
#define DQ_GPSS_DTENC1     (1L<<17)    // Data encoding : 00, 01 - reserved
#define DQ_GPSS_DTENC0     (1L<<16)    // 10 - NRZ, 11 - NRZI
//
#define DQ_GPSS_CLKSRC1    (1L<<15)    // Clock source selector: 00-disabled, 10-PLL
#define DQ_GPSS_CLKSRC0    (1L<<14)    // 10-DNA,11-external
#define DQ_GPSS_TPOL       (1L<<13)    // Trigger polarity (0-positive)
#define DQ_GPSS_TSOURCE    (1L<<12)    // 0-DNA,1-external
//
#define DQ_GPSS_TMODE1     (1L<<11)    // Trigger mode:
#define DQ_GPSS_TMODE0     (1L<<10)    // 00-TX:one word/trigger, RX:one frame/trigger
                                       // 01-TX:FIFO/trigger, RX - no trigger required
                                       // 10-TX/RX:until trigger active (level only, full words transmitted)
                                       // 11-TX:until stop bit detected or FIFO empty, RX - no trigger required
#define DQ_GPSS_TTYPE      (1L<<9)     // Trigger type: (0-level, 1-edge)
#define DQ_GPSS_DTWLEN4    (1L<<8)     // Data word length : 0-reserved, 1-variable
//
#define DQ_GPSS_DTWLEN0    (1L<<4)     // 2-31 - corresponds to 3-32 bits
//
#define DQ_GPSS_DTPOLARITY (1L<<3)     // Data polarity (0-positive, 1-negative)
#define DQ_GPSS_FSPOLARITY (1L<<2)     // Frame SYNC polarity (0-positive, 1-negative)
#define DQ_GPSS_FSTYPE1    (1L<<1)     // Frame SYNC type: 00-reserved
#define DQ_GPSS_FSTYPE0    (1L<<0)     // 01-N bits, 10-N words, 11-Frame


#define DQ_GPSS_DTWLEN(N)       ((((N))&0x1f)<<4)
#define DQ_GPSS_GETDTWLEN(N)    ((((N)>>4)&0x1f))

// defines to program TBR
#define DQ_GPSS_POL_POS             (0)         // Positive polarity
#define DQ_GPSS_POL_NEG             (1)         // Negative polarity
#define DQ_GPSS_CLKEDGE_FALL        (0)         // Falling edge is active
#define DQ_GPSS_CLKEDGE_RISE        (1)         // Rising edge is active
#define DQ_GPSS_DTENC_NRZ           (2)         // NRZ data encoding
#define DQ_GPSS_DTENC_NRZI          (3)         // NRZI data encoding
#define DQ_GPSS_CLKSRC_DIS          (0)         // Clock disabled
#define DQ_GPSS_CLKSRC_PLL          (1)         // PLL
#define DQ_GPSS_CLKSRC_DNA          (2)         // DNA
#define DQ_GPSS_CLKSRC_EXT          (3)         // External
#define DQ_GPSS_DIR_RX              (0)         // Receive mode is active
#define DQ_GPSS_DIR_TX              (1)         // Transmit mode is active
#define DQ_GPSS_TSOURCE_DNA         (0)         // DNA trigger is active
#define DQ_GPSS_TSOURCE_EXT         (1)         // External trigger is active
#define DQ_GPSS_TMODE_1WORD         (0)         // One word(TX)frame(RX)/trigger
#define DQ_GPSS_TMODE_FIFO          (1)         // TX until FIFO is empty/Reserved for RX
#define DQ_GPSS_TMODE_ACT           (2)         // TX/RX until trigger is active
#define DQ_GPSS_TMODE_SBIT          (3)         // TX until stop bit is detected in FIFO/Reserved for RX
#define DQ_GPSS_TTYPE_LEVEL         (0)         // Level trigger is used
#define DQ_GPSS_TTYPE_EDGE          (1)         // Edge trigger is used
#define DQ_GPSS_DTWLEN_VAR          (1)         // Variable data word length
#define DQ_GPSS_FSTYPE_NBIT         (1)         // Frame SYNC type - N bits
#define DQ_GPSS_FSTYPE_NWRD         (2)         // Frame SYNC type - N words
#define DQ_GPSS_FSTYPE_FRM          (3)         // Frame SYNC type - continuous

// IER/ISR/ICR Bit description
// IER Interrupt Enable register used to enable interrupts on per-source basis
// ISR Interrupt status register used to report status - which interrupt was fired (enabled-only)
// ICR Interrupt clear register used to clear interrupt conditions
#define DQ_IR_CPT                   (31)        // Request interrupt if counter complete current operation
#define DQ_IR_CR0L                  (30)        // Request interrupt if current value of CR < CR0
#define DQ_IR_CR0GE                 (29)        // Request interrupt if current value of CR >= CR0
#define DQ_IR_CR1                   (28)        // Request interrupt if current value of CR >= CR1
#define DQ_IR_LHI                   (27)        // Request interrupt if low-high transition was detected on the input pin (deglitched)
#define DQ_IR_LHG                   (26)        // Request interrupt if low-high transition was detected on the gate pin (deglitched)
#define DQ_IR_HLI                   (25)        // Request interrupt if high-low transition was detected on the input pin (deglitched)
#define DQ_IR_HLG                   (24)        // Request interrupt if high-low transition was detected on the gate pin (deglitched)
#define DQ_IR_CRH                   (23)        // Request interrupt if data is available in CRH
#define DQ_IR_CRL                   (22)        // Request interrupt if data is available in CRL
#define DQ_IR_IFE                   (21)        // Request interrupt if input FIFO is empty
#define DQ_IR_IFH                   (20)        // Request interrupt if input FIFO is at least half full
#define DQ_IR_IFF                   (19)        // Request interrupt if input FIFO is full
#define DQ_IR_EVT                   (19)        // (logics >= 0x01021076) Request interrupt from event module
#define DQ_IR_OFE                   (18)        // Request interrupt if output FIFO is empty
#define DQ_IR_OFH                   (17)        // Request interrupt if output FIFO is at least half full
#define DQ_IR_OFF                   (16)        // Request interrupt if output FIFO is full
#define DQ_IR_FRME                  (15)        // GPSS mode TX/RX Frame incomplete error
#define DQ_IR_FRMDR                 (14)        // GPSS mode Rx frame is received in FIFO
#define DQ_IR_FRMDT                 (13)        // GPSS mode Tx frame is sent

#define DQ_IR_TS_FE                 (10)        // Pattern generator FIFO empty IRQ
#define DQ_IR_TS_FHF                 (9)        // Pattern generator FIFO below watermark IRQ
#define DQ_IR_TS_UI                  (8)        // Pattern generator user IRQ

#define DQ_IR601_CPT                (1L<<31)    // Request interrupt if counter complete current operation
#define DQ_IR601_CR0L               (1L<<30)    // Request interrupt if current value of CR < CR0
#define DQ_IR601_CR0GE              (1L<<29)    // Request interrupt if current value of CR >= CR0
#define DQ_IR601_CR1                (1L<<28)    // Request interrupt if current value of CR >= CR1
#define DQ_IR601_LHI                (1L<<27)    // Request interrupt if low-high transition was detected on the input pin (deglitched)
#define DQ_IR601_LHG                (1L<<26)    // Request interrupt if low-high transition was detected on the gate pin (deglitched)
#define DQ_IR601_HLI                (1L<<25)    // Request interrupt if high-low transition was detected on the input pin (deglitched)
#define DQ_IR601_HLG                (1L<<24)    // Request interrupt if high-low transition was detected on the gate pin (deglitched)
#define DQ_IR601_CRH                (1L<<23)    // Request interrupt if data is available in CRH
#define DQ_IR601_CRL                (1L<<22)    // Request interrupt if data is available in CRL
#define DQ_IR601_IFE                (1L<<21)    // Request interrupt if input FIFO is empty
#define DQ_IR601_IFH                (1L<<20)    // Request interrupt if input FIFO is at least half full
#define DQ_IR601_IFF                (1L<<19)    // Request interrupt if input FIFO is full
#define DQ_IR601_EVT                (1L<<19)    // (logics >= 0x01021076) Request interrupt from event module
#define DQ_IR601_OFE                (1L<<18)    // Request interrupt if output FIFO is empty
#define DQ_IR601_OFH                (1L<<17)    // Request interrupt if output FIFO is at least half full
#define DQ_IR601_OFF                (1L<<16)    // Request interrupt if output FIFO is full
#define DQ_IR601_FRME               (1L<<15)    // GPSS mode Rx frame incomplete error
#define DQ_IR601_FRMDR              (1L<<14)    // GPSS mode Rx frame is received in FIFO
#define DQ_IR601_FRMDT              (1L<<13)    // GPSS mode Tx frame is sent

#define DQ_IR602_TS_FE              (1L<<10)    // Pattern generator FIFO empty IRQ
#define DQ_IR602_TS_FHF              (1L<<9)    // Pattern generator FIFO below watermark IRQ
#define DQ_IR602_TS_UI               (1L<<8)    // Pattern generator user IRQ

// End-mode defines (CCR)
#define DQ_EM_CR0                   (0)         // "End-mode" CR=CR0
#define DQ_EM_CR1                   (1)         // "End-mode" CR=CR1
#define DQ_EM_FFF                   (2)         // "End-mode" CR=0xFFFFFFFF
#define DQ_EM_PC                    (3)         // "End-mode" PC=0
#define DQ_EM_TBR                   (4)         // "End-mode" TBR=0
#define DQ_EM_GT                    (5)         // "End-mode" H->L on gate

#define DQ_EM_PULSES                (0x80)      // stop output when PC is used as a stop trigger (CCR_PCSPT)

#define DQL_ADDMODE_DOUBLE_PRECISION (1L<<14)   // double precision mode - to "or" with end-mode constant

#define EV601_LOW_TO_HI             (1)
#define EV601_HI_TO_LOW             (2)

// CT-601 Counter counting mode defines
#define DQ_CM_CT                    (0x0)       // Timer
#define DQ_CM_TPPM                  (0x1)       // TPPM - Timed Pulse Period Measurement
#define DQ_CM_VR                    (0x2)       // VR variable reluctance (i.e. Z-tooth) mode
#define DQ_CM_TCT                   (0x4)       // Triggered timer
#define DQ_CM_TTPPM                 (0x5)       // TTPPM - Triggered Timed Pulse Period Measurement
#define DQ_CM_RTCT                  (0x7)       // Triggered timer, re-trigger upon gate
#define DQ_CM_ECT                   (0x8)       // External event counter
#define DQ_CM_HP                    (0x9)       // 1/2 period capture
#define DQ_CM_NP                    (0xA)       // N periods capture
#define DQ_CM_QE                    (0xB)       // Quadrature encoder
#define DQ_CM_TECT                  (0xC)       // Triggered event counter
#define DQ_CM_THP                   (0xD)       // Triggered 1/2 period capture
#define DQ_CM_TNP                   (0xE)       // Triggered N periods capture

// --------------------------------------------------------------------------------------------------------------------
// ------  CT60x  DIRECT IO  ------------------------------------------------------------------------------------------
// --------------------------------------------------------------------------------------------------------------------
#define CT60x_IO_SUPPORTED          (1076)      // logic version in which I/O register GPIOR starts to be available

// CT-601 direct I/O defines  0x0018(0x101)            -------------------
#define DQ_PL601_GPIOR              (CLI_GPIOR) // R/W (available in logics 0x01021076 or later)
#define DQ_PL601_GPIOR_WRITE        (0x101)     // R/W register number to use to access GPIOR WRITE using the DAQLib
                                                // functions: DqAdv601GetRegister() and DqAdv601SetRegister()
#define DQ_PL601_GPIOR_READ         (0x102)     // R   register number to use to access GPIOR READ using the DAQLib
                                                // function DqAdv601GetRegister()
// GPIOR WRITE  (0x101) CT-601 only
#define DQ_PL601_GPIOR_GPVAL_MASK   (0x00FF)
#define DQ_PL601_GPIOR_GPEN_SHIFT   (8)
#define DQ_PL601_GPIOR_GPEN7        (1L<<15)    // =1 - Switch GPIOx/CLKOUTx into the user mode, in user mode
#define DQ_PL601_GPIOR_GPEN6        (1L<<14)    // value that is driven to the output is set by the corresponding
#define DQ_PL601_GPIOR_GPEN5        (1L<<13)    // GPVALx bit
#define DQ_PL601_GPIOR_GPEN4        (1L<<12)    //  "
#define DQ_PL601_GPIOR_GPEN3        (1L<<11)    //  "
#define DQ_PL601_GPIOR_GPEN2        (1L<<10)    //  "
#define DQ_PL601_GPIOR_GPEN1        (1L<<9)     //  "
#define DQ_PL601_GPIOR_GPEN0        (1L<<8)     //  "
#define DQ_PL601_GPIOR_GPVAL7       (1L<<7)     // Value of CLKOUT7 in user mode
#define DQ_PL601_GPIOR_GPVAL6       (1L<<6)     // Value of CLKOUT6 in user mode
#define DQ_PL601_GPIOR_GPVAL5       (1L<<5)     // Value of CLKOUT5 in user mode
#define DQ_PL601_GPIOR_GPVAL4       (1L<<4)     // Value of CLKOUT4 in user mode
#define DQ_PL601_GPIOR_GPVAL3       (1L<<3)     // Value of CLKOUT3 in user mode
#define DQ_PL601_GPIOR_GPVAL2       (1L<<2)     // Value of CLKOUT2 in user mode
#define DQ_PL601_GPIOR_GPVAL1       (1L<<1)     // Value of CLKOUT1 in user mode
#define DQ_PL601_GPIOR_GPVAL0       (1L<<0)     // Value of CLKOUT0 in user mode

// GPIOR_READ (0x102) CT-601 only
#define DQ_PL601_GPIOR_GATE7        (1L<<23)    // Current value of the corresponding GATE pin
#define DQ_PL601_GPIOR_GATE6        (1L<<22)
#define DQ_PL601_GPIOR_GATE5        (1L<<21)
#define DQ_PL601_GPIOR_GATE4        (1L<<20)
#define DQ_PL601_GPIOR_GATE3        (1L<<19)
#define DQ_PL601_GPIOR_GATE2        (1L<<18)
#define DQ_PL601_GPIOR_GATE1        (1L<<17)
#define DQ_PL601_GPIOR_GATE0        (1L<<16)
#define DQ_PL601_GPIOR_CLKOUT7      (1L<<15)    // Current value of the corresponding CLKOUT pin
#define DQ_PL601_GPIOR_CLKOUT6      (1L<<14)    //
#define DQ_PL601_GPIOR_CLKOUT5      (1L<<13)    //
#define DQ_PL601_GPIOR_CLKOUT4      (1L<<12)    //
#define DQ_PL601_GPIOR_CLKOUT3      (1L<<11)    //
#define DQ_PL601_GPIOR_CLKOUT2      (1L<<10)    //
#define DQ_PL601_GPIOR_CLKOUT1      (1L<<9)     //
#define DQ_PL601_GPIOR_CLKOUT0      (1L<<8)     //
#define DQ_PL601_GPIOR_CLKIN7       (1L<<7)     // Current value of the corresponding CLKIN pin
#define DQ_PL601_GPIOR_CLKIN6       (1L<<6)     //
#define DQ_PL601_GPIOR_CLKIN5       (1L<<5)     //
#define DQ_PL601_GPIOR_CLKIN4       (1L<<4)     //
#define DQ_PL601_GPIOR_CLKIN3       (1L<<3)     //
#define DQ_PL601_GPIOR_CLKIN2       (1L<<2)     //
#define DQ_PL601_GPIOR_CLKIN1       (1L<<1)     //
#define DQ_PL601_GPIOR_CLKIN0       (1L<<0)     //

// CT-602 direct I/O defines  (0x101)(0x102)           -------------------
#define DQ_PL602_GPIOR              (DQL_CLI_GPIOR) // R/W (available in logics 0x01021076 or later)
#define DQ_PL602_GPIOR_WRITE        (0x101)     // R/W register number to use to access GPIOR WRITE using the DAQLib
                                                // functions: DqAdv601GetRegister() and DqAdv601SetRegister()
#define DQ_PL602_GPIOR_READ         (0x102)     // R   register number to use to access GPIOR READ using the DAQLib
                                                // function DqAdv601GetRegister()
// write bit pattern for CT-602 I/O write register DQ_PL602_GPIOR_WRITE:(0x101)
#define DQ_PL602_GPIOR_TRIGEN3      (1L<<31)    //  =1 - enable 422/485 buffer for corresponding TRIGOUTx pin
#define DQ_PL602_GPIOR_TRIGEN2      (1L<<30)    //
#define DQ_PL602_GPIOR_TRIGEN1      (1L<<29)    //
#define DQ_PL602_GPIOR_TRIGEN0      (1L<<28)    //

#define DQ_PL602_GPIOR_CLKEN3       (1L<<27)    //  =1 - enable 422/485 buffer for corresponding CLKOUTx pin
#define DQ_PL602_GPIOR_CLKEN2       (1L<<26)    //
#define DQ_PL602_GPIOR_CLKEN1       (1L<<25)    //
#define DQ_PL602_GPIOR_CLKEN0       (1L<<24)    //

#define DQ_PL602_GPIOR_TXTRMEN3     (1L<<23)    //  =1 - enable 100 Ohm termination on the output pins of the
#define DQ_PL602_GPIOR_TXTRMEN2     (1L<<22)    //  corresponding channel (both CLKOUT and TRIGOUT will be terminated)
#define DQ_PL602_GPIOR_TXTRMEN1     (1L<<21)    //
#define DQ_PL602_GPIOR_TXTRMEN0     (1L<<20)    //

#define DQ_PL602_GPIOR_RXTRMEN3     (1L<<19)    //  =1 - enable 100 Ohm termination on the input pins of the
#define DQ_PL602_GPIOR_RXTRMEN2     (1L<<18)    //  corresponding channel (both CLKIN and GATE will be terminated)
#define DQ_PL602_GPIOR_RXTRMEN1     (1L<<17)    //
#define DQ_PL602_GPIOR_RXTRMEN0     (1L<<16)    //

#define DQ_PL602_GPIOR_GPEN7        (1L<<15)    // Switch GPIO7/CLKOUT3 into the user mode
#define DQ_PL602_GPIOR_GPEN6        (1L<<14)    // Switch GPIO6/TRIGOUT3 into the user mode
#define DQ_PL602_GPIOR_GPEN5        (1L<<13)    // Switch GPIO5/CLKOUT2 into the user mode
#define DQ_PL602_GPIOR_GPEN4        (1L<<12)    // Switch GPIO4/TRIGOUT2 into the user mode

#define DQ_PL602_GPIOR_GPEN3        (1L<<11)    // Switch GPIO3/CLKOUT1 into the user mode
#define DQ_PL602_GPIOR_GPEN2        (1L<<10)    // Switch GPIO2/TRIGOUT1 into the user mode
#define DQ_PL602_GPIOR_GPEN1        (1L<<9)     // Switch GPIO1/CLKOUT0 into the user mode
#define DQ_PL602_GPIOR_GPEN0        (1L<<8)     // Switch GPIO0/TRIGOUT0 into the user mode

#define DQ_PL602_GPIOR_GPVAL7       (1L<<7)     // Value of the GPIO7/CLKOUT3 in the user mode
#define DQ_PL602_GPIOR_GPVAL6       (1L<<6)     // Value of the GPIO6/TRIGOUT3 in the user mode
#define DQ_PL602_GPIOR_GPVAL5       (1L<<5)     // Value of the GPIO5/CLKOUT2 in the user mode
#define DQ_PL602_GPIOR_GPVAL4       (1L<<4)     // Value of the GPIO4/TRIGOUT2 in the user mode

#define DQ_PL602_GPIOR_GPVAL3       (1L<<3)     // Value of the GPIO3/CLKOUT1 in the user mode
#define DQ_PL602_GPIOR_GPVAL2       (1L<<2)     // Value of the GPIO2/TRIGOUT1 in the user mode
#define DQ_PL602_GPIOR_GPVAL1       (1L<<1)     // Value of the GPIO1/CLKOUT0 in the user mode
#define DQ_PL602_GPIOR_GPVAL0       (1L<<0)     // Value of the GPIO0/TRIGOUT0 in the user mode

#define DQ_PL602_GPIOR_TRIGEN_SHFT  (28)        //
#define DQ_PL602_GPIOR_CLKEN_SHFT   (24)        //
#define DQ_PL602_GPIOR_TXTERM_SHFT  (20)        //
#define DQ_PL602_GPIOR_RXTERM_SHFT  (16)        //
#define DQ_PL602_GPIOR_GPEN_SHFT    (8)
#define DQ_PL602_GPIOR_ENABLE_OUT   (0xff000000)
#define DQ_PL602_GPIOR_TERM_MASK    (0x00ff0000) //
#define DQ_PL602_GPIOR_GPEN_MASK    (0x0000ff00) //
#define DQ_PL602_GPIOR_GPVAL_MASK   (0x000000ff) //

//read bit pattern for CT-602 I/O read register DQ_PL602_GPIOR_READ:(0x102)
#define DQ_PL602_GPIOR_CLKOUT3      (1L<<15)    // Current value of the corresponding CLKOUT pin
#define DQ_PL602_GPIOR_TRIGOUT3     (1L<<14)    //
#define DQ_PL602_GPIOR_CLKOUT2      (1L<<13)    //
#define DQ_PL602_GPIOR_TRIGOUT2     (1L<<12)    //
#define DQ_PL602_GPIOR_CLKOUT1      (1L<<11)    //
#define DQ_PL602_GPIOR_TRIGOUT1     (1L<<10)    //
#define DQ_PL602_GPIOR_CLKOUT0      (1L<<9)     //
#define DQ_PL602_GPIOR_TRIGOUT0     (1L<<8)     //
#define DQ_PL602_GPIOR_CLKIN3       (1L<<7)     // Current value of the corresponding CLKIN pin
#define DQ_PL602_GPIOR_GATE3        (1L<<6)     //
#define DQ_PL602_GPIOR_CLKIN2       (1L<<5)     //
#define DQ_PL602_GPIOR_GATE2        (1L<<4)     //
#define DQ_PL602_GPIOR_CLKIN1       (1L<<3)     //
#define DQ_PL602_GPIOR_GATE1        (1L<<2)     //
#define DQ_PL602_GPIOR_CLKIN0       (1L<<1)     //
#define DQ_PL602_GPIOR_GATE0        (1L<<0)     //
//
//    M272_STS        0x0000,    // R      Status register
// Sticky bits 31:16
#define DQ_PL602_M272_STS_AERR        (1L<<20)  // Acknowledge was not received

#define DQ_PL602_M272_STS_PERR        (1L<<19)  // Parity error detected in DI data
#define DQ_PL602_M272_STS_FDONE       (1L<<18)  // =1 when full frame is transmitted and received
#define DQ_PL602_M272_STS_DTERR       (1L<<17)  // =1 if command was expected but data word received
#define DQ_PL602_M272_STS_SSERR       (1L<<16)  // =1 if subsystem error was detected during RX/TX

//0
// Static bits 15:0
#define DQ_PL602_M272_STS_SERR        (1L<<8)   // Report current logic value at Subsystem Error pin

#define DQ_PL602_M272_STS_ACK         (1L<<7)   // Report current logic value at Acknowledge pin
#define DQ_PL602_M272_STS_DI          (1L<<6)   // Report current logic value at DIn pin
#define DQ_PL602_M272_STS_MERR        (1L<<5)   // Report current logic value at Manchester Error pin
#define DQ_PL602_M272_STS_DO          (1L<<4)   // Report current logic value at DOut pin

#define DQ_PL602_M272_STS_REQ         (1L<<3)   // Report current logic value at Request pin
#define DQ_PL602_M272_STS_TX          (1L<<2)   // Report current logic value at Transmit pin
#define DQ_PL602_M272_STS_CLK         (1L<<1)   // Report current logic value at Clock pin
#define DQ_PL602_M272_STS_BUSY        (1L<<0)   // =1 if protocol state machine is busy

//
//    M272_DOFDR        0x0010,    // W    DO FIFO data register
//    M272_DOFWR        0x0014,    // W    DO FIFO watermark register
//    M272_DOFCR        0x0018,    // R    DO FIFO count register
//

// Output FIFO is 32x2048 requires 9 words/transmission. First word should be
// written with M272_DOF_CW bit set to 1 - indicating control word followed by
// 8 data words. Every time when word with control bit set to one is received
// sequence is restarted, only full frames will be processed.
// Data word format in FIFO:
#define DQ_PL602_M272_FIFOSZ      (2048)    // size of the FIFOs
#define DQ_PL602_M272_FIFO_WORDS   (9)      // number of words to send


#define DQ_PL602_M272_DOF_ZERO    (1L<<31)  // Always set to 0
#define DQ_PL602_M272_DOF_CW      (1L<<30)  // This bit should be set for the control word
                                            // and cleared for the data word
#define DQ_PL602_M272_DOF_DLY_US  (1L<<29)  // Reserved - set to 0
#define DQ_PL602_M272_DOF_DIE     (1L<<28)  // Valid in control word only =1 - initiate 5-word
                                            // RX frame after 9-word frame is transmitted
#define DQ_PL602_M272_DOF_PGE     (1L<<27)  // Valid in control word only =1 - add odd parity
                                            // automatically based on 16-bit payload
#define DQ_PL602_M272_DOF_PVE     (1L<<26)  // Valid in control word only =1 - check odd parity
                                            // on the DI data
#define DQ_PL602_M272_DOF_FCE     (1L<<25)  // Valid in control word only =1 - wait for the frame
                                            // clock prior to starting frame
#define DQ_PL602_M272_DOF_WCE     (1L<<24)  // Valid in control word only =1 - wait for the word
                                            // clock prior to sending data from each word out
#define DQ_PL602_M272_DOF_DIF     (1L<<23)  // Valid in control word only =1 - save outgoing data
                                            // back to the DI FIFO
#define DQ_PL602_M272_DOF_DEF     (1L<<22)  // Valid in control word only =1 - save echo data
                                            // back to the DI FIFO

// Format for the data payload
#define DQ_PL602_M272_DOF_PAR     (1L<<16)  // Parity bit - used when M272_DOF_PGE in control word
#define DQ_PL602_M272_DOF_D15     (1L<<15)  // 16-bit data payload
#define DQ_PL602_M272_DOF_D0      (1L<<0)   //

#define DQ_PL602_M272_DOF(D,P)    (((D)&0xffff)|(((P)&1)<<16))

// Format for the data as transferred on the wire
#define DQ_PL602_M272_BUS_D15     (1L<<16)  // 16-bit data payload
#define DQ_PL602_M272_BUS_D0      (1L<<1)   //
#define DQ_PL602_M272_BUS_PAR     (1L<<0)   // Parity bit


//    M272_DIFDR        0x0020,    // R    DI FIFO data register
//    M272_DIFWR        0x0024,    // W    DI FIFO watermark register
//    M272_DIFCR        0x0028;    // R    DI FIFO count register
// DI FIFO is 32x2048 and stores incoming packets along with timestamp and other information
#define DQ_PL602_M272_DIF_PSTS    (1L<<31)  // =1 packet timestamp (bits 30-0), mutually
                                            // exclusive with bits RDW, EOF
#define DQ_PL602_M272_DIF_ZERO    (1L<<30)  // This bit should be set to zero with exception of timestamp
#define DQ_PL602_M272_DIF_RDW     (1L<<29)  // =1 redirected data word (from DO FIFO)
#define DQ_PL602_M272_DIF_EOF     (1L<<28)  // =1 last data word in the packet

#define DQ_PL602_M272_DIF_ERR     (1L<<27)  // =1 protocol error was detected during data word reception
#define DQ_PL602_M272_DIF_TO      (1L<<26)  // =1 timeout was detected during data word reception
#define DQ_PL602_M272_DIF_SERR    (1L<<25)  // =1 subsystem/manchester error was detected during
                                            // data word reception
// Format for the data payload
#define DQ_PL602_M272_DIF_DLY6    (1L<<23)      // 7-bit value representing  delay from the previous
#define DQ_PL602_M272_DIF_DLY0    (1L<<17)  // data word - measured in system clocks (66MHz)
#define DQ_PL602_M272_DIF_DLY(N)  (((N)&0x0x7F)>>17)

#define DQ_PL602_M272_DIF_PAR     (1L<<16)  // Parity bit - used when M272_DOF_PGE in control word

#define DQ_PL602_M272_DIF_D15     (1L<<15)  // 16-bit data payload
#define DQ_PL602_M272_DIF_D0      (1L<<0)   //
#define DQ_PL602_M272_DIF_D(N)    ((N)&0xffff)   //

// Format for the timestamp [PSTS==1]
#define DQ_PL602_M272_DIF_TS29    (1L<<30)  // 31-bit layer's timestamp
#define DQ_PL602_M272_DIF_TS(N)   ((N)&0x7fffffff)   //

// Format for the timeout (ACK not released) error [PSTS==0,EOF==1,TO=1]
#define DQ_PL602_M272_DIF_ERRTS23 (1L<<23)   // 24-bit part of layer's timestamp
#define DQ_PL602_M272_DIF_ERRTS0  (1L<<0)    //

#define DQ_PL602_M272_DIF_ERRTS(N)  ((N)&0xffffff)    //

//    CT602_808_PXX_STS        (1L<<16'h2024)    // R      PRF/PIM Status register
// Sticky bits 31:16
#define DQ_CT602_808_PXX_STS_PIM_DONE     (1L<<26)  // PIM frame was received
#define DQ_CT602_808_PXX_STS_PRF_DONE     (1L<<25)  // PRF data was received
#define DQ_CT602_808_PXX_STS_PRFPIM_FHF   (1L<<24)  // PRF/PIM RX FIFO is above watermark

#define DQ_CT602_808_PXX_STS_PRFPIM_FF    (1L<<23)  // PRF/PIM RX FIFO is full - critical IRQ
#define DQ_CT602_808_PXX_STS_PRFRCLKTERR  (1L<<22)  // PRF clock timing error
#define DQ_CT602_808_PXX_STS_PRFCLKCERR   (1L<<21)  // PRF clock count error
#define DQ_CT602_808_PXX_STS_PIMCLKTERR   (1L<<20)  // PIM clock timing error

#define DQ_CT602_808_PXX_STS_PIMCLKCERR   (1L<<19)  // PIM clock count error
#define DQ_CT602_808_PXX_STS_PRFDTERR     (1L<<18)  // PRF data bit timing error (glitch)
#define DQ_CT602_808_PXX_STS_PIMDTERR     (1L<<17)  // PIM data bit timing error (stalled p_code)
#define DQ_CT602_808_PXX_STS_PIMDWE       (1L<<16)  // Error detected while receiving PIM 35-bit word

// 0
// 0
// Static bits 15:0
#define DQ_CT602_808_PXX_STS_PIM_IDLE     (1L<<7)  // =1 if PIM SM is in IDLE
#define DQ_CT602_808_PXX_STS_PRF_IDLE     (1L<<6)  // =1 if PRF SM is in IDLE
#define DQ_CT602_808_PXX_STS_ACC          (1L<<5)  // Report current logic status of ACCEPT strobe
#define DQ_CT602_808_PXX_STS_CLK          (1L<<4)  // Report current logic value at Clock pin

#define DQ_CT602_808_PXX_STS_CODE         (1L<<3)  // Report current logic value at Code pin
#define DQ_CT602_808_PXX_STS_BPIM         (1L<<2)  // =1 if PRF/PRM protocol SM is in PIM receive
#define DQ_CT602_808_PXX_STS_BPRF         (1L<<1)  // =1 if PRF/PRM protocol SM is in PRF receive
#define DQ_CT602_808_PXX_STS_IDLE         (1L<<0)  // =1 if PRF/PRM protocol SM is in IDLE

//    CT602_808_PXX_DIFDR        0x2030,    // R    PRF/PIM RX FIFO data register
//    CT602_808_PXX_DIFWR        0x2034,    // W    PRF/PIM RX FIFO watermark register
//    CT602_808_PXX_DIFCR        0x2038,    // R    PRF/PIM RX FIFO count register
// PRF/PIM data is stored into the 2048x32 RX FIFO. Protocol state machine processes
// PRF data words individually, with optional block of the PIM data that can follow.
// Note that protocol validation errors during the data reception may result in
// incomplete PIM frames stored into the FIFO.
#define DQ_CT602_808_PXX_DIF_FMT1    (1L<<31)    // Upper two bits of the PRF/PIM FIFO are used
#define DQ_CT602_808_PXX_DIF_FMT0    (1L<<30)    // to specify which format is used for the following
#define DQ_CT602_808_PXX_DIF_FMT(N)  ((N)<<30)   // to specify which format is used for the following

#define DQ_CCT602_808_PXX_DIF_FMT_TS  0  // 00 PRF timestamp
#define DQ_CCT602_808_PXX_DIF_FMT_DS  1  // 01 PRF data and status flags
#define DQ_CCT602_808_PXX_DIF_FMT_PT  2  // 10 PIM timestamp, start/stop/parity and first 8 bit of data
#define DQ_CCT602_808_PXX_DIF_FMT_PD  3  // 11 PIM data bits 23-0, status bits

// Format type 00 - timestamp
#define DQ_CT602_808_PXX_DIF_TS29    (1L<<29) // Timestamp  provides lowest 30 bits of the
#define DQ_CT602_808_PXX_DIF_TS0     (1L<<0)  // layer's timestamp, default timebase is 10uS
#define DQ_CT602_808_PXX_DIF_TS(N)   ((N)&0x3fffffff)

// Format type  01 PRF data and status flags
// 29-16    PRF_STS    Status - reserved
#define DQ_CT602_808_PXX_DIF_DS15    (1L<<15) // 16-bit PRF data as received from the bus
#define DQ_CT602_808_PXX_DIF_DS(N)   ((N)&0xffff)

// Format type 10  PIM timestamp, start/stop/parity and first 8 bit of data
#define DQ_CT602_808_PXX_DIF_STB    (1L<<29)  // Start bit, Stop bit. Note that start/stop bits are
#define DQ_CT602_808_PXX_DIF_SPB    (1L<<28)  // validated and thus should match their pre-configured values
#define DQ_CT602_808_PXX_DIF_PAR    (1L<<27)  // Parity bit as received (parity precedes stop bit)
#define DQ_CT602_808_PXX_DIF_RES26  (1L<<26)  //    PIM_RSV    Reserved
#define DQ_CT602_808_PXX_DIF_ERR    (1L<<25)  // =1  Error detected while waithing for the EOF
                                              // (PRF received while waiting for PIM EOF)
#define DQ_CT602_808_PXX_DIF_EOF    (1L<<24)  // =1  Last word in PIM frame, set when 16th PIM frame clock
                                              // is detected within time specified in CT602_808_PIM_16CLKDLY
#define DQ_CT602_808_PXX_DIF_PTS15   (1L<<23) // Timestamp  provides lowest 16 bits of the layer's
#define DQ_CT602_808_PXX_DIF_PTS(TS) (1L<<8)  // timestamp, default timebase is 10uS


#define DQ_CT602_808_PXX_DIF_PD31    (1L<<7)  // Bits 31-24 of the data payload of the PIM data word
#define DQ_CT602_808_PXX_DIF_PD24    (1L<<0)  //

// Format type 11  PIM data bits 23-0, status
#define DQ_CT602_808_PXX_DIF_RES29   (1L<<29) // 29-24    PIM_RSV    Reserved
#define DQ_CT602_808_PXX_DIF_RES24   (1L<<24)
#define DQ_CT602_808_PXX_DIF_PD23    (1L<<23) // Bits 23-0 of the data payload of the PIM data word
#define DQ_CT602_808_PXX_DIF_PD0     (1L<<0)  //


//    PGEN_CFG    0x0000,    // R/W    Pattern generator configuration register
//    This register is used to select whether start/stop trigger should be used
// to start/stop pattern generator
#define DQ_CT602_PGEN_CFG_STTEN    (1L<<1) // Start trigger enable
#define DQ_CT602_PGEN_CFG_SPTEN    (1L<<0) // Stop trigger enable

#define DQ_CT602_PGEN_CFG_ENABLE   (1L<<31) // enable/disable PGEN mode
#define DQ_CT602_PGEN_EN_OUT       (1L<<30) // enable of disable output buffers without switching on/off PGEN mode


//    PGEN_STS    0x0004,    // R    Pattern generator status register
// Bits 31-16 report current status
#define DQ_CT602_PGEN_STS_FHF    (1L<<17)  // =1 Pattern generator FIFO is below watermark
#define DQ_CT602_PGEN_STS_FE     (1L<<16)  // =1 Pattern generator FIFO is empty

// Bits 15-0 are sticky
#define DQ_CT602_PGEN_STS_IRQ    (1L<<2)   // =1 IRQ from the pattern generator was issued
#define DQ_CT602_PGEN_STS_CLK    (1L<<1)   // =1 clock from the pattern generator was issued
#define DQ_CT602_PGEN_STS_ERR    (1L<<0)   // =1 if error in the TX data/command sequence was detected

//    PGEN_FCMDR    0x0008,    // W    Pattern generator FIFO command register
// Each pattern generator transaction requires two pieces of the information -
// command which tells what to do, which clock source to use, what is delay
// before outputting pattern, etc. and second - actual data that should be written
// to the output. This register holds command, each command should be followed by
// the data which should be written to PGEN_FDR register

#define DQ_CT602_PGEN_FCMDR_CLK            (1L<<20) // =1 - issue clock when pattern outputted
#define DQ_CT602_PGEN_FCMDR_IRQ            (1L<<19) // =1 - issue IRQ when pattern outputted

#define DQ_CT602_PGEN_FCMDR_CLKSRC(N)      (((N)&0x7)<<16) // 0 - system clock
                                                           // 1 - frame clock CL IN CL
                                                           // 2 - word clock  CL IN CV
                                                           // 3 - time clock  CL OUT CV
                                                           // 4 - pattern wait
                                                           // All other sources are reserved and will
                                                           // stall time sequencer if selected
#define DQ_CT602_PGEN_FCMDR_DLY_D(N)       ((N)&0xffff)        //

#define DQ_CT602_PGEN_FCMDR_PAT_EN_D(N)    (((N)&0xff)<<8) // Enable bits for the input pattern
#define DQ_CT602_PGEN_FCMDR_PAT_IN_D(N)    (((N)&0xff)<<0) // Input pattern compare value

#define DQ_CT602_PGEN_FCMDR_CLKSRC_DEF   (0)  // Default - system clock, 66MHz for most layers
                                              // Note that pattern generator state machine takes
                                              // minimum of five clock cycles that should be
                                              // accounted for when using system clock
#define DQ_CT602_PGEN_FCMDR_CLKSRC_FC    (1)  // Frame clock | Note: that frame, word and time
#define DQ_CT602_PGEN_FCMDR_CLKSRC_WC    (2)  // Word clock  | clocks are just three edge-
#define DQ_CT602_PGEN_FCMDR_CLKSRC_TC    (3)  // Time clock | qualified clock sources
                                              // All three clocks should be slower than
                                              // system clock/5
#define DQ_CT602_PGEN_FCMDR_CLKSRC_PW    (4)  // Pattern wait is a special mode when lower
                                              // eight bits of the delay code are used as a
                                              // pattern and upper eight as enable/disable
                                              // bits for the pattern checker.
                                              // Example : 0x480F will check bits 3 and 6 of
                                              // the input pattern and wait until bit 3
                                              // equal 1 and bit 6 equal 0

//    PGEN_FDR    0x000C,    // W    Pattern generator FIFO data register
// Pattern generation data, 8 LSBs are valid
#define DQ_CT602_PGEN_PGEN7    (1L<<7)   // GPIO7/CLKOUT3(CT-602)/CLKOUT7(CT-601)
#define DQ_CT602_PGEN_PGEN6    (1L<<6)   // GPIO6/TRIGOUT3(CT-602)/CLKOUT6(CT-601)
#define DQ_CT602_PGEN_PGEN5    (1L<<5)   // GPIO5/CLKOUT2(CT-602)/CLKOUT5(CT-601)
#define DQ_CT602_PGEN_PGEN4    (1L<<4)   // GPIO4/TRIGOUT2(CT-602)/CLKOUT4(CT-601)
#define DQ_CT602_PGEN_PGEN3    (1L<<3)   // GPIO3/CLKOUT1(CT-602)/CLKOUT3(CT-601)
#define DQ_CT602_PGEN_PGEN2    (1L<<2)   // GPIO2/TRIGOUT1(CT-602)/CLKOUT2(CT-601)
#define DQ_CT602_PGEN_PGEN1    (1L<<1)   // GPIO1/CLKOUT0(CT-602)/CLKOUT1(CT-601)
#define DQ_CT602_PGEN_PGEN0    (1L<<0)   // GPIO0/TRIGOUT0(CT-602)/CLKOUT0(CT-601)

//     PGEN_FWR    0x0010,    // W    Pattern generator FIFO watermark register
// Pattern FIFO watermark register - used to set interrupt level.

//    PGEN_FCR    0x0014,    // R    Pattern generator FIFO count register
// This register reports current number of occupied words in the time sequencer FIFO,
// each transaction uses two words
//

// Upper part of the configuration word - PL-601 specific
#define DQ_PL_601_MODESCAN          (0L << 16)  // single scan update mod
#define DQ_PL_601_MODEFIFO          (2L << 16)  // continuous acquisition with FIFO
#define DQ_PL_601_MODECONT          (3L << 16)  // continuous acquisition

#define DQ_PL_601_TSCOPY            (1L << 18)  // Push timestamp into FIFO along with data

// Output FIFO to read data
#define DQ_PL_601_FIFO_GET_DATA     (DQ_FIFO_GET_DATA)



#define DQ_PL_601_NAMELEN           (16)        // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_PL_601_CHAN][DQ_PL_601_NAMELEN];
} DQCNAMES_601_, *pDQCNAMES_601_;

/* specific device structure - calibration values */
typedef struct {
    uint32 placeholder;
} DQCALSET_601_, *pDQCALSET_601_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_PL_601_CHAN*2]; // channel list - full
    uint32 conf;                    // control word - layer API flags
    uint32 cvclk;                   // CV clock
    uint32 clclk;                   // CL clock
    uint32 trig;                    // trigger conditions
    int clperint;                   // <reserved>
} DQOPMODEPRM_601_, *pDQOPMODEPRM_601_;

/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_601_ calset;
    DQOPMODEPRM_601_ opmodeprm;
    DQCNAMES_601_ cname;
    DQPRMFLAGS eeflags;
    //uint8            res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)- sizeof(DQCALSET_601_)-
    //                     sizeof(DQOPMODEPRM_601_)- sizeof(DQCNAMES_601_)-
    //                     sizeof(DQPRMFLAGS)- sizeof(DQEEPROMTAIL)];
    //DQEEPROMTAIL     eever_crc;     // contains EEPROM_STRUCT_VER_601 and CRC
} DEVEEPROM_601_, *pDEVEEPROM_601_;

// channel list structure for run-time
typedef struct {
    uint32  startmode;              // trigger mode DQ_PL601_TRG###
    uint32  sampwidth;              // expected sample width

    uint32  ps;                     // prescaler
    uint32  pc;                     // period counter
    uint32  cr0;
    uint32  cr1;                    // compare 0/1
    uint32  tbr;                    // time base
    uint32  dbg;
    uint32  dbc;                    // debounce
    uint32  ctr;                    // ctr - input, gate, output inversion
    uint32  ccr;                    // configuration
    uint32  lr;                     // load
    uint32  ier;                    //
} DQCHNLSET_601_, *pDQCHNLSET_601_;

typedef struct {
    uint16 in_wm;                   // pwm
    uint16 out_wm;                  // others
} DQWMSET_601_, *pDQWMSET_601_;

typedef struct {
    uint8   chnl;                   // |7-4 = event flags|3-0 = channel|
    uint32 data[DQ_FLEX_ARRAY];                  // n - 32bit samples
} DQMSG_601, *pDQMSG_601;

typedef struct {
    uint32 tstamp;
    uint8  msglen;
    uint8  chnl;
    uint8  data[DQ_FLEX_ARRAY];
} DQMSG_601_L, *pDQMSG_601_L;


// For DqAdv602SetM272Cfg()
#define DQ_M272_MASK_PRF_1kmin      (1L<<0)
#define DQ_M272_MASK_PRF_1kmax      (1L<<1)
#define DQ_M272_MASK_PRF_1klen      (1L<<2)
#define DQ_M272_MASK_PRF_1kpmin     (1L<<3)
#define DQ_M272_MASK_PRF_1kpmax     (1L<<4)
#define DQ_M272_MASK_PRF_1kidle     (1L<<5)

#define DQ_M272_MASK_PRF_1kcmin     (1L<<6)
#define DQ_M272_MASK_PRF_1kcmax     (1L<<7)

#define DQ_M272_MASK_PIM_10kmin     (1L<<8)
#define DQ_M272_MASK_PIM_10kmax     (1L<<9)
#define DQ_M272_MASK_PIM_10klen     (1L<<10)
#define DQ_M272_MASK_PIM_10kpmin    (1L<<11)
#define DQ_M272_MASK_PIM_10kpmax    (1L<<12)
#define DQ_M272_MASK_PIM_10kidle    (1L<<13)

#define DQ_M272_MASK_PXX_accdly     (1L<<14)
#define DQ_M272_MASK_PXX_acclen     (1L<<15)

#define DQ_M272_MASK_PIM_16clkdly   (1L<<16)

#define DQ_M272_MASK_272_2mdiv      (1L<<17)
#define DQ_M272_MASK_272_ackdodly   (1L<<18)
#define DQ_M272_MASK_272_ackdidly   (1L<<19)
#define DQ_M272_MASK_272_dwgap      (1L<<20)
#define DQ_M272_MASK_272_clkdly     (1L<<21)
#define DQ_M272_MASK_272_merrlen    (1L<<22)
#define DQ_M272_MASK_272_serrlen    (1L<<23)
#define DQ_M272_MASK_272_rxtxdly    (1L<<24)

#define DQ_M272_MASK_NODEF          (1L<<31)    // do not use default values


// Default values for the parametric registers
#define DQ_M272_MASK_PRF_1kmin_def      0
#define DQ_M272_MASK_PRF_1kmax_def      0
#define DQ_M272_MASK_PRF_1klen_def      0
#define DQ_M272_MASK_PRF_1kpmin_def     0
#define DQ_M272_MASK_PRF_1kpmax_def     0
#define DQ_M272_MASK_PRF_1kidle_def     0

#define DQ_M272_MASK_PRF_1kcmin_def     0
#define DQ_M272_MASK_PRF_1kcmax_def     0

#define DQ_M272_MASK_PIM_10kmin_def     0
#define DQ_M272_MASK_PIM_10kmax_def     0
#define DQ_M272_MASK_PIM_10klen_def     0
#define DQ_M272_MASK_PIM_10kpmin_def    0
#define DQ_M272_MASK_PIM_10kpmax_def    0
#define DQ_M272_MASK_PIM_10kidle_def    0

#define DQ_M272_MASK_PXX_accdly_def     0
#define DQ_M272_MASK_PXX_acclen_def     0

#define DQ_M272_MASK_PIM_16clkdly_def   0

#define DQ_M272_MASK_272_2mdiv_def      0
#define DQ_M272_MASK_272_ackdodly_def   0
#define DQ_M272_MASK_272_ackdidly_def   0
#define DQ_M272_MASK_272_dwgap_def      0
#define DQ_M272_MASK_272_clkdly_def     0
#define DQ_M272_MASK_272_merrlen_def    0
#define DQ_M272_MASK_272_serrlen_def    0
#define DQ_M272_MASK_272_rxtxdly_def    0

// configuration
#define DQ_M272_CFG_EN_272          (1L<<0)     // enable M272 protocol
#define DQ_M272_CFG_EN_PIM          (1L<<1)     // enable PIM protocol
#define DQ_M272_CFG_EN_PRF          (1L<<2)     // enable PRF protocol

#define DQ_M272_CFG_PIM_ACC_EN      (1L<<4)     // clock accept after PIM reception
#define DQ_M272_CFG_PRF_ACC_EN      (1L<<5)     // clock accept after PRF reception
#define DQ_M272_CFG_FIFO_DIDO       (1L<<6)     // echo transmitted words into FIFO in M272 protocol
#define DQ_M272_CFG_MERR_EN         (1L<<7)     // enable m272_merr generation when parity error is detected

// M272/PRF/PMI configuration structure. All members must be uint32
typedef struct {
    uint32 mask;            // specify which parameters needs to be taken over default settings
    uint32 config;          // configuration register
    uint32 param0;          // assitional mask parameters
    uint32 param1;          //

    uint32 prf_1kmin;       // Minimum length of the 1KHz clock high
    uint32 prf_1kmax;       // Maximum length of the 1KHz clock high
    uint32 prf_1klen;       // Nominal period of the 1KHz
    uint32 prf_1kpmin;      // Minimum period of the 1KHz
    uint32 prf_1kpmax;      // Maximum period of the 1KHz period
    uint32 prf_1kidle;      // # of 1KHz clocks prior to detecting PRF idle state

    uint32 prf_1kcmin;      // Minimum length of the code at 1KHz
    uint32 prf_1kcmax;      // Maximum length of the code at 1KHz

    uint32 pim_10kmin;      // Minimum length of the 10KHz clock high
    uint32 pim_10kmax;      // Maximum length of the 10KHz clock high
    uint32 pim_10klen;      // Nominal period of the 10KHz
    uint32 pim_10kpmin;     // Minimum period of the 10KHz
    uint32 pim_10kpmax;     // Maximum period of the 10KHz period
    uint32 pim_10kidle;     // # of 10KHz clocks prior to detecting PIM idle state

    uint32 pxx_accdly;      // Delay prior to issuing "p_accept" pulse
    uint32 pxx_acclen;      // Duration of the "p_accept" pulse

    uint32 pim_16clkdly;    // Maximum delay prior to 16-th EOF clock in PIM mode

    uint32 m272_2mdiv;      // Divider for 2MHz clock (2x output clock rate)
    uint32 m272_ackdodly;   // Request high/low to acknowledge high/low delay DOut
    uint32 m272_ackdidly;   // Request high/low to acknowledge high/low delay DIn
    uint32 m272_dwgap;      // Length of the data word gap
    uint32 m272_clkdly;     // Acknowledge to first M272 CLK delay
    uint32 m272_merrlen;    // M272 Manchester Error pulse length
    uint32 m272_serrlen;    // Minimum length of the M272 Subsystem error pulse
    uint32 m272_rxtxdly;    // Delay prior to starting TX frame after end of RX frame

} DQ_M272_CFG, *pDQ_M272_CFG;


typedef struct {
    uint32 config;          // configuration register
    uint32 frm_clk_sel;     // selector of the frame clock (CL IN CL)
    uint32 word_clk_sel;    // selector of the frame clock (CL IN CV)
    uint32 time_clk_sel;    // selector of the frame clock (CL OUT CV)
    uint32 tmr0_div;        // TMR0 divider
    uint32 tmr1_div;        // TMR0 divider
    uint32 start_trig;      // start trigger source
    uint32 stop_trig;       // stop trigger source
    uint32 gpio_mask;       // specify which lines needs to be enabled
} DQ_CT602_PGEN_CONF, *pDQ_CT602_PGEN_CONF;

// clocks can be selected from one of the following sources
// clock sources for the definition above
#define DQ_CT602_PGEN_SRC_SW     (0x0)   //   0    0000 - software, software clock may also used
                                         //     with any other clock source
#define DQ_CT602_PGEN_SRC_TMR0   (0x1)   //   1    0001 - TMR0 (pulse)
#define DQ_CT602_PGEN_SRC_CROSS  (0x2)   //   2    0010 - "cross-clock" from "opposite" channel list
#define DQ_CT602_PGEN_SRC_TMR1   (0x3)   //   3    0011 - TMR1 (pulse)
#define DQ_CT602_PGEN_SRC_EXT0   (0x4)   //   4    0100 - iso_ext0
#define DQ_CT602_PGEN_SRC_EXT1   (0x5)   //   5    0101 - iso_ext1
#define DQ_CT602_PGEN_SRC_TB     (0x6)   //   6    0110 - timebase
#define DQ_CT602_PGEN_SRC_INTER0 (0x8)   //   8    1000 - Internal source 0, layer-specific
                                         //     601 - clkout[0]
#define DQ_CT602_PGEN_SRC_INTER1 (0x9)   //   9    1001 - Internal source 1, layer-specific
                                         //     601 - clkout[1]
#define DQ_CT602_PGEN_SRC_SYNC0  (0xC)   //   12   1100 - External SYNC line 0
#define DQ_CT602_PGEN_SRC_SYNC1  (0xD)   //   13   1101 - External SYNC line 1
#define DQ_CT602_PGEN_SRC_SYNC2  (0xE)   //   14   1110 - External SYNC line 2
#define DQ_CT602_PGEN_SRC_SYNC3  (0xF)   //   15   1111 - External SYNC line 3
//
// Start and stop trigger can be selected from the following sources
//
#define DQ_CT602_PGEN_TSCFG_NA    (0x0)  //    0    0000 - trigger not used (start trigger always detected/stop trigger never detected)
#define DQ_CT602_PGEN_TSCFG_SW    (0x1)  //    1    0001 - software (read from TSCFG/TPCFG; read/write BTP/BTS)
#define DQ_CT602_PGEN_TSCFG_EXT0  (0x4)  //    4    0100 - iso_ext0
#define DQ_CT602_PGEN_TSCFG_EXT1  (0x5)  //    5    0101 - iso_ext1
#define DQ_CT602_PGEN_TSCFG_TB    (0x6)  //    6    0110 - timebase
#define DQ_CT602_PGEN_TSCFG_PB    (0x7)  //    7    0111 - Push button
#define DQ_CT602_PGEN_TSCFG_SYNC0 (0xC)  //    12   1100 - External SYNC line 0
#define DQ_CT602_PGEN_TSCFG_SYNC1 (0xD)  //    13   1101 - External SYNC line 1
#define DQ_CT602_PGEN_TSCFG_SYNC2 (0xE)  //    14   1110 - External SYNC line 2
#define DQ_CT602_PGEN_TSCFG_SYNC3 (0xF)  //    15   1111 - External SYNC line 3
                                         //
#define DQ_CT602_PGEN_TSCFG_EDGE  (0x10) //        10000 - Use rising edge

#pragma pack()


#define DQ_PL_604_CHAN    4         // working channels
#define DQ_PL_604_CHANSVC 4         // total channels including service
#define DQ_PL_604_INFOSZ  DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_PL_604_BASE    BUS_FREQUENCY  // 66MHz base frequency
#define DQ_PL_604_PLL     16500000       // 16.5Mhz clock

// Maximum working frequencies
#define DQ_PL_604_MAXCLFRQ  50000
#define DQ_PL_604_MAXCVFRQ  50000

// helper macros
#define DQ_PL604_CHNLMASK (0xf0)
#define DQ_PL604_MSGNORM (0)

// ioctls
#define DQL_IOCTL604_SETCHNL_CFG (1L)
#define DQL_IOCTL604_SET_REG (2L)
#define DQL_IOCTL604_GET_REG (3L)
#define DQL_IOCTL604_CTR_EN (4L)
#define DQL_IOCTL604_CTR_DIS (5L)
#define DQL_IOCTL604_ENALL (6L)
#define DQL_IOCTL604_DISALL (7L)
#define DQL_IOCTL604_READCHNL (8L)
#define DQL_IOCTL604_CTR_CLR (9L)
#define DQL_IOCTL604_SET_WM (10L)
#define DQL_IOCTL604_GET_DIN (11L)
#define DQL_IOCTL604_GET_DOUT (12L)
#define DQL_IOCTL604_SET_DOUT (13L)

#define DQ_L604_FIFOSZ      1024 // size of fifo

// Interrupt enable/mask/status clear bits in CLI IER/IMR/ICR/ISR

// used by QDU0-QDU3 counters
#define DQ_ICR_QDU3 3   // CTU3 interrupt
#define DQ_ICR_QDU2 2   // CTU2 interrupt
#define DQ_ICR_QDU1 1   // CTU1 interrupt
#define DQ_ICR_QDU0 0   // CTU0 interrupt

#define DQ_ICR_QDU_MASK (0xf) // IRQ mask

// Counter 0-3 base addresses
#define QD604_QDU0S    0x2100   // QDU 0 start/base
#define QD604_QDU0E    0x21FC   // QDU 0 end
#define QD604_QDU1S    0x2200   // QDU 1 start/base
#define QD604_QDU1E    0x22FC   // QDU 1 end
#define QD604_QDU2S    0x2300   // QDU 2 start/base
#define QD604_QDU2E    0x23FC   // QDU 2 end
#define QD604_QDU3S    0x2400   // QDU 3 start/base
#define QD604_QDU3E    0x24FC   // QDU 3 end

// Global register addresses
#define QD604_DIN_604   0x2000 // R Current value of the all QUAD-604 debounced input pins
#define QD604_DOUT_604  0x2004 // R/W Digital output port for the GPIO pins

// QDU register addresses
#define QD604_QDU_STR   0x00    //  R   QDU status register
#define QD604_QDU_CTR   0x04    //  R/W QDU control register
#define QD604_QDU_CCR   0x08    //  R/W QDU Counter control register
#define QD604_QDU_CR    0x0C    //  R   Current value of the count register
#define QD604_QDU_LR    0x10    //  R/W Load register
#define QD604_QDU_IDBA  0x14    //  R/W Debouncing register for the input A
#define QD604_QDU_IDBB  0x18    //  R/W Debouncing register for the input B
#define QD604_QDU_IDBZ  0x1C    //  R/W Debouncing register for the input Z
#define QD604_QDU_IDBT  0x20    //  R/W Debouncing register for the input T
#define QD604_QDU_CR0   0x24    //  R/W QDU compare register 0
#define QD604_QDU_CR1   0x28    //  R/W QDU compare register 1
#define QD604_QDU_TBR   0x2C    //  R/W Timebase register
#define QD604_QDU_QED   0x30    //  R/W Quadrature Encoder Delay register
#define QD604_QDU_OW    0x34    //  R/W TRIGOUT/CLKOUT pulse width
#define QD604_QDU_INC   0x38    //  R/W Increment value for the EM_INC mode
#define QD604_QDU_FCNTI 0x3C    //  R   QDU Input FIFO Count
#define QD604_QDU_IFWR  0x40    //  R/W QDU Input FIFO Watermark Register
#define QD604_QDU_FDTI  0x44    //  R   QDU Input FIFO Data
#define QD604_QDU_IER   0x48    //  R/W QDU Interrupt Enable register
#define QD604_QDU_ISR   0x4C    //  R   QDU Interrupt status register
#define QD604_QDU_ICR   0x4C    //  W   QDU Interrupt Clear register

// 0x2000 RD - QD604_DIN_604 - Current value of the all QUAD-604 debounced
#define QD604_DIN_604_INT3  15  // Value of the QDU3 input pin TRIGIN
#define QD604_DIN_604_INZ3  14  // Value of the QDU3 input pin Z
#define QD604_DIN_604_INB3  13  // Value of the QDU3 input pin B
#define QD604_DIN_604_INA3  12  // Value of the QDU3 input pin A
#define QD604_DIN_604_INT2  11  // Value of the QDU2 input pin TRIGIN
#define QD604_DIN_604_INZ2  10  // Value of the QDU2 input pin Z
#define QD604_DIN_604_INB2  9   // Value of the QDU2 input pin B
#define QD604_DIN_604_INA2  8   // Value of the QDU2 input pin A
#define QD604_DIN_604_INT1  7   // Value of the QDU1 input pin TRIGIN
#define QD604_DIN_604_INZ1  6   // Value of the QDU1 input pin Z
#define QD604_DIN_604_INB1  5   // Value of the QDU1 input pin B
#define QD604_DIN_604_INA1  4   // Value of the QDU1 input pin A
#define QD604_DIN_604_INT0  3   // Value of the QDU0 input pin TRIGIN
#define QD604_DIN_604_INZ0  2   // Value of the QDU0 input pin Z
#define QD604_DIN_604_INB0  1   // Value of the QDU0 input pin B
#define QD604_DIN_604_INA0  0   // Value of the QDU0 input pin A

// 0x2004 RD/WR - QD604_DOUT_604 - Digital output port for the GPIO pins
#define QD604_DOUT_604_CLK3     7   // QTU3 CLKOUT/DOUT1 output value
#define QD604_DOUT_604_TRIG3    6   // QTU3 TRIGOUT/DOUT0 output value
#define QD604_DOUT_604_CLK2     5   // QTU2 CLKOUT/DOUT1 output value
#define QD604_DOUT_604_TRIG2    4   // QTU2 TRIGOUT/DOUT0 output value
#define QD604_DOUT_604_CLK1     3   // QTU1 CLKOUT/DOUT1 output value
#define QD604_DOUT_604_TRIG1    2   // QTU1 TRIGOUT/DOUT0 output value
#define QD604_DOUT_604_CLK0     1   // QTU0 CLKOUT/DOUT1 output value
#define QD604_DOUT_604_TRIG0    0   // QTU0 TRIGOUT/DOUT0 output value

// 0x2100 RD - QD604_QDU_STR - QDU status register
#define QD604_QDU_STR_EN      31 // 1 indicates that CR is enabled in QDU_CTR CTR_EN bit
#define QD604_QDU_STR_TOOFAST 30 // 1 indicates that input ferquency for the main counter is above the limit (reserved)
#define QD604_QDU_STR_CR0L    29 // 1 indicates that CR < CR0
#define QD604_QDU_STR_BUSY    30  //  1 indicates that CR is counting or 0 if current counting operation is complete
#define QD604_QDU_STR_CROL    29  //  1 indicates that current value of CR < CR0
#define QD604_QDU_STR_CROG    28  //  1 indicates that current value of CR >= CR0
#define QD604_QDU_STR_CR1     27  //  1 indicates that current value of CR >= CR1
#define QD604_QDU_STR_AHL     26  //  1 indicates that 1-0 (HL) or 0-1 (LH) transition
#define QD604_QDU_STR_ALH     25  //  was detected on the input pin since last read from
#define QD604_QDU_STR_BHL     24  //  QDU_STR.
#define QD604_QDU_STR_BLH     23  //  This bit will be automatically cleared after each read
#define QD604_QDU_STR_ZHL     22  //
#define QD604_QDU_STR_ZLH     21  //
#define QD604_QDU_STR_THL     20  //
#define QD604_QDU_STR_TLH     19  //
#define QD604_QDU_STR_RQ      18  //  1 indicates that interrupt was requested
#define QD604_QDU_STR_IFE     17  //  1 indicates that input FIFO is empty
#define QD604_QDU_STR_IFH     16  //  1 indicates that input FIFO is at least 1/2 full
#define QD604_QDU_STR_IFF     15  //  1 indicates that input FIFO is full
#define QD604_QDU_STR_TE      14  //  1 indicates that quadrature decoder timeout detected
#define QD604_QDU_STR_QE      13  //  1 indicates that quadrature decoder error (wrong transition) was detected
#define QD604_QDU_STR_GTS     12  //  Report status of the "global" trigger (1 - started/0 - stopped)
#define QD604_QDU_STR_DIR     11  //  Valid in QEx mode only -  current direction of the rotation, 0=clockwise, 1= counter-clockwise

// 0x2104 RD/WR - QD604_QDU_CTR - QDU control register
#define QD604_QDU_CTR_EN    31  // Enable (l)/Disable (0) counter register. When disabled,
                                // CR along with prescaler and de-bouncer circuitry
                                // freezes it's current operation which may be re-enabled
                                // by writing one to the CTR EN bit. In Re-triggerable
                                // modes CTR_EN should be written once for the initial
                                // start and then it will be internally re-enabled (set to 1)
                                // with every trigger. Clearing this bit in any mode,
                                // including re-triggerable, stops counter.

#define QD604_QDU_CTR_AIE   30  // Enable (l)/Disable (0) inversion of the input/output pin.
#define QD604_QDU_CTR_BIE   29  // Value of the pin is inverted right at the input before
#define QD604_QDU_CTR_ZIE   28  // debouncing circuitry, for the outputs output is postinverted
#define QD604_QDU_CTR_TIE   27  // if corresponding bit is set to 1.
#define QD604_QDU_CTR_DO0IE 26  //
#define QD604_QDU_CTR_DO1IE 25  //
#define QD604_QDU_CTR_CLR   24  // If this bit is set during write to CTR, All QDUx registers
                                // and state machines will be reset to the default state and
                                // FIFO will be flashed

#define QD604_QDU_CTR_TOE   23  // 1=Enable trigger output, if TRIGOUT pin is disabled, it
                                // is controlled via DOUT_604 (0x2004) register or output
                                // channel list if channel list operation is enabled in the
                                // LCR(0x0).
#define QD604_QDU_CTR_TOM2  22  // Trigger output pin operation mode, valid if
#define QD604_QDU_CTR_TOM1  21  // CTR_TOE=1:
#define QD604_QDU_CTR_TOM0  20  // (0)TRIGOUT=1 if CR<CR0
                                // (1) TRIGOUT=1 if CR=CR0
                                // (2) TRIGOUT=global trigger status
                                // (3) TRIGOUT=start trigger detected pulse
                                // (4) TRIGOUT=direction (0=clockwise, 1= counterclockwise)
                                // (5) TRIGOUT= EM event
                                // All other combinations are reserved

#define QD604_QDU_CTR_COE   19  // Enable clock output, if CLKOUT pin is disabled, it is
                                // controlled via DOUT_604 (0x2004) register or output
                                // channel list if channel list operation is enabled in the LCR(0x0).

#define QD604_QDU_CTR_COM2  18  // Clock output pin operation mode, valid if CTR_COE=1:
#define QD604_QDU_CTR_COM1  17  // (0)CLKOUT=1 if CR>CRl
#define QD604_QDU_CTR_COM0  16  // (1) CLKOUT = 1 if CR=CR1
                                // (2) CLKOUT = lx QE clock
                                // (3) CLKOUT = 2x QE clock
                                // (4) CLKOUT = 4x QE clock
                                // (5) CLKOUT = Index event
                                // (6) CLKOUT = Inc/Dec N - pulse when CR
                                // increments/decrements by QDU_INC counts
                                // All other combinations are reserved

#define QD604_QDU_CTR_GTSE  15  // Enable (l)/Disable (0) global start trigger (from the SYNC interface) of the layer.
#define QD604_QDU_CTR_GTPE  14  // Enable (1)/Disable (0) global stop trigger (from the SYNC interface) of the layer.
#define QD604_QDU_CTR_IFE   13  // Enable (1)/Disable (0) input FIFO. When input FIFO is
                                // enabled, data is placed into it every EM (end-mode)
                                // event. CTR_TSM field define information that will be
                                // stored in the FIFO
#define QD604_QDU_CTR_TSM1  12  // Timestamp mode (valid only if CTR_IFE=1)
#define QD604_QDU_CTR_TSM0  11  // (0) - no timestamps
                                // (1) - add timestamp to every sample copied at EM event
                                // (2) - put only timestamp into the FIFO at EM event

// 0x2108 - RD/WR - QD604_QDU_CCR - QDU Counter control register
#define QD604_QDU_CCR_EC3       31  // Set end of the count mode. At the end of the counting
#define QD604_QDU_CCR_EC2       30  // counter may dump itself and/or timestamp and then
#define QD604_QDU_CCR_EC1       29  // reloaded with the pre-defined value that depends on
#define QD604_QDU_CCR_EC0       28  // CRM mode.
                                    // (0)000 - EM_CR0, end, when CR<CRO
                                    // (1)001 - EM_CR1, end, when CR>CR1
                                    // (2)010 - EM_CR01 end, when counter value is less,
                                    //          then CRO or more, then CR1
                                    // (3)011 - EM_IE, end on event (index or user)
                                    // (4)100 - EM_TBR, end, when time-base counter reaches 0
                                    // (5)101 - EM_INC end, when counter changes by predefined number
                                    // (5)110 - EM_INF indefinite wrap-around counter
                                    // All other combinations are reserved

#define QD604_QDU_CCR_CM3       27  // Set counter mode:
#define QD604_QDU_CCR_CM2       26  // (0x0)0000 - CM_CDU count-up A input
#define QD604_QDU_CCR_CM1       25  // (0x1)0001 - CM_CDA count-down A input
#define QD604_QDU_CCR_CM0       24  // (0x2)0010 - CM_DC direction counter
                                    // (0x3)0011 - CM_QE quadrature encoder mode
                                    // (0x4)0100 - CM_TCUA - triggered CM_CUA
                                    // (0x5)0101 - CM_TCDA - triggered CM_CDA
                                    // (0x6)0110 - CM_TDC - triggered CM_DC
                                    // (0x7)0111 - CM_TQE - triggered CM_QE
                                    // (0x8)1100 - CM_RTCUA - re-triggered CM_CUA
                                    // (0x9)1101 - CM_RTCDA - re-triggered CM_CDA
                                    // (OxA)1011 - CM_RTDC - re-triggered CM_DC
                                    // (OxB)l111 - CM_RTQE - re-triggered CM_QE
                                    // Triggered modes are using software/hardware trigger
                                    // to start operation, trigger source (HW/SW) is selected
                                    // using CCR TRS bit. Re-triggerable modes start
                                    // counting on the hardware/stop trigger and generally
                                    // stop counter when EM event is detected, CCR_ENC
                                    // should be set with re-triggerable modes to stop
                                    // counter at EM event and re-start at next trigger.

#define QD604_QDU_CCR_TRS       23  // Select Hardware(l)/Software(0) trigger source for the
                                    // triggered modes. Hardware-triggered modes will start
                                    // at low-high transition on the TRIGIN. In software
                                    // trigger mode CTR_EN bit in CTR should be used as a
                                    // trigger (CTR EN will be cleared at the end of the
                                    // counting operation if CCR_TRS bit is cleared and
                                    // triggered mode is selected CM_Txx)

#define QD604_QDU_CCR_ENC       22  // This bit compliments CCR_TRS bit and also works
                                    // only in a triggered mode - if set (1) enables auto-clear
                                    // of the CTR EN bit at the end of the current operation
                                    // (once EM condition is detected). Good for the singleshot
                                    // and retriggerable modes.

#define QD604_QDU_CCR_TBS2      21  // Select clock source for the time-base register. Please
#define QD604_QDU_CCR_TBS1      20  // note, that for the sources other then 66MHz maximum
#define QD604_QDU_CCR_TBS0      19  // frequency should not exceed 16.5MHz
                                    // (0)000 - 66Mhz
                                    // (1)001 - debounced TRIGIN pin
                                    // (4)100-SYNC0 1ine
                                    // (5)101 -SYNC1 line
                                    // (6)110-SYNC2 1ine
                                    // (7)111 -SYNC3 line
                                    // All other combinations are reserved and should not be used

#define QD604_QDU_CCR_CRM2      18  // Counter reload mode. Counter may be reloaded when
#define QD604_QDU_CCR_CRM1      17  // EM condition is detected. Following options are
#define QD604_QDU_CCR_CRM0      16  // available:
                                    // (0) CRM_LR, LR (load register)
                                    // (1) CRM_CR01, CR0 for the down count and CR1 for the up count
                                    // (2) CRM_CR10, CR1 for the down count and CR0 for the up count
                                    // (3) CRM_NR, No reload (counter keeps it's value)
                                    // (4) CRM_OTR, One-time reload (load counter only
                                    //     once per every start trigger and following event)
                                    //     All other combinations are reserved
#define QD604_QDU_CCR_ES        15  // Select event source for the bits 14-12
                                    // 0 - Z input
                                    // 1 - TRIGIN input
#define QD604_QDU_CCR_EB2       14  // Select event behavior
#define QD604_QDU_CCR_EB1       13  // (0) - no event
#define QD604_QDU_CCR_EB0       12  // (1) - rising edge on the debounced input
                                    // (2) - rising edge on the debounced input followed by A/B = low/low
                                    // (3) - rising edge on the debounced input followed by A/B = low/high
                                    // (4) - rising edge on the debounced input followed by A/B = high/low
                                    // (5) - rising edge on the debounced input followed by A/B = high/high
#define QD604_QDU_CCR_QEM1      11  // Select quadrature encoder counting mode (valid if one
#define QD604_QDU_CCR_QEM0      10  // of the CM_xQE modes is used):
                                    // (0) - normal counting
                                    // (1) - 2x mode (count "A" edges)
                                    // (2) - 4x mode (count "A" and "B" edges)

#define QD604_QDU_CCR_QED       9   // Use QDU_QED register for the Quadrature decoder
                                    // error generation. QED allows detection of glitches
                                    // and wrong states of the A and B inputs
#define QD604_QDU_CCR_QESWAP    8   // 1=swap A/B pins of the QDU in logic (valid if one of the CM_xQE modes is used)


// 0x212C - time base register
#define QD604_QDU_TBR_EN        31  // TBR enable bit

// 0x214C - IER/ISR/ICR bit descriptions
#define QD604_QDU_IR_CPT        31  //  Request interrupt if counter complete current operation (EM condition IRQ)
#define QD604_QDU_IR_CR0L       30  //  Request interrupt if current value of CR < CR0
#define QD604_QDU_IR_CR01       29  //  Request interrupt if current value of CR < CR0 or > CR1
#define QD604_QDU_IR_CR1        28  //  Request interrupt if current value of CR > CR1
#define QD604_QDU_IR_LHA        27  //  Request interrupt if low-high transition was detected on the A
#define QD604_QDU_IR_HLA        26  //  Request interrupt if high-low transition was detected on the A
#define QD604_QDU_IR_LHB        25  //  Request interrupt if low-high transition was detected on the B
#define QD604_QDU_IR_HLB        24  //  Request interrupt if high-low transition was detected on the B
#define QD604_QDU_IR_LHZ        23  //  Request interrupt if low-high transition was detected on the Z
#define QD604_QDU_IR_HLZ        22  //  Request interrupt if high-low transition was detected on the Z
#define QD604_QDU_IR_IFE        21  //  Request interrupt if input FIFO is empty
#define QD604_QDU_IR_IFH        20  //  Request interrupt if input FIFO is above watermark level
#define QD604_QDU_IR_IFF        19  //  Request interrupt if input FIFO is full
#define QD604_QDU_IR_TE         18  //  Request interrupt if timeout was detected (reserved)
#define QD604_QDU_IR_QE         17  //  Request interrupt if quadrature decoder error was detected
#define QD604_QDU_IR_DIR        16  //  Request interrupt if direction was changed

// CTR trigger modes
#define QDU_TOM_CR0L    0   //  (0) TRIGOUT=1 if CR<CR0
#define QDU_TOM_CR0E    1   //  (1) TRIGOUT=1 if CR=CR0
#define QDU_TOM_GTS     2   //  (2) TRIGOUT=global trigger status
#define QDU_TOM_STD     3   //  (3) TRIGOUT=start trigger detected pulse
#define QDU_TOM_DIR     4   //  (4) TRIGOUT=direction (0=clockwise, 1= counter-clockwise)
#define QDU_TOM_EM      5   //  (5) TRIGOUT= EM event

// CTR clock output mode
#define QDU_COM_CR1G    0   //  (0) CLKOUT=1 if CR>CRl
#define QDU_COM_CR1E    1   //  (1) CLKOUT=1 if CR=CR1
#define QDU_COM_1X      2   //  (2) CLKOUT = lx QE clock
#define QDU_COM_2X      3   //  (3) CLKOUT = 2x QE clock
#define QDU_COM_4X      4   //  (4) CLKOUT = 4x QE clock
#define QDU_COM_IE      5   //  (5) CLKOUT = Index event
#define QDU_COM_N       6   //  (6) CLKOUT = Inc/Dec N - pulse when CR increments/decrements by QDU_INC counts
                            //  All other combinations are reserved 0
// CTR timestamp modes
#define QDU_TSM_NOTS    0   //  (0) - no timestamps
#define QDU_TSM_TSADD   1   //  (1) - add timestamp to every sample copied at EM event
#define QDU_TSM_TSONLY  2   //  (2) - put only timestamp into the FIFO at EM event

// CCR end modes
#define QDU_EM_CR0      0   //  (0)000 - EM_CR0, end, when CR<CR0
#define QDU_EM_CR1      1   //  (1)001 - EM_CR1, end, when CR>CR1
#define QDU_EM_CR01     2   //  (2)010 - EM_CR01 end, when counter value is less than CR0 or more than CR1
#define QDU_EM_IE       3   //  (3)011 - EM_IE, end on event (index or user)
#define QDU_EM_TBR      4   //  (4)100 - EM_TBR, end, when time-base counter reaches 0
#define QDU_EM_INC      5   //  (5)101 - EM_INC end, when counter changes by pre-defined number
#define QDU_EM_INF      6   //  (6)110 - EM_INF indefinite wrap-around counter

// CCR counter mode
#define QDU_CM_CDU      0   //  (0x0)0000 - CM_CDU count-up A input
#define QDU_CM_CDN      1   //  (0x1)0001 - CM_CDN count-down A input
#define QDU_CM_DC       2   //  (0x2)0010 - CM_DC direction counter
#define QDU_CM_QE       3   //  (0x3)0011 - CM_QE quadrature encoder mode
#define QDU_CM_TCDU     4   //  (0x4)0100 - CM_TCUA - triggered CM_CUA
#define QDU_CM_TCDN     5   //  (0x5)0101 - CM_TCDA - triggered CM_CDA
#define QDU_CM_TDC      6   //  (0x6)0110 - CM_TDC - triggered CM_DC
#define QDU_CM_TQE      7   //  (0x7)0111 - CM_TQE - triggered CM_QE
#define QDU_CM_RTCDU    8   //  (0x8)1000 - CM_RTCUA - re-triggered CM_CUA
#define QDU_CM_RTCDN    9   //  (0x9)1001 - CM_RTCDA - re-triggered CM_CDA
#define QDU_CM_RTDC     0xA //  (0xA)1010 - CM_RTDC - re-triggered CM_DC
#define QDU_CM_RTQE     0xB //  (0xB)l011 - CM_RTQE - re-triggered CM_QE

// CCR timebase clock source
#define QDU_TBS_66M     0   // (0)000 - 66Mhz
#define QDU_TBS_TRIG    1   // (1)001 - debounced TRIGIN pin
#define QDU_TBS_SYNC0   4   // (4)100 - SYNC0 1ine
#define QDU_TBS_SYNC1   5   // (5)101 - SYNC1 line
#define QDU_TBS_SYNC2   6   // (6)110 - SYNC2 1ine
#define QDU_TBS_SYNC3   7   // (7)111 - SYNC3 line

// CCR reload mode
#define QDU_CRM_LR      0   //  (0) CRM_LR, LR (load register)
#define QDU_CRM_CR01    1   //  (1) CRM_CR01, CR0 for the down count and CR1 for the up count
#define QDU_CRM_CR10    2   //  (2) CRM_CR10, CR1 for the down count and CR0 for the up count
#define QDU_CRM_NR      3   //  (3) CRM_NR, No reload (counter keeps it's value)
#define QDU_CRM_OTR     4   //  (4) CRM_OTR, One-time reload (load counter only once per every start trigger and following event)

// CCR trigger source
#define QDU_TRS_SW      0 // Software trigger source
#define QDU_TRS_HW      1 // Hardware trigger source


// CCR event source
#define QDU_ES_Z        0   // Z input
#define QDU_ES_T        1   // Trigin

// CCR event behavoir
#define QDU_EB_NO       0   //  (0) - no event
#define QDU_EB_RE       1   //  (1) - rising edge on the debounced input
#define QDU_EB_RE_LL    2   //  (2) - rising edge on the debounced input followed by A/B = low/low
#define QDU_EB_RE_LH    3   //  (3) - rising edge on the debounced input followed by A/B = low/high
#define QDU_EB_RE_HL    4   //  (4) - rising edge on the debounced input followed by A/B = high/low
#define QDU_EB_RE_HH    5   //  (5) - rising edge on the debounced input followed by A/B = high/high
                            //  All other combinations are reserved
// CCR quadrature count mode
#define QDU_QEM_1X      0   //  (0) - normal counting
#define QDU_QEM_2X      1   //  (1) - 2x mode (count "A" edges)
#define QDU_QEM_4X      2   //  (2) - 4x mode (count "A" and "B" edges)


#define DQ_PL_604_NAMELEN   16  // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_PL_604_CHAN][DQ_PL_604_NAMELEN];
} DQCNAMES_604_, *pDQCNAMES_604_;

/* specific device structure - calibration values */
typedef struct {
    uint32 placeholder;
} DQCALSET_604_, *pDQCALSET_604_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_PL_604_CHAN*2]; // channel list - full
    uint32 conf;                // control word - layer API flags
    uint32 cvclk;               // CV clock
    uint32 clclk;               // CL clock
    uint32 trig;                // trigger conditions
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_604_, *pDQOPMODEPRM_604_;


/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_604_ calset;
    DQOPMODEPRM_604_ opmodeprm;
    DQCNAMES_604_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_604_, *pDEVEEPROM_604_;

// channel list structure for run-time
typedef struct {
    uint32 lr;      // load register
    uint32 ctr;     // control
    uint32 ccr;     // config
    uint32 cr0;
    uint32 cr1;
    uint32 tbr;     // timebase
    uint32 ier;     // store IER temp value

    uint32 idba;    // debounce
    uint32 idbb;
    uint32 idbz;
    uint32 idbt;

    uint32 qed;     // encoder delay
    uint32 ow;      // output width
    uint32 inc;     // em_inc mode value

    uint32 ifwr;    // fifo watermark
} DQCHNLSET_604_, *pDQCHNLSET_604_;

typedef struct {
    uint8   chnl;     // |7-2 = event flags|1-0 = channel|
    uint32 data[DQ_FLEX_ARRAY];    // n - 32bit samples
} DQMSG_604, *pDQMSG_604;

#pragma pack()

// -----------------------------------------------------------------------------------------

#define DQ_VR608_CHAN               (8)         // CT-608 working channels
#define DQ_VR608_CHAN_PAIRS         (4)         // CT-608 paired channels (0 and 1 ... 6 and 7)
#define DQ_VR608_AICHAN             (8)         // ADC's
#define DQ_VR608_AOCHAN             (16)        // DAC's

#define DQ_VR608_INFOSZ             (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_VR608_BASE               (BUS_FREQUENCY)     // 66MHz base frequency

#define DQ_VR608_LISTSZ             (350)       // max number of uint32 output entries

// Maximum working frequencies
#define DQ_VR608_MAXCLFRQ           (320000)    // max frequency at which ADC can be clocked
#define DQ_VR608_MAXFIFORATE        (20000)     // max frequency to store data into FIFO
#define DQ_VR608_FIFOSZ             (0x200)     // FIFO size
#define DQ_VR608_FIFOSZ_R2          (0x800)     // FIFO size for rev 2 layers

// helper macros
#define DQ_VR608_CHNLTYPE_MASK      (0xf0)      // extract channel type (A or B) from channel entry
#define DQ_VR608_CHNLNUM_MASK       (0x07)      // extract channel number from channel entry

// special channels used to specify that we wish to read/write other
// registers than default capture/compare register
#define DQ_VR608_CHNLTYPE_STATUS    (0x10)      // Reads channel STR register
#define DQ_VR608_CHNLTYPE_CRH       (0x20)      // Reads channel CRH register
#define DQ_VR608_CHNLTYPE_CRL       (0x30)      // Reads channel CRL register
#define DQ_VR608_CHNLTYPE_CR        (0x40)      // Writes channel CRR register
#define DQ_VR608_CHNLTYPE_CRR       (0x50)      // Writes channel CR1 register
#define DQ_VR608_CHNLTYPE_SHADOW    (0x60)      // Reads shadow CR/CRL/CRH/timestamp registers
#define DQ_VR608_CHNLTYPE_TSTAMP    (0x70)      // Request timestamp for this channel into the FIFO
#define DQ_VR608_CHNLTYPE_SDRH      (0x80)      // Request channel shadow CRH register
#define DQ_VR608_CHNLTYPE_SDRL      (0x90)      // Request channel shadow CRL register
#define DQ_VR608_CHNLTYPE_SDRT      (0xA0)      // Request channel shadow timestamp
#define DQ_VR608_CHNLTYPE_AINSTS    (0xB0)      // Request Analog Input status channel
#define DQ_VR608_CHNLTYPE_ALARMSTS  (0xC0)      // Request alarm status channel

#define DQ_VR608_ADC_SPAN           (12.0)      // span for raw to float.  linear calibration range is +3.6V to -2.2V
#define DQ_VR608_ADC_OFFS           (DQ_VR608_ADC_SPAN/2.0)   // +/-5V range of converter -> +/-6V input range due to the divider
#define DQ_VR608_ADC_MAX            (0xffff)
#define DQ_VR608_ADC_MULT           ((10.0+100.0)/100.0)
#define DQ_VR608_DFLT_ADC_RATE      (200000)    // 100kHz is good, 200k by default, DQ_VR608_MAXCLFRQ max (DQ_VR608_ADC_DEFRATE) 5us period

#define DQ_VR608_ADC_OPENLOW        (0.5)       // reported minimum ADC voltage if input is open. ADC value = 0x8AAA
          // when ADC voltage is between DQ_VR608_ADC_OPENLOW and DQ_VR608_ADC_OPENHIGH  channel is considered open
#define DQ_VR608_ADC_OPENHIGH       (1.5)       // reported maximum ADC voltage if input is open. ADC value = 0xA200
#define DQ_VR608_ADC_TOOSMALL       0x100       // 40mV signal is considered too small for detection (in ADC counts)

#define DQ_VR608_DAC_SPAN           (5.0)       // 5V
#define DQ_VR608_DAC_OFFS           (0.0)       // 0-5V range
#define DQ_VR608_DAC_MAX            (0xffff)

#define DQ_VR608_DFLT_APT_TH        (2.0)       // 2V default DAC threshold voltage (DQ_VR608_DAC_DEFTRSHLD)

#define DQ_VR608_DFLT_TMODE_RATE    (10.0)      // default frequency to store accumulated values into the regs/FIFO (DQ_VR608_TBR_DEFRATE)

// DAQLib structure returned by DqAdv608Read()
typedef struct {
    double velocity;    // number of teeth per time period
    uint32 position;    // teeth since index gear tooth was last detected
    uint32 tcount;      // total teeth count
    uint32 tstamp;      // default DQ_LN_10us_TIMESTAMP means each increment is 10us
    uint32 rd_flags;    // see DQ_VR608_RD_FLAG constant
    uint32 status;      // channel status register (see DQ_VR608_ADC_STS.status)
    double adc_val;     // last calibrated ADC value (see DQ_VR608_ADC_STS.last)
} DQ_VR608_READ_DATA, *pDQ_VR608_READ_DATA;

// DAQLib constants valid when both DQ_VR608_CHNLRQ_ADC_RD|DQ_VR608_CHNLRQ_STATUS flags are used
#define DQ_VR608_RD_FLAG_CKT_MASK   (0x3)       // 3=Open 2=Closed 1=Invalid 0=Null or Not Calculated
#define DQ_VR608_RD_FLAG_CKT_OPEN   (3L<<0)     // Open circuit: no fluctuation detected & input floating
#define DQ_VR608_RD_FLAG_CKT_CLOSED (2L<<0)     // Closed circuit: edge detected or input floating
#define DQ_VR608_RD_FLAG_CKT_NODATA (0L<<0)     // No data (bad CHNLRQ, no chan config, or ADC not ready)
#define DQ_VR608_GET_CKT_OPEN(S)    (((S)&DQ_VR608_RD_FLAG_CKT_MASK)==DQ_VR608_RD_FLAG_CKT_OPEN)
#define DQ_VR608_GET_CKT_CLOSED(S)  (((S)&DQ_VR608_RD_FLAG_CKT_MASK)==DQ_VR608_RD_FLAG_CKT_CLOSED)

// DAQLib constants for data status
#define DQ_VR608_RD_FLAG_NOTREADY   (1L<<31)

// special channels used to specify that we wish to read/write other
// registers than default capture/compare register
#define DQ_VR608_CHNLRQ_MASK        (0x0F0)     // extract channel type from channel entry

#define DQ_VR608_CHNLRQ_STATUS      (0x10)      // Reads channel STR register in addition to CR
#define DQ_VR608_CHNLRQ_TSTAMP      (0x20)      // Request timestamp for this channel into the FIFO
#define DQ_VR608_CHNLRQ_ADC_RD      (0x40)      // Reads Analog Input last calibrated value from A/B

// top level IOCTL that causes prog_601 or snap_601 to execute without
// switching to operation mode. They are used for asynchronous operations
#define DQL_IOCTL608_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL608_STOP           (0x0BL)     // immediate mode stop
#define DQL_IOCTL608_READ_FIFO      (0x0CL)     // read FIFO
#define DQL_IOCTL608_READ_ADC_FIFO  (0x0DL)     // read ADC FIFO (stream of data)
#define DQL_IOCTL608_READ_ADC_STS   (0x0EL)     // read current ADC status information

// getparam_608 commands
#define DQL_IOCTL608_GET_REG        (3L)
#define DQL_IOCTL608_GETCHNL_CFG    (8L)
#define DQL_IOCTL608_GETCHNL_CFGR2  (9L)

// setparam_608 commands
#define DQL_IOCTL608_SETCHNL_CFG    (1L)
#define DQL_IOCTL608_SET_REG        (2L)
#define DQL_IOCTL608_CTR_EN         (4L)        // software start
#define DQL_IOCTL608_CTR_DIS        (5L)        // software stop
#define DQL_IOCTL608_ENALL          (6L)
#define DQL_IOCTL608_DISALL         (7L)
#define DQL_IOCTL608_CTR_CLR        (10L)
#define DQL_IOCTL608_SET_WM         (11L)
#define DQL_IOCTL608_SET_ADCRATE    (12L)
#define DQL_IOCTL608_SET_SIM        (13L)
#define DQL_IOCTL608_SETCHNL_CFG_R2 (14L)
#define DQ_SETPARAM_608R2_RET       (32L)       // signal to DAQLib for rev2 compatibility

// --- Front-end configuration <front_cfg> used by DqAdv608SetCfg().front_cfg and DQINITPRM_608_.front_cfg
// <front_cfg> zero-cross threshold control
#define DQ_VR608_ZC_FIXED           (0L<<0)     // zero level is set by the user; defaults to mid-scale voltage (18kHz max)
#define DQ_VR608_ZC_ONCHIP          (1L<<0)     // zero crossing detection performed by front-end ASIC
#define DQ_VR608_ZC_LOGIC           (1L<<1)     // zero level is calculated (MIN+MAX)/2 in the logic (18kHz max)

// <front_cfg> (adaptive) peak threshold control
#define DQ_VR608_APT_ONCHIP         (0L<<4)     // adaptive peak threshold automatically detected by front-end ASIC, mode 'A1'
#define DQ_VR608_APT_FIXED          (1L<<4)     // peak threshold is user-configured by writing raw threshold voltage to DACs, mode 'B' of 9926
#define DQ_VR608_APT_LOGIC          (2L<<4)     // adaptive peak threshold is detected in the logic, mode 'B' of 9926
#define DQ_VR608_APT_TTL            (3L<<4)     // peak threshold is set to 'Mode C of 9926' for unipolar TTL
#define DQ_VR608_APT_MASK           (0xf0)      // bits 7..4

// --- Mode configuration <mode>             <mode> parameter for DqAdv608SetCfg()
// <mode> for channel pair 0/1, 2/3, 4/5, 6/7 (we can call them even/odd or A/B channels for brevity)
#define DQ_VR608_MODE_COUNTER       (0L<<0)     // counts number of teeth for each channel (channels are individual)
#define DQ_VR608_MODE_DECODER       (1L<<0)     // for quadrature-connected VR sensors both channels (0+1, 1+2, ...)
                                                // of a channel pair are used together to determine position & direction
                                                // both A and B should be connected for the chip to recognize direction
                                                // VR608_MODE_DECODER is valid only for even channels - the next
                                                // odd channel will be automatically switched into decoder mode for you

// <mode> Select whether and what to write into the FIFO - only when FIFO mode is enabled
#define DQ_VR608_FIFO_POS           (1L<<4)     // store position/count into the FIFO
                                                // (sCRH register, CRL+CRR register - 2 words - VR mode only)
                                                // This enables writes to the FIFO
                                                // (sCR register - optional for VR, should be for encoder)
#define DQ_VR608_FIFO_TS            (8L<<4)     // accomplish FIFO data with the timestamps (any mode)

// <mode> Select what clock to use to latch data into registers/FIFO - both FIFO and immediate modes
// These settings used in VR608_MODE_COUNTER mode and ignored in VR608_MODE_DECODER
#define DQ_VR608_MODE_TIMED         (0L<<8)     // store data (number of teeth, time, and teeth/time) at a timed rate of <tbr_ps> Hz
                                                // i.e. latch data or clock FIFO from TBR (event is timebase register expiration)
#define DQ_VR608_MODE_NPULSE        (1L<<8)     // store data (teeth/time) every time that <ps_param> teeth have been counted
                                                // i.e. latch data or  clock data into the FIFO each N pulses
                                                // (A and B must be used - A provides count, B provides gate to clock data into FIFO)
#define DQ_VR608_MODE_ZPULSE        (2L<<8)     // store data (number of teeth, time, and teeth/time) every time z_tooth is detected
                                                // i.e. latch data or clock data into the FIFO each time Z-tooth is found
#define DQ_VR608_MODE_TORQUE        (3L<<8)     //<REVISION2> store data (torque pulse width) every time that <ps_param> teeth have been counted
                                                // i.e. latch data or  clock data into the FIFO each N pulses
#define DQ_VR608_MODE_TPPM          (4L<<8)     //<REVISION2>  store data (counts and pulses) at a timed rate of <tbr_ps> Hz
                                                // i.e. latch CRH, CRL to FIFO from TBR (event is timebase register expiration)
#define DQ_VR608_MODE_MASK          (0xfL<<8)   // mask for VR608_MODE_COUNTER mode

// <mode> Special flags for each channel
#define DQ_VR608_FLAG_CH_FIR_BYPASS (1L<<25)    // bypass the ADC FIR, useful when ADC tooth rate is above 10KHz
#define DQ_VR608_FLAG_CH_ZDET_H     (1L<<26)    // select high pulse detect when .27 enabled
#define DQ_VR608_FLAG_CH_ZDET_L     (0L<<26)    // select low  pulse detect when .27 enabled
                                                // ZDET_HL_ is for DQ_VR608_ZC_FIXED and DQ_VR608_ZC_LOGIC front_cfg's only
#define DQ_VR608_FLAG_CH_ZDET_HL_EN (1L<<27)    // set.27 to enable high or low tooth detection, resulting z pulse connects to DQ_VR608_CFG_DO_ZDETn
#define DQ_VR608_FLAG_CH_USEFALLEDGE (1L<<28)   // use falling edge of the VR signal instead of the rising one
#define DQ_VR608_FLAG_CH_AUTOSTART  (1L<<29)    // internally call DqAdv608Enable at powerup
#define DQ_VR608_FLAG_CH_VALID      (1L<<30)    // channel programmed & enabled; channel (mode) data invalid when clear (status bit)


// Number of words copying into the FIFO w/o timestamp for different modes
#define DQ_VR608_FIFO_ENTRIES_TIMED (3)         // # of words when COUNTER mode is TIMED (aka DQ_VR608_FIFO_ENTRIES_TBR)
#define DQ_VR608_FIFO_ENTRIES_NPULSE (2)
#define DQ_VR608_FIFO_ENTRIES_ZPULSE (3)
#define DQ_VR608_FIFO_ENTRIES_DECOD (1)

   // DqAdv608SetSensorSim() tooth_cfg parameter,  in addition, output needs to be enabled with DqAdv608SetCfg() by
   // using DQ_CT608_GPIO_DIO_SIM as one of the DQ_CT608_GPIO_DIOn sources in DQ_VR608_CFG.d_out.
   //
#define DQ_VR608_SIM_CONTINUOUS     (0)         // set sensor simulation signal on Dout pin for continuous pulses
#define DQ_VR608_SIM_Z_PULSE        (1)         // set to simulate a missing pulse
#define DQ_VR608_SIM_Z_FUSED        (2)         // set simulation of fused tooth

// --- Structure defines settings for VR608 layer
// (C) means that the pararmeter can be applied per channel individually
// (P) means that this parameter is applied for the *pair* of channels - 0 and 1, 2 and 3, 4 and 5, 6 and 7
//     the latest write overrides parameter for both channels
// (B) setting this parameter applies to all SYNC or GP DIO lines
// (L) setting this parameter applies to all channels on layer
// Note: analog data is only accessible for a pair of channels at the same time.
//
// <ext_flags> Set flags from the ones below to indicate which configuration parameters are valid or
//             clear the flags to use default parameters built into the firmware
#define DQ_VR608_CFGVLD_ALARM_SRC   (1L<<29)    // (L) select which alarm conditions will activate DOUTs when DQ_VR608_CFG.d_out has alarms selected by
                                                // using DQ_CT608_GPIO_DIO_ALARM as one of the DQ_CT608_GPIO_DIOn sources
#define DQ_VR608_CFGVLD_ADC_RATE    (1L<<28)    // (L) reprogram analog input rate for entire board (not just this channel)
#define DQ_VR608_CFGVLD_TMODE_RATE  (1L<<27)    // (C) VR608_MODE_TIMED mode: scan rate (timebase register prescaler) contains valid data
#define DQ_VR608_CFGVLD_OFS_BIAS    (1L<<26)    //     reserved for ofs_bias analog bias level
#define DQ_VR608_CFGVLD_ZC_LEVEL    (1L<<25)    // (C) VR608_ZC_FIXED: zero-cross voltage level
#define DQ_VR608_CFGVLD_APT_TH      (1L<<24)    // (C) VR608_APT_FIXED/VR608_APT_TTL: peak threshold voltage
#define DQ_VR608_CFGVLD_APT_DIV     (1L<<23)    // (C) VR608_APT_LOGIC: 1/2^n divider coefficient
#define DQ_VR608_CFGVLD_ADC_MV_AVG  (1L<<22)    // (P) VR608_ZC_FIXED/VR608_ZC_LOGIC/VR608_APT_LOGIC: moving average
#define DQ_VR608_CFGVLD_SYNC_IN     (1L<<21)    // (L) sync_in is valid
#define DQ_VR608_CFGVLD_SYNC_OUT    (1L<<20)    // (L) sync_out is valid
#define DQ_VR608_CFGVLD_D_OUT       (1L<<19)    // (L) d_out is valid
#define DQ_VR608_CFGVLD_NUM_TEETH   (1L<<18)    // (C) number of teeth (pulse parameter)
#define DQ_VR608_CFGVLD_Z_TOOTH_SZ  (1L<<17)    // (C) size of z-tooth in teeth
#define DQ_VR608_CFGVLD_TORQUE_CFG  (1L<<16)    // (P) <REVISION2>torque_cfg is valid, configure sensor pair for torque measurement
#define DQ_VR608_CFGVLD_TTL_CFG     (1L<<15)    // (L) ttl_cfg is valid, configure ttl inputs
#define DQ_VR608_CFGFLG_CLEAR       (1L<<0)     // clear all parameters (set to defaults)

typedef struct {    // user config struct for rev2
    uint32 cfgformat;   // contains VR608_EECFG_FORMAT_VER (and a free uint16)

    uint32 cfg_flags;   // bitmap of parameters that contain valid configurations (see DQ_VR608_CFGVLD_ defines)

    uint32 reserved[2];
    float  adc_rate;    // (L) analog input rate, Hz, for the board - last value written overwrites ALL channels
    float  tmode_rate;  // (C) prescaler for timebase clock, Hz = how often to store accumulated data (VR608_MODE_TIMED mode)

    float  ofs_bias;    // <reserved> for offset bias
    float  zc_level;    // (C) VR608_ZC_FIXED: zero cross level sets fixed DAC bias reference voltage for front-end ASIC to -5..5V
    float  apt_th;      // (C) VR608_APT_FIXED: analog peak threshold can be fixed to 0-5V (in practice 2.0-4.5V)
    uint32 apt_div;     // (C) VR608_APT_LOGIC: divider for AIn to set automatic AOut threshold (1..15)

    uint32 adc_mv_avg;  // (C) moving average in VR608_*_LOGIC/ZC_FIXED modes (logic 11.A4 or newer)

    uint32 sync_in;     // (L) select which SYNC line to take for timebase clock (reserved)
    uint32 sync_in_ps;  // (L) select prescaler for timebase clock (reserved)
    uint32 sync_out;    // (L) select which SYNC line and which signal to route out (reserved)
    uint32 d_out;       // (L) select which DOut lines and which signals to route out. use DQ_VR608_DBG_N macro
    uint32 num_teeth;   // (C) VR608_MODE_NPULSE: number of teeth
    int    z_tooth_sz;  // (C) VR608_MODE_ZPULSE: size of Z-tooth in teeth
                        // this is a correction factor in DAQLib to compensate for number of teeth
                        // that Z-tooth substitutes (either missing teeth or a wider tooth)
    uint32 alarm_src;   // (L) determines which alarm conditions will set the d_out lines. These are used when .d_out is set for alarm
    uint32 torque_cfg;  // (P) set flags for polarity of torque sensor pair and rotation direction, DQ_VR608_TORQCFG_x
    uint32 ttl_cfg;     // (L) configure ttl inputs
    uint32 res2[2];     // reserved for future development

} DQ_VR608_CFG_R2, *pDQ_VR608_CFG_R2;



typedef struct {    // user config struct for rev1
    uint32 cfgformat;   // contains VR608_EECFG_FORMAT_VER (and a free uint16)

    uint32 cfg_flags;   // bitmap of parameters that contain valid configurations (see DQ_VR608_CFGVLD_ defines)

    uint32 reserved[2];
    float  adc_rate;    // (L) analog input rate, Hz, for the board - last value written overwrites ALL channels
    float  tmode_rate;  // (C) prescaler for timebase clock, Hz = how often to store accumulated data (VR608_MODE_TIMED mode)

    float  ofs_bias;    // <reserved> for offset bias
    float  zc_level;    // (C) VR608_ZC_FIXED: zero cross level sets fixed DAC bias reference voltage for front-end ASIC to -5..5V
    float  apt_th;      // (C) VR608_APT_FIXED: analog peak threshold can be fixed to 0-5V (in practice 2.0-4.5V)
    uint32 apt_div;     // (C) VR608_APT_LOGIC: divider for AIn to set automatic AOut threshold (1..15)

    uint32 adc_mv_avg;  // (C) moving average in VR608_*_LOGIC/ZC_FIXED modes (logic 11.A4 or newer)

    uint32 sync_in;     // (L) select which SYNC line to take for timebase clock (reserved)
    uint32 sync_in_ps;  // (L) select prescaler for timebase clock (reserved)
    uint32 sync_out;    // (L) select which SYNC line and which signal to route out (reserved)
    uint32 d_out;       // (L) select which DOut lines and which signals to route out. use DQ_VR608_DBG_N macro
    uint32 num_teeth;   // (C) VR608_MODE_NPULSE: number of teeth
    int    z_tooth_sz;  // (C) VR608_MODE_ZPULSE: size of Z-tooth in teeth
                        // this is a correction factor in DAQLib to compensate for number of teeth
                        // that Z-tooth substitutes (either missing teeth or a wider tooth)
} DQ_VR608_CFG, *pDQ_VR608_CFG;

// <torque_cfg> bitwise OR the following flags as needed for configuration of a torque measurement sensor pair
#define DQ_VR608_TORQCFG_LEAD       (1L<<0)     // (P) set rotation direction, 0=even ch leads odd ch
#define DQ_VR608_TORQCFG_POL        (1L<<1)     // (P) set polarity of sensor signal, 0=default polarity, 1=invert

// <ttl_cfg>
// VR608_TTL_SRC
#define DQ_VR608_TTL_SRC_7          (1L<<31)    // select timer module 7 to receive ttl input
#define DQ_VR608_TTL_SRC_7E         (1L<<29)    // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_7S         (1L<<28)    // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_6          (1L<<27)    // select timer module 6 to receive ttl input
#define DQ_VR608_TTL_SRC_6E         (1L<<25)    // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_6S         (1L<<24)    // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_5          (1L<<23)    // select timer module 5 to receive ttl input
#define DQ_VR608_TTL_SRC_5E         (1L<<21)    // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_5S         (1L<<20)    // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_4          (1L<<19)    // select timer module 4 to receive ttl input
#define DQ_VR608_TTL_SRC_4E         (1L<<17)    // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_4S         (1L<<16)    // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_3          (1L<<15)    // select timer module 3 to receive ttl input
#define DQ_VR608_TTL_SRC_3E         (1L<<13)    // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_3S         (1L<<12)    // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_2          (1L<<11)    // select timer module 2 to receive ttl input
#define DQ_VR608_TTL_SRC_2E         (1L<<9)     // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_2S         (1L<<8)     // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_1          (1L<<7)     // select timer module 1 to receive ttl input
#define DQ_VR608_TTL_SRC_1E         (1L<<5)     // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_1S         (1L<<4)     // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

#define DQ_VR608_TTL_SRC_0          (1L<<3)     // select timer module 0 to receive ttl input
#define DQ_VR608_TTL_SRC_0E         (1L<<1)     // select which ttl input is to be connected
#define DQ_VR608_TTL_SRC_0S         (1L<<0)     // 11=DIN-3, 10=DIN-2, 01=DIN-1, 00=DIN-0

// TTL source macro to populate DQ_VR608_CFGR2.ttl_cfg.
// Bitwise OR (|) as needed, e.g.  DQ_VR608_CFGR2.ttl_cfg = DQ_VR608_TTL_SRC(1,0,2) |  DQ_VR608_TTL_SRC(1,1,3);
//                      (E= 1=enable timer to use TTL input,  0=off,corresponding VR input connects to timer)
//                      (N= select timer channel, 0..7)    0=0A, 1=0B, 2=1A, 3=1B, 4=2A, 5=2B, 6=3A, 7=3B
//                      (T= TTL input to use 0..3)
#define DQ_VR608_TTL_SRC(E,N,T)     ((((T)& 0x03)|((E)?8:0))<<(((N)&7)<<2))



#define DQ_VR608_DFLT_ADC_MV_AVG    (3)         // moving average default divider (2^3=8x)
#define DQ_VR608_DFLT_APT_DIV       (2)         // adaptive threshold default divider (apt_div)

// -- for DQL_IOCTL608_READ_ADC_STS
typedef struct {
    uint32 status;
    uint32 last_0;      // last calibrated ADC value for the even channel
    uint32 last_1;      // last calibrated ADC value for the odd channel
    uint32 max_0;       // maximum level registered for the even channel
    uint32 max_1;       // maximum level registered for the odd channel
    uint32 min_0;       // minimum level registered for the even channel
    uint32 min_1;       // minimum level registered for the odd channel

} DQ_VR608_ADC_STS, *pDQ_VR608_ADC_STS;

// convert DQ_VR608_ADC_STS values from RAW to DOUBLE
#define DQ_VR608_ADC_RAW2DBL(X) (DQ_VR608_ADC_SPAN*((double)((X) & 0xfffc))/DQ_VR608_ADC_MAX - DQ_VR608_ADC_OFFS)

// DqAdv608SetSensorSim() tooth_cfg parameter,  in addition, output needs to be enabled with DqAdv608SetCfg() by
// using DQ_CT608_GPIO_DIO_SIM as one of the DQ_CT608_GPIO_DIOn sources in DQ_VR608_CFG.d_out.
//
#define DQ_VR608_SIM_CONTINUOUS     (0)         // set sensor simulation signal on Dout pin for continuous pulses
#define DQ_VR608_SIM_Z_PULSE        (1)         // set to simulate a missing pulse
#define DQ_VR608_SIM_Z_FUSED        (2)         // set simulation of fused tooth
#define DQ_VR608_SIM_TORQUE_PAIR    (3)         // set pair of simulators to simulate a torque measurement
#define DQ_VR608_SIM_PHASED_PAIR    (3)         // set pair of simulators to simulate a torque measurement (deprecated)
#define DQ_VR608_SIM_STOPPED        (4)         // stop simulator output
#define DQ_VR608_SIM_MAX_LIMIT      (30)        // 1.8M rpm limit used internally by DAQLib
//VR608_SIM_PH1               (0x2048)    //   W  phase of sim output on DIO1, enabled w/0x2900.1 (AOBLOCK 1) bit 1   (rev2+)
//VR608_SIM_PH3               (0x204C)    //   W  phase of sim output on DIO3, enabled w/0x2B00.1 (AOBLOCK 3) bit 1   (rev2+)
// Use these 2 registers to set time delay between the 2 phases of the torque simulation pair. Delay is spec'd in 15.15ns units (1/66MHz)

// VR-608 DOut and SyncOut line selector, aka debug mux

//Use the following macro to populate the struct DQ_VR608_CFG.d_out member with DQ_VR608_CFG_DO_ defines used by DqAdv608SetCfg(,,,extcfg)
#define DQ_VR608_DBG_N(D3,D2,D1,D0) (((D3)<<24)|((D2)<<16)|((D1)<<8)|(D0))         // populate unused elements with DQ_VR608_CFG_DO_DBG_OFF
#define DQ_VR608_DFLT_SYNCOUT       DQ_VR608_DBG_N(DQ_VR608_CFG_DO_DBG_OFF,DQ_VR608_CFG_DO_DBG_OFF,DQ_VR608_CFG_DO_DBG_OFF,DQ_VR608_CFG_DO_DBG_OFF)  // 0x3F3F3F3F
#define DQ_VR608_DFLT_DOUT          DQ_VR608_DBG_N(DQ_VR608_CFG_DO_FORCE0,DQ_VR608_CFG_DO_FORCE0,DQ_VR608_CFG_DO_FORCE0,DQ_VR608_CFG_DO_FORCE0)       // 0x38383838
#define DQ_VR608_DFLT_DOUT_0        DQ_VR608_DBG_N(DQ_VR608_CFG_DO_FORCE0,DQ_VR608_CFG_DO_FORCE0,DQ_VR608_CFG_DO_FORCE0,DQ_VR608_CFG_DO_FORCE0)       // 0x38383838
#define DQ_VR608_DFLT_ILLEGAL       DQ_VR608_DBG_N(DQ_VR608_CFG_DO_VR_DRN0,DQ_VR608_CFG_DO_VR_DRN0,DQ_VR608_CFG_DO_VR_DRN0,DQ_VR608_CFG_DO_VR_DRN0)   // 0x00000000
#define DQ_VR608_DFLT_DOUT_1        DQ_VR608_DBG_N(DQ_VR608_CFG_DO_FORCE1,DQ_VR608_CFG_DO_FORCE1,DQ_VR608_CFG_DO_FORCE1,DQ_VR608_CFG_DO_FORCE1)       // 0x39393939
#define DQ_VR608_DOUT_ALL_SIMS      DQ_VR608_DBG_N(DQ_VR608_CFG_DO_SIG_SIM3,DQ_VR608_CFG_DO_SIG_SIM2,DQ_VR608_CFG_DO_SIG_SIM1,DQ_VR608_CFG_DO_SIG_SIM0)  // 0x3E3D3C3B
#define DQ_VR608_DOUT_ALL_ALARMS    DQ_VR608_DBG_N(DQ_VR608_CFG_DO_ALARM3,DQ_VR608_CFG_DO_ALARM2,DQ_VR608_CFG_DO_ALARM1,DQ_VR608_CFG_DO_ALARM0)         // 0x17161514


// VR-608 DOut and SyncOut line selector for <REVISION 1>VR-608 units
#define DQ_VR608_CFG_DO_DBG_OFF     (0x3F)      // disable line, use to populate unused (D) params of DQ_VR608_DBG_N() macro
#define DQ_VR608_CFG_DO_SIG_SIM3    (0x3E)      // sensor simulator 3 from AO module
#define DQ_VR608_CFG_DO_SIG_SIM2    (0x3D)      // sensor simulator 2 from AO module
#define DQ_VR608_CFG_DO_SIG_SIM1    (0x3C)      // sensor simulator 1 from AO module
#define DQ_VR608_CFG_DO_SIG_SIM0    (0x3B)      // sensor simulator 0 from AO module
#define DQ_VR608_CFG_DO_FORCE1      (0x39)      // Drive TTL High/1
#define DQ_VR608_CFG_DO_FORCE0      (0x38)      // Drive TTL Low/0
#define DQ_VR608_CFG_DO_ADC_DETA3   (0x2F)      // NPULSE (UEI logic: ADC)
#define DQ_VR608_CFG_DO_ADC_DETA2   (0x2E)      // VR detector from ADC module
#define DQ_VR608_CFG_DO_ADC_DETA1   (0x2D)
#define DQ_VR608_CFG_DO_ADC_DETA0   (0x2C)
#define DQ_VR608_CFG_DO_ADC_DETB3   (0x2B)
#define DQ_VR608_CFG_DO_ADC_DETB2   (0x2A)
#define DQ_VR608_CFG_DO_ADC_DETB1   (0x29)
#define DQ_VR608_CFG_DO_ADC_DETB0   (0x28)
#define DQ_VR608_CFG_DO_ZDET7       (0x13)      // ZPULSE detector
#define DQ_VR608_CFG_DO_ZDET6       (0x12)
#define DQ_VR608_CFG_DO_ZDET5       (0x11)
#define DQ_VR608_CFG_DO_ZDET4       (0x10)
#define DQ_VR608_CFG_DO_ZDET3       (0x0F)
#define DQ_VR608_CFG_DO_ZDET2       (0x0E)
#define DQ_VR608_CFG_DO_ZDET1       (0x0D)
#define DQ_VR608_CFG_DO_ZDET0       (0x0C)
#define DQ_VR608_CFG_DO_VR_INPULS7  (0x0B)      // NPULSE (MAX9926 IC)
#define DQ_VR608_CFG_DO_VR_INPULS6  (0x0A)      // VR IC output pins
#define DQ_VR608_CFG_DO_VR_INPULS5  (0x09)
#define DQ_VR608_CFG_DO_VR_INPULS4  (0x08)
#define DQ_VR608_CFG_DO_VR_INPULS3  (0x07)
#define DQ_VR608_CFG_DO_VR_INPULS2  (0x06)
#define DQ_VR608_CFG_DO_VR_INPULS1  (0x05)
#define DQ_VR608_CFG_DO_VR_INPULS0  (0x04)
#define DQ_VR608_CFG_DO_VR_DRN3     (0x03)      // VR IC drn pins
#define DQ_VR608_CFG_DO_VR_DRN2     (0x02)
#define DQ_VR608_CFG_DO_VR_DRN1     (0x01)
#define DQ_VR608_CFG_DO_VR_DRN0     (0x00)


// VR-608 DOut and SyncOut line selector for VR-608 units <REVISION 2> or greater
#define DQ_VR608_CFG_DO_DBG_OFF     (0x3F)      // disable line
#define DQ_VR608_CFG_DO_SIG_SIM3    (0x3E)      // sensor simulator 3
#define DQ_VR608_CFG_DO_SIG_SIM2    (0x3D)      // sensor simulator 2
#define DQ_VR608_CFG_DO_SIG_SIM1    (0x3C)      // sensor simulator 1
#define DQ_VR608_CFG_DO_SIG_SIM0    (0x3B)      // sensor simulator 0
#define DQ_VR608_CFG_DO_FORCE1      (0x39)      // Drive TTL High/1
#define DQ_VR608_CFG_DO_FORCE0      (0x38)      // Drive TTL Low/0
#define DQ_VR608_CFG_DO_EM7         (0x33)      // measurement complete  7
#define DQ_VR608_CFG_DO_EM6         (0x32)      // measurement complete  6
#define DQ_VR608_CFG_DO_EM5         (0x31)      // measurement complete  5
#define DQ_VR608_CFG_DO_EM4         (0x30)      // measurement complete  4
#define DQ_VR608_CFG_DO_ADC_DETA3   (0x2F)      // NPULSE (UEI logic: ADC)
#define DQ_VR608_CFG_DO_ADC_DETA2   (0x2E)      // zero crossings from ADC module
#define DQ_VR608_CFG_DO_ADC_DETA1   (0x2D)      //  "       "
#define DQ_VR608_CFG_DO_ADC_DETA0   (0x2C)
#define DQ_VR608_CFG_DO_ADC_DETB3   (0x2B)
#define DQ_VR608_CFG_DO_ADC_DETB2   (0x2A)
#define DQ_VR608_CFG_DO_ADC_DETB1   (0x29)
#define DQ_VR608_CFG_DO_ADC_DETB0   (0x28)
#define DQ_VR608_CFG_DO_EM3         (0x27)      // measurement complete  3
#define DQ_VR608_CFG_DO_EM2         (0x26)      // measurement complete  2
#define DQ_VR608_CFG_DO_EM1         (0x25)      // measurement complete  1
#define DQ_VR608_CFG_DO_EM0         (0x24)      // measurement complete  0
#define DQ_VR608_CFG_DO_TORQUE3     (0x23)      // torque pulse from sensor pair 6,7
#define DQ_VR608_CFG_DO_TORQUE2     (0x22)      // torque pulse from sensor pair 4,5
#define DQ_VR608_CFG_DO_TORQUE1     (0x21)      // torque pulse from sensor pair 2,3
#define DQ_VR608_CFG_DO_TORQUE0     (0x20)      // torque pulse from sensor pair 0,1
#define DQ_VR608_CFG_DO_TTL3        (0x1F)      // from dsub pin 15, ttl gnd = pins 20,25,29,34
#define DQ_VR608_CFG_DO_TTL2        (0x1E)      // from dsub pin 10, all ttl input pins share same gnd
#define DQ_VR608_CFG_DO_TTL1        (0x1D)      // from dsub pin 6
#define DQ_VR608_CFG_DO_TTL0        (0x1C)      // from dsub pin 1
#define DQ_VR608_CFG_DO_SYNC3       (0x1B)      // from sync line 3
#define DQ_VR608_CFG_DO_SYNC2       (0x1A)      // from sync line 2
#define DQ_VR608_CFG_DO_SYNC1       (0x19)      // from sync line 1
#define DQ_VR608_CFG_DO_SYNC0       (0x18)      // from sync line 0
#define DQ_VR608_CFG_DO_ALARM3      (0x17)
#define DQ_VR608_CFG_DO_ALARM2      (0x16)
#define DQ_VR608_CFG_DO_ALARM1      (0x15)
#define DQ_VR608_CFG_DO_ALARM0      (0x14)
#define DQ_VR608_CFG_DO_ZDET7       (0x13)      // ZPULSE detector
#define DQ_VR608_CFG_DO_ZDET6       (0x12)      // = high pulse detector when mode = fixed or logic
#define DQ_VR608_CFG_DO_ZDET5       (0x11)      // VR asic z pulse when mode = onchip
#define DQ_VR608_CFG_DO_ZDET4       (0x10)      //
#define DQ_VR608_CFG_DO_ZDET3       (0x0F)
#define DQ_VR608_CFG_DO_ZDET2       (0x0E)
#define DQ_VR608_CFG_DO_ZDET1       (0x0D)
#define DQ_VR608_CFG_DO_ZDET0       (0x0C)
#define DQ_VR608_CFG_DO_VR_INPULS7  (0x0B)      // NPULSE (MAX9926 IC)
#define DQ_VR608_CFG_DO_VR_INPULS6  (0x0A)      // VR IC output pins
#define DQ_VR608_CFG_DO_VR_INPULS5  (0x09)
#define DQ_VR608_CFG_DO_VR_INPULS4  (0x08)
#define DQ_VR608_CFG_DO_VR_INPULS3  (0x07)
#define DQ_VR608_CFG_DO_VR_INPULS2  (0x06)
#define DQ_VR608_CFG_DO_VR_INPULS1  (0x05)
#define DQ_VR608_CFG_DO_VR_INPULS0  (0x04)
#define DQ_VR608_CFG_DO_VR_DRN3     (0x03)      // VR IC drn pins
#define DQ_VR608_CFG_DO_VR_DRN2     (0x02)
#define DQ_VR608_CFG_DO_VR_DRN1     (0x01)
#define DQ_VR608_CFG_DO_VR_DRN0     (0x00)

// Alarm selection for <REVISION2> or greater units only
// alarm selection bits for using the DOUT pins as open sensor or stalled rotation indicators.
//  These bits are used when DIOx source(DQ_VR608_CFG.d_out) for the DOUT in non-user mode is set to
//  DQ_CT608_GPIO_DIO_ALARM . Each DOUT pin can be set to go high when any or all of the alarm
//  conditions for the indicated alarm number are present. Use to populate DQ_VR608_CFGR2.alarm_src
#define DQ_VR608_CFG_ALARM3_OPEN7   (1L<<27)    // config bits for DOUT3 when DQ_CT608_GPIO_DIO_ALARM is
#define DQ_VR608_CFG_ALARM3_OPEN6   (1L<<26)    // selected by bits [31:28] of DQ_VR608_GPIOR and bit 11
#define DQ_VR608_CFG_ALARM3_STAL7   (1L<<25)    // of DQ_VR608_GPIOR is 0
#define DQ_VR608_CFG_ALARM3_STAL6   (1L<<24)

#define DQ_VR608_CFG_ALARM2_OPEN5   (1L<<19)    // config bits for DOUT2 when DQ_CT608_GPIO_DIO_ALARM is
#define DQ_VR608_CFG_ALARM2_OPEN4   (1L<<18)    // selected by bits [27:24] of DQ_VR608_GPIOR and bit 10
#define DQ_VR608_CFG_ALARM2_STAL5   (1L<<17)    // of DQ_VR608_GPIOR is 0
#define DQ_VR608_CFG_ALARM2_STAL4   (1L<<16)

#define DQ_VR608_CFG_ALARM1_OPEN3   (1L<<11)    // config bits for DOUT1 when DQ_CT608_GPIO_DIO_ALARM is
#define DQ_VR608_CFG_ALARM1_OPEN2   (1L<<10)    // selected by bits [23:20] of DQ_VR608_GPIOR and bit 9
#define DQ_VR608_CFG_ALARM1_STAL3   (1L<<9)     // of DQ_VR608_GPIOR is 0
#define DQ_VR608_CFG_ALARM1_STAL2   (1L<<8)     //

#define DQ_VR608_CFG_ALARM0_OPEN1   (1L<<3)     // config bits for DOUT0 when DQ_CT608_GPIO_DIO_ALARM is
#define DQ_VR608_CFG_ALARM0_OPEN0   (1L<<2)     // selected by bits [19:16] of DQ_VR608_GPIOR and bit 8
#define DQ_VR608_CFG_ALARM0_STAL1   (1L<<1)     // of DQ_VR608_GPIOR is 0
#define DQ_VR608_CFG_ALARM0_STAL0   (1L<<0)

#define DQ_VR608_CFG_ALARM_ALL_STAL ( DQ_VR608_CFG_ALARM0_STAL0 |\
                                    DQ_VR608_CFG_ALARM0_STAL1   |\
                                    DQ_VR608_CFG_ALARM1_STAL2   |\
                                    DQ_VR608_CFG_ALARM1_STAL3   |\
                                    DQ_VR608_CFG_ALARM2_STAL4   |\
                                    DQ_VR608_CFG_ALARM2_STAL5   |\
                                    DQ_VR608_CFG_ALARM3_STAL6   |\
                                    DQ_VR608_CFG_ALARM3_STAL7  )

#define DQ_VR608_CFG_ALARM_ALL_OPEN ( DQ_VR608_CFG_ALARM0_OPEN0 |\
                                    DQ_VR608_CFG_ALARM0_OPEN1   |\
                                    DQ_VR608_CFG_ALARM1_OPEN2   |\
                                    DQ_VR608_CFG_ALARM1_OPEN3   |\
                                    DQ_VR608_CFG_ALARM2_OPEN4   |\
                                    DQ_VR608_CFG_ALARM2_OPEN5   |\
                                    DQ_VR608_CFG_ALARM3_OPEN6   |\
                                    DQ_VR608_CFG_ALARM3_OPEN7 )

#define DQ_VR608_CFG_ALARM_ALL      (DQ_VR608_CFG_ALARM_ALL_OPEN | DQ_VR608_CFG_ALARM_ALL_STAL)

// AIN_STS flags for DQ_VR608_CHNLRQ_STATUS in DqAdv608Read()
#define DQ_VR608_AIN_STS_ZLHB       (1L<<20)    // - Rising edge zero crossing was detected on "B" (odd channel)
#define DQ_VR608_AIN_STS_ZHLB       (1L<<19)    // - Falling edge zero crossing was detected on "B" (odd channel)
#define DQ_VR608_AIN_STS_ZLHA       (1L<<18)    // - Rising edge zero crossing was detected on "A" (even channel)
#define DQ_VR608_AIN_STS_ZHLA       (1L<<17)    // - Falling edge zero crossing was detected on "A" (even channel)
#define DQ_VR608_AIN_STS_ABD        (1L<<16)    // - "A" and "B" data is ready

/*typedef struct {
    DQ_VR608_CFG2  extcfg2[DQ_VR608_CHAN];      // extended REV2 configuration tables
} DQINITPRM_EX_608_, *pDQINITPRM_EX_608_;
*/

typedef struct {
    uint16 aioffs[DQ_VR608_AICHAN];             // 16b 2'sCompl  , 0x2140, 0x2148, 0x2240, 0x2248, 0x2340, 0x2348, 0x2440, 0x2448
    uint16 aigain[DQ_VR608_AICHAN];             // 0x8000for G=1 , 0x2144, 0x214C, 0x2244, 0x224C, 0x2344, 0x234C, 0x2444, 0x244C
    uint16 aooffs[DQ_VR608_AOCHAN];             // 16b 2'sCompl  , 0x2840, 0x2848, 0x2940, 0x2948, 0x2A40, 0x2A48...
    uint16 aogain[DQ_VR608_AOCHAN];             // 0x8000for G=1 , 0x2844, 0x284C, 0x2944, 0x294C, 0x2A44, 0x2A4C...
} DQCALSET_608_, *pDQCALSET_608;

#define DQ_VR608_EECFG_FORMAT_VER   (0x6081)    // EEPROM & CFG structure REV 1
#define DQ_VR608_EECFG_FORMAT_VER2  (0x6082)    // EEPROM & CFG structure REV 2

typedef struct {   // unchanging EEPROM struct for both REV1 and REV2 layers
    uint32 cfgformat;   // contains VR608_EECFG_FORMAT_VER (and a free uint16)

    uint32 cfg_flags;   // bitmap of parameters that contain valid configurations (see DQ_VR608_CFGVLD_ defines)
    uint32 reserved[2];
    float  adc_rate;    // (L) analog input rate, Hz, for the board - last value written overwrites ALL channels
    float  tmode_rate;  // (C) prescaler for timebase clock, Hz = how often to store accumulated data (VR608_MODE_TIMED mode)

    float  ofs_bias;    // <reserved> for offset bias
    float  zc_level;    // (C) VR608_ZC_FIXED: zero cross level sets fixed DAC bias reference voltage for front-end ASIC to -5..5V
    float  apt_th;      // (C) VR608_APT_FIXED: analog peak threshold can be fixed to 0-5V (in practice 2.0-4.5V)
    uint32 apt_div;     // (C) VR608_APT_LOGIC: divider for AIn to set automatic AOut threshold (1..15)

    uint32 adc_mv_avg;  // (C) moving average in VR608_*_LOGIC/ZC_FIXED modes (logic 11.A4 or newer)

    uint32 sync_in;     // (L) select which SYNC line to take for timebase clock (reserved)
    uint32 sync_in_ps;  // (L) select prescaler for timebase clock (reserved)
    uint32 sync_out;    // (L) select which SYNC line and which signal to route out (reserved)
    uint32 d_out;       // (L) select which DOut lines and which signals to route out.
    uint32 num_teeth;   // (C) VR608_MODE_NPULSE: number of teeth
    int    z_tooth_sz;  // (C) VR608_MODE_ZPULSE: size of Z-tooth in teeth
                        // this is a correction factor in DAQLib to compensate for number of teeth
                        // that Z-tooth substitutes (either missing teeth or a wider tooth)
} DQ_VR608_EP_CFG, *pDQ_VR608_EP_CFG;

typedef struct {    // struct for eeprom, for both REV1 and REV2
    uint32 front_cfg[DQ_VR608_CHAN];            // front-end configuration
    uint32 mode[DQ_VR608_CHAN];                 // mode of operation
    DQ_VR608_EP_CFG extcfg[DQ_VR608_CHAN];      // extended configuration tables
} DQINITPRM_608_, *pDQINITPRM_608_;

typedef struct {     // struct for eeprom, 608 REV2  this struct is similar to DQ_VR608_EX2 but with extra space reserved in the EEPROM
    uint32 alarm_src;   // (L) determines which alarm conditions will set the d_out lines. These are used when .d_out is set for alarm
    uint32 ttl_cfg;     // (L) configure ttl inputs
    uint32 res2[DQ_VR608_CHAN * 2];     // reserved for future development
    uint32 torque_cfg[DQ_VR608_CHAN_PAIRS];  // (P) set flags for polarity of torque sensor pair and rotation direction, DQ_VR608_TORQCFG_x
} DQ_VR608_EP_R2, *pDQ_VR608_EP_R2;



typedef struct {    // struct for eeprom, for configuration values added in REV2
    DQ_VR608_EP_R2 extcfg2;      // extended configuration tables
} DQINITPRM_608_R2, *pDQINITPRM_608_R2;

// -----------------------------------------------------------------------------------------
#define DQ_CT650_CHAN               1           // single input and output channel

#define DQ_CT650_INFOSZ             DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_CT650_BASE               100000000   // 100MHz base frequency instead of the usual 66MHz
#define DQ_CT650_PERIOD_nS          10          // 10ns per tick
#define DQ_CT650_BASE_uS            100         // 100 ticks per us
#define DQ_CT650_BASE_mS            100000      // 100000 ticks per ms
#define DQ_CT650_MAXCLFRQ           2000
#define DQ_CT650_MAXCVFRQ           2000

#define DQL_LCR650_LED              2           // switch LED on
#define DQL_CT650_GPS_BAUD          9600        // baud rate

#define DQ_CT650_RXGPSFIFOSIZE      512        // Rx FIFO size for GPS
#define DQ_CT650_TXGPSFIFOSIZE      512        // Tx FIFO size for GPS
#define DQ_CT650_EVTFIFOSIZE        1024       // Event receive FIFO size

#define DQ_CT650_RXGPSFIFOWM        2048       // Rx FIFO watermark
#define DQ_CT650_TXGPSFIFOWM        2048       // Tx FIFO watermark

#define CT650_SEC_IN_MIN            60
#define CT650_SEC_IN_HOUR           3600
#define CT650_SEC_IN_DAY            86400
#define CT650_TKPERIOD_NOMINAL      (100000000-1)     // nominal period can be corrected for oscillator variations
#define DQ_CT650_BASE_PERIOD_uS     (DQ_CT650_BASE/1000000)       // 100 ticks per uS at 100Mhz

#define CT650_1PPM_FRQ              (1.0/CT650_SEC_IN_MIN)
#define CT650_1PPH_FRQ              (1.0/CT650_SEC_IN_HOUR)


#define L650_DIV(RATE, BASECLOCK)   (uint32)((BASECLOCK + (8 * RATE)) / (RATE * 16))

#define CT650_SWG_50Mhz             ((DQ_CT650_BASE/50000000)-1)   // DAC divider 50Mhz
#define CT650_SWG_5Mhz              ((DQ_CT650_BASE/5000000)-1)    // DAC divider 5Mhz
#define CT650_SWG_05Mhz             ((DQ_CT650_BASE/500000)-1)     // DAC divider 0.5Mhz

#define CT650_CY22150_BASE          (20000000)  // 20MHz used as a PLL reference input


// Output FIFO to read data
#define DQ_650_FIFO_GET_DATA        DQ_FIFO_GET_DATA

// Input FIFO to read data
#define DQ_650_FIFO_SET_DATA        DQ_FIFO_SET_DATA

typedef struct {
    uint16 cmd;      // command
    uint16 bit;      // bit number (in TK TREGx)
    uint16 reg;      // TREG number
    uint16 desc;    // data description
} CT650_VALID_TABLE, *pCT650_VALID_TABLE;

// Sections of data <sec>
#define CT650_SECT_BCD  1   // BCD time data
#define CT650_SECT_CF   2   // control functions
#define CT650_SECT_SBS  3   // straight binary seconds

// Description of the data <desc>
#define BCD_NoP_d()      (CT650_SECT_BCD<<8)    // NOP or Positional character
#define BCD_NoP_b()      (0)
#define BCD_NoP_r()      (0)

#define BCD_SEC100        1
#define BCD_SEC100_d(B)   ((BCD_SEC100<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_SEC100_b(B)   ((B))               // 1/100 of a second
#define BCD_SEC100_r(B)   ((0))
#define IS_BCD_SEC_100(B) (((B)&0xf000) == (BCD_SEC100<<12))

#define BCD_SEC10         2
#define BCD_SEC10_d(B)    ((BCD_SEC10<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_SEC10_b(B)    ((B)+8)              // 1/10 of a second
#define BCD_SEC10_r(B)    ((0))
#define IS_BCD_SEC_10(B)  (((B)&0xf000) == (BCD_SEC10<<12))

#define BCD_SEC           3
#define BCD_SEC_d(B)      ((BCD_SEC<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_SEC_b(B)      ((B))                // seconds
#define BCD_SEC_r(B)      ((1))
#define IS_BCD_SEC(B)     (((B)&0xf000) == (BCD_SEC<<12))

#define BCD_MIN           4
#define BCD_MIN_d(B)      ((BCD_MIN<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_MIN_b(B)      ((B)+8)              // minutes
#define BCD_MIN_r(B)      ((1))
#define IS_BCD_MIN(B)     (((B)&0xf000) == (BCD_MIN<<12))

#define BCD_HOUR          5
#define BCD_HOUR_d(B)     ((BCD_HOUR<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_HOUR_b(B)     ((B))                // hours
#define BCD_HOUR_r(B)     ((2))
#define IS_BCD_HOUR(B)    (((B)&0xf000) == (BCD_HOUR<<12))

#define BCD_DAYS          6
#define BCD_DAYS_d(B)     ((BCD_DAYS<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_DAYS_b(B)     ((B))                // days
#define BCD_DAYS_r(B)     ((3))
#define IS_BCD_DAYS(B)    (((B)&0xf000) == (BCD_DAYS<<12))

#define BCD_YEAR          7
#define BCD_YEAR_d(B)     ((BCD_YEAR<<12)|(CT650_SECT_BCD<<8)|(B))
#define BCD_YEAR_b(B)     ((B))                // year
#define BCD_YEAR_r(B)     ((5))
#define IS_BCD_YEAR(B)    (((B)&0xf000) == (BCD_YEAR<<12))

#define BCD_SPEC_BIT      0
#define BCD_LEAPYR_d()    ((BCD_SPEC_BIT<<12)|(CT650_SECT_BCD<<8)|0)
#define BCD_LEAPYR_b()    ((8))                // leap year flag
#define BCD_LEAPYR_r()    ((2))

#define BCD_DLFLAG_d()    ((BCD_SPEC_BIT<<12)|(CT650_SECT_BCD<<8)|1)
#define BCD_DLFLAG_b()    ((9))                // DL flag
#define BCD_DLFLAG_r()    ((2))

#define SBS_SEC_d(B)      ((BCD_SPEC_BIT<<12)|(CT650_SECT_SBS<<8)|(B))
#define SBS_SEC_b(B)      (((B)<=15)?(B):(15))    // 17th SBS second bit is stored in TREG2/BIT15
#define SBS_SEC_r(B)      (((B)<=15)?(4):(2))

#define CF_BITS_d(B)      ((BCD_SPEC_BIT<<12)|(CT650_SECT_CF<<8)|(B))

#define CF_NoP_d()        (CT650_SECT_CF<<8)    // NOP or Positional character
#define CF_NoP_b()        (0)
#define CF_NoP_r()        (0)
#define IS_CF(B)          (((B)&0xf00) == (CT650_SECT_CF<<8))

#define SBS_NoP_d()       (CT650_SECT_SBS<<8)    // NOP or Positional character
#define SBS_NoP_b()       (0)
#define SBS_NoP_r()       (0)
#define IS_SBS(B)         (((B)&0xf00) == (CT650_SECT_SBS<<8))
#define IS_BCD(B)         (((B)&0xf00) == (CT650_SECT_BCD<<8))

// macros to retrieve parts of time code from TREG
#define CT650_GET_BCD_SEC100(A)  (((*((uint32*)(A)+0))&0xf)>>0)
#define CT650_GET_BCD_SEC10(A)   (((*((uint32*)(A)+0))&0xf00)>>8)
#define CT650_GET_BCD_SEC(A)     (((*((uint32*)(A)+1))&0x7f)>>0)
#define CT650_GET_BCD_MIN(A)     (((*((uint32*)(A)+1))&0x7f00)>>8)
#define CT650_GET_BCD_HOUR(A)    (((*((uint32*)(A)+2))&0x7f)>>0)
#define CT650_GET_BCD_DAYS(A)    (((*((uint32*)(A)+3))&0x3ff)>>0)
#define CT650_GET_BCD_YEAR(A)    (((*((uint32*)(A)+5))&0xff)>>0)
#define CT650_GET_SBS_SEC(A)     ((*((uint32*)(A)+4))|(((*((uint32*)(A)+2))&0x8000)<<1))
#define CT650_GET_PHASE_DLY(A)   ((*((uint32*)(A)+13))|(((*((uint32*)(A)+12)))<<16))
#define CT650_GET_TIMESTAMP(A)   ((*((uint32*)(A)+15))|(((*((uint32*)(A)+14)))<<16))

#pragma pack(1)
typedef struct {
    uint32 sig_source;
    uint32 tc_format;
    uint32 tc_source;
    uint32 tk_cfg;
} CT650_IRIG_SRC, *pCT650_IRIG_SRC;

typedef struct {
    char tcode_name[32];    // timecode name
    char tcode_subtype[32]; // timecode signal
    double bit_frq;         // timecode bit rate, Hz
    double frame_frq;       // timecode frame rate, Hz
    double carrier_frq;     // carrier frequency
    uint32 ratio_f_er;      // frequency to code bit ratio
    uint32 logic_0;         // number of cycles for logic_0
    uint32 logic_1;         // number of cycles for logic_1
    uint32 pos_id;          // number of cycles for position identifier
    int is_bcd;             // TRUE if BCD code is present in the data
    int is_cf;              // TRUE if CF codes are present
    int is_sbs;             // TRUE if SBS is present
    int is_year;            // TRUE if CF characters 50-58 contain BCD year data
} CT650_IRIG_PRM_DEF, *pCT650_IRIG_PRM_DEF;

#define CT650_VAL_MAX   128 // maximum number of validation entries

typedef struct {
    char timecode_name[32]; // timecode name
    uint32 val_table_sz;    // timecode table size
    CT650_VALID_TABLE val_table[CT650_VAL_MAX];   // timecode table (128 bits maximum)
} CT650_IRIG_CODE_DEF, *pCT650_IRIG_CODE_DEF;

typedef struct {
    // user-definied part
    double ppx;           // time between time codes (for most IRIG-x == 1pps)
    uint32 pph;           // pulses per hour, 1PPS=3600PPH
    uint32 in_freq;       // input carier frequency
    uint32 rx_ici;        // ct650_rx_ici - pulses per bit
    uint32 dbcnt;         // ct650_dbcnt (debouncing counter only in NRZ input mode in 10ns)
    uint32 rxmsg_len;     // ct650_rxmsg_len input message length
    uint32 pi_min;        // ct650_pi_min - minimum number of pulses in position identifier
    uint32 pi_max;        // ct650_pi_max - maximum number of pulses in position identifier
    uint32 l0_min;        // ct650_l0_min - minimum number of pulses in level 0 position
    uint32 l0_max;        // ct650_l0_max - maximum number of pulses in level 0 position
    uint32 l1_min;        // ct650_l1_min - minimum number of pulses in level 1 position
    uint32 l1_max;        // ct650_l1_max - maximum number of pulses in level 1 position

    // system-defined part
    uint32 cr_tol_min;    // ct650_cr_tol_min (signal tolerance - MAN2 mode only)
    uint32 ct_tol_max;    // ct650_ct_tol_max (signal tolerance - MAN2 mode only)
    uint32 mii_tol;       // ct650_mii_tol 50us @ 100Mhz base
    uint32 pps_min;       // ct650_pps_min - flywheel clock divider auto-correction low limit
    uint32 pps_max;       // ct650_pps_max - flywheel clock divider auto-correction high limit
    uint32 ppsmav;        // ct650_ppsmav 3 = 8 points
} CT650_IRIG_SIG_DEF, *pCT650_IRIG_SIG_DEF;

#pragma pack()

// constant flags to validate each member of CT650_IRIG_SIG_DEF
#define CT650_RX_ICIWR      (1L<<0)
#define CT650_DBCNTWR       (1L<<1)
#define CT650_RXMSG_LENWR   (1L<<2)
#define CT650_PI_MINWR      (1L<<3)
#define CT650_PI_MAXWR      (1L<<4)
#define CT650_L0_MINWR      (1L<<5)
#define CT650_L0_MAXWR      (1L<<6)
#define CT650_L1_MINWR      (1L<<7)
#define CT650_L1_MAXWR      (1L<<8)
#define CT650_CR_TOL_MINWR  (1L<<9)
#define CT650_CR_TOL_MAXWR  (1L<<10)
#define CT650_MII_TOLWR     (1L<<11)
#define CT650_PPS_MINWR     (1L<<12)
#define CT650_PPS_MAXWR     (1L<<13)
#define CT650_PPSMAVWR      (1L<<14)

// Event data for 650 layer
#define DQ_L650_EV_CHAN             9  // nine asynchronous event channels
#define CT650_EVENT_CH0             0  // Event channel 0 (status and asynchronous event only)
#define CT650_EVENT_CH1             1  // Event channel 1 (status and asynchronous event only)
#define CT650_EVENT_CH2             2  // Event channel 2 (status and asynchronous event only)
#define CT650_EVENT_CH3             3  // Event channel 3 (status and asynchronous event only)
#define CT650_EVENT_CHD             4  // Event channel 4 (status and event data FIFO only)
#define CT650_EVENT_CHPPS           5  // 1PPS event
#define CT650_EVENT_CHTRDY          6  // time ready (frame rate) event
#define CT650_EVENT_CHERR           7  // input error event

typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 evtmask;                 // subype of reported events (mask)
    uint32 status;                  // event status register
    uint32 tstamp;                  // timestamp of event taken from layer TS generator
    uint32 size;                    // size of the following data in bytes
    uint32 avail;                   // number of bytes available
    uint32 data[DQ_FLEX_ARRAY];                   // data to follow (byte pointer - ntohx() and convert properly)
} EV650_ID, *pEV650_ID;

typedef enum {
    EV650_CLEAR = 0x1000,           // clear all events
    EV650_EVENT = 0x101,            // event has happened
    EV650_PPS_CLK = 0x102,          // 1PPS pacer clock event
    EV650_TIMERDY = 0x103,          // Time received and processed (based on FPS rate)
    EV650_GPSRX = 0x104,            // GPS data was received (reserved)
    EV650_ERROR = 0x110             // multiple errors in TK or TA

} event650_t;

#define ISR650_OVERRUN_TIME     (198)                   // i.e. prevent interrupt to be called faster than this rate (originally ISR501_OVERRUN_TIME, now measured by hand)
#define ISR650_OVERRUN_NUM      (DQ_L650_EV_CHAN)       // i.e. number of overruns to be detected in row for the isr to be cleared

// Event configuation structure for each of 4+1 event sources
typedef struct {
    uint32 event_cfg;           // event configuration bitfield
    uint32 event_prm;           // event parameters
    uint32 event_val;           // parametric-dependent value
    uint32 event_sub0_dly;      // subevent 0 delay
    uint32 event_sub1_dly;      // subevent 1 delay
} EV650_CFG, *pEV650_CFG;

// Event status
typedef struct {
    uint32 event_sts;           // event status
    uint32 event_tstamp;        // event timestamp
    uint32 event_ad;            // event address/data (debug only)
} EV650_STS, *pEV650_STS;

typedef struct {
    uint32 s100;     // 100's of a second (4 bits)
    uint32 s10;      // 10's of a second (4 bits)
    uint32 sec;      // seconds (7 bits)
    uint32 min;      // minutes (7 bits)
    uint32 hours;    // hours (7 bits)
    uint32 days;     // days
    uint32 year;     // year
} CT650_BCD_TIME, *pCT650_BCD_TIME;

#define CT650_CH_READ_BCD       0
#define CT650_CH_READ_SBS       1
#define CT650_CH_READ_ANSI      2


#define DqAdv650ConfigEvents_PARAMSZ (7)        // maximum number of uint32 parameters after pEV650_ID

// ioctls for IRIG-650 layer
#define DQL_IOCTL650_SETMODE        (0x01L)     // configures timekeeper
#define DQL_IOCTL650_SETINMODE      (0x02L)     // sets input mode
#define DQL_IOCTL650_SETOUTMODE     (0x03L)     // sets output mode
#define DQL_IOCTL650_TIME           (0x04L)     // sets or gets time

#define DQL_IOCTL650_READ_FIFO      (0x06L)     // read a channel FIFO
#define DQL_IOCTL650_WRITE_FIFO     (0x07L)     // write a channel FIFO
#define DQL_IOCTL650_TRIGGER        (0x08L)     // set event trigger conditions
#define DQL_IOCTL650_CONTROL        (0x09L)     // control IRIG-650 parameters without restarting
#define DQL_IOCTL650_START          (0x0AL)     // immediate mode start

#define DQL_IOCTL650_SET_TTL        (0x0BL)     // set TTL outputs
#define DQL_IOCTL650_ADJUST         (0x0CL)     // adjust different parameters
#define DQL_IOCTL650_EVENTS         (0x0DL)     // set events
#define DQL_IOCTL650_RESERVED_E     (0x0EL)     // reserved

#define DQL_IOCTL650_STATUS         (0x0FL)     // get interface status

#define DQL_IOCTL650_RD_MSGDEC      (0x1001L)   // read decoded time code message
#define DQL_IOCTL650_RD_TREG        (0x1002L)   // read TREGs
#define DQL_IOCTL650_CALIBR         (0x1003L)   // 10MHz clock calibration

// for DQL_IOCTL650_ADJUST
#define DQL_IOCTL650_SET_PROP       (0x1L)  // set propagation delay
#define DQL_IOCTL650_SET_AMOUT      (0x2L)  // adjust AM outputs
#define DQL_IOCTL650_SET_LOCAL      (0x3L)  // adjust for local time difference vs. UTC
#define DQL_IOCTL650_READ_REG       (0x4L)  // read register
#define DQL_IOCTL650_WRITE_REG      (0x5L)  // write register
#define DQL_IOCTL650_PROG_PLL       (0x6L)  // set up PLL frequency
#define DQL_IOCTL650_SET_AMZC       (0x7L)  // set AM zero crossing parameters
#define DQL_IOCTL650_PROG_GPS       (0x8L)  // reset and reprogram GPS
#define DQL_IOCTL650_TRACK_GPS      (0x9L)  // enable/disable GPS message tracking
#define DQL_IOCTL650_SETTIME_GPS    (0xAL)  // set timekeeper time from GPS upon 1pps pulse


// for DQL_IOCTL650_TIME
#define DQL_IOCTL650_GETTM_SBS      (0x1L)  // gets time SBS
#define DQL_IOCTL650_GETTM_ANSI     (0x2L)  // gets time in ANSI structure
#define DQL_IOCTL650_GETTM_BCD      (0x3L)  // gets time in BCD form
#define DQL_IOCTL650_SETTM_SBS      (0x4L)  // sets time SBS
#define DQL_IOCTL650_SETTM_ANSI     (0x5L)  // sets time in ANSI structure
#define DQL_IOCTL650_SETTM_BCD      (0x6L)  // sets time in BCD form
#define DQL_IOCTL650_GETTM_BCD_RESET_TS (0x7L)  // does as 0x3 but also resets timestamps of layers specified
#define DQL_IOCTL650_GETTM_ANSI_RESET_TS (0x8L)  // does as 0x2 but also resets timestamps of layers specified

// for DQL_IOCTL650_GETTM_ANSI_RESET_TS <mask> parameters
#define DQL_IOCTL650_GETTM_SETTO_uS  (2L<<16)   // reset timstamp to equal IRIG-650 seconds/microseconds timestamps
#define DQL_IOCTL650_GETTM_SETTO_TS  (1L<<16)   // reset timstamp to equal IRIG-650 timestamps


// for DQL_IOCTL650_READ_FIFO/DQL_IOCTL650_WRITE_FIFO
#define DQL_IOCTL650_EVENT_FIFO     (1)   // access to event FIFO
#define DQL_IOCTL650_GPS_FIFO       (2)   // access to GPS FIFO

// for DQL_IOCTL650_STATUS
#define DQL_IOCTL650_GPS_STATUS     (1L<<0)   // Get GPS subsystem status
#define DQL_IOCTL650_TK_STATUS      (1L<<1)   // Get timekeeper subsystem status
#define DQL_IOCTL650_TIN_STATUS     (1L<<2)   // Get timecode input status
#define DQL_IOCTL650_TOUT_STATUS    (1L<<3)   // Get timecode output status
#define DQL_IOCTL650_EVT_STS        (1L<<8)   // Get event status

// for DQL_IOCTL650_CALIBR
#define DQL_IOCTL650_CAL_CT_ENABLE  (1L<<0)   // Clock Calibration: Enable counter
#define DQL_IOCTL650_CAL_CT_DISABLE (1L<<1)   // Clock Calibration: Disable counter
#define DQL_IOCTL650_CAL_DATA_READY (1L<<2)   // Clock Calibration: Calibration counter data is ready
#define DQL_IOCTL650_CAL_CT_RD      (1L<<3)   // Clock Calibration: Read counter value
#define DQL_IOCTL650_CAL_CT_WR      (1L<<4)   // Clock Calibration: Write value to counter
#define DQL_IOCTL650_CAL_TTL_IN_RD  (1L<<5)   // TTL Inputs: Read state of TTL inputs
#define DQL_IOCTL650_CAL_GPSICID_RD (1L<<6)   // GPS Calibration: Read GPS CHIP ID

// for DQL_IOCTL650_EVENTS
#define DQL_IOCTL650_IRQ_EN         (1L<<0)   // Enable IRQs
#define DQL_IOCTL650_EVT_EN         (1L<<31)  // Enable events without IRQs

// for DQL_IOCTL650_PROG_GPS argin[1]
#define DQ_CT650_GPS_RST    (1L<<3)     // reset GPS
#define DQ_CT650_GPS_PTP    (1L<<2)     // enable PTP operations
#define DQ_CT650_GPS_COM1   (1L<<1)     // use serial port 1

// for DQL_IOCTL650_SET_TTL
#define DQ_CT650_TTL_SYNCX  (1L<<31)    // Assign SYNC outputs instead of TTL output

// Timekeeper configuration ---
// Mode of TK operation (for DqAdv650ConfigTimekeeper())
#define CT650_TKPPS_IO(N)          (((N)&1)+13) // External 1PPS signal from I/O lines
#define CT650_TKPPS_RFIN           (12)    // External 1PPS signal from RFIn1
#define CT650_TKPPS_SYNC(N)        (((N)&3)+8) // One of the SyncX lines
#define CT650_TKPPS_TIMECODE_SLOW  (6)     // work with faster than 1PPS derived from external time code
#define CT650_TKPPS_GPS            (3)     // GPS as a source of 1PPS
#define CT650_TKPPS_INTERNAL       (2)     // rely on internal synchronization
#define CT650_TKPPS_TIMECODE       (1)     // work with 1PPS or slower derived from external time code (AM or MII or NRZ)
#define CT650_TKPPS_DISABLED       (0)     // timekeeper disabled

// Additional TK flags
#define CT650_TKFLG_AUTOFOLLOW    (1L<<13) // if external PPS is missing use internal timebase to continue
#define CT650_TKFLG_USENOMINAL    (1L<<16) // if external PPS is lost use internal timebase instead
                                           // of measured one from the time when it was available
#define CT650_TKFLG_SUBPPS        (1L<<14) // external timebase can be slower than 1PPS (1PPM/1PPH)
                                           // (CT650_TKFLG_USENOMINAL should be used in conjunction)
#define CT650_TKFLG_USESBS        (1L<<18) // Force use SBS for TK hour/min decoding
#define CT650_TKFLG_SEC_INVALID   (1L<<19) // Incoming time code BCD seconds are invalid
#define CT650_TKFLG_MIN_INVALID   (1L<<20) // Incoming time code BCD minutes are invalid
#define CT650_TKFLG_DAY_INVALID   (1L<<21) // Incoming time code BCD minutes are invalid

// Timecode input configuration: Input mode and deviations from standard definition
#define CT650_IN_ENABLED    (1)     // enable input
#define CT650_IN_DISABLED   (0)     // disable input
#define CT650_IN_TC_UPD_YR  (1L<<9) // enable timekeeper year update from timecode.
#define CT650_IN_EXT10MHZ   (1L<<8) // use external 10MHz connected to RFIn1
#define CT650_IN_1PPS_OBE   (1L<<5) // enable extra 1PPS when 1ppM/1ppH comes out of bounds
#define CT650_IN_P0_ONLY    (1L<<4) // enable single Px character at the beginning
#define CT650_IN_IDLE_EN    (1L<<3) // enable "idle" characters within time message
#define CT650_IN_DICON_TDTK (1L<<2) // disconnect TD from TK - disable "time ready" output strobe to TK

// Timecode input configuration: where time code is coming from
#define CT650_IN_AM         (0x30)  // Time code is on AM signal
#define CT650_IN_M2_RF0     (0x20)  // Manchester II code on RFIn0 input
#define CT650_IN_M2_RF1     (0x24)  // Manchester II code on RFIn1 input
#define CT650_IN_M2_IO0     (0x28)  // Manchester II code on I/O 0 input
#define CT650_IN_M2_IO1     (0x2C)  // Manchester II code on I/O 1 input
#define CT650_IN_NRZ_RF0    (0x10)  // NRZ code on RF0 input
#define CT650_IN_NRZ_RF1    (0x14)  // NRZ code on RF1 input
#define CT650_IN_NRZ_IO0    (0x18)  // NRZ code on I/O 0 input
#define CT650_IN_NRZ_IO1    (0x1C)  // NRZ code on I/O 1 input
#define CT650_IN_GPS        (0x1)   // Time code is taken from GPS NMEA message

// Timecode output configuration: Output mode and deviations from standard definition
#define CT650_OUT_DISABLED   (0)    // disable output
#define CT650_OUT_ENABLED    (1)    // enable output
#define CT650_OUT_ONVALID    (2)    // =1 -Disable output waveform generation until TA restart
                                    // avoid incorrect output during initial synchronization
                                    // with external time signal source. NOTE : that waveform
                                    // restart works properly only if
#define CT650_OUT_EXTSYNCRQ  (4)    // =1 - External Resynchronization Required bit - works
                                    // as a modifier for the CT650_OUT_ONVALID, if this bit is
                                    // set and CT650_OUT_ONVALID=1 output waveform will be disabled until
                                    // resynchronization with external source is achieved plus one
                                    // ta_restart pulse is received from the time keeper (extra
                                    // ta_restart period is required because time keeper re-syncs
                                    // in the middle of the pps/ppm/pph period. Note that for the
                                    // codes that repeat every hour re-synchronization process
                                    // can take up to three hours

// Flags for set time
#define CT650_TIME_TM_SEC   (1L<<0)    // seconds after the minute - [0,59]
#define CT650_TIME_TM_MIN   (1L<<1)    // minutes after the hour - [0,59]
#define CT650_TIME_TM_HOUR  (1L<<2)    //  hours since midnight - [0,23]
#define CT650_TIME_TM_MDAY  (1L<<3)    // day of the month - [1,31]
#define CT650_TIME_TM_MON   (1L<<4)    // months since January - [0,11]
#define CT650_TIME_TM_YEAR  (1L<<5)    // years since 1900
#define CT650_TIME_TM_WDAY  (1L<<6)    // days since Sunday - [0,6]
#define CT650_TIME_TM_YDAY  (1L<<7)    // days since January 1 - [0,365]
#define CT650_TIME_TM_ISDST (1L<<8)    // daylight savings time flag
#define CT650_TIME_TM_ALL   (0x1ff)    // everything


#define CT650_MII_DBVAL     10         // number of clock to debounce NRZ code
#define CT650_PPS_MINVAL    99990000   // default minimum PPS tolerance value
#define CT650_PPS_MAXVAL    100009999  // default maximum PPS tolerance value
#define CT650_PPS_MAVVAL    3          // default moving avg window: 3=8
#define CT650_CR_TOL_DIV    20         // tolerance is 1/20 part of the range (5%)



#define CT650_TKDLY_DEF     0x100000   // default timekeeper delay

#define CT650_TKDLY_FIXED_AM_01fps     0x18f80    // timekeeper delay for 0.1Hz code
#define CT650_TKDLY_FIXED_AM_1fps      0x2C0      // fixed delay cause by 50MHz conversion clock
#define CT650_TKDLY_FIXED_AM_10fps     0x2cf0
#define CT650_TKDLY_FIXED_AM_100fps    0x650

#define CT650_TKDLY_FIXED_NRZ_01fps     (-102272)    // timekeeper delay for 0.1Hz code
#define CT650_TKDLY_FIXED_NRZ_1fps      (-55536)       // fixed delay cause by 50MHz conversion clock
#define CT650_TKDLY_FIXED_NRZ_10fps     (-11504)
#define CT650_TKDLY_FIXED_NRZ_100fps    (-1616)

#define CT650_MARK_GAIN     0x4000      // 8000
#define CT650_SPACE_GAIN    0x1555      // 2AAA
#define CT650_SIG_OFFSET    0

#define CT650_ZCSC_DEF      2           // # of samples in AM zero detection default value

#define CT650_ZCSC_100      5           // # of samples in AM zero detection
#define CT650_ZCSC_1k       3           //
#define CT650_ZCSC_10k      2           //
#define CT650_ZCSC_100k     1           //


#define CT650_ADC_uS        4           // 4us per clock
#define CT650_ADC_PIPELN    5           // pipeline depth

#define CT650_ZAV_DEF_MAX    8           // maximum number of samples in average for ADC data (256)
#define CT650_ZAV_DEF1000    7           // default number of samples in average for ADC data
#define CT650_ZAV_DEF100     5           //
#define CT650_ZAV_DEF10      3           //
#define CT650_ZAV_DEF1       1           //



// Reports various high-level status information
#define CT650_STS_CHAR_ERR       (1L<<22)    // TD : =1 if modulated signal is invalid (does not match any character)
#define CT650_STS_TREG_RDY       (1L<<21)    // TD : =1 when time registers update is complete
#define CT650_STS_FMT_ERR        (1L<<20)    // TA : Error in formatting routine (wrong command/register ID)
#define CT650_STS_PPX_ERR        (1L<<19)    // TA : "ppx_in" received when output was still in process
#define CT650_STS_B2B_ERR        (1L<<18)    // TK : =1 if BCB2BIN or BIN2BCB conversion error
#define CT650_STS_TIME_ERR       (1L<<17)    // TK : =1 if time code mismatch detected
#define CT650_STS_PPS_ERR        (1L<<16)    // TK : =1 if last detected 1PPS was invalid

#define CT650_STS_TTL_IN(N)      ((N&0xF8)>>3)// Helper macros for read state of TTL inputs
#define CT650_STS_TTLIN4         (1L<<7)      // Current state of TTL4 input
#define CT650_STS_TTLIN3         (1L<<6)      // Current state of TTL3 input
#define CT650_STS_TTLIN2         (1L<<5)      // Current state of TTL2 input
#define CT650_STS_TTLIN1         (1L<<4)      // Current state of TTL1 input
#define CT650_STS_TTLIN0         (1L<<3)      // Current state of TTL0 input
#define CT650_STS_CAL_AVAIL      (1L<<2)     // CAL650 :  =1 - calibration counter data is ready
#define CT650_STS_AZU            (1L<<1)     // AM2NRZ : =1 if autozero is in use (enabled and valid)
#define CT650_STS_MII_VAL        (1L<<0)     // MII2NRZ : =1 if clock of Manchester code was properly detected
// Timekeeper status bits
#define CT650_TKSTS_BIN2BCD_ERR   (1L<<13) // sticky, =1 if binary time code is invalid (logic error)
#define CT650_TKSTS_BCD2BIN_ERR   (1L<<12) // sticky, =1 if BCD time code is invalid (serial stream error)
#define CT650_TKSTS_TK_ERR        (1L<<11) // sticky, =1 if time code received mismatch current time
#define CT650_TKSTS_1PPS_GEN      (1L<<10) // sticky, =1 if 1PPS was generated
#define CT650_TKSTS_1PPS_RCV      (1L<<9)  // sticky, =1 if selected 1PPS was received
#define CT650_TKSTS_TC_RCV        (1L<<8)  // sticky, =1 if external time code was received and applied

#define CT650_TKSTS_1PPS_ADVAL    (1L<<3)  // =1 if 1ppS output of adaptive PLL in TK is valid
#define CT650_TKSTS_PPS_LOST      (1L<<2)  // =1 1ppS was not detected within last validation interval
#define CT650_TKSTS_AVG_INVAL     (1L<<1)  // =1 if averaged 1ppS does not pass validation criteria
#define CT650_TKSTS_1PPS_INVAL    (1L<<0)  // =1 if last detected external 1ppS was invalid

#define CT650_TKSTS_STICKY        (CT650_TKSTS_BIN2BCD_ERR|CT650_TKSTS_BCD2BIN_ERR|CT650_TKSTS_TK_ERR|CT650_TKSTS_1PPS_GEN|CT650_TKSTS_1PPS_RCV|CT650_TKSTS_TC_RCV)

//    CT650_ZCCFG        =    16'h2080,    // R/W    Zero crossing configuration register
// AM zero crossing configuration - should be set in order to properly detect AM carrier
#define CT650_ZCCFG_ZAV(N)  (((N)&0xf)<<28)  // number of samples in average for ADC data


#define CT650_ZCCFG_ZCAZ    (1L<<25)        // =1-use "auto zero" if it auto-calculated zero level is within
                                            // of the 1/8 of "zero_level" (ZCL_Dx)
#define CT650_ZCCFG_ZCZD    (1L<<24)        // Select direction of the crossing for min/max detection (1=rising)
//#define CT650_ZCCFG_ZCAS3    =    23,      // # of samples in min/max (span) averaging
#define CT650_ZCCFG_ZCAS(N) (((N)&0xf)<<20)  // 0=1, 1=2, 2=4, 3=8, 4=16, 5=32, 6=64, 7=128, 8=256
//#define CT650_ZCCFG_ZCSC3    =    19,      // # of samples in AM zero detection
#define CT650_ZCCFG_ZCSC(N) (((N)&0xf)<<16)  // 0=1, 1=2, 2=4, 3=8, 4=16, 5=32, 6=64, 7=128, 8=256,
                                             // should be accounted for when calculating internal delays
//    CT650_ZCCFG_ZCL_D15    =    15,        // Zero crossing level, normally should
#define CT650_ZCCFG_ZCL_D(N)    (((N)&0xffff)<<0)        // be set to 0x8000 (midscale)

//    CT650_OUT_TTLCFG=    16'h20A0,    // W    TTL Output configuration register
// CT650 has 4 programmable TTL outputs, each can be driven by one of 32 available sources
#define CT650_OUT_TTL3_40nS     (1L<<31)    // If any of these bits is set - corresponding TTL output pulse
#define CT650_OUT_TTL2_40nS     (1L<<30)    // will NOT be extended to at least 60uS, any pulse longer than 60uS
#define CT650_OUT_TTL1_40nS     (1L<<29)    // will not be extended
#define CT650_OUT_TTL0_40nS     (1L<<28)    //
#define CT650_OUT_TTL_40nS      (0xf<<28)   // all pulses are 60 us length


#define CT650_OUT_DBG       (1L<<25)        // switch TTL outputs to debug mode
#define CT650_OUT_RF1TERM   (1L<<24)        // =1 - Enable 50 Ohm termination for the TTL RF1 (TRIGIN) input
#define CT650_OUT_RF0TERM   (1L<<23)        // =1 - Enable 50 Ohm termination for the TTL RF0 (CLKIN) input
#define CT650_OUT_AMTERM    (1L<<22)        // =1 - Enable 50 Ohm termination for the AM input
#define CT650_OUT_TTLEN1    (1L<<21)        // =1 - Enable buffer 1 (bits 3-0)
#define CT650_OUT_TTLEN0    (1L<<20)        // =1 - Enable buffer 0 (bits 3-0)

#define CT650_OUT_SYNCEN3   (1L<<27)        // =1 - Enable SYNC3 buffer
#define CT650_OUT_SYNCEN2   (1L<<26)        // =1 - Enable SYNC2 buffer
#define CT650_OUT_SYNCEN1   (1L<<25)        // =1 - Enable SYNC1 buffer
#define CT650_OUT_SYNCEN0   (1L<<24)        // =1 - Enable SYNC0 buffer


// CT650 has 4 programmable TTL outputs, each can be driven by one of 32 available sources
// Also very similar format is used for the SYNC interface routing in the CT-650.
// SYNC notes:
// 1. Following four standard SYNC sources are re-assigned for the CT-650 (in CLI_ESCFG):
//       0001 - Instead of CLI_CLCLK - TTL0 source selected in CT650_SYNCCFG
//       0010 - Instead of CLI_CVCLK - TTL1 source selected in CT650_SYNCCFG
//       0011 - Instead of CLO_CLCLK - TTL2 source selected in CT650_SYNCCFG
//       0100 - Instead of CLO_CVCLK - TTL3 source selected in CT650_SYNCCFG
// 2. "Debug" sources can be enabled individually for each SYNC TTL line
#define CT650_SYNC_DBG3     (1L<<23)        // =1 - switch selected combinations of the TTL outputs into the
#define CT650_SYNC_DBG2     (1L<<22)        //  "debug" mode for the corresponding SYNC output
#define CT650_SYNC_DBG1     (1L<<21)        //
#define CT650_SYNC_DBG0     (1L<<20)        //
// 3. Following bits are reserved
//  27:24

#define CT650_OUT_CFG_AM_NRZ      31    // AM->NRZ output
#define CT650_OUT_CFG_GPS_FIXV    30    // GPS Fix Valid output
#define CT650_OUT_CFG_GPS_ANSH    29    // GPS Antenna Shorted output
#define CT650_OUT_CFG_GPS_ANOK    28    // GPS Antenna Ok output
#define CT650_OUT_CFG_GPS_TXD1    27    // GPS TXD1 (COM1) output
#define CT650_OUT_CFG_GPS_TXD0    26    // GPS TXD0 (COM0) output
#define CT650_OUT_CFG_SRC_1US     25    // 0.000001sec pulse
#define CT650_OUT_CFG_MII_NRZ     24    // Reserved for decoded Manchester II -> NRZ sequence
#define CT650_OUT_CFG_EVENT3      23    // Event 3
#define CT650_OUT_CFG_EVENT2      22    // Event 2
#define CT650_OUT_CFG_EVENT1      21    // Event 1
#define CT650_OUT_CFG_EVENT0      20    // Event 0
#define CT650_OUT_CFG_SRC_SYNC3   19    // Drive output from sync[3]
#define CT650_OUT_CFG_SRC_SYNC2   18    // Drive output from sync[2]
#define CT650_OUT_CFG_SRC_SYNC1   17    // Drive output from sync[1]
#define CT650_OUT_CFG_SRC_SYNC0   16    // Drive output from sync[0]
#define CT650_OUT_CFG_CR_OUT      15    // Output carrier frequency
#define CT650_OUT_CFG_SRC_CR      14    // Custom frequency output (from PLL)
#define CT650_OUT_CFG_SRC_10MHZ   13    // Precision 10MHz
#define CT650_OUT_CFG_SRC_5MHZ    12    // Precision 5MHz
#define CT650_OUT_CFG_SRC_1MHZ    11    // Precision 1MHz
#define CT650_OUT_CFG_SRC_NRZS    10    // Output NRZ start strobe
#define CT650_OUT_CFG_SRC_MII      9    // Manchester II output time code
#define CT650_OUT_CFG_SRC_NRZ      8    // NRZ output time code
#define CT650_OUT_CFG_SRC_1GPS     7    // Re-route GPS 1PPS pulse
#define CT650_OUT_CFG_SRC_1PPH     6    // 1PPH pulse
#define CT650_OUT_CFG_SRC_1PPM     5    // 1PPM pulse
#define CT650_OUT_CFG_SRC_1PPS     4    // 1PPS pulse
#define CT650_OUT_CFG_SRC_0_1S     3    // 0.1sec pulse
#define CT650_OUT_CFG_SRC_0_01S    2    // 0.01sec pulse
#define CT650_OUT_CFG_SRC_1        1    // Drive output with 1
#define CT650_OUT_CFG_SRC_0        0    // Drive output with 0


// TTL output assingments for debugging
#define CT650_OUT_CFG_TD_PPX      30    // Detected 1PPx from the time decoder
#define CT650_OUT_CFG_TD_RDY      29    // Time decoder validation complete
#define CT650_OUT_CFG_TD_1PPSD    28    // TK: internal delayed 1PPS strobe (i.e. 1pps applied delay)
                                        // DELAY = TKPERIOD - TKDLY - (w_tkcfg_pdc ? in_dly : 0)
#define CT650_OUT_CFG_TA_CR       27    // Carrier clock for time assembler

#define CT650_OUT_CFG_FW_RLD      26    // TK: =1 if flywheel counter should be reloaded (r_flywheel_reload)
#define CT650_OUT_CFG_FW_RST      25    // TK: =1 if flywheel counter (and 1ppS delay) should be cleared (r_flywheel_reset)
#define CT650_OUT_CFG_FW_DONE     24    // TK: Flywheel counter expired or early 1ppS (r_fw_cnt_done)
#define CT650_OUT_CFG_FW_EXP      23    // TK: =1 if flywheel counter expired and reloaded by itself
#define CT650_OUT_CFG_TD_CR       22    // TD: Carrier pulses (start of each pulse indicate start of the carrier period)
#define CT650_OUT_CFG_TT_RDY      21    // TTL2TIME: Character ready pulse
#define CT650_OUT_CFG_TA_IDLE     20    // TA: Idle state of the TTL NRZ output state machine
#define CT650_OUT_CFG_TA_RESTART  19    // TA: Restart request by delayed external PPx generated by the time keeper


// Read bits description (bits 2:0 represent current state of the configuration bits):
// These bits are ruturned as gsp_status in DqAdv650GetGPSStatus()

#define CT650_GPS_ACC_GPSANTSHRT (1L<<9)    // Use DQ_CT650_ACC_GPS_HW_ constants
#define CT650_GPS_ACC_GPSANTOK   (1L<<8)    // Use DQ_CT650_ACC_GPS_HW_ constants
#define CT650_GPS_ACC_GPSRXD1    (1L<<7)    // Current value of GPS RXD1 pin
#define CT650_GPS_ACC_GPSTXD1    (1L<<6)    // Current value of GPS TXD1 pin
#define CT650_GPS_ACC_GPSRXD0    (1L<<5)    // Current value of GPS RXD0 pin
#define CT650_GPS_ACC_GPSTXD0    (1L<<4)    // Current value of GPS TXD0 pin
#define CT650_GPS_ACC_GPSFIXV    (1L<<3)    // Fix valid output from GPS. Carries 0.5Hz square wave
                                            // when GPS fixes it's position (Rev1/2 only)

#define DQ_CT650_ACC_GPS_HW_ANT_MASK    (3L<<8)  // Mask for antenna status bits from GPS hardware block
#define DQ_CT650_ACC_GPS_HW_ANTSHORTED  (0L<<8)  // Antenna is shorted, or high current draw (>30mA)
#define DQ_CT650_ACC_GPS_HW_ANTINVALID  (1L<<8)  // Reserved
#define DQ_CT650_ACC_GPS_HW_ANTPASVOPN  (2L<<8)  // Antenna is passive, or circuit is open
#define DQ_CT650_ACC_GPS_HW_ANTACTIVE   (3L<<8)  // Antenna is active, or current between 10mA-30mA

// Additional (soft bits)
#define CT650_GPS_ACC_GPSAPPLIED (1L<<18)   // Time is set to GPS time
#define CT650_GPS_ACC_SATNUM     (1L<<17)   // number of satellites tracked
#define CT650_GPS_ACC_ACTIVE     (1L<<16)   // GPRMC is valid; GPS datettime is valid & tracking is active

// Calibration GPS identifier
#define CT650_GPS_CHIP_ID_1     0x100
#define CT650_GPS_CHIP_ID_2     0x200
#define CT650_GPS_CHIP_ID_3     0x300
#define CT650_CHIP_ID_VALID(N)      ((N == CT650_GPS_CHIP_ID_1) || (N == CT650_GPS_CHIP_ID_2) || (N == CT650_GPS_CHIP_ID_3))
#define CT650_FLAGVER_VALID(EV,FV)  ((EV == DQ_CT650_EECFG_FORMAT_VER) && CT650_CHIP_ID_VALID(FV))

#define CT650_TDSTS_VAL_CNT(N)  (((N)&0x7f00)>>8)   // validation state machine

#define CT650_TDSTS_MSG_ID      (1L<<7)    // Currently active (in reception) message
//#define CT650_TDSTS_MSG_CNT6    =    6,    // Message character counter - within
#define CT650_TDSTS_MSG_CNT(N)    (((N)&0x7f)>>0)    // message reception state machine
#define CT650_SWG_STS_NUM(N)   (((N)&0x1fff0000)>>16)
//#define CT650_SWG_STS_IDX12    =    12,        // Current index within waveform memory
#define CT650_SWG_STS_IDX(N)   (((N)&0x1fff)>>0)
#define CT650_IR_PPS_IRQ   (1L<<12)   // Dedicated interrupt for 1 PPS clock
#define CT650_IR_B2B_ERR   (1L<<11)   // Time keeper reports BCB2BIN or BIN2BCB conversion error - invalid BCD time code received
#define CT650_IR_TIME_ERR  (1L<<10)   // Time code received did not match time of the time keeper (normal during initial synchronization to IRIG signal)
#define CT650_IR_PPS_ERR   (1L<<9)    // Time keeper reports that PPS interval did not pass validation
#define CT650_IR_FMT_ERR   (1L<<8)    // Error in time assembler formatting routine
#define CT650_IR_PPX_ERR   (1L<<7)    // "ppx_in" received by time assembler when output was still in process
#define CT650_IR_TREG_RDY  (1L<<6)    // =1 when time registers update is complete (time information is decoded and ready)
#define CT650_IR_UART_TX   (1L<<5)    // GPS STX FIFO IRQ
#define CT650_IR_UART_RX   (1L<<4)    // GPS SRX FIFO IRQ/Pattern detected IRQ
#define CT650_IR_EVT3      (1L<<3)    // IRQ from the event 3
#define CT650_IR_EVT2      (1L<<2)    // IRQ from the event 2
#define CT650_IR_EVT1      (1L<<1)    // IRQ from the event 1
#define CT650_IR_EVT0      (1L<<0)    // IRQ from the event 0

#define CT650_IR_EVT_ALL   (CT650_IR_EVT0|CT650_IR_EVT1|CT650_IR_EVT2|CT650_IR_EVT3)    // all events
#define CT650_IR_ERR_ALL   (CT650_IR_B2B_ERR|CT650_IR_TIME_ERR|CT650_IR_PPS_ERR|CT650_IR_FMT_ERR|CT650_IR_PPX_ERR)
#define CT650_EVT_CFG_EN          EVTMOD_CFG_EN       // Enable event. Once enabled event can be triggered
                                                      // by the event source; if STE bit is set event should be
                                                      // pre-armed by the global start trigger; note that stop
                                                      // trigger that follows start trigger can disarm event
                                                      // if EVT_CFG_SPTE bit is set
                                                      // Single (RPT=0) event will auto-clear this bit upon
                                                      // finishing generating event pulse(es)
#define CT650_EVT_CFG_RSV30       EVTMOD_CFG_RSV30    // Reserved
#define CT650_EVT_CFG_RSV29       EVTMOD_CFG_RSV29    // Reserved
#define CT650_EVT_CFG_SPTE        EVTMOD_CFG_SPTE     // Use global (layer) stop trigger to "disarm" event
#define CT650_EVT_CFG_EV1IRQ      EVTMOD_CFG_EV1IRQ   // Generate IRQ based on sub-event 1
#define CT650_EVT_CFG_EV0IRQ      EVTMOD_CFG_EV0IRQ   // Generate IRQ based on sub-event 0
#define CT650_EVT_CFG_DBL         EVTMOD_CFG_DBL      // Number of sub-events) 0-single) 1-dual
#define CT650_EVT_CFG_RPT         EVTMOD_CFG_RPT      // Set repeat mode (0-one-time) 1-retriggerable)
#define CT650_EVT_CFG_EVTPLE      EVTMOD_CFG_EVTPLE   // Specify event pulse length (set to 0 or 1 for events
#define CT650_EVT_CFG_EVTPLS      EVTMOD_CFG_EVTPLS   // that generate interrupts and nothing else)
#define CT650_EVT_CFG_ISRCE       EVTMOD_CFG_ISRCE    // Specify clock source for the event period counter
#define CT650_EVT_CFG_ISRCS       EVTMOD_CFG_ISRCS    // 00-layer's 66/100MHz) 10-1MHz) 11-1KHz
#define CT650_EVT_CFG_STTE        EVTMOD_CFG_STTE     // Use global (layer) start trigger to "arm" event
#define CT650_EVT_CFG_IRSRCE      EVTMOD_CFG_IRSRCE   // Reset source for the internal event period counter
#define CT650_EVT_CFG_IRSRCS      EVTMOD_CFG_IRSRCS   // same codes as for ESRCx field
#define CT650_EVT_CFG_YM          EVTMOD_CFG_YM       // For date/time events - enable year compare
#define CT650_EVT_CFG_DM          EVTMOD_CFG_DM       // For date/time events - enable day compare
#define CT650_EVT_CFG_HM          EVTMOD_CFG_HM       // For date/time events - enable hour compare
                                                      // Note - bit 8 may be used differently depending on the event source
#define CT650_EVT_CFG_MM          EVTMOD_CFG_MM       // For date/time events - enable minute compare
#define CT650_EVT_CFG_ISRCM       EVTMOD_CFG_ISRCM    // For internal counter event - modifier for ISRCE:ISRCS
#define CT650_EVT_CFG_SM          EVTMOD_CFG_SM       // For date/time events - enable second compare
#define CT650_EVT_CFG_UM          EVTMOD_CFG_UM       // For date/time events - enable microsecond compare
#define CT650_EVT_CFG_EDGE        EVTMOD_CFG_EDGE     // Specify active edge of the event source (8-31)
#define CT650_EVT_CFG_ESRCE       EVTMOD_CFG_ESRCE    // Event source (specify type of the event)
#define CT650_EVT_CFG_ESRCS       EVTMOD_CFG_ESRCS    // events 8-31 are edge-triggered


    // Clock source for the internal counter, used in EVT_CFG_ESRC_IPC mode
    // values for EVT_CFG_ISRCE:EVT_CFG_ISRCS When EVT_CFG_ISRCM = 0
//#define CT650_EVT_CFG_ISRC_1KHZ       2'b11,  // 1KHz always derived from layer's local clock
//#define CT650_EVT_CFG_ISRC_1MHZ       2'b10,  // 1MHz always derived from layer's local clock
//#define CT650_EVT_CFG_ISRC_100I       2'b00,  // Layer locally generated 100MHz clock, on the layers
                                    // where local clock is not present - same as DNA bus 66MHz

    // values for EVT_CFG_ISRCE:EVT_CFG_ISRCS When EVT_CFG_ISRCM = 1
//#define CT650_EVT_CFG_ISRC_CLKIN      2'b10   // "clkin" pin (CT-602 only)
//#define CT650_EVT_CFG_ISRC_1MHZE      2'b10   // 1MHz from time keeper (IRIG-650 only)
//#define CT650_EVT_CFG_ISRC_PLL        2'b00   // PLL post-divider output (IRIG-650), PLL output (CT-602)

// Event pulse length is measured in layer local clocks and for the codes
// 0-13 corresponds to 1-14 clocks, with two special cases listed below (1uS and 1mS)
#define CT650_EVT_CFG_EVTPL_1MS    EVTMOD_CFG_EVTPL_1MS      // Use 1mS event pulse length
#define CT650_EVT_CFG_EVTPL_1US    EVTMOD_CFG_EVTPL_1US      // Reserved for 1uS event pulse length
#define CT650_EVT_CFG_EVTPL(N)     EVTMOD_CFG_EVTPL(N)  // Reserved for 2^{2..13}*10nsec event pulse length

// Clock source for the internal counter, used in #define CT650_EVT_CFG_ESRC_IPC mode
#define CT650_EVT_CFG_ISRC_1KHZ    EVTMOD_CFG_ISRC_1KHZ    // 1KHz always derived from layer's local clock
#define CT650_EVT_CFG_ISRC_1MHZ    EVTMOD_CFG_ISRC_1MHZ    // 1MHz always derived from layer's local clock
#define CT650_EVT_CFG_ISRC_100I    EVTMOD_CFG_ISRC_100I    // Layer locally generated 100MHz clock, on the layers
                                              // where local clock is not present - same as DNA bus 66MHz

// Event sources and internal counter reset sources
#define CT650_EVT_CFG_ESRC_DEVT23  EVTMOD_CFG_ESRC_DEVT23    // Digital event source 23
//..
#define CT650_EVT_CFG_ESRC_DEVT0   EVTMOD_CFG_ESRC_DEVT0   // Digital event source 0
#define CT650_EVT_CFG_ESRC_RES7    EVTMOD_CFG_ESRC_RES7    // Reserved
#define CT650_EVT_CFG_ESRC_DPLL    EVTMOD_CFG_ESRC_DPLL    // DPLL - Digital PLL
#define CT650_EVT_CFG_ESRC_DNAB    EVTMOD_CFG_ESRC_DNAB    // DNA bus condition
#define CT650_EVT_CFG_ESRC_IPC     EVTMOD_CFG_ESRC_IPC     // Internal period counter
#define CT650_EVT_CFG_ESRC_SBT     EVTMOD_CFG_ESRC_SBT     // BCD time mode, event condition is
                                                           // "Straight Binary Input time" >= "SB set time"
                                                           // BCD time mode allows creation of the events
                                                           // that will repeat every month, day, minute or
                                                           // second - by masking unused parameters in CFG0
                                                           // register
#define CT650_EVT_CFG_ESRC_BCDT    EVTMOD_CFG_ESRC_BCDT    // BCD time mode, event condition is
                                                           // "BCD Input time" >= "BCD set time"
                                                           // NOTE:
                                                           // #define CT650_EVT_CFG_ESRC_DNAB,  #define CT650_EVT_CFG_ESRC_IPC
                                                           // #define CT650_EVT_CFG_ESRC_SBT and #define CT650_EVT_CFG_ESRC_BCDT
                                                           // are mutually exclusive in ESRC/IRSRC fields
#define CT650_EVT_CFG_ESRC_SWF     EVTMOD_CFG_ESRC_SWF     // Software only, note that event sources
                                                           // 2-31 are ORed with software.
                                                           // For the ESRC field software clock is read
                                                           // from EVT_EMP1 register.
                                                           // For the IRSRC field software clock is read
                                                           // from EVT_EMP0 register.
#define CT650_EVT_CFG_ESRC_DIS     EVTMOD_CFG_ESRC_DIS     // No active source - event is in disabled state

// Internal counter reset sources
#define CT650_EVT_CFG_ICRS_DEVT23  EVTMOD_CFG_ICRS_DEVT23  // Digital event source 23
//..
#define CT650_EVT_CFG_ICRS_DEVT0   EVTMOD_CFG_ICRS_DEVT0   // Digital event source 0
#define CT650_EVT_CFG_ICRS_RES7    EVTMOD_CFG_ICRS_RES7    // Reserved
#define CT650_EVT_CFG_ICRS_RES6    EVTMOD_CFG_ICRS_RES6    // Reserved
#define CT650_EVT_CFG_ICRS_DNAB    EVTMOD_CFG_ICRS_DNAB    // DNA bus condition
#define CT650_EVT_CFG_ICRS_IPC     EVTMOD_CFG_ICRS_IPC     // Internal period counter
#define CT650_EVT_CFG_ICRS_SBT     EVTMOD_CFG_ICRS_SBT     // BCD time mode, event condition is
                                                           // "Straight Binary Input time" >= "SB set time"
                                                           // BCD time mode allows creation of the events
                                                           // that will repeat every month, day, minute or
                                                           // second - by masking unused parameters in CFG0
                                                           // register
#define CT650_EVT_CFG_ICRS_BCDT    EVTMOD_CFG_ICRS_BCDT    // BCD time mode, event condition is
                                                           // "BCD Input time" >= "BCD set time"
                                                           // NOTE:
                                                           // #define CT650_EVT_CFG_ICRS_DNAB,  #define CT650_EVT_CFG_ICRS_IPC
                                                           // #define CT650_EVT_CFG_ICRS_SBT and #define CT650_EVT_CFG_ICRS_BCDT
                                                           // are mutually exclusive in ESRC/IRSRC fields
#define CT650_EVT_CFG_ICRS_SWF     EVTMOD_CFG_ICRS_SWF     // Software only, note that event sources
                                                           // 2-31 are ORed with software.
                                                           // For the ESRC field software clock is read
                                                           // from EVT_EMP1 register.
                                                           // For the IRSRC field software clock is read
                                                           // from EVT_EMP0 register.
#define CT650_EVT_CFG_ICRS_DIS     EVTMOD_CFG_ICRS_DIS     // No active source - event is in disabled state

// Digital events defined as follows (IRIG-650 specific):
#define CT650_EVT_SEVT00      8   // Event 0/ Subevent 0 (start event)
#define CT650_EVT_SEVT01      9   // Event 0/ Subevent 1 (stop event)
#define CT650_EVT_SEVT10     10   // Event 1/ Subevent 0 (start event)
#define CT650_EVT_SEVT11     11   // Event 1/ Subevent 1 (stop event)
#define CT650_EVT_SEVT20     12   // Event 2/ Subevent 0 (start event)
#define CT650_EVT_SEVT21     13   // Event 2/ Subevent 1 (stop event)
#define CT650_EVT_SEVT30     14   // Event 3/ Subevent 0 (start event)
#define CT650_EVT_SEVT31     15   // Event 3/ Subevent 1 (stop event)
#define CT650_EVT_SYNC0      16   // SYNC bus line 0
#define CT650_EVT_SYNC1      17   // SYNC bus line 1
#define CT650_EVT_SYNC2      18   // SYNC bus line 2
#define CT650_EVT_SYNC3      19   // SYNC bus line 3
#define CT650_EVT_PPS        20   // PPS pulse
#define CT650_EVT_EXTT       21   // External time received and applied
#define CT650_EVT_EINV       22   // External sync lost
#define CT650_EVT_TTL0       23   // External TTL input 0
#define CT650_EVT_TTL1       24   // External TTL input 1
#define CT650_EVT_TTL2       25   // External TTL input 2
#define CT650_EVT_TTL3       26   // External TTL input 3
#define CT650_EVT_TTL4       27   // External TTL input 4


//    EVT_EMP0    =    16'h04,        // W    Event mode parameters register 0
//                                // R    Software reset for period counter
// This register is used to set one of the following:
// - when ESRC=EVT_CFG_ESRC_DNAB - DNA bus address and additional trigger parameters
// - when ESRC=EVT_CFG_ESRC_IPC - event period counter (divider that selects event period)
// - when ESRC=EVT_CFG_ESRC_SBT - straight binary seconds and years
// - when ESRC=EVT_CFG_ESRC_BCDT - BCD seconds, minutes, hours and day of the year
//#define CT650_EVT_EMP0_LSAE        =    31,        // Layer select address portion(dna_addr[19:16]) when
#define CT650_EVT_EMP0_LSAS(N)     EVTMOD_EMP0_LSAS(N)   // monitored address/data combination
#define CT650_EVT_EMP0_DRD         EVTMOD_EMP0_DRD   // =1 - monitor /rd (reads) on the DNA bus
#define CT650_EVT_EMP0_DWR         EVTMOD_EMP0_DWR   // =1 - monitor /wr (writes) on the DNA bus
//#define CT650_EVT_EMP0_DCSE        =    25,        // DNA chip select line (0-3) that should be associated
#define CT650_EVT_EMP0_DCSS(N)     EVTMOD_EMP0_DCSS(N)  // with monitored address/data combination
//#define CT650_EVT_EMP0_DDLYE        =    23,       // Number of clocks after /rd or /wr strobe start to
#define CT650_EVT_EMP0_DDLYS(N)    EVTMOD_EMP0_DDLYS(N)   // comparing address and data (0-15)
//#define CT650_EVT_EMP0_DNAAVE        =    19,      // Number of valid MSBs in the DNAA field. 1-14 - select#
#define CT650_EVT_EMP0_DNAAVS(N)   EVTMOD_EMP0_DNAAVS(N)   // of bits, 0 - ignore DNA address and compare data only
//#define CT650_EVT_EMP0_DNAAE        =    15,       // bits [15:2] of the DNA bus address that covers address
#define CT650_EVT_EMP0_DNAAS(N)    EVTMOD_EMP0_DNAAS(N) // space of every individual layer
#define CT650_EVT_EMP0_DLAC        EVTMOD_EMP0_DLAC  // Use layer address portion (dna_addr[19:16]) when
                                                     // comparing DNA/DNR address, available only on the
                                                     // DNA versions of the layers with event capability except
                                                     // for the CPU where it is always available
#define CT650_EVT_EMP0_DDC         EVTMOD_EMP0_DDC   // 1-compare DNA data. If DNA data is compare feature is
                                                     // used, data should be pre-loaded into #define CT650_EVT_EMP1 and layer
                                                     // timestamp of the event will be stored in #define CT650_EVT_SDNADC

//#define CT650_EVT_EMP0_SBSE         28,        // Straight binary seconds of the day (0x0h to 0x15180h)
#define CT650_EVT_EMP0_SBSS(N)     EVTMOD_EMP0_SBSS(N)     //
//#define CT650_EVT_EMP0_SBYE         11,        // Straight binary year
#define CT650_EVT_EMP0_SBYS(N)     EVTMOD_EMP0_SBYS(N)     //
//
//#define CT650_EVT_EMP0_SECE         27,        // BCD seconds of the day
#define CT650_EVT_EMP0_SECS(N)     EVTMOD_EMP0_SECS(N)
//#define CT650_EVT_EMP0_MINE         21,        // BCD minute of the hour
#define CT650_EVT_EMP0_MINS(N)     EVTMOD_EMP0_MINS(N)     //
//#define CT650_EVT_EMP0_HRE         15,         // BCD hour of the day
#define CT650_EVT_EMP0_HRS(N)      EVTMOD_EMP0_HRS(N)     //
//#define CT650_EVT_EMP0_DOYE         9,         // BCD day of the year
#define CT650_EVT_EMP0_DOYS(N)     EVTMOD_EMP0_DOYS(N)     //
//
//#define CT650_EVT_EMP0_ICNTDIVE    =    31,        // 32-bit counter, reset source is selected in
#define CT650_EVT_EMP0_ICNTDIVS(N)  (N)        // #define CT650_EVT_CFG_IRSRC, clock source - in #define CT650_EVT_CFG_ISRC

//    #define CT650_EVT_EMP1    =    16'h08,        // W    Event mode parameters register 1; R    Software event source
// This register is used to set one of the following:
// - when ESRC=#define CT650_EVT_CFG_ESRC_DNAB - DNA bus data
// - when ESRC=#define CT650_EVT_CFG_ESRC_SBT - straight binary day of the year (and SB microseconds)
// - when ESRC=#define CT650_EVT_CFG_ESRC_BCDT - microseconds
//#define CT650_EVT_EMP1_SBDE        =    30,       // Straight binary day of the year
#define CT650_EVT_EMP1_SBDS(N)  EVTMOD_EMP1_SBDS(N)   //
//#define CT650_EVT_EMP1_USE        =    19,        // Number of microseconds for the SB and BCD time mode
#define CT650_EVT_EMP1_USS(N)   EVTMOD_EMP1_USS(N)    //  (uS are always binary, 0-999999) that used in event generation
//
//#define CT650_EVT_EMP1_DNADE        =    31,        // 32-bit DNA data to compare with actual data on the
#define CT650_EVT_EMP1_DNADS(N)      (N)              // DNA bus (used only if #define CT650_EVT_EMP0_DDC=1)

//    #define CT650_EVT_DLY0    =    16'h0C,        // W    Subevent 0 time delay register
//    #define CT650_EVT_DLY1    =    16'h10,        // W    Subevent 1 time delay register
// Event source selected in the CFG_ESRC acts as a trigger that initiates DLY0/DLY1 counters,
// these counters provide programmable delay prior to the generating output pulse and/or
// interrupt. This behavior may be used to create sequence of events that are triggered by the
// same source but should be separated in time by the pre-defined intervals. Two sub-events are
// provided thus allowing more flexible handling of the timing. Putting 0 into these registers
// will result in the event pulse/interrupt delayed by 4-5 clocks from the time of the event
// source
//#define CT650_EVT_DLY_EVTDLE        =    31,        // Event delay
#define CT650_EVT_DLY_EVTDLS(N)      (N)        //

//    #define CT650_EVT_STS        =    16'h14,        // R    Event status register
// Event status register provide information about current condition of the event module
// including number of processed events
#define CT650_EVT_STS_SEARM        EVTMOD_STS_SEARM    // =1-if event is armed by the start trigger
#define CT650_EVT_STS_SEVT1        EVTMOD_STS_SEVT1    // =1-if subevent 1 counter is active
#define CT650_EVT_STS_SEVT0        EVTMOD_STS_SEVT0    // =1-if subevent 0 counter is active
#define CT650_EVT_STS_RSV28        EVTMOD_STS_RSV28    // Reserved
#define CT650_EVT_STS_RSV27        EVTMOD_STS_RSV27    // Reserved
#define CT650_EVT_STS_RSV26        EVTMOD_STS_RSV26    // Reserved
#define CT650_EVT_STS_SEVT1D       EVTMOD_STS_SEVT1D   // =1-if subevent 1 was issued
                                                       // (auto-cleared after read)
#define CT650_EVT_STS_SEVT0D       EVTMOD_STS_SEVT0D   // =1-if subevent 0 was issued
                                             // (auto-cleared after read)
//#define CT650_EVT_STS_ECTE         (1L<<23)  // Event counter. Counter is incremented when
#define CT650_EVT_STS_ECTS         EVTMOD_STS_ECTS     // event start condition is detected and cleared when event is disabled

//    #define CT650_EVT_SDNADC    =    16'h18,        // R    DNA data/timestamp capture register
// Data of the DNA transaction that does not require data compare (#define CT650_EVT_EMP1_DNADE=0)
// will be stored in this register. If data compare is enabled (#define CT650_EVT_EMP1_DNADE=1) this
// register will contain timestamp of the DNA transaction that triggered #define CT650_EVT_CFG_ESRC_DNAB
// event. For all other event sources this register is unused
//#define CT650_EVT_SDNADC_DE        =    31,        // 32-bit DNA data or layer timestamp
#define CT650_EVT_SDNADC_DS(N)       (N)        //

//    #define CT650_EVT_SDNAAC    =    16'h1C,        // R    DNA address capture register
// Address of the DNA transaction that triggered triggered #define CT650_EVT_CFG_ESRC_DNAB
// event. For all other event sources this register is unused
//#define CT650_EVT_SDNAAC_LACE        =    19,        // DNA layer address capture
#define CT650_EVT_SDNAAC_LACS(N)      EVTMOD_SDNAAC_LACS(N)  // read
//#define CT650_EVT_SDNAAC_ACE        =    15,         // DNA address capture
#define CT650_EVT_SDNAAC_ACS(N)       EVTMOD_SDNAAC_ACS(N)  // read

// Validation memory bit description
#define CT650_TREG_NUM      16        // 16 general purpose 16-bit time-code storage regiaters
#define CT650_TREG_WIDTH    16        //

// Validation memory bit description
//#define CT650_VAL_C2          (1L<<18)  // Validation/store command
#define CT650_VAL_CMD(N)        (((N)&7)<<16)  //
#define CT650_FMRT_CMD(N)        (((N)&7)<<16)  //
#define CT650_GET_VAL_CMD(N)    (((N)>>16)&7)  //

//#define CT650_VAL_B3          (1L<<11)  // These bits select bit# in the target register
#define CT650_VAL_BIT(N)        (((N)&0x1f)<<8)   // Registers are 17-bit wide
#define CT650_FMRT_BIT(N)       (((N)&0xf)<<8)    //
#define CT650_GET_VAL_BIT(N)    (((N)>>8)&0xf)    //

//#define CT650_VAL_R3          (1L<<3)   // These bits select one of the 16 available
#define CT650_VAL_REG(N)        (((N)&0xf))   // target registers
#define CT650_FMRT_REG(N)        (((N)&0xf))   //
#define CT650_GET_VAL_REG(N)    (((N)&0xf))   //


// Validation Commands
#define CT650_VAL_NOP       0  // 000 - NOP, go to the next character in the message
#define CT650_VAL_CPYT      1  // 001 - Copy timestamp to TREG[14],TREG[15]
#define CT650_VAL_CPYD      2  // 010 - Copy phase delay to TREG[12],TREG[13]
#define CT650_VAL_01        4  // 100 - "0" or "1" is expected, copy to target register
#define CT650_VAL_P         5  // 101 - Px marker is expected, do not copy
#define CT650_VAL_0         6  // 110 - "0" is expected
#define CT650_VAL_1         7  // 111 - "1" is expected


// Pre-defined registers
#define CT650_VAL_TREG0     0     //  Time register  0
#define CT650_VAL_TREG1     1     //  Time register  1
#define CT650_VAL_TREG2     2     //  Time register  2
#define CT650_VAL_TREG3     3     //  Time register  3
#define CT650_VAL_TREG4     4     //  Time register  4
#define CT650_VAL_TREG5     5     //  Time register  5
#define CT650_VAL_TREG6     6     //  Time register  6
#define CT650_VAL_TREG7     7     //  Time register  7
#define CT650_VAL_TREG8     8     //  Time register  8
#define CT650_VAL_TREG9     9     //  Time register  9
#define CT650_VAL_TREG10   10     //  Time register 10
#define CT650_VAL_TREG11   11     //  Time register 11

#define CT650_VAL_TREG12    12    // Time register 12    phase delay MSB
#define CT650_VAL_TREG13    13    // Time register 13    phase delay LSB
#define CT650_VAL_TREG14    14    // Time register 14    timestamp MSB
#define CT650_VAL_TREG15    15    // Time register 15    timestamp LSB

// Output message format memory bits description
#define CT650_FMT_C2        18       // Format command
#define CT650_FMT_C0        16       //
#define CT650_FMT_B4        12       // These bits select bit# in the source register,
#define CT650_FMT_B0        8        // source registers width varies
#define CT650_FMT_R3        3        // These bits select one of the available source
#define CT650_FMT_R0        0        // registers

#define CT650_FMT_CMD(N)   (((N)&0x7)<<CT650_FMT_C0)

#define CT650_FMT_NOP       0        // 000 - NOP, go to the next command in the message
#define CT650_FMT_REG       1        // 001 - Value of the output ("0" or "1") defined by source register
#define CT650_FMT_SPACE     4        // 100 - Output should be in idle condition
#define CT650_FMT_P         5        // 101 - Drive output with Position Px marker
#define CT650_FMT_0         6        // 110 - Drive output with "0" character
#define CT650_FMT_1         7        // 111 - Drive output with "1" character

#define CT650_FMT_R_DAY     0   // Use "BCD day" as a source register
                                // Valid values for the bit# in source : 9-0
#define CT650_FMT_R_HOUR    1   // Use "BCD hour" as a source register
                                // Valid values for the bit# in source : 5-0
#define CT650_FMT_R_MIN     2   // Use "BCD minutes" as a source register
                                // Valid values for the bit# in source : 6-0
#define CT650_FMT_R_SEC     3   // Use "BCD seconds" as a source register
                                // Valid values for the bit# in source : 6-0
#define CT650_FMT_R_SEC10   4   // Use "BCD 1/10 seconds" as a source register
                                // Valid values for the bit# in source : 3-0
#define CT650_FMT_R_SEC100  5   // Use "BCD seconds" as a source register
                                // Valid values for the bit# in source : 3-0
#define CT650_FMT_R_SBS     6   // Use "SBS seconds" as a source register
                                // Valid values for the bit# in source : 16-0
#define CT650_FMT_R_FLG     7   // Use CT650_TXMSG_LEN[31:16] as a source register
                                // Valid values for the bit# in source : 15-0

// Message memory bit description
#define CT650_MSG_D31       (1L<<31)   // MSB of the message descriptor
#define CT650_MSG_D16       (1L<<16)   // Bit 16
#define CT650_MSG_D15       (1L<<15)   // Bit 15
#define CT650_MSG_D0        (1L<<0)    // LSB of the message descriptor
#define CT650_MSG_C1        (1L<<1)    // Character code - see below:
#define CT650_MSG_C0        (1L<<0)    //

#define CT650_CHAR_TSTAMP(N)   ((N)>>CT650_CHAR_WIDTH)   // 10us timstamp

#define CT650_CHAR_WIDTH    2       // Number of bits identifying single character
#define CT650_CHAR_IDLE     0       // Decoded characters
#define CT650_CHAR_POS      1       // 01 - Position Identifier
#define CT650_CHAR_ZERO     2       // 10 - "0"
#define CT650_CHAR_ONE      3       // 11 - "1"

#pragma pack(1)

#define DQ_CT650_NAMELEN            32          // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_CT650_CHAN][DQ_CT650_NAMELEN];
} DQCNAMES_650_, *pDQCNAMES_650_;

typedef struct {
    uint32 conf;                    // control word (to feed to config_io)
    uint32 chop;                    // chopper divider value (2kHz, reserved)
    uint32 mask;                    // change-of-state mask
    uint32 clclk;                   // CL clock (divider)
    uint32 cvclk;                   // CV clock (divider)
    int clperint;                   // <reserved>
    uint32 trig;                    // trigger config
} DQOPMODEPRM_650_, *pDQOPMODEPRM_650_;

typedef struct {
    uint32 ttl_state;               // line states in init mode
    uint32 dac_adjust;              // 20MHz clock adjustment DAC settings
} DQINITPRM_650_, *pDQINITPRM_650_;

typedef struct {
    uint32 ttl_state;                     // line states in shutdown mode
} DQSDOWNPRM_650_, *pDQSDOWNPRM_650_;

#define DQ_CT650_EECFG_FORMAT_VER   0x6501  // EEPROM & CFG structure version

typedef struct {    // Space reserved in DEVEEPROM_650_ for future use
    uint8 res[DQ_EEMAXSIZE - sizeof(DQEECMNDEVS)-
              sizeof(DQOPMODEPRM_650_)- sizeof(DQINITPRM_650_)- sizeof(DQSDOWNPRM_650_)-
              sizeof(DQCNAMES_650_)- sizeof(DQPRMFLAGS)- sizeof(DQEEPROMTAIL)];
} DQEERSVD_650_;

// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS      ee;
    DQOPMODEPRM_650_ opmodeprm;
    DQINITPRM_650_   initprm;
    DQSDOWNPRM_650_  sdownprm;
    DQCNAMES_650_    cname;
    DQPRMFLAGS       eeflags;
    DQEERSVD_650_    reserved;      // do not read at init; reading slows down bootup
    DQEEPROMTAIL     eever_crc;     // contains DQ_CT650_EECFG_FORMAT_VER and CRC
} DEVEEPROM_650_, *pDEVEEPROM_650_;

#pragma pack()

#define DQ_CT_651_CHAN              (4)
#define DQ_CT_651_CHAN_MASK         (0x3)
#define DQ_CT_651_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_CT_651_BASE_66           (66000000)  // 66MHz DNx base frequency
#define DQ_CT_651_BASE_100          (100000000) // 100MHz CT-651 base frequency
#define DQ_CT_651_BASE_160          (160000000) // 160MHz CT-651 base frequency

// ----- Special bits in LCR register -----
// you can set these bits by using DqAdv651SetRegister() with reg = DQL_IOCTL651_SET_LCR
#define DQ_LCR651_RXT               (1L<<4)     // sets 50 ohm termination on the input signal
//use one of the following 2 defines to select base flywheel clock rate "clock_fw"
#define DQ_LCR651_CLK_160MHZ        (1L<<2)     // use 160MHz clock for timing
#define DQ_LCR651_CLK_100MHZ        (0L<<2)     // use 100MHz clock for timing

#define DQ_LCR651_LED               (1L<<1)     // Enable/disable STS LED driver (always ON)
#define DQ_LCR651_DCEN              (1L<<0)     // DC/DC converter enable, =1 to operate, RDY LED shows state

// ioctls - 'reg' parameter for DqAdv651SetRegister() DAQLib function
#define DQL_IOCTL651_SET_LCR        (1L)        // set LCR special bits
#define DQL_IOCTL651_SET_FWCFG      (3L)        // Output mode config register
#define DQL_IOCTL651_SET_DW         (4L)        // DAC Write register
#define DQL_IOCTL651_SET_FWDC       (5L)        // Flywheel duty cycle register
#define DQL_IOCTL651_SET_FWDIV      (6L)        // Output period Register
#define DQL_IOCTL651_SET_FWCLK_MIN  (7L)        // Flywheel clock divider auto-correction low limit, 32 bits
#define DQL_IOCTL651_SET_FWCLK_MAX  (8L)        // Flywheel clock divider auto-correction high limit, 32 bits

// ioctls - 'reg' parameter for DqAdv651GetRegister() DAQLib function
#define DQL_IOCTL651_GET_LCR        (1L)        // get LCR register
#define DQL_IOCTL651_GET_STS        (2L)        // General Status Register
#define DQL_IOCTL651_GET_FWCFG      (3L)        // Output mode config register
#define DQL_IOCTL651_GET_FWDC       (5L)        // Flywheel duty cycle register
#define DQL_IOCTL651_GET_FWDIV      (6L)        // Output period Register
#define DQL_IOCTL651_GET_FWCLK_MIN  (7L)        // Flywheel clock divider auto-correction low limit, 32 bits
#define DQL_IOCTL651_GET_FWCLK_MAX  (8L)        // Flywheel clock divider auto-correction high limit, 32 bits
#define DQL_IOCTL651_GET_FWCRH      (9L)        // Input clock "high" count in 100MHz or 160MHz clocks
#define DQL_IOCTL651_GET_FWCRP      (10L)       // Input clock period count in 100MHz or 160MHz clocks
#define DQL_IOCTL651_GET_FWCNT      (11L)       // Current value of the flywheel counter, debug only

// ----- CT651_STS General status register (GET only) -----
#define DQ_LCR651_STS_ICF           (1L<<2)     // =1 if input clock has failed validation, sticky,
                                                //    autocleared after each read
#define DQ_LCR651_DB                (1L<<1)     // =1 if DAC write is in progress
#define DQ_LCR651_STS_ICIV          (1L<<0)     // =1 if input clock is currently invalid

// ----- CT651_DW DAC write register (SET only) -----
// In many applications the user will not need to set the DAC outputs. The CT-651 layer driver code automatically
// sets the dac outputs to their default values at system start-up.

// dac command, use one of the following 6 defines
#define DQ_CT651_DW_C_LD_LDAC       (6L<<19)    // load LDAC
#define DQ_CT651_DW_C_RESET         (5L<<19)    // reset
#define DQ_CT651_DW_C_PWR_DN        (4L<<19)    // power-down DAC
#define DQ_CT651_DW_C_WR_UPD_CH     (3L<<19)    // write and update channel  <-- preferred value
#define DQ_CT651_DW_C_WRUPD_ALL     (2L<<19)    // write channel, update all
#define DQ_CT651_DW_C_UPD_CH        (1L<<19)    // Update channel

// dac data destination, use one of the following 5 defines
#define DQ_CT651_DW_A_ALLAOUTS      (7L<<16)
#define DQ_CT651_DW_A_AOUTD         (3L<<16)    // adjust 20MHz reference clock within +/-500ppb,
                                                //  set to midscale if adjustment is not needed.
#define DQ_CT651_DW_A_AOUTC         (2L<<16)    // hysteresis comparator high voltage
#define DQ_CT651_DW_A_AOUTB         (1L<<16)    // hysteresis comparator low voltage, threshold when hysteresis disabled
#define DQ_CT651_DW_A_AOUTA         (0L<<16)    // not used on CT-651

// dac data
#define DQ_CT651_DW_D_MSB           (1L<<15)    // 16-bit data to write to DAC
#define DQ_CT651_DW_D_LSB           (1L<<0)

#define DQ_CT651_DW_D_MIDSCALE      (0x8000)    // DAC midscale value for AOUTD
#define DQ_CT651_DW_D_HYST_DEF      (0x800)     // default value for hysteresis comparator, AOUTB and AOUTC

// ----- CT651_FWCFG Output mode configuration register (SET and GET) -----
// The mode configuration register consists of 4 control bits that affect all modes and four 4-bit mode settings,
// one for each of the 4 outputs.
#define DQ_CT651_FWCFG_EIH          (1L<<19)    // =1 - enable hysteresis on the input - use two outputs
                                                // from the input comparator to with following truth table:
                                                // 00    - "qualified" input = 0
                                                // 01/10 - do not change
                                                // 11    - "qualified" input = 1
                                                // If this mode is used - input clock is delayed by 1-2 100/160Mhz clock

#define DQ_CT651_FWCFG_ACRFW        (1L<<18)    // =1 Reset internal flywheel counter every valid rising edge of input
                                                // clock, this mode should be used in combination with following two bits
#define DQ_CT651_FWCFG_ACFWDC       (1L<<17)    // =1 -Auto correct FWDC (duty cycle) on every valid rising edge of the input clock
#define DQ_CT651_FWCFG_ACFWDIV      (1L<<16)    // =1 -Auto correct FWDIV (flywheel freq) on every valid rising edge of the input clock.
                                                // in auto-correct the FWCRP register determines the flywheel rate

#define DQ_CT651_FWCFG_CH3_M3       (1L<<15)    // mode for channel 3
#define DQ_CT651_FWCFG_CH3_M0       (1L<<12)    //
#define DQ_CT651_FWCFG_CH2_M3       (1L<<11)    // mode for channel 2
#define DQ_CT651_FWCFG_CH2_M0       (1L<<8)     //
#define DQ_CT651_FWCFG_CH1_M3       (1L<<7)     // mode for channel 1
#define DQ_CT651_FWCFG_CH1_M0       (1L<<4)     //
#define DQ_CT651_FWCFG_CH0_M3       (1L<<3)     // mode for channel 0
#define DQ_CT651_FWCFG_CH0_M0       (1L<<0)     //

#define DQ_CT651_FWCFG_CH0          (0)         // shift for ch0 mode
#define DQ_CT651_FWCFG_CH1          (4)         // shift for ch1 mode
#define DQ_CT651_FWCFG_CH2          (8)         // shift for ch2 mode
#define DQ_CT651_FWCFG_CH3          (12)        // shift for ch3 mode

// mode numbers for each of the 4 outputs. (DQ_CT651_FWCFG bits 0-3,4-7,8-11,12-15)
#define DQ_CT651_CH_M_DIS_BUF       (0)         // disable output buffer (~1K to GND) ( test mode )
#define DQ_CT651_CH_M_FOLLOW        (1)         // follow input, <10nS FPGA delay
#define DQ_CT651_CH_M_FLYWHEEL      (2)         // flywheel (output rate/duty cycle set by FWDIV/FWDC)
#define DQ_CT651_CH_M_AUTO_FOL      (3)         // auto-follow input (switch to flywheel if  input does not pass
                                                // validation set in FWCLK_MIN/ FWCLK_MAX, if input appears it will
                                                // be used again starting from the second valid input clock pulse,
                                                // this mode suffers 2-3 100/160MHz clocks delay)
#define DQ_CT651_CH_M_OUT_0         (4)         // keep output at 0 ( use this setting to disable an unused output )
#define DQ_CT651_CH_M_OUT_1         (5)         // keep output at 1 ( test mode ) this setting should not be used on
                                                // more than one channel at a time or for longer than 5 seconds
#define DQ_CT651_CH_M_FOL_DUTY      (6)         // follow input but duty cycle is set by the FWDC register
#define DQ_CT651_CH_M_AUTO_DUTY     (7)         // auto-follow input but duty cycle in both follow and flywheel states
                                                // is set by the FWDC register
#define DQ_CT651_CH_M_SYNC_0        (8)         // DNx bus SYNCx line 0 drives the output
#define DQ_CT651_CH_M_SYNC_1        (9)         // DNx bus SYNCx line 1 drives the output
#define DQ_CT651_CH_M_SYNC_2        (0xa)       // DNx bus SYNCx line 2 drives the output
#define DQ_CT651_CH_M_SYNC_3        (0xb)       // DNx bus SYNCx line 3 drives the output

#define DQ_CT651_CH_MODE_MASK       (0xf)       //

// ----- CT651_FWDC -  Flywheel duty cycle register, 32 bits (SET and GET) -----
// defines high time of outputs that are in modes 2, 3(flywheel state only),6 and 7.
//  e.g. set to 50000 for a 500 microsecond pulse with 100MHz clock
#define DQ_CT651_FWDC_D31           (1L<<31)    // Duty cycle in "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWDC_D0            (1L<<0)     // lsb

// ----- CT651_FWDIV - Flywheel period Register, 32 bits  (SET and GET) -----
// defines period of flywheel when DQ_CT651_FWCFG_ACFWDIV = 0.
// when using 100MHz clock, set this register to 100 Million for a 1Hz output
#define DQ_CT651_FWDIV_D31          (1L<<31)    // Period in "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWDIV_D0           (1L<<0)     // lsb

// ----- CT651_FWCLK_MIN - Flywheel clock divider auto-correction low limit, 32bits  (SET and GET) -----
// This register is always set to a value that is less than the number of "clock_fw" clock cycles
// that are expected in one period of the input clock signal. Exact value should be computed based upon the
// accuracy specification of the user supplied input signal.
#define DQ_CT651_FWCLK_MIN_D31      (1L<<31)    // Period in "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWCLK_MIN_D0       (1L<<0)     // lsb

// ----- CT651_FWCLK_MAX - Flywheel clock divider auto-correction high limit, 32bits  (SET and GET) -----
// This register is always set to a value that is greater than the number of "clock_fw" clock cycles
// that are expected in one period of the input clock signal.  Exact value should be computed based upon the
// accuracy specification of the user supplied input signal.
#define DQ_CT651_FWCLK_MAX_D31      (1L<<31)    // Period in "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWCLK_MAX_D0       (1L<<0)     // lsb

// ----- CT651_FWCRH - Input clock "high" time, 31+1 bits (GET only) -----
// Most recently measured "high" time of input signal in "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWCRH_STOP         (1L<<31)    // =1 - measurement interval exceeded maximum allowable limit
#define DQ_CT651_FWCRH_D30          (1L<<30)    // msb
#define DQ_CT651_FWCRH_D0           (1L<<0)     // lsb

// ----- CT651_FWCRP - Input clock period count, 31+1 bits (GET only) -----
// Most recently measured input clock period in "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWCRP_STOP         (1L<<31)    // =1 - measurement interval exceeded maximum allowable limit
#define DQ_CT651_FWCRP_D31          (1L<<30)    // msb
#define DQ_CT651_FWCRP_D0           (1L<<0)     // lsb

// ----- CT651_FWCNT - Current value of the flywheel counter, debug only, 32 bits (GET only) -----
// for debug purposes only. this register may not appear in future releases.
#define DQ_CT651_FWCNT_D31          (1L<<31)    //  "clock_fw" (100MHz or 160MHz) clocks
#define DQ_CT651_FWCNT_D0           (1L<<0)     // lsb


#define DQ_L651_NAMELEN             (32)  // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cnames[DQ_CT_651_CHAN][DQ_L651_NAMELEN];
} DQCNAMES_651_, *pDQCNAMES_651_;

/* specific device structure - calibration values */
typedef struct {
    uint32 val;
} DQCALSET_651_, *pDQCALSET_651_;

typedef struct {
    uint32 val;             // DC/DC states (cfg register) in init mode
} DQINITPRM_651_, *pDQINITPRM_651_;

typedef struct {
    uint32 lcr;
    uint32 dac_wr[4];
    uint32 fwcfg;
    uint32 fwdc;
    uint32 fwdiv;
    uint32 fwclk_min;
    uint32 fwclk_max;
} DQOPMODEPRM_651_, *pDQOPMODEPRM_651_;

typedef struct {
    uint32 val;             // DC/DC states (cfg register) in shutdown mode
} DQSDOWNPRM_651_, *pDQSDOWNPRM_651_;

typedef struct {
    uint32  flag_ver;
} DQPRMFLAGS_651_, *pDQPRMFLAGS_651_;

#define DQ_AR664_CHAN               (2)         // Channels
#define DQ_AR664_INFOSZ             (DQ_MAX_INFO_SIZE)    // maximum size of information structure
#define DQ_AR664_BASE               (66000000)  // 66MHz base frequency
#define DQ_AR664_MAXCLFRQ           (2000)      // 500us minimum GAP
#define DQ_AR664_MAXCVFRQ           (2000)      //

#define DQ_AR664_MAXDLYCNT          (65535)     // Maximum value for the delay counter

#define DQ_AR664_LED                (2)         // switch LED on by adding to CLI LCR

#define DQ_AR664_READMEM_CYCLES     (2000)       // number of attempt to receive a flag from ARINC PPC
#define DQ_AR664_WAIT4BOOT          (200)       // 10 seconds for the layer to boot max in 0.1 increments


#define DQ_AR664_SCH_ARR_SZ         (512)       // max. number of elements in scheduler array == total number of ports

//- definition of used variables ---------------------------------

#define DQL_IOCTL664_SETCFG         (0x01L)     // sets a custom configuration

#define DQL_IOCTL664_RESERVED5      (0x05L)     // reserved 5
#define DQL_IOCTL664_RESERVED6      (0x06L)     // reserved 6
#define DQL_IOCTL664_READ_CHNL      (0x07L)     // read a channel message
#define DQL_IOCTL664_WRITE_CHNL     (0x08L)     // write a channel message
#define DQL_IOCTL664_09             (0x09L)     // reserved
#define DQL_IOCTL664_START          (0x0AL)     // immediate mode start
#define DQL_IOCTL664_SETCHNL_CFG    (0x0BL)     // set channel configuration
#define DQL_IOCTL664_CONTROL        (0x0CL)     // control device
#define DQL_IOCTL664_STATUS         (0x0DL)     // retrieve various statuses from the device
#define DQL_IOCTL664_LL_CMD         (0x0EL)     // issue DQCMD_IOCTLD command to ARINC-664 PPC
#define DQL_IOCTL664_IO_CMD         (0x0FL)     // issue DQCMD_IOCTL to ARINC-664 PPC

// for DQL_IOCTL664_SETCFG
typedef struct {
    uint32 buscfg;      // Enable or disable bus
    uint32 speed;       // Set speed for the bus
} AR664_ARCFG, *pAR664_ARCFG;

// for DQL_IOCTL664_SETCHNL_CFG
#define DQL_IOCTL664_SETCHNL_CHCFG      (1)     // set channel configuration
#define DQL_IOCTL664_SETCHNL_CLRCFG     (2)     // clear channel configuration
#define DQL_IOCTL664_SETCHNL_ADDVL      (3)     // add virtual link
#define DQL_IOCTL664_SETCHNL_ADDPORT    (4)     // add port
#define DQL_IOCTL664_SETCHNL_UPDVL      (5)     // update VL
#define DQL_IOCTL664_SETCHNL_UPDPORT    (6)     // update port
#define DQL_IOCTL664_GETCHNL_VLPORT     (7)     // get a VL or port handle
#define DQL_IOCTL664_SETCHNL_VMAP       (8)     // add channel into VMap table by handle
#define DQL_IOCTL664_SETSCH_BINS        (9)     // set scheduling bins and table parameters
#define DQL_IOCTL664_SETSCH_TABLE       (10)    // set scheduling table

// for DQL_IOCTL664_START
#define DQL_IOCTL664_START_ENOPS        (1)     // enable/disable layer operations
#define DQL_IOCTL664_START_ENVLPORT     (2)     // enable/disable VL or port
#define DQL_IOCTL664_START_ENENDSYS     (3)     // enable/disable End System
#define DQL_IOCTL664_START_ENPART       (4)     // enable/disable Partition

// for DQL_IOCTL664_READ_CHNL and DQL_IOCTL664_WRITE_CHNL
#define DQL_IOCTL664_RC_FRAME_SE    (1L<<1)    // First frame of single-frame sequence
#define DQL_IOCTL664_RC_FRAME_S     (2L<<1)    // First frame of multi-frame sequence
#define DQL_IOCTL664_RC_FRAME_C     (3L<<1)    // Tell to continue sending frames
#define DQL_IOCTL664_RC_FRAME_E     (4L<<1)    // Last frame (or only frame) of frame sequence
#define DQL_IOCTL664_RC_FRAMEMASK   (7L<<1)    // Mask

// for DQL_IOCTL664_CONTROL
#define DQL_IOCTL664_CONTROL_ERR        (1)     // control rejection/injection of errors
#define DQL_IOCTL664_CONTROL_BUS        (2)     // control bus
#define DQL_IOCTL664_CONTROL_SYNC       (3)     // control synchronization settings

// for DQL_IOCTL664_STATUS
#define DQL_IOCTL664_STATUS_BUS         (1)     // retrieve bus status
#define DQL_IOCTL664_STATUS_VLPORT      (2)     // retrieve virtual link or port status
#define DQL_IOCTL664_STATUS_PORTMSG     (3)     // reply how much data each port in the list has
#define DQL_IOCTL664_STATUS_PORTARRAY   (8)     // retrieve array of port statistic(s)
#define DQL_IOCTL664_STATUS_DEVICE      (0x10)  // retrieve device info
#define DQL_IOCTL664_STATUS_PORTCTR     (4)     // return the number of messages each port processed 
 
// Commands for ARINC-664 DNA->ARINC side notificatons for DB0


// Output FIFO to read data
#define DQ_AR664_FIFO_GET_DATA      DQ_FIFO_GET_DATA

// Input FIFO to read data
#define DQ_AR664_FIFO_SET_DATA      DQ_FIFO_SET_DATA

// Virtual Link table (must be all int/uint32 to work with the library)
typedef struct {
    // define execution
    int VLID;           // VL ID
    int reserved1;      // reserved for future use
    int ICMP_mode;      // Flags for VL ICMP support (Rx VL can respond and Tx VL can send echo requests)
    int ICMP_VLID;      // what is ICMP reply VL
    int mode;           // mode of operation (bit-wise)
    int bag;            // bag for this VL, in microseconds
    int n_subVL;        // number of sub-VLs: 0/1 = one subVL==VL, 2 = two subVLs, max 4 subVLs
    int lmax;           // maximum Ethernet frame size for Tx/ MTU for Rx for IC [i.e. 64..1518]
    int max_jitter;     // maximum jitter allowed, us
    int skew_max;       // maximum skew between packets for redundancy check in microseconds
                        // after which any SN are accepted as a base line
    int skew_delay;     // delay for respective bus relatively to the beginning of the BAG to introduce error
    uint32 prev_sn_range; // previoud SN range used for RM
    
    // EDE related
    int ede_mode;       // EDE mode
    uint32 ede_sid;     // EDE subscriber ID
    uint32 ede_skew_max;// EDE maximum skew, us
    uint32 ede_age_max; // EDE maximum age, us
    uint32 ede_lag_max; // EDE maxium allowed lag, us

} AR664_VL_CFG, *pAR664_VL_CFG;

// We support only ECHO of the following ICMP Types and Codes
//
// Type Code Description
// 0         Echo Reply     
//       0     Echo reply (used to ping)
// 8         Echo Request
//       0     Echo request (used to ping)
#define AR664_ICMP_ECHO_EN   (1L<<0)
// 3         Destination Unreachable     
//       0     Destination network unreachable
//       1     Destination host unreachable
//       2     Destination protocol unreachable
//       3     Destination port unreachable
#define AR664_ICMP_UNREACH   (1L<<1)    // <reserved, "not applicable" in att.2 ARINC664p7>
//       4     Fragmentation required, and DF flag set
#define AR664_ICMP_FRAGRQ    (1L<<2)    // <reserved, "not applicable" in att.2 ARINC664p7>
//       5     Source route failed
//       6     Destination network unknown
//       7     Destination host unknown
#define AR664_ICMP_NOROUTE   (1L<<3)    // <reserved, "not applicable" in att.2 ARINC664p7>
//       8     Source host isolated
//       9     Network administratively prohibited
//       10    Host administratively prohibited
//       11    Network unreachable for TOS
//       12    Host unreachable for TOS
//       13    Communication administratively prohibited
//       14    Host Precedence Violation
//       15    Precedence cutoff in effect
#define AR664_ICMP_PROHIB    (1L<<4)    // <reserved, "not applicable" in att.2 ARINC664p7>
// 11        Time Exceeded
//       0     TTL expired in transit
//       1     Fragment reassembly time exceeded
#define AR664_ICMP_TMEXCEED  (1L<<5)    // <reserved, "not applicable" in att.2 ARINC664p7>
// 12      Parameter Problem: Bad IP header
//       0     Pointer indicates the error
//       1     Missing a required option
//       2     Bad length
#define AR664_ICMP_BADIP     (1L<<6)    // <reserved, "not applicable" in att.2 ARINC664p7>
//

// <mode>
// Bus usage is decided on per-VL basis
// Same VL numbers can be on each bus if configured separately
// VL can operate either on a single bus - A or B - i.e. in non-redundant mode. 
// If so only integrity checing is available (i.e. checking for the proper sequence numbers)
//
// If VL operates in dual-redundant mode integrity checking and redundant management
// can be enabled separately
// If redundancy management is enabled only one frame (received either from A or from B)
// is delivered into port[ch=0]
// If redundancy management is disabled both frames are delivered (into port[0] and port[1])
//
// zero value means that the VL entry is not used
//#define AR664_VL_EN        (1L<<31) // VL is enabled right away

// <status>
//#define AR664_VL_ONCE     (1L<<31)  // VL is executed at least once, clear upon read
//#define AR664_VL_ERR      (1L<<30)  // VL has an error, clear upon read
//#define AR664_VL_DIS      (1L<<29)  // error caused the VL to be disabled
//#define AR664_VL_EX       (1L<<28)  // entry is executed, cleared automatically if periodic port
//#define AR664_VL_READY    (1L<<27)  // the bag has expired, we can output
//#define AR664_VL_MEMERR   (1L<<1)   // not enough memory/error in the memory

// This table must be defined for each port, only table zero is used if
// both A and B networks are used together for redundancy
// (must be all int/uint32 to work with the library)
typedef struct {
    // define execution
    uint32 mode;        // mode of operation (bit-wise)
    uint32 portID;      // port ID (used for app data management)
    int VLID;           // VLID this powerID belongs to (used for app data management)
    int period;         // transmission period for this port in microseconds
    int period_skew;    // skew for the periodic transmission in microsecond relatively to the beginning of VL BAG
    int icmp_handle;    // port handle to use to reply on ICMP requests (must be an already created Tx ICMP port)
    
                        // define connection
    int endsys_src;     // end-sustem ID corresponded with this entry
    int part_src;       // avionics subsystem partition
    int endsys_dst;     // end-sustem ID corresponded with this entry
    int part_dst;       // avionics subsystem partition
    int subvl_id;       // sub-VL ID
    int udp_src_port;   // UDP source port
    int udp_dst_port;   // UDP destination port
    
                        // define data port
    uint32 port_type;   // VL port type - sampling/queuing
    uint32 d_size;      // size of the data for sampling port
    uint32 depth;       // depth of the queueing or SAP port, messages
    
    uint32 port_handle; // ARINC-664-664 port handle of this port

} AR664_PORT_CFG, *pAR664_PORT_CFG;

#define AR664_EN_VL_4_PORT  (1L<<2)     // force VL to be enabled/disabled alongside with the
                                        // belonging port 

// Table to hold ARINC-664 handles in DAQLib
// This table is returned when AR664 board is configured from DqAdv664SetConfig() from XML file
// When VL is created PortID returns as zero; for each Port all parameters are returned
typedef struct {
    uint16 VlId;        // VL Id
    uint16 PortID;      // PortId
    uint16 VlHandle;    // Handle to VL
    uint16 PortHandle;  // Handle to Port
    uint32 Status;      // Mode 
    uint32 Line;        // Line in XML configuration file this VL/Port tag corresponds to
    AR664_VL_CFG Vl;    // VL configuration structure
    AR664_PORT_CFG Port; // port configuration structure
} AR664_CFG_HANDLES, *pAR664_CFG_HANDLES;

// Reserved for future use
typedef struct {
    uint32 rst_msk;       // what parameters to reset
    uint32 enf_msk;       // which new parameters to enforce
    uint32 sn;            // new sequence number
    uint32 err_ign;       // errors to ignore (mask)
    uint32 err_inj;       // errors to inject 
    uint32 param_a[32];   // parameters for each error injection bit
   
} AR664_ERR_INJ, *pAR664_ERR_INJ;

// DAQLib-only function definitions
#define DQ_AR664_ENABLE_FLAGMASK    (DQ_AR664_EN_HMF_A|DQ_AR664_EN_HMF_B|AR664_VL_BUS_MASK)
#define DQ_AR664_OPERATION_ENABLE   ((AR664_VL_USE_A|AR664_VL_USE_B)|((DqGetLibVersionBuild() < 0x040A0000)? 0:(DQ_AR664_EN_HMF_A|DQ_AR664_EN_HMF_B))) // default high-speed dual-bus settings
#define DQ_AR664_OPERATION_DISABLE  (0)

// DAQLib-only XML configuration codes
#define DQ_AR664_CFG_XML_CHRBUF     (1<<29L) // use XML character buffer instead of file for DqAdv664SetConfig(..,flags,..)
#define DQ_AR664_CFG_XML_FLAGMASK   (DQ_AR664_CFG_XML_CHRBUF|AR664_VL_BUS_MASK)

// DAQLib-only XML error codes
#define AR664_BAD_XML_VER_OR_FORMAT (1L<<24) // Unrecognized version or format or encoding (UTF-8 w/o BOM)
#define AR664_MISSING_XML_ATTR      (1L<<25) // mandatory XML attribute is missing
#define AR664_INVALID_XML_ATTR      (1L<<26) // XML attribute is invalid
#define AR664_DUPLICT_XML_ATTR      (1L<<27) // XML attribute is set more than once
#define AR664_XML_NO_CHILD_PORTS    (1L<<28) // TRUE if VL contains no Ports; FALSE if VL contains Ports
#define AR664_INVALID_VL_CFG        (1L<<29) // The VL configuration has invalid field(s)
#define AR664_INVALID_PORT_CFG      (1L<<30) // The Port config has invalid field(s) (w.r.t. VL parameters)
#define AR664_XML_DQ_INTERNAL_ERR   (1L<<31) // Internal XML or DQ Error (negative integer, e.g. -1)
#define AR664XMLGETSTATUSERR(s)     (s&0xFF000000)  // Bits [31:24] are 0 when no error
#define AR664XMLGETSTATUSPRM(s)     (s&0x0000FFFF)  // Bits [16:0 ] may be used to provide parameter(s)
#define AR664XMLCHKSETATTRIB(a,n)  {if ((a & (1<<n)) != 0) {return AR664_DUPLICT_XML_ATTR;} else {a |= (1<<n);}}
#define DQ_AR664_LISTSZ             (360)       // max number of uint32 output entries

#define DQ_AR664_VL_ARR_SZ          (2048)      // max. number of elements in VL array == total number of VLs
#define DQ_AR664_PORT_ARR_SZ        (4096)      // max. number of elements in scheduler array == total number of ports

#define AR644_SCH_RESOL             (2)         // number of ticks of the scheduler per millisecond (Hz/1000)
#define AR664_SCH_RESOL_uS          (500)       // the duration of tick in microseconds (period)
#define AR664_SCH_mS_in_uS          (1000)      // number of microseconds in a millisecond
#define AR664_QUEUE_SZ              (360)       // maximum queue depth (can be extended if multiple AR664_QUE packets are used)
#define AR664_MIN_BAG               (500)       // minimum BAG value, us
#define AR664_MAX_BAG               (128000)    // maximum BAG value, us
#define AR664_BAG_BINS              (AR664_MAX_BAG/AR664_MIN_BAG)   // number of bins to cover all possible BAGs
#define AR664_DROP_FRAG_UNCOND      (1024*1000/AR664_TS_TIME_ADJ_DIV)    // 2 sec. - max BAG is 128ms and there is max of
                                                // Sub-VL per VL so even if every other packet is lost we still should be
                                                // able to receive a new fragment in 4*2*128=1024ms
#define AR664_DROP_FRAG_UNCOND_COUNT (16)       // The packet is kept eight BAG periods maximum plus time for two lost packets


// Set to 1 for normal operations, 100 for debugging
#define AR664_DEBUG_DLY             (1)         // debugging only to slow down PIT timebase source. SHOULD BE 1 in the build

#define AR664_MIN_PKT_SZ            (59)        // 59 bytes (+1 for S/N and +4 for the packet CRC = 64)
#define AR664_MAX_PKT_SZ            (1514)      // 1514 bytes (and +4 for the packet CRC)

#define AR664_MIN_ETH_SZ            (64)        // 64 bytes (including +4 for the packet CRC)
#define AR664_MAX_ETH_SZ            (1518)      // 1518 bytes (including +4 for the packet CRC)
#define AR664_MAX_ETH_CRC           (4)         // +4 for the packet CRC

#define AR664_MIN_MSG_SZ_N          (1)         // minimum message size for non-fragmented IP message (S-port)
#define AR664_MAX_MSG_SZ_N          (1471)      // maximum message size for non-fragmented IP message (S-port)
#define AR664_MAX_MSG_SZ_F          (8192)      // maximum message size for fragmented IP message (Q- and SAP-port)
#define AR664_SN_SZ                 sizeof(uint8)   // size of the sequence number (last byte of the message)
#define AR664_SN_CNT                (256)         // rollover number of the sequence number (last byte of the message)
#define AR664_MAX_FRAG              (342)         // maximum number of fragments in one 8192-byte message (as 64B frames/24B datagrams)

#define AR664_MAX_SUBVL             (4)                 // maximum number of Sub-VLs per one VL
#define AR664_MAX_REASS             (AR664_MAX_SUBVL*2) // maximum number of simultaneous re-assemblies per VL
                                                        // by protocol is limited to the number of Sub-VL
                                                        // *2 because we can have a situation with one broken chain
                                                        // waiting to expire and one current one per sub-VL

// Protocol header sizes
#define AR664_ETH_CRC               (4)  // Four bytes of Ethernet packet CRC32 bring Ethernet frame size to 18
#define AR664_ETH_HDR_SZ            (14) // Eth packet header size
#define AR664_IP_HDR_SZ             (20) // IP packet header size
#define AR664_UDP_HDR_SZ            (8)  // UDP packet header size
#define AR664_ICMP_HDR_SZ           (8)  // ICMP packet header size
#define AR664_EDE_HDR_SZ            (8)  // EDE packet header size

#define AR664_ETH_HDR_TYPE_IP       (0x800)

#define AR664_IP_PROTO_ICMP         (1)
#define AR664_IP_PROTO_UDP          (17)
#define AR664_IP_PROTO_UDPLITE      (136)
#define AR664_IP_PROTO_TCP          (6)

#define AR664_ICMP_ER               (0)  // echo reply
#define AR664_ICMP_DUR              (3)  // destination unreachable (reserved)
#define AR664_ICMP_SQ               (4)  // source quench (reserved)
#define AR664_ICMP_ECHO             (8)  // echo
#define AR664_ICMP_TS               (13) // timestamp (reserved)
#define AR664_ICMP_TSR              (14) // timestamp reply (reserved)

#define AR664_ETH_MAC_SZ            (6)  // MAC address is 6 bytes

#define AR664_SYS_HDR_SZ            (AR664_UDP_HDR_SZ+AR664_IP_HDR_SZ+AR664_ETH_HDR_SZ) // header for IPv4 Eth before data
#define AR664_SYS_HDR_FRAG_SZ       (AR664_IP_HDR_SZ+AR664_ETH_HDR_SZ) // header for IPv4 Eth fragment 1..n before data

#define AR664_TS_DIVIDER            DQ_LN_10us_TIMESTAMP    // which timestamp constant to use for packet timing
#define AR664_TS_TIME_ADJ_DIV       (10)  // a divider to divide microsecond resolution into timestamp clocks

#define AR664_IP_TTL                (1)   // only one switch can be on the way of ESs

// Commands for ARINC-664 DNA->ARINC side for DB0
// This is an interrupt-based processing
// Command can be only issued but never waited for completion
// Thus for the purpose of retrieving data a pair of request/retrieve shall be used
#define DQL_CMD664_HEARTBIT         (0x1001)    // heartbit, PPC layer stores EEPROM and current status
#define DQL_CMD664_GETHEARTBIT      (0x1002)    // retrieves data stored in heartbit command
#define DQL_CMD664_SETFLASHPTR      (0x1003)    // initiate flash write parameters
#define DQL_CMD664_WRITEFLASH       (0x1004)    // write data to flash
#define DQL_CMD664_RUN_BIT          (0x1005)    // execute built-in test (not implemented)
#define DQL_CMD664_WAKEUP_ASYNC     (0x1006)    // tell ARINC side that DNA freed the memory
#define DQL_CMD664_LEDTEST          (0x1007)    // performs a LED test on the ARINC PPC CPU

// Commands for ARINC-664 DNA->ARINC side for DB1
// This is IOCTL-based processing
// Handler waits for the completion of the command by ARINC PPC and then returns results
#define DQL_CMD664_GETSTATUS        (0x1101)     // returns a status of ARINC PPC CPU

#define DQL_CMD664_WRFRAME          (0x1102)     // write a frame
#define DQL_CMD664_RDFRAME          (0x1103)     // read a frame
#define DQL_CMD664_WR_NFRAMES       (0x1104)     // write N frames in a single request
#define DQL_CMD664_RD_NFRAMES       (0x1105)     // read N frames in one request

#define DQL_CMD664_MEMTEST          (0x110E)     // perform a memory test on the ARINC PPC CPU
#define DQL_CMD664_GET_DEVINFO      (0x110F)     // get device status and information
#define DQL_CMD664_RESET            (0x1201)    // Perform ARINC PPC reset
#define DQL_CMD664_AEVENT           (0x1202)    // Asynchronous event has happened on the firmware side
// for DQL_CMD664_RDFRAME/DQL_CMD664_WRFRAME
//#define DQL_WR664_ALT_CHNL        (1L<<31)   // request data rejected by RM algorithm <excluded from initial releases>
#define DQL_WR664_FLAGS_HDR         (1L<<30)   // request header data with read/write channel frame
// <todo> For DQL_CMD664_UPDVL
#define AR664_UPDVL_CLEAR_RST       (1L<<31)    // clear IC and RM variables - i.e. reset
#define AR664_UPDVL_COPY            (1L<<30)    // simply copy new VL replacing current one
#define AR664_UPDVL_REENABLE        (1L<<29)    // re-enable error-disabled VL
#define AR664_UPDVL_DISABLE         (1L<<28)    // disable VL
#define AR664_UPDVL_UPD_PRM         (1L<<27)    // sets new values for bag, skew_max, skew_delay
#define AR664_UPDVL_SET_SN          (1L<<26)    // force new sequence number
#define AR664_UPDVL_UPD_EDE         (1L<<25)    // sets new values for EDE parameters

// <todo> For DQL_CMD664_UPDPORT
#define AR664_UPDP_CLEAR_RST        (1L<<31)    // clear IC and RM variables - i.e. reset
#define AR664_UPDP_REENABLE         (1L<<30)    // re-enable error-disabled port
#define AR664_UPDP_DISABLE          (1L<<29)    // disable port
#define AR664_UPDP_UPD_PRM          (1L<<28)    // sets new values for connection parameters
#define AR664_UPDP_COPY             (1L<<27)    // simply copy new port replacing current one
// Definitions for scheduler entries
// <mode>
#define AR664_PORT_EN        (1L<<31)   // port is enabled
#define AR664_PORT_MCAST     (1L<<8)    // this port uses multicast addressing
#define AR664_PORT_FRAGEN    (1L<<7)    // this port is capable of fragmentation
#define AR664_PORT_PERIOD    (1L<<2)    // entry needs to be executed periodically
// <port_type>
#define AR664_PORT_SMPL         (1)         // sampling port
#define AR664_PORT_QUEUE        (2)         // queueing port
#define AR664_PORT_SAP          (4)         // service access port
#define AR664_PORT_ICMP_LEGACY  (5)         // reserved for ICMP echo port (only one allowed per VL), deprecated
#define AR664_PORT_ICMP_1100    (8)         // reserved for ICMP echo port (only one allowed per VL), deprecated
#define AR664_PORT_ICMP         (AR664_PORT_ICMP_LEGACY)    // reserved for future use, deprecated
#define AR664_PORT_TYPE_MSK     (0xF)       // port mode mask

#define AR664_PORT_TYPE_IS_SMPL(X)  ((X&AR664_PORT_TYPE_MSK)==AR664_PORT_SMPL)
#define AR664_PORT_TYPE_IS_QUEUE(X) ((X&AR664_PORT_TYPE_MSK)==AR664_PORT_QUEUE)
#define AR664_PORT_TYPE_IS_SAP(X)   ((X&AR664_PORT_TYPE_MSK)==AR664_PORT_SAP)
#define AR664_PORT_TYPE_IS_ICMP(X)  (((X&AR664_PORT_TYPE_MSK)==AR664_PORT_ICMP_LEGACY)||((X&AR664_PORT_TYPE_MSK)==AR664_PORT_ICMP_1100))
#define AR664_PORT_TYPE_IS_SAP_OR_ICMP(X)   (AR664_PORT_TYPE_IS_SAP(X)||AR664_PORT_TYPE_IS_ICMP(X))

// <status>
#define AR664_PORT_EXEC         (1L<<31)    // port is executed at least once, clear upon read
#define AR664_PORT_ERR          (1L<<30)    // port has an error, clear upon read
#define AR664_PORT_DIS          (1L<<29)    // error caused the port to be disabled (reserved)
#define AR664_PORT_BUSY         (1L<<28)    // port is busy
#define AR664_PORT_OVF          (1L<<27)    // port overflow (queue & sap & icmp)
#define AR664_PORT_MEMERR       (1L<<26)    // not enough memory/error in the memory
#define AR664_PORT_ADDROK       (1L<<25)    // addresses are successfully stored
#define AR664_PORT_READY        (1L<<24)    // port is ready to use for Tx/Rx activities
#define AR664_PORT_JITTER       (1L<<23)    // port jitter exceeds maximum VL jitter
#define AR664_PORT_MORE         (1L<<22)    // port in the process of getting all fragments out (reserved)
#define AR664_PORT_FRGCFG       (1L<<21)    // port attempted to send or receive a fragmented packet if not configured (queue & sap)
#define AR664_PORT_ASYNCOVR     (1L<<20)    // Packet was lost because it could not be transfered to the CPU
#define AR664_PORT_STAT_MINMAX  (1L<<16)    // bit indicates that the port's min and max statistics are valid
#define AR664_PORT_NEW_DATA_OVR (1L<<2)     // sampling port had unread data that was overwritten by newer data
#define AR664_PORT_HAS_DATA     (1L<<1)     // port has new data; this bit is cleared when buffer is read

#define AR664_ENDSYS(NETID,EQID)    ((((NETID)&0xff)<<8)|((EQID)&0xff))

// <mode>
#define AR664_VL_EN        (1L<<31) // VL enabled
#define AR664_VL_RX        (0L<<30) // this is RX VL
#define AR664_VL_TX        (1L<<30) // this is TX VL
#define AR664_VL_MULTI     (1L<<8)  // this VL has multiple sinks
#define AR664_VL_FRAG_EN   (1L<<7)  // fragmentation is enabled
#define AR664_VL_ICMP_EN   (1L<<6)  // ES needs to respond on ICMP requests on this VL
#define AR664_VL_INTGR_EN  (1L<<3)  // integrity checking is enabled
#define AR664_VL_RED_MGM   (1L<<2)  // redundancy management is enabled
#define AR664_VL_DUAL      (3L<<0)  // (3) use both A and B for redundancy management
#define AR664_VL_USE_B     (2L<<0)  // (2) send/receive on port B
#define AR664_VL_USE_A     (1L<<0)  // (1) send/receive on port A
#define AR664_VL_BUS_MASK  (3)

// <status>
#define AR664_VL_ONCE      (1L<<31) // VL is executed at least once, clear upon read
#define AR664_VL_ERR       (1L<<30) // VL has an error, clear upon read
#define AR664_VL_DIS       (1L<<29) // error caused the VL to be disabled
#define AR664_VL_EX        (1L<<28) // entry is executed, cleared automatically if periodic port
#define AR664_VL_READY     (1L<<27) // the bag has expired, we can output
#define AR664_VL_MEMERR     (1L<<1) // not enough memory/error in the memory

#define DQ_AR664_EN_HMF_B  (1L<<5) // set to use fast hardware frame filter on bus A
#define DQ_AR664_EN_HMF_A  (1L<<4) // set to use fast hardware frame filter on bus B

// Currently handle is 12-bit for the entry index (i.e. 4096 items), can be changed
// in the future if the table will need expansion
#define AR664_HANDLE_TX   (1L<<15)  // This is TX handle
#define AR664_HANDLE_B    (1L<<14)  // Handle for B bus
#define AR664_HANDLE_A    (1L<<13)  // Handle for A bus (both A and B if dual RM)

#define AR664_HANDLE_VL   (1L<<12)  // mark that this is VL and not a port handle

#pragma pack(1)

// structure defines header information to be tranferred to the host
typedef struct {
    uint8 dst[AR664_ETH_MAC_SZ];   // destination MAC address
    uint8 src[AR664_ETH_MAC_SZ];   // source MAC address
    uint16 type;    // service type
} ETH_HEADER, *pETH_HEADER;

#ifndef __ARM_MX6SX__
// structure defines header information to be tranferred to the host
#define IP_RF 0x8000        // reserved fragment flag
#define IP_DF 0x4000        // dont fragment flag
#define IP_MF 0x2000        // more fragments flag
#define IP_OFFMASK 0x1fff   // mask for fragmenting bits
#endif /* __ARM_MX6SX__ */

typedef struct {
    uint16 v_hl_tos;    // version / header length / type of service
    uint16 len;         // total length
    uint16 id;          // identification
    uint16 offset;      // fragment offset field
    uint16 ttl_proto;   // time to live / protocol
    uint16 chksum;      // IP header checksum
    uint32 src;         // source IP address
    uint32 dst;         // destination IP address
} IP4_HEADER, *pIP4_HEADER;

typedef struct {
    uint16 src;         // source UDP port
    uint16 dst;         // destination UDP port
    uint16 len;         // packet length
    uint16 chksum;      // UDP header checksum
} UDP_HEADER, *pUDP_HEADER;

typedef struct {
    uint16 type_code;  // subtype code
    uint16 chksum;     // checksum
    uint16 id;         // request ID
    uint16 seqno;      // sequence number
} ICMP_HEADER;

typedef union {
    UDP_HEADER udp;     // UDP and ICMP are the same size
    ICMP_HEADER icmp;
} UDP_ICMP_HDR;

// this structure should have size at 32-bit boundary
//
#define AR664_SAP_EDE_TSTAMP    (1L<<22)// Reserved
#define AR664_SAP_EDE_SN        (1L<<21)// Reserved
#define AR664_SAP_EDE_CRC_Y     (1L<<20)// Reserved
#define AR664_SAP_EDE_CRC_X     (1L<<19)// Reserved

#define AR664_SAP_ICMP_SEQNO    (1L<<18)// ICMP sequence number is provided
#define AR664_SAP_ICMP_ID       (1L<<17)// ICMP ID is provided
#define AR664_SAP_ICMP_CHKSUM   (1L<<16)// ICMP checksum is provided
#define AR664_SAP_ICMP_CODE     (1L<<15)// ICMP type code

#define AR664_SAP_UDP_CHKSUM    (1L<<14)// UDP checksum is specified
#define AR664_SAP_UDP_PORT_DST  (1L<<13)// UDP port is specified
#define AR664_SAP_UDP_PORT_SRC  (1L<<12)// UDP port is specified

#define AR664_SAP_IP_DSF        (1L<<11)// IPv4 differentiated service field is included
#define AR664_SAP_IP_CHKSUM     (1L<<10)// IPv4 checksum is included
#define AR664_SAP_IP_OFFS       (1L<<9) // IPv4 Fragment offset
#define AR664_SAP_IP_ID         (1L<<8) // IPv4 ID is supplied
#define AR664_SAP_IP_LEN        (1L<<7) // IPv4 length
#define AR664_SAP_IP_TTLPROT    (1L<<5) // IPv4 TTL/Protocol field is supplied
#define AR664_SAP_IP_ADDR_DST   (1L<<4) // IPv4 address is supplied
#define AR664_SAP_IP_ADDR_SRC   (1L<<3) // IPv4 address is supplied

#define AR664_SAP_ETH_TYPE      (1L<<2) // Eth type is supplied (default 0x800)
#define AR664_SAP_ETH_MAC_DST   (1L<<1) // MAC address is supplied
#define AR664_SAP_ETH_MAC_SRC   (1L<<0) // MAC address is supplied

typedef struct {
    ETH_HEADER eth;     // Ethernet header
    IP4_HEADER ip;      // IPv4 header
    UDP_ICMP_HDR icmp_udp; // ICMP/UDP header
    uint32 fields;      // Flags to tell which fields are filled and the rest is autofilled
    uint32 eth_CRC;     // Ethernet CRC to receive
    uint32 timestamp;   // Timestamp
    uint8 sn;           // ARINC-664 Sequence number
    uint8 ede_hdr[AR664_EDE_HDR_SZ];    // EDE header
    uint16 ede_crc_x;   // EDE CRC X
    uint16 ede_crc_y;   // EDE CRC Y
    uint8 reserved;     // to bring size to 32-bit boundary
} AR664_HEADERS, *pAR664_HEADERS;

typedef struct {
    uint32 flags;       // active parts of the filter (bitmask)
    uint8 mac_src[AR664_ETH_MAC_SZ];   // MAC source
    uint8 mac_dst[AR664_ETH_MAC_SZ];   // MAC destination
    uint32 ip_src;      // IP source
    uint32 ip_dst;      // IP destination
    uint16 service;     // type of service to record
    uint16 udp_src;     // UDP source
    uint16 udp_dst;     // UDP destination
} AR664_PKT_FLT, pAR664_PKT_FLT;

// Structure to control behavior of the layer
typedef struct {
    uint32 enable_b;    // enable or disable bus activity (see AR664_CTRL_ENABLE_)
    uint32 rst_msk;     // reserved for future use
    uint32 enf_msk;     // reserved for future use
    uint32 eth_speed;   // speed of Eth interface (10/100/1000) (see AR664_CTRL_SEL and AR664_CTRL_ETH)
} AR664_CTRL, *pAR664_CTRL;

#define AR664_CTRL_DISABLE_RX_B  (1L<<5) // disable Rx on bus B
#define AR664_CTRL_DISABLE_RX_A  (1L<<4) // disable Rx on bus A (use AR664_CTRL_ENABLE_A to re-enable)

#define AR664_CTRL_DISABLE_B  (1L<<3) // disable bus B
#define AR664_CTRL_DISABLE_A  (1L<<2) // disable bus A
#define AR664_CTRL_ENABLE_B   (1L<<1) // enable bus B
#define AR664_CTRL_ENABLE_A   (1L<<0) // enable bus A (use AR664_CTRL_DISABLE_(RX_)A to disable)

#define AR664_CTRL_SEL_B      (1L<<5) // change bus B speed
#define AR664_CTRL_SEL_A      (1L<<4) // change bus A speed
#define AR664_CTRL_ETH10_B    (1L<<3) // enforce 10-Base-T bus B
#define AR664_CTRL_ETH1000_B  (1L<<2) // enforce 1000-Base-T bus B
#define AR664_CTRL_ETH100_B   (0L<<2) // 100-Base-T (default) bus B
#define AR664_CTRL_ETH10_A    (1L<<1) // enforce 10-Base-T bus A
#define AR664_CTRL_ETH1000_A  (1L<<0) // enforce 1000-Base-T bus A
#define AR664_CTRL_ETH100_A   (0L<<0) // 100-Base-T (default) bus A


// Structure to get message count processed for a port_handle
typedef struct {
    uint16 port_handle;     // port handle
    uint16 reserved16;
    uint32 reserved32;
    uint32 msg_count;       // number of messages processed
} AR664_PORT_MSGCNT, *pAR664_PORT_MSGCNT;

#pragma pack()

// constants for AR664_VL_CTRL
#define AR664_CTRLVL_DISABLE    (1L<<1)     // disable VL
#define AR664_CTRLVL_ENABLE     (1L<<0)     // enable VL

// Parameters to reset
#define AR664_CTRLVL_RST_SN    (1L<<31)     // reset sequence number
#define AR664_CTRLVL_RST_IGN   (1L<<30)     // reset previously set errors to ignore
#define AR664_CTRLVL_RST_INJ   (1L<<29)     // reset previously set errors to inject

// Parameters to enforce
#define AR664_CTRLVL_ENF_SN    (1L<<31)     // set sequence number
#define AR664_CTRLVL_ENF_IGN   (1L<<30)     // set errors to ignore
#define AR664_CTRLVL_ENF_INJ   (1L<<29)     // set errors to inject

// Errors to ignore
#define AR664_CV_ERIGN_ETH      (1L<<31)    // ignore errors on Ethernel layer
#define AR664_CV_ERIGN_IP       (1L<<30)    // ignore errors on IP layer
#define AR664_CV_ERIGN_UDP      (1L<<29)    // ignore errors on UDP layer
#define AR664_CV_ERIGN_IC       (1L<<28)    // ignore integrity checking errors
#define AR664_CV_ERIGN_RM       (1L<<27)    // ignore redundancy management errors
#define AR664_CV_ERIGN_BAG      (1L<<26)    // ignore timing errors
#define AR664_CV_ERIGN_EDE_SKEW (1L<<25)    // ignore EDE skew max errors
#define AR664_CV_ERIGN_EDE_AGE  (1L<<24)    // ignore EDE age max errors
#define AR664_CV_ERIGN_EDE_LAG  (1L<<23)    // ignore EDE lag max errors
#define AR664_CV_ERIGN_EDE_CRC  (1L<<22)    // ignore EDE CRC errors

// Errors are defined separately for A and B since handle dor dual red mode is for both VLs
#define AR664_CV_ERINJ_SYM      (1L<<31)    // inject symbol error
#define AR664_CV_ERINJ_CRC      (1L<<30)    // inject CRC error
#define AR664_CV_ERINJ_DATA     (1L<<29)    // inject data error
#define AR664_CV_ERINJ_LEN      (1L<<28)    // inject preamble length error
#define AR664_CV_ERINJ_ADDR     (1L<<27)    // inject addressing error
#define AR664_CV_ERINJ_BAG      (1L<<26)    // inject bag error
#define AR664_CV_ERINJ_IP       (1L<<25)    // inject IP header error
#define AR664_CV_ERINJ_IP_CRC   (1L<<24)    // inject IP header CRC error
#define AR664_CV_ERINJ_FRAG     (1L<<23)    // inject IP fragmentation error
#define AR664_CV_ERINJ_UDP      (1L<<22)    // inject UDP header error
#define AR664_CV_ERINJ_UDP_CRC  (1L<<21)    // inject UDP header CRC error
#define AR664_CV_ERINJ_EDE_SKEW (1L<<25)    // inject EDE skew max errors
#define AR664_CV_ERINJ_EDE_AGE  (1L<<24)    // inject EDE age max errors
#define AR664_CV_ERINJ_EDE_LAG  (1L<<23)    // inject EDE lag max errors
#define AR664_CV_ERINJ_EDE_CRC  (1L<<22)    // inject EDE CRC errors
// definitions for AR664_PORT_CTRL
#define AR664_CTRLP_DISABLE    (1L<<1)     // disable port
#define AR664_CTRLP_ENABLE     (1L<<0)     // enable port

// Parameters to reset
#define AR664_CTRLP_RST_QUEUE (1L<<31)     // reset message queue
#define AR664_CTRLP_RST_IGN   (1L<<30)     // reset previously set errors to ignore
#define AR664_CTRLP_RST_INJ   (1L<<29)     // reset previously set errors to inject

// Parameters to enforce
#define AR664_CTRLP_ENF_IGN   (1L<<30)     // set errors to ignore
#define AR664_CTRLP_ENF_INJ   (1L<<29)     // set errors to inject

// Errors to ignore
#define AR664_CP_ERIGN_DLEN    (1L<<30)    // ignore data length error
#define AR664_CP_ERIGN_IC      (1L<<29)    // ignore integrity checking errors
#define AR664_CP_ERIGN_EDE     (1L<<28)    // ignore EDE errors for this port

// Errors are defined separately for A and B since handle dor dual red mode is for both VLs
#define AR664_CP_ERINJ_DLEN    (1L<<29)    // inject port data length error
#define AR664_CP_ERINJ_ADDR    (1L<<27)    // inject addressing error

// ARINC-664 bus statistics

// macros to unpack the cpu statistics
#define AR664_STAT_CURCPU(s) ((s)&0xFF)
#define AR664_STAT_MAXCPU(s) (((s)>>8) & 0xFF)

#define AR664_BUS_STAT_PRMB 0x57471571     // [24-bit preamble][8-bit version] for AR664_BUS_STAT_EXT
#pragma pack(1)
typedef struct {
    uint32 preamble;        // always AR664_BUS_STAT_PRMB
    uint32 timestamp;       // timestamp when data was collected
    uint32 afdx_cpu_use;    // percent use of the ARINC-664 CPU at time of collection
    uint32 iom_cpu_use;     // percent use of the  IOM CPU at time of collection

    // Protocol statistics constants
    uint32 bytes_rcv;       // number of frame octets received before filtering (rollover at 4GB)
    uint32 bytes_snd;       // number of frame octets sent to network interface (rollover at 4GB)
    uint32 pkts_rcv;        // number of packets received
    uint32 pkts_rcv_s;      // sampling packets/messages received
    uint32 msgs_rcv_q;      // queueing messages received
    uint32 msgs_rcv_sap;    // SAP messages received
    uint32 msgs_icmp;       // ICMP messages received
    uint32 pkts_snd;        // packets sent
    uint32 pkts_snd_p;      // periodic sampling packets/messages sent
    uint32 pkts_snd_s;      // sampling packets/messages sent
    uint32 pkts_snd_q;      // queueing packets (fragments) sent
    uint32 pkts_snd_sap;    // SAP packets (fragments) sent
    uint32 msgs_snd_q;      // queueing messages sent
    uint32 msgs_snd_sap;    // SAP messages sent
                            // packets dropped due to:
    uint32 eth_hdr_err;     // - Ethernet header error (unrecognized protocol, incorrect FCS, short frame, long frame, etc)
    uint32 eth_addr_err;    // - MAC address encoding does not match ARINC-664 standard
    uint32 bus_not_match;   // - bus encoded in MAC address does not match VL's bus
    uint32 bus_dis;         // - drop because bus disabled
    uint32 vl_dis;          // - drop because VL disabled
    uint32 vl_lmax_exceed;  // - Ethernet frame length is larger than VL's LMax
    uint32 ip_hdr_err;      // - IP header does not match ARINC-664 standard (protocol, version, etc)
    uint32 ip_addr_err;     // - IP address encoding does not match ARINC-664 standard
    uint32 ip_chksum;       // - IP checksum failed
    uint32 ip_too_big;      // - message length exceeds MTU for a port with fragmentation disabled
    uint32 ip_frag_timeout; // - fragments took too long to arrive
    uint32 ip_frag_nomatch; // - fragmentation identifier unmatched
    uint32 ip_frag_nomem;   // - not enough memory for more fragments
    uint32 ip_frag_err;     // - drop due to other fragmentation error
    uint32 udp_chksum;      // - UDP checksum failed
    uint32 addr_not_ours;   // - address does not match any enabled VL or Port (MAC, IP, and UDP quintuple)
    uint32 port_dis;        // - drop because Port doesn't match any enabled or configured port
    uint32 ede_crc_err;     // - EDE CRC check failure (reserved)
    uint32 ede_ord_err;     // - EDE ordinal checking failed (reserved)
    uint32 ede_age_err;     // - EDE age validation error (reserved)
                            // packets dropped or accepted at IC/RM:
    uint32 ic_reset;        // - accepted due to internal timeout at integrity checking
    uint32 ic_drop;         // - dropped due to sequence number at integrity checking
    uint32 rm_skewmax;      // - accepted because time exceeded skew_max
    uint32 rm_drop;         // - other bus delivered the message before this one
                            // message storage errors:
    uint32 buf_rcv_ovwr;    // - sampling port buffer overwritten before it could be read
    uint32 buf_rcv_ovf;     // - queueing/SAP buffer overflow; not stored
    uint32 buf_snd_ovwr;    // - sampling port buffer overwritten before it could be transmitted
    uint32 buf_snd_ovf;     // - send buffer overflow; not stored
                            // packet transmission:
    uint32 tx_sch_err;      // - transmit scheduler error
    uint32 tx_sch_p_bsy;    // - skipped because transmitter is busy
    uint32 tx_sch_jitter;   // - transmit scheduling jitter
    uint32 reserved[2];     // reserved for future use

    // aEvent statistics (entire board)
    uint32 ae_proc_req;     // aEvent port process request
    uint32 ae_proc_ok;      // aEvent port process completed successfully
    uint32 ae_proc_ovf;     // aEvent port process buffers full; message dropped
    uint32 ae_proc_err;     // aEvent port process general error (see debug console)
    uint32 ae_emit_req;     // aEvent emit packet request from AR664 to IOM-CPU
    uint32 ae_emit_ok;      // aEvent emit packet successfully sent to CPU
    uint32 ae_emit_retried; // aEvent emit needed to retry to send to CPU
    uint32 ae_emit_timeout; // aEvent emit timed out while sending to CPU
    uint32 ae_emit_err;     // aEvent emit general error (see debug console)

    // Internal errors
    uint32 mem_err;         // memory errors (memory not available - firmware internal)
    uint32 pkt_err;         // packet errors (errors in packet management - firmware internal)

} AR664_BUS_STAT, *pAR664_BUS_STAT;

// Statistics is collected on per-bus basis (legacy version)
typedef struct {
    uint32 timestamp;       // timestamp when data was collected

    // Protocol statistics constants
    uint32 pkts_rcv;        // number of packets recevied
    uint32 pkts_rcv_s;      // sampling packets received
    uint32 pkts_rcv_q;      // queued packets received
    uint32 pkts_rcv_sap;    // SAP packets received
    uint32 pkts_snd;        // packets sent
    uint32 pkts_snd_p;      // periodic packets sent
    uint32 pkts_snd_s;      // sampling packets sent
    uint32 pkts_snd_q;      // queued packets sent
    uint32 pkts_snd_sap;    // SAP packets sent
    uint32 pkts_icmp;       // number of ICMP packets being processed
    uint32 rdnd_skewmax;    // number of times redundancy management time exceed skew_max
    uint32 rdnd_reset;      // number of times redundancy management was reset due to reset timeout
    uint32 intg_drop;       // packets dropped due to: - the integrity check
    uint32 rdnd_drop;       // - because other bus has deliverd message before this one
    uint32 bus_not_match;   // - bacause bus and bus encoded in MAC address do not match
    uint32 bus_dis;         // - the bus being disabled
    uint32 vl_dis;          // - VL being disabled
    uint32 port_dis;        // - VL has no enabled ports
    uint32 link_err;        // - link layer failed
    uint32 ip_addr_err;     // - IP addressing error
    uint32 buf_rcv_ovf;     // - recevie buffer overflow
    uint32 buf_snd_ovf;     // - send buffer overflow
    uint32 ip_chksum;       // - IP checksum failed
    uint32 ip_hdr_err;      // - IP header error (like version, etc.)
    uint32 ip_frag_err;     // - fragmentation errors
    uint32 ip_too_big;      // - packets too big for MTU and fragmentation settings
    uint32 udp_chksum;      // - UDP checksum failed
    uint32 udp_port_err;    // - addressed to an incorrect port

    // EDE statistics
    uint32 ede_crc_err;     // packets dropped due to: - EDE CRC check failure
    uint32 ede_ord_err;     // - EDE ordinal checking failed
    uint32 ede_age_err;     // - age validation error

    // Internal errors
    uint32 mem_err;         // memory errors (memory not available - firmware internal)
    uint32 pkt_err;         // packet errors (errors in packet management - firmware internal)

    // CPU status
    uint32 afdx_cpu_use;    // percent use of the CPU

} AR664_BUS_STAT_LEGACY, *pAR664_BUS_STAT_LEGACY;

// This is the structure returned when application requests port activity information
// For output ports size=<max size> and messages=number of empty frames in the queue (for Q/SAP)
// For input ports size=<current message size> and messages=number of messages to be retrieved (for Q/SAP)
// For S ports size=1 if the message was already sent or received and 0 if the message has not
// being sent
typedef struct {
    uint16 size_hndl;   // size of the top message or handle for blind request
    uint16 messages;    // number of available message frames
} AR664_PORT_INFO, *pAR664_PORT_INFO;

// Selectors for DqAdv664GetPortStatistic(hd, devn, selectors, ...) function available in v1.0.0.88
#define AR664_STAT_PORT_VLPORTHNDL   (1<<3)  // Blind list of VL << 16 | PORT handle
#define AR664_VP_STAT_VLPORTIDS      (1<<4)  // Blind list of VL << 16 | PORT ID
#define AR664_STAT_PORT_MSGCTR       (1<<6)  // Number of messages processed (also in aEvent header)
// Timestamp difference between messages; only valid if status &= AR664_PORT_STAT_MINMAX
#define AR664_STAT_PORT_UNDERJITRCTR (1<<7)  // Port's under jitter counter
#define AR664_STAT_PORT_OVERJITRCTR  (1<<8)  // Port's over jitter counter
#define AR664_STAT_PORT_LO_JITR_TS   (1<<9)  // Port's lowest seen jitter
#define AR664_STAT_PORT_HI_JITR_TS   (1<<10) // Port's highest seen jitter
// Selectors for DqAdv664GetPortStatistic(hd, devn, selectors, ...) function available in v1.1.0.0
#define AR664_STAT_PORT_MSGSTORCTR   (1<<11) // Number of messages written to the port's transmit buffer
#define AR664_STAT_PORT_MSGSTOVRCTR  (1<<12) // Number of messages overwritten in the port's transmit buffer

// Mask of all AR664_STAT_PORT_ selectors used by DAQLib to sanitize input
#define AR664_STAT_PORT_MASK         (AR664_STAT_PORT_VLPORTHNDL|\
                                      AR664_VP_STAT_VLPORTIDS|AR664_STAT_PORT_MSGCTR|\
                                      AR664_STAT_PORT_UNDERJITRCTR|AR664_STAT_PORT_OVERJITRCTR|\
                                      AR664_STAT_PORT_LO_JITR_TS|AR664_STAT_PORT_HI_JITR_TS|\
                                      AR664_STAT_PORT_MSGSTORCTR|AR664_STAT_PORT_MSGSTOVRCTR)

#pragma pack()

// Information and status constants and structure for 664 layer
#define DQ_AR664_MAX_LOGIC_VER  0x01021166  // latest 664 logic version used with this IOM CPU firmware
#define DQ_AR664_MAX_DAQLIBVER  0x0409023D  // latest DAQLib version used with this IOM CPU firmware
#define DQ_AR664_MAX_AFDXFWVER  0x0100005D  // latest 664 firmware version used with this IOM CPU firmware
#define DQ_AR664_MIN_DAQLIBVER  0x0408001C  // last DAQLib version where AR664 binary interface changed
#define DQ_AR664_MIN_AFDXFWVER  0x01000058  // last 664 version where AR664 binary interface changed
#define DQ_AR664_DEV_INFO_PRMB  0x57A7      // fixed preamble for AR664_DEV_INFO
#define DQ_AR664_DEV_INFO_SVER  0x01        // current version of AR664_DEV_INFO
#define DQ_AR664_ERR_OLD_AR_FW  (1<<1L)     // AR664_DEV_INFO incompatible DAQLib(old)<->IOMC protocol
#define DQ_AR664_ERR_OLD_DQBIOS (1<<2L)     // AR664_DEV_INFO incompatible AR664(old)<->IOMC protocol

typedef struct {
    uint16 preamble;                    // set to AR664_DEV_INFO_PRMB
    uint8 structver;                    // set to AR664_DEV_INFO_SVER
    uint8 incompatible;                 // defined by DQ_AR664_ERR_OLD_
    uint32 iomc_fw_ver;                 // IOM CPU firmware version
    uint32 afdx_fw_ver;                 // ARINC-664 firmware version
    char afdx_fw_date[24];              // ARINC-664 firmware build time/date
} AR664_DEV_INFO, *pAR664_DEV_INFO;

// Event data for 664 layer (should be aligned by 32 bit boundary)
typedef struct {
    uint32 chan;                    // channel information
    uint32 evtype;                  // type of the event
    uint32 tstamp;                  // timestamp of event
    uint32 size;                    // size of the following data in bytes
    uint32 avail;                   // number of bytes available (reserved)
    uint8 data[DQ_FLEX_ARRAY];      // data to follow (one character takes one byte)
} EV664_ID, *pEV664_ID;

// Structure for transferring messages (should be aligned by 32 bit boundary)
typedef struct {
    uint16 size;                    // size of the following message (zero is no more messages)
    uint16 handle;                  // handle for which this message is for
    uint32 timestamp;               // timestamp when message was received
    uint32 ctr;                     // counters: [8-bit SN]|[message number on that port]
    uint8 data[DQ_FLEX_ARRAY];      // body of the message
} EV664_MSG, *pEV664_MSG;

#define EV664_MSG_CTR_GET_SN(ctr)   (ctr >> 24)         // gets the ARINC-664 sequence number
#define EV664_MSG_CTR_GET_PMN(ctr)  (ctr & 0x00FFFFFF)  // gets the number of messages rx/tx on the port

#define DqAdv664ConfigEvents_PARAMSZ (7)        // maximum number of uint32 parameters after pEV664_ID

// firmware maintains three event lists:
//
// - the first one for EV664_TO and EV664_RXSZ
// these events combine received messages into one event until size of bus idle timeout is reached
//
// - the second handle list is for EV664_RX and includes port handles which needs to be send immediately
// after receiving the packet
//
// - the third one is when data on the handle is transferred
// use a combination (EV664_CLEAR+EV664_xxxx) to clear appropriate handle list
//
typedef enum {
    EV664_CLEAR = 0x1000,   // clear all events and handle lists
                            // if or-ed with other events it clears only that particular event and associated lists

    EV664_RESET = 0x2000,   // reset handle list for the event and start over again

    EV664_TO = 0x101,       // send all accumulated data after pre-programmed timeout expires
                            // eparam == timeout in us
                            // list == handles to add to the event list

    EV664_RXSZ,             // send all accumulated data after buffer accumulates selected size (+ data)
                            // or the next received packet cannot fit the buffer (cannot be used together with EV664_RX)
                            // eparam == size of the buffer
                            // list == handles to add to the event list

    EV664_RX,               // data received on the selected list of ports (+ data)
                            // eparam == maximum event size
                            // list == handles to add to the event list

    EV664_TX,               // data transmission completed on selected list of ports
                            // eparam == maximum event size
                            // list == handles to add to the event list

    EV664_BUS_ERROR,        // bus or protocol errors
                            // eparam == maximum event size
                            // list == none

    EV664_RX_UNXP,          // unexpected RX data or data overflow (most likely receiving error)
    EV664_TX_UNXP,           // unexpected TX data or data overflow (most likely transmitting error)
                            // eparam == maximum event size
                            // list == none

    EV664_VRFY_RX          // reception verification packet
                            // eparam == timeout in us
                            // list == handles to add to the event list
} event664_t;


#define EV664_FIFO_DATA          (1L<<0)     // send FIFO data upon TO or RX interrupt
#define EV664_ACC_DATA           (1L<<1)     // accumulate data to send predefined length only
#define EV664_TS_DATA            (1L<<20)    // send timestamp before data (internal use only in EV664_TO_TS)

#define EV664_EV_MASK            0xFFF       // mask event numebr from event clear/restart

#define EV664_RXUNX_EVOVER       (1L<<0)     // We don't have enough memory to store an RX event. Emit an EV664_RX_UNXP event


#define L8000_INFOSZ    DQ_MAX_INFO_SIZE
#define L8000_MODEL     0x8000
#define L8000_OPTION    0x1
#define L8000_SERNUM    0x8021234

#define _CAPS_8000_ \
"NumberSS=1\n" \
"SS0.Type=SL\n" \
"SS0.Chnls=1\n"


#define L8000_TIMER            0   // Standard way thru the timer
#define L8000_CPUTMR_MASTER    1   // Program CPU timer and route to SyncOut, process them
#define L8000_CPUTMR_SLAVE     2   // Process interrupts from SyncIn line
#define L8000_CPUTMR_START     3   // Start timer
#define L8000_CPUTMR_STOP      4   // Stop timer
#define L8000_CPUTMR_DISABLE   5   // Disable CPUTMR timer

#define DQMAXTRL (DQ_MAXDEVN * DQ_MAXSS)
#define DQMAXCHNLS (32)
#define DQ_VDD_DMAPID_IN        DQ_DMAP_LASTID_IN
#define DQ_VDD_DMAPID_OUT       DQ_DMAP_LASTID_OUT
#define DQ_VDD_SS (2)

#define MPC5200_GPT_100US_PS (6600)
#define MPC5200_GPT_10US_PS  (660)
#define MPC5200_GPT_1US_PS   (66)


#define DQ_PL_801_CHAN    4         // working channels
#define DQ_PL_801_CHANSVC 4         // total channels including service
#define DQ_PL_801_INFOSZ  DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_PL_801_BASE    BUS_FREQUENCY  // 66MHz base frequency

// Maximum working frequencies
#define DQ_PL_801_MAXCLFRQ  50000
#define DQ_PL_801_MAXCVFRQ  50000

// helper macros
#define DQ_PL801_CHNLMASK (0xf0)
#define DQ_PL801_MSGNORM (0)

// sample width sizes
#define DQ_PL801_SW8  (1L)
#define DQ_PL801_SW16 (2L)
#define DQ_PL801_SW32 (4L)

// Individual register addresses
// Actual access address is calculated as <device base>+CLI_CTUxS+CTU_xx
#define DQ_CDS_STR      0x00    // STatus Register
#define DQ_CDS_CTR      0x00    // ComTrol Register
#define DQ_CDS_IFWR   0x0C  // input fifo watermark
#define DQ_CDS_OFWR   0x10  // output fifo watermark
#define DQ_CDS_FDTI   0x14  // input Fifo DaTa register
#define DQ_CDS_FDTO   0x18  // output Fifo DaTa register
#define DQ_CDS_FCNTI    0x1C    // input Fifo CouNT register (actual # samps in fifo)
#define DQ_CDS_FCNTO    0x20    // output Fifo CouNT register
#define DQ_COM_CNT    0x24  // COM AUX system RX count register
#define DQ_COM_DATA   0x28  // COM AUX system DATA register
#define DQ_COM_TS     0x2C  // COM AUX system Timestamp register

// Start and stop bit masks for CDU data
#define DQ_CDU_START_MASK  0x001FFBFE   // Start bits (0) - AND this mask.
#define DQ_CDU_STOP_MASK   0x00200400   // Stop bits (1) - OR this mask.

// Message length - Used to set watermark and read/write loops
#define DQ_FGC_MSGSIZE  8   // Message size is 256 bits ('8' 32 bit words)
#define DQ_CDU_MSGSIZE  1   // Message size is 21 bits ('1' 32bit word).

// start modes

// ioctls
#define DQL_IOCTL801_START    (0x0AL)  // immediate mode start

// subcommands for IOCTLs
#define DQL_IOCTL801_SETCHNL_CFG (1L) // Load channel configuraion reg
#define DQL_IOCTL801_SET_REG (2L)     // Generic chan reg load
#define DQL_IOCTL801_GET_REG (3L)     // Generic chan reg read
#define DQL_IOCTL801_SET_LCR (4L)     // Load layer configuration reg
#define DQL_IOCTL801_GET_LCR (5L)     // Read layer configuration reg
#define DQL_IOCTL801_SET_WM (11L)     // Load channel watermarks


#define DQ_L801_FIFOSZ      256 // size of fifo

// Channel 0-3 base addresses
#define DQ_CLI_CDS0S    0x2000  // CDU 0 start

// Channel Control Reg Bit description
// Status register is used to report current operational status of the counter
// timer unit via dedicated bits for every status condition reported.
#define DQ_CR801_TXF 0x20000   // TX Fifo Enable
#define DQ_CR801_RXF 0x10000   // RX Fifo Enable
#define DQ_CR801_LB  0x00010   // Loopback Enable
#define DQ_CR801_TS  0x00008   // Timestamp Enable
#define DQ_CR801_OED 0x00004   // Output enable DATA
#define DQ_CR801_OES 0x00002   // Output enable STROBE
#define DQ_CR801_OEC 0x00001   // Output enable CLOCK

// Upper part of the configuration word - PL-801 specific
#define DQ_PL_801_MODESCAN  (0L << 16)  // single scan update mod
#define DQ_PL_801_MODEFIFO  (2L << 16)  // continuous acquisitione with FIFO
#define DQ_PL_801_MODECONT  (3L << 16)  // continuous acquisition

#define DQ_PL_801_TSCOPY    (1L << 18)  // Push timestamp into FIFO along with data

// Output FIFO to read data
#define DQ_PL_801_FIFO_GET_DATA     DQ_FIFO_GET_DATA


#define DQ_PL_801_NAMELEN   16  // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_PL_801_CHAN][DQ_PL_801_NAMELEN];
} DQCNAMES_801_, *pDQCNAMES_801_;

/* specific device structure - calibration values */
typedef struct {
    uint32 placeholder;
} DQCALSET_801_, *pDQCALSET_801_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_PL_801_CHAN*2]; // channel list - full
    uint32 conf;                // control word - layer API flags
    uint32 cvclk;               // CV clock
    uint32 clclk;               // CL clock
    uint32 trig;                // trigger conditions
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_801_, *pDQOPMODEPRM_801_;


/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_801_ calset;
    DQOPMODEPRM_801_ opmodeprm;
    DQCNAMES_801_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_801_, *pDEVEEPROM_801_;

// chnanel list structure for run-time
typedef struct {
    uint32  ccr;    // configuration
    uint32  lr;     // load
    uint32  ier;    //
    uint32  sampwidth;
} DQCHNLSET_801_, *pDQCHNLSET_801_;

typedef struct {
    uint16 in_wm;   // watermark in (Rx)
    uint16 out_wm;  // watermark out (Tx)
} DQWMSET_801_, *pDQWMSET_801_;

typedef struct {
    uint8   chnl;       // |7-4 = event flags|3-0 = channel|
    uint32 data[];    // n - 32bit samples
} DQMSG_801, *pDQMSG_801;

typedef struct {
  uint32  tx[DQ_FGC_MSGSIZE];      // Latest outgoing data
  uint32  rx[DQ_FGC_MSGSIZE+1];    // Latest incoming data (includes timestamp)
  uint32  timestamp;               // Timestamp of last incoming data
} DQFGC,  *pDQFGC;

typedef struct {
  uint32  com_aux;    // Latest incoming com aux data
  uint32  com_ts;     // Com aux timestamp
  uint32  nav_aux;    // Latest incoming nav aux data
  uint32  nav_ts;     // Nav aux timestamp
  uint32  tx;         // Outgoing data (not used)
} DQCDU,  *pDQCDU;

#pragma pack()


#define DQ_PL_802_CHAN    4         // working channels
#define DQ_PL_802_CHANSVC 4         // total channels including service
#define DQ_PL_802_INFOSZ  DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_PL_802_BASE    BUS_FREQUENCY  // 66MHz base frequency

// Maximum working frequencies
#define DQ_PL_802_MAXCLFRQ  50000
#define DQ_PL_802_MAXCVFRQ  50000

// helper macros
#define DQ_PL802_CHNLMASK (0xf0)
#define DQ_PL802_MSGNORM (0)

// sample width sizes
#define DQ_PL802_SW8  (1L)
#define DQ_PL802_SW16 (2L)
#define DQ_PL802_SW32 (4L)

// Individual register addresses
// Actual access address is calculated as <device base>+CLI_CTUxS+CTU_xx
#define DQ_MAN_STR      0x00    // STatus Register
#define DQ_MAN_CTR      0x00    // ComTrol Register
#define DQ_MAN_IFWR     0x0C    // input fifo watermark
#define DQ_MAN_OFWR     0x10    // output fifo watermark
#define DQ_MAN_FDTI     0x14    // input Fifo DaTa register
#define DQ_MAN_FDTO     0x18    // output Fifo DaTa register
#define DQ_MAN_FCNTI    0x1C    // input Fifo CouNT register (actual # samps in fifo)
#define DQ_MAN_FCNTO    0x20    // output Fifo CouNT register

// Message length - Used to set watermark and read/write loops
#define DQ_MAN_MSGSIZE 256    // Max size 256 bytes.

// start modes
// ioctls
#define DQL_IOCTL802_START    (0x0AL)  // immediate mode start

// ioctls
#define DQL_IOCTL802_SETCHNL_CFG (1L) // Load channel configuraion reg
#define DQL_IOCTL802_SET_REG (2L)     // Generic chan reg load
#define DQL_IOCTL802_GET_REG (3L)     // Generic chan reg read
#define DQL_IOCTL802_SET_LCR (4L)     // Load layer configuration reg
#define DQL_IOCTL802_GET_LCR (5L)     // Read layer configuration reg
#define DQL_IOCTL802_SET_WM (11L)     // Load channel watermarks

#define DQ_L802_FIFOSZ      256 // size of fifo

// Channel 0-3 base addresses
#define DQ_CLI_MANSS    0x2100  // CDU 0 start

// Channel Control Reg Bit description
// Status register is used to report current operational status of the counter
// timer unit via dedicated bits for every status condition reported.
#define DQ_CR802_TXF    0x20000   // TX Fifo Enable
#define DQ_CR802_RXF    0x10000   // RX Fifo Enable
#define DQ_CR802_LB     0x00010   // Internal Loopback Enable
#define DQ_CR802_RAW    0x00008   // RAW (analog) Manchester mode
#define DQ_CR802_PRIMUS 0x00004   // Primus Manchester data mode


// Upper part of the configuration word - PL-802 specific
#define DQ_PL_802_MODESCAN  (0L << 16)  // single scan update mod
#define DQ_PL_802_MODEFIFO  (2L << 16)  // continuous acquisitione with FIFO
#define DQ_PL_802_MODECONT  (3L << 16)  // continuous acquisition

#define DQ_PL_802_TSCOPY    (1L << 18)  // Push timestamp into FIFO along with data

// Output FIFO to read data
#define DQ_PL_802_FIFO_GET_DATA     DQ_FIFO_GET_DATA


#define DQ_PL_802_NAMELEN   16  // maximum length of the channel name (trailing 0 isn't included)

#pragma pack(1)

/* channel names */
typedef struct {
    char cname[DQ_PL_802_CHAN][DQ_PL_802_NAMELEN];
} DQCNAMES_802_, *pDQCNAMES_802_;

/* specific device structure - calibration values */
typedef struct {
    uint32 placeholder;
} DQCALSET_802_, *pDQCALSET_802_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_PL_802_CHAN*2]; // channel list - full
    uint32 conf;                // control word - layer API flags
    uint32 cvclk;               // CV clock
    uint32 clclk;               // CL clock
    uint32 trig;                // trigger conditions
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_802_, *pDQOPMODEPRM_802_;


/* combined structure to be allocated after CMNDEVS */
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_802_ calset;
    DQOPMODEPRM_802_ opmodeprm;
    DQCNAMES_802_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_802_, *pDEVEEPROM_802_;

// chnanel list structure for run-time
typedef struct {
    uint32  ccr;    // configuration
    uint32  lr;     // load
    uint32  ier;    //
    uint32  sampwidth;
} DQCHNLSET_802_, *pDQCHNLSET_802_;

typedef struct {
    uint16 in_wm;   // watermark in (Rx)
    uint16 out_wm;  // watermark out (Tx)
} DQWMSET_802_, *pDQWMSET_802_;

typedef struct {
    uint8   chnl;       // |7-4 = event flags|3-0 = channel|
    uint32 data[DQ_FLEX_ARRAY];    // n - 32bit samples
} DQMSG_802, *pDQMSG_802;

typedef struct {
  uint32  count;                    // Transfer counter
  uint32  size;                     // Number of bytes to send
  uint8   man_data[DQ_MAN_MSGSIZE]; // Outgoing data
} DQMAN, *pDQMAN;

#pragma pack()


#define DQ_PL820_LINES             (104)       // number of I/O lines
#define DQ_PL820_CHAN              (2)         // working channels
#define DQ_PL820_CHANSVC           (2)         // total channels including service
#define DQ_PL820_INFOSZ            DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_PL820_BASE              BUS_FREQUENCY  // 66MHz base frequency
#define DQ_PL820_PLL_DEF           24000000     // default PLL frequency

#define DQ_PL820_PORTS             (4)         // four 32-bit ports in total available to the user outside
#define DQ_PL820_NIS_PORTS         (2)         // two 32-bit ports connect FPGA and CPLD layers



#define PL820_MAX_ISR_WAIT         100        // microseconds/2 to wait for IS reply

#define PL820_SPI_TX_FIFO_SZ        1024       // SPI0/1 TX FIFO size
#define PL820_SPI_RX_FIFO_SZ        1024       // SPI0/1 RX FIFO size

//
// ADC is optional and provide ability to read all voltages and temperature
//
// Bits 18-0 are encoded as listed below as delivered from LTC2486 converter   (sub-LSBs not included)
#define PL820IS_ADC_EOC           (1L<<18)      // "EOC" bit 0 indicates valid data
                                                // 1 - conversion result read too son (hardware error)
#define PL820IS_ADC_DMY           (1L<<17)      // "DUMMY" bit - should be always 0
#define PL820IS_ADC_SIG           (1L<<16)      // Sign bit if this bit is same as MSB - conversion out of the range
#define PL820IS_ADC_DATA(D)       ((D)&0xffff)  // Data 16 bit

#define PL820IS_ADC_DLY_WIDTH            8      // Number of bits in ADC /CS hold delay counter
#define PL820IS_ADC_CTRL_WIDTH          13      // Number of bits in ADC control word
#define PL820IS_ADC_DATA_WIDTH          19      // # of bits in ADC data word (do not read 12 data bits and 5 sub-lsbs)
#define PL820IS_ADCCH_NUM                5      // # of ADC channels (4 SE + die temperature)
#define PL820IS_ADC_CH0CFG           0x1610     // default ADC channel config
#define PL820IS_ADC_CH1CFG           0x1710     // default ADC channel config
#define PL820IS_ADC_CH2CFG           0x1630     // default ADC channel config
#define PL820IS_ADC_CH3CFG           0x1730     // default ADC channel config
#define PL820IS_ADC_CH4CFG           0x1418     // default ADC channel config


// FPGA registers - CLI side
#define PL820_CLI_STR     (0x0000)    // R   layer status register
#define PL820_CLI_LCR     (0x0000)    //   W layer control register, do readback with DQL_CLI_LCRR
#define PL820_CLI_ISDR    (0x0004)    // R   isolated side RX data register
#define PL820_CLI_ISTR    (0x0004)    //   W isolated side TX transmit register

#define PL820_CLI_LID     (0x0008)    // R   layer identification {u16 BOM,u16 Model}

#define PL820_CLI_NISV    (0x000C)    // R   NIS logic revision {u8 rsvd, u8 major, u8 minor, u8 dbg}

#define PL820_CLI_SPD0    (0x0010)    // R/W scratchpad register 0 (8 bits)
#define PL820_CLI_SPD1    (0x0014)    // R/W scratchpad register 1 (8 bits)
#define PL820_CLI_TSTD    (0x00B8)    // R/W write timestamp divider of BUS_FREQUENCY, read timestamp

// PL820_CLI_LCR
#define PL820_LCR_LIOE     (1UL<<31)  // Layer I/O enable - controls iso_cmd line
#define PL820_LCR_LRE      (1UL<<30)  // Layer reset enable

#define PL820_LCR_LED      (1UL<<1)   // LED control
#define PL820_LCR_DCDC     (1UL<<0)   // DC/DC control

// PL820_CLI_STR
// Layer Status Register  PL820_CLI_LSR (0x0000+RD)
// individual bit definitions
#define PL820_LSR_BSY     (1UL<<31)  // Layer BUSY (reserved)
#define PL820_LSR_ILS     (1UL<<30)  // Interrupt line status (1=IRQ requested)
#define PL820_LSR_EDR     (1UL<<29)  // EEPROM data ready
#define PL820_LSR_EIB     (1UL<<28)  // EEPROM interface busy
#define PL820_LSR_IDR     (1UL<<27)  // IS-data ready
#define PL820_LSR_IBT     (1UL<<26)  // IS-interface TX busy
#define PL820_LSR_IBR     (1UL<<25)  // IS-interface RX busy
#define PL820_LSR_LES     (1UL<<24)  // Layer error status (reserved)
#define PL820_LSR_EXT1    (1UL<<23)  // iso_ext1 line current state
#define PL820_LSR_EXT0    (1UL<<22)  // iso_ext0 line current state
#define PL820_LSR_EXT_POS (22)       // bit position of iso_ext0
#define PL820_LSR_INT1    (1UL<<21)  // iso_int1 line current state
#define PL820_LSR_INT0    (1UL<<20)  // iso_int0 line current state


// FPGA registers - PL820 FPGA side
#define PL820_S                      0x2000     // Base address for the FPGA

#define PL820_CFG                    0x2000     // R/W  General configuration register
#define PL820_STS                    0x2004     // R    General status register

// DPLL control
#define PL820_PLL0_BCFG              0x2020     // W    PLL0 configuration register
#define PL820_PLL0_BSTS              0x2020     // R    Status of the PLL0
#define PL820_PLL1_BCFG              0x2024     // W    PLL1 configuration register
#define PL820_PLL1_BSTS              0x2024     // R    Status of the PLL1
#define PL820_PLL0_DIV               0x2028     // W    Post-divider for PLL0 (0 = bypass divider)
#define PL820_PLL1_DIV               0x202C     // W    Post-divider for PLL1 (0 = bypass divider)

// NIS pins mode
#define PL820_NISMD0                 0x2040     // W    NIS IO31-0 mode (0-default 1-test;
                                                //      NIS-IO 2, 4, 8, 12, 16 excluded)
#define PL820_NISMD1                 0x2044     // W    NIS IO 63-32 mode (0-default 1-test;
                                                //      NIS-IO 39 excluded)
// NIS pins direction
#define PL820_NISDIR0                0x2048     // W    NIS IO 31-0 direction in test mode (1-output)
#define PL820_NISDIR1                0x204C     // W    NIS IO 63-32 direction in test mode (1-output)

// NIS pins values on output
#define PL820_NISOUT0                0x2050     // R/W  NIS IO 31-0 value when test mode is enabled
                                                //      and direction is output; read return last
                                                //      written value
#define PL820_NISOUT1                0x2054     // R/W  NIS IO 63-32 value when test mode is enabled
                                                //      and direction is output; read return last
                                                //      written value
// NIS pins readbask
#define PL820_NISIN0                 0x2058     // R    NIS IO 31-0 current state
#define PL820_NISIN1                 0x205C     // R    NIS IO 63-0 current state

// SPI0 section (user SPI)
#define PL820_SPI0_CFG               0x2100     // W    SPI0 configuration register
#define PL820_SPI0_STS               0x2104     // R    SPI0 status register
#define PL820_SPI0_FWM               0x210C     // W    SPI0 FIFO watermark register
#define PL820_SPI0_OFDT0             0x2110     // W    SPI0 output FIFO data register bits 31-0
#define PL820_SPI0_OFDT1             0x2114     // W    SPI0 output FIFO data register bits 63-32
#define PL820_SPI0_OFDT0E            0x2118     // W    SPI0 output FIFO last word data register bits 31-0
#define PL820_SPI0_IFDT0             0x2120     // R    SPI0 input FIFO bits 31-0 data register
#define PL820_SPI0_IFDT1             0x2124     // R    SPI0 input FIFO bits 63-32 data register

// SPI1 section (user SPI)
#define PL820_SPI1_CFG               0x2180     // W    SPI1 configuration register
#define PL820_SPI1_STS               0x2184     // R    SPI1 status register
#define PL820_SPI1_FWM               0x218C     // W    SPI1 FIFO watermark register
#define PL820_SPI1_OFDT0             0x2190     // W    SPI1 output FIFO data register bits 31-0
#define PL820_SPI1_OFDT1             0x2194     // W    SPI1 output FIFO data register bits 63-32
#define PL820_SPI1_OFDT0E            0x2198     // W    SPI1 output FIFO last word data register bits 31-0
#define PL820_SPI1_IFDT0             0x21A0     // R    SPI1 input FIFO bits 31-0 data register
#define PL820_SPI1_IFDT1             0x21A4     // R    SPI1 input FIFO bits 63-32 data register

//            PL820_CFG              0x2000     // R/W  General configuration register
#define PL820_CFG_SPI1R              (1L<<2)    // 1 - reset user SPI1
#define PL820_CFG_SPI0R              (1L<<1)    // 1 - reset user SPI0
#define PL820_CFG_CPLDR              (1L<<0)    // 1 - reset CPLD

//            PL820_STS              0x2004     // R        General status register
// Report status of the PL-820 module
// Sticky (latched) status bits auto-cleared after read
#define PL820_STS_SPI1TXFES          (1L<<23)   // 1 - SPI1 TX FIFO is empty
#define PL820_STS_SPI1TXHFS          (1L<<22)   // 1 - SPI1 TX FIFO is below watermark
#define PL820_STS_SPI1RXFFS          (1L<<21)   // 1 - SPI1 RX FIFO is full
#define PL820_STS_SPI1RXHFS          (1L<<20)   // 1 - SPI1 RX FIFO is above watermark
#define PL820_STS_SPI0TXFES          (1L<<19)   // 1 - SPI0 TX FIFO is empty
#define PL820_STS_SPI0TXHFS          (1L<<18)   // 1 - SPI0 TX FIFO is below watermark
#define PL820_STS_SPI0RXFFS          (1L<<17)   // 1 - SPI0 RX FIFO is full
#define PL820_STS_SPI0RXHFS          (1L<<16)   // 1 - SPI0 RX FIFO is above watermark
// Current (static) status bits
#define PL820_STS_SPI1TXFE           (1L<<15)   // 1 - SPI1 TX FIFO is empty
#define PL820_STS_SPI1TXHF           (1L<<14)   // 1 - SPI1 TX FIFO is below watermark
#define PL820_STS_SPI1TXFF           (1L<<13)   // 1 - SPI1 TX FIFO is full
#define PL820_STS_SPI1RXFE           (1L<<12)   // 1 - SPI1 RX FIFO is empty
#define PL820_STS_SPI1RXHF           (1L<<11)   // 1 - SPI1 RX FIFO is above watermark
#define PL820_STS_SPI1RXFF           (1L<<10)   // 1 - SPI1 RX FIFO is full
#define PL820_STS_SPI0TXFE           (1L<<9)    // 1 - SPI0 TX FIFO is empty
#define PL820_STS_SPI0TXHF           (1L<<8)    // 1 - SPI0 TX FIFO is below watermark
#define PL820_STS_SPI0TXFF           (1L<<7)    // 1 - SPI0 TX FIFO is full
#define PL820_STS_SPI0RXFE           (1L<<6)    // 1 - SPI0 RX FIFO is empty
#define PL820_STS_SPI0RXHF           (1L<<5)    // 1 - SPI0 RX FIFO is above watermark
#define PL820_STS_SPI0RXFF           (1L<<4)    // 1 - SPI0 RX FIFO is full
#define PL820_STS_SPI1BSY            (1L<<3)    // 1 - SPI1 busy
#define PL820_STS_SPI0BSY            (1L<<2)    // 1 - SPI0 busy
#define PL820_STS_ISRDBSY            (1L<<1)    // 1 - CPLD->FPGA interface busy
#define PL820_STS_ISWRBSY            (1L<<0)    // 1 - FPGA->CPLD interface busy

//            PL820_PLL0_BCFG        0x2020             // W       PLL0 configuration register
//            PL820_PLL0_BSTS        0x2020             // R        Status of the PLL0
//            PL820_PLL1_BCFG        0x2024             // W       PLL1 configuration register
//            PL820_PLL1_BSTS        0x2024             // R        Status of the PLL1
// PLL0 is currently for SPI0 clock
// PLL1 is currently for SPI1 clock
#define PL820_PLL_BCFG_RLD           (1L<<27)   // 1 - reload configuration from ROM check BSTS_BUSY bit
                                                // (should be  0 after data is loaded) reload should be
                                                // followed by PLL update (PUPD) cycle
#define PL820_PLL_BCFG_PUPD          (1L<<26)   // 1 - update PLL with previously written data bit is auto-
                                                // cleared after it is applied  to the PLL check BSTS_BUSY bit
                                                // (should be  0 after data is written)
#define PL820_PLL_BCFG_PWR           (1L<<25)   // 1 - write PLL register bit is auto-cleared after it is
                                                // applied to the PLL check BSTS_BUSY bit
                                                // (should be  0 after data is written)
#define PL820_PLL_BCFG_PCLR          (1L<<24)   // 1 - reset PLL bit is auto-cleared after it is applied to the PLL
#define PL820_PLL_BCFG_CPRM2         (1L<<22)   // 3-bit counter parameter (see Cyclone ALTPLL_RECONFIG table 3-5)
#define PL820_PLL_BCFG_CPRM(D)       ((D)<<20)  // C0-C4 :  0-high count (8-bit data); 1-low count (8-bit data);
                                                //          4 - bypass (1-bit data); 5 - mode (odd/even 1-bit data)
                                                // M/N :  0145 - same as for C0-C4; 7 - load nominal count (9-bit data)
#define PL820_PLL_BCFG_CTYPE3        (1L<<19)   // 4-bit counter type (see Cyclone ALTPLL_RECONFIG table 3-4)
#define PL820_PLL_BCFG_CTYPE(D)      ((D)<<16)  // 0 - N 1 - M 2 - CP/LF 3 - VCO 4-8 - C0-C4
#define PL820_PLL_BCFG_D8            (1L<<8)    // 9-bit data that will be written to the PLL register
#define PL820_PLL_BCFG_D(D)          ((D)&0x1ff)  //

#define PL820_PLL_BSTS_LOCKED        (1L<<1)    // 1 - PLL is locked (normal operation)
#define PL820_PLL_BSTS_BUSY          (1L<<0)    // 1 - PLL is busy (in reconfiguration mode)

//            PL820_NISMD0                 0x2040             // W   NIS IO31-0 mode (0-default 1-test;
//                                                                   NIS-IO 2,4,8,12,16 excluded)
//            PL820_NISMD1                 0x2044             // W   NIS IO 63-32 mode (0-default 1-test;
//                                                                   NIS-IO 39 excluded)
//            PL820_NISDIR0                0x2048             // W   NIS IO 31-0 direction in test mode (1-output)
//            PL820_NISDIR1                0x204C             // W   NIS IO 63-32 direction in test mode (1-output)
//            PL820_NISOUT0                0x2050             // R/W  NIS IO 31-0 value when test mode is enabled
//                                                                   and direction is output; read return last
//                                                                   written value
//            PL820_NISOUT1                0x2054             // R/W  NIS IO 63-32 value when test mode is enabled
//                                                                   and direction is output; read return last
//                                                                   written value
//            PL820_NISIN0                 0x2058             // R        NIS IO 31-0 current state
//            PL820_NISIN1                 0x205C             // R        NIS IO 63-0 current state
// All registers above are 32-bit wide; bits 2,4,8,12,16,39 are always written with 0s
//


//            PL820_SPI0_CFG               0x2100             // W       SPI0 configuration register
//            PL820_SPI1_CFG               0x2180             // W       SPI1 configuration register
// Master SPI can be reconfigured at any time however after each re-configuration SPI reset
// should be issued by toggling corresponding PL820_CFG_SPIxR bit
#define PL820_SPI_CFG_CSI             (1L<<31)  // Invert SCS if 1

#define PL820_SPI_CFG_ABE(N)          ((N)<<24)  // Address bit MSB set to "PL820_SPI_CFG_DBE"
                                                 // if address is unused
#define PL820_SPI_CFG_PSR             (1L<<23)   // If==1 - receive data is valid on rising edge of the clock
#define PL820_SPI_CFG_ABS(N)          ((N)<<16)  // Address bit LSB set to 0
                                                 // if address is unused
#define PL820_SPI_CFG_PSW             (1L<<15)   // If==1 - transmit data is valid on rising edge of the clock
#define PL820_SPI_CFG_DBE(N)          ((N)<<8)   // Data MSB
#define PL820_SPI_CFG_MWE             (1L<<7)    // 1 multi-word mode + auto-increment address once RX SPI data is latched

#define PL820_SPI_CFG_DBS(N)          ((N)<<0)   // Data LSB

// get parts of the config word into usable bits
#define PL820_SPI_CFGGET_CSI(W)       (((W)&PL820_SPI_CFG_CSI) >> 31)
#define PL820_SPI_CFGGET_ABE(W)       ((W & PL820_SPI_CFG_ABE(0x3F))>>24)
#define PL820_SPI_CFGGET_PSR(W)       (((W)&PL820_SPI_CFG_PSR) >>23)
#define PL820_SPI_CFGGET_ABS(W)       ((W & PL820_SPI_CFG_ABS(0x3F))>>16)
#define PL820_SPI_CFGGET_PSW(W)       (((W)&PL820_SPI_CFG_PSW) >> 15)
#define PL820_SPI_CFGGET_DBE(W)       (((W) & PL820_SPI_CFG_DBE(0x3F))>>8)
#define PL820_SPI_CFGGET_MWE(W)       (((W)&PL820_SPI_CFG_MWE) >> 7)
#define PL820_SPI_CFGGET_DBS(W)       ((W & PL820_SPI_CFG_DBS(0x3F))>>0)

//            PL820_SPI0_STS                               0x2104             // R        SPI0 status register
//            PL820_SPI1_STS                               0x2184             // R        SPI1 status register
// Report current FIFO levels and status of the SPI interface
#define PL820_SPI_STS_TXFE           (1L<<31)   // 1 if TX FIFO was ever empty since the last read
#define PL820_SPI_STS_RXFF           (1L<<30)   // 1 if RX FIFO was ever full since the last read

// Bits 26-0 are static i.e. current values are reported
#define PL820_SPI_STS_TXFUW_N(W)     (((W)>>16)&(PL820_SPI_TX_FIFO_SZ-1))  //  # of occupied words in the TX FIFO
#define PL820_SPI_STS_SPIB           (1L<<15)   //  1 if SPI transaction is in progress

#define PL820_SPI_STS_RXFUW_N(W)     ((W)&(PL820_SPI_RX_FIFO_SZ-1)) // # of occupied words in the RX FIFO

//            PL820_SPI0_FWM                           0x210C             // W       SPI0 FIFO watermark register
//            PL820_SPI1_FWM                           0x218C             // W       SPI1 FIFO watermark register
// Watemark registers are used to set FIFO half-full interup levels
#define PL820_SPI_FWM_TXWM(N)        (((N)&(PL820_SPI_TX_FIFO_SZ-1))<<16)  //            TX FIFO watermark level
#define PL820_SPI_FWM_RXWM(N)        ((N)&(PL820_SPI_RX_FIFO_SZ-1))        //            RX FIFO watermark level

#define PL820_SPI_FWMGET_TXWM(N)        (((N)&PL820_SPI_FWM_TXWM((PL820_SPI_RX_FIFO_SZ-1)))>>16)  //            TX FIFO watermark level
#define PL820_SPI_FWMGET_RXWM(N)        ((N)&PL820_SPI_FWM_RXWM((PL820_SPI_RX_FIFO_SZ-1)))        //            RX FIFO watermark level

//            PL820_SPI0_OFDT0        0x2110             // W       SPI0 output FIFO data register bits 31-0
//            PL820_SPI0_OFDT1        0x2114             // W       SPI0 output FIFO data register bits 63-32
//            PL820_SPI0_OFDT0E       0x2118             // W       SPI0 output FIFO last word data register bits 31-0
//            PL820_SPI1_OFDT0        0x2190             // W       SPI1 output FIFO data register bits 31-0
//            PL820_SPI1_OFDT1        0x2194             // W       SPI1 output FIFO data register bits 63-32
//            PL820_SPI1_OFDT0E       0x2198             // W       SPI1 output FIFO last word data register bits 31-0
// Up to 64-bits of the output data are split into the two registers. For the >32 bits write to
// PL820_SPIx_OFDT1 should preceed write to PL820_SPIx_OFDT0 or PL820_SPIx_OFDT0E.
// Write to PL820_SPI0_OFDT0E indicates end of the frame for the multi-word transaction

//            PL820_SPI0_IFDT0           0x2120           // R      SPI0 input FIFO bits 31-0 data register
//            PL820_SPI0_IFDT1           0x2124           // R      SPI0 input FIFO bits 63-32 data register
//            PL820_SPI1_IFDT0           0x21A0           // R      SPI1 input FIFO bits 31-0 data register
//            PL820_SPI1_IFDT1           0x21A4           // R      SPI1 input FIFO bits 63-32 data register
// Up to 64-bits of the input data are split into the two registers. For the >32 bits read from
// PL820_SPIx_IFDT1 should preceed read from PL820_SPIx_IFDT0.
// Read from PL820_SPIx_IFDT0 advances RX FIFO.

#define PL820_E                          0x2FFC           // Last address in FPGA address space


// All CPLD PL820IS_xx registers are accessed via serial interface utilizing
// NIS-IO pins 2,4,8,12,16,39 in serial mode and thus require delay of ~(42) 33MHz clocks
// for the write and ~(42+34) 33MHz clocks for the read operation
// Also access can be interrupt-driven or polled - based on status bits in LSR register
#define PL820IS_S                        0x3000    // Base address for the CPLD

#define PL820IS_CFG                      0x3000    // R/W  General configuration register
#define PL820IS_STS                      0x3004    // R    General status register
#define PL820IS_ID                       0x3008    // R    0x000vA820 - v==PCB revision

// Format for the UEI serial interface -  40-bit FPGA-->CPLD
// MSB is a write bit (1 - write to the register) following 7 bits - address of the
// register in the CPLD shifted 2 bits to the right and ANDed with 16'h7F and 32 bits data
// CPLD-->FPGA returns back 32 bits of data. In both directions transmission starts with two
// start bits
//
#define PL820IS_WREN_BIT               (1L<<39)            // 1 - write to the register
#define PL820IS_ADDR_A8                                    // (Register address >> 2)
#define PL820IS_ADDR_A2_8(A)           (((A)&0x7f)<<32)    // - mapped to 0x3000-0x31FC address space
#define PL820IS_ADDRDNA_A8                                 // DNA address bits mapped to CPLD
#define PL820IS_ADDRDNA_A2_8(A)        (((A)&0x7f)<<2)     // - address space
#define PL820IS_DATA_D31                                   // 32-bit data
#define PL820IS_DATA_D(D)              ((D)&0xffffffff)

// Interrupt on the CPLD side
#define PL820IS_IER                    0x3010     // W   Interrupt enable register
#define PL820IS_ISR                    0x3014     // R   Interrupt status register
#define PL820IS_ICR                    0x3018     // R   Interrupt clear register

// NIS pins mode
#define PL820IS_NISMD0                 0x3030     // W   NIS IO31-0 mode (0-default 1-test;
                                                  //     NIS-IO 2, 4, 8, 12, 16 excluded)
#define PL820IS_NISMD1                 0x3034     // W   NIS IO 63-32 mode (0-default 1-test;
                                                  //     NIS-IO 39 excluded)

// NIS pins direction
#define PL820IS_NISDIR0                0x3038     // W   NIS IO 31-0 direction in test mode (1-output)
#define PL820IS_NISDIR1                0x303C     // W   NIS IO 63-32 direction in test mode (1-output)

// NIS pins value
#define PL820IS_NISOUT0                0x3040     // R/W NIS IO 31-0 value when test mode is enabled
                                                  //     and direction is output; read return last
                                                  //     written value

#define PL820IS_NISOUT1                0x3044     // R/W  NIS IO 63-32 value when test mode is enabled
                                                  //      and direction is output; read return last
                                                  //      written value
// NIS pins readback
#define PL820IS_NISIN0                 0x3048     // R    NIS IO 31-0 current state
#define PL820IS_NISIN1                 0x304C     // R    NIS IO 63-0 current state

// ADC readback registers
#define PL820IS_ADC0                   0x3050     // R    ADC Channel 0 data (3+16LSB valid)
#define PL820IS_ADC1                   0x3054     // R    ADC Channel 1 data (3+16LSB valid)
#define PL820IS_ADC2                   0x3058     // R    ADC Channel 2 data (3+16LSB valid)
#define PL820IS_ADC3                   0x305C     // R    ADC Channel 3 data (3+16LSB valid)
#define PL820IS_ADCTC                  0x3060     // R    ADC Channel Temperature data (3+16LSB valid)

// external pins direction
#define PL820IS_USRDIR0                0x3080     // W    USER IO 31-0 direction (1-output)
#define PL820IS_USRDIR1                0x3084     // W    USER IO 63-32 direction (1-output)
#define PL820IS_USRDIR2                0x3088     // W    USER IO 95-64 direction (1-output)
#define PL820IS_USRDIR3                0x308C     // W    USER IO 104-96 direction (1-output)

// external pins value (if output is selected)
#define PL820IS_USROUT0                0x3090     // R/W  USER IO 31-0 value
#define PL820IS_USROUT1                0x3094     // R/W  USER IO 63-32 value
#define PL820IS_USROUT2                0x3098     // R/W  USER IO 95-64 value
#define PL820IS_USROUT3                0x309C     // R/W  USER IO 104-96 value

// external pins readback
#define PL820IS_USRIN0                 0x30A0     // R    USER IO 31-0 current state
#define PL820IS_USRIN1                 0x30A4     // R    USER IO 63-32 current state
#define PL820IS_USRIN2                 0x30A8     // R    USER IO 95-64 current state
#define PL820IS_USRIN3                 0x30AC     // R    USER IO 104-96 current state

// SPI0 section (user)
#define PL820IS_SPI0_CFG               0x3100     // W    SPI0 configuration register
#define PL820IS_SPI0_STS               0x3104     // R    SPI0 status register
#define PL820IS_SPI0_ODT0              0x3108     // W    SPI0 output data register bits 31-0
#define PL820IS_SPI0_ODT1              0x310C     // W    SPI0 output data register bits 63-32
#define PL820IS_SPI0_IDT0              0x3110     // R    SPI0 input bits 31-0 data register bits 31-0
#define PL820IS_SPI0_IDT1              0x3114     // R    SPI0 input bits 63-32 data register bits 63-32
#define PL820IS_SPI0_IADDR             0x3118     // R    SPI0 input address bits register
#define PL820IS_SPI0_ACFG              0x311C     // W    SPI0 address configuration register
#define PL820IS_SPI0_REG0              0x3120     // W    SPI0 register pool, 8 32-bit registers
#define PL820IS_SPI0_REG1              0x3124     // R/W
#define PL820IS_SPI0_REG2              0x3128     // R/W
#define PL820IS_SPI0_REG3              0x312C     // R/W
#define PL820IS_SPI0_REG4              0x3130     // R/W
#define PL820IS_SPI0_REG5              0x3134     // R/W
#define PL820IS_SPI0_REG6              0x3138     // R/W
#define PL820IS_SPI0_REG7              0x313C     // R/W

// SPI1 section (user)
#define PL820IS_SPI1_CFG               0x3180     // W    SPI1 configuration register
#define PL820IS_SPI1_STS               0x3184     // R    SPI1 status register
#define PL820IS_SPI1_ODT0              0x3188     // W    SPI1 output data register bits 31-0
#define PL820IS_SPI1_ODT1              0x318C     // W    SPI1 output data register bits 63-32
#define PL820IS_SPI1_IDT0              0x3190     // R    SPI1 input bits 31-0 data register bits 31-0
#define PL820IS_SPI1_IDT1              0x3194     // R    SPI1 input bits 63-32 data register bits 63-32
#define PL820IS_SPI1_IADDR             0x3198     // R    SPI1 input address bits register
#define PL820IS_SPI1_ACFG              0x319C     // W    SPI1 address configuration register
#define PL820IS_SPI1_REG0              0x31A0     // R/W  SPI1 register pool, 8 32-bit registers
#define PL820IS_SPI1_REG1              0x31A4     // R/W
#define PL820IS_SPI1_REG2              0x31A8     // R/W
#define PL820IS_SPI1_REG3              0x31AC     // R/W
#define PL820IS_SPI1_REG4              0x31B0     // R/W
#define PL820IS_SPI1_REG5              0x31B4     // R/W
#define PL820IS_SPI1_REG6              0x31B8     // R/W
#define PL820IS_SPI1_REG7              0x31BC     // R/W


//            PL820IS_CFG                                      0x3000             // R/W  General configuration register
#define PL820IS_CFG_ADCR               (1L<<3)    // 1 - reset ADC
#define PL820IS_CFG_SPI1R              (1L<<2)    // 1 - reset user SPI1
#define PL820IS_CFG_SPI0R              (1L<<1)    // 1 - reset user SPI0
#define PL820IS_CFG_LED                (1L<<0)    // 1 - turn ON user LED

//            PL820IS_STS                                       0x3004             // R        General status register
#define PL820IS_STS_ADCDR              (1L<<18)   // 1 - data ready from ADC (cleared after read)
#define PL820IS_STS_SPI1DR             (1L<<17)   // 1 - data ready from SPI1 (cleared after read)
#define PL820IS_STS_SPI0DR             (1L<<16)   // 1 - data ready from SPI0 (cleared after read)

        // Current (static) status bits
#define PL820IS_STS_SPI1BSY            (1L<<9)    // 1 - SPI1 busy
#define PL820IS_STS_SPI0BSY            (1L<<8)    // 1 - SPI0 busy
#define PL820IS_STS_LVER7              (1L<<7)    // Report logic version
#define PL820IS_STS_LVER0              (1L<<0)    //

//            PL820IS_IER                                       0x3010             // W       Interrupt enable register
//            PL820IS_ISR                                       0x3014             // R        Interrupt status register
//            PL820IS_ICR                                       0x3018             // R        Interrupt clear register
#define PL820IS_IR_ADCDR               (1L<<5)    // 1 - data ready from ADC
#define PL820IS_IR_SPI1WR              (1L<<3)    // 1 - SPI1 write request (RX data received)
#define PL820IS_IR_SPI1RDY             (1L<<2)    // 1 - SPI1 ready (detects end of "busy")
#define PL820IS_IR_SPI0WR              (1L<<1)    // 1 - SPI0 write request (RX data received)
#define PL820IS_IR_SPI0RDY             (1L<<0)    // 1 - SPI0 ready (detects end of "busy")

//            PL820IS_NISMD0                             0x3040             // W       NIS IO31-0 mode (0-default 1-test;
//                            NIS-IO 2, 4, 8, 12, 16 excluded)
//            PL820IS_NISMD1                             0x3044             // W       NIS IO 63-32 mode (0-default 1-test;
//                            NIS-IO 39 excluded)
//            PL820IS_NISDIR0                              0x3048             // W       NIS IO 31-0 direction in test mode (1-output)
//            PL820IS_NISDIR1                              0x304C             // W       NIS IO 63-32 direction in test mode (1-output)
//            PL820IS_NISOUT0                            0x3040             // R/W  NIS IO 31-0 value when test mode is enabled
//                            and direction is output; read return last
//                            written value
//            PL820IS_NISOUT1                            0x3044             // R/W  NIS IO 63-32 value when test mode is enabled
//                                                                                                                                                            //                            and direction is output; read return last
//                                                                                                                                                            //                            written value
//            PL820IS_NISIN0                                0x3048             // R        NIS IO 31-0 current state
//            PL820IS_NISIN1                                0x304C             // R        NIS IO 63-0 current state
// All registers above are 32-bit wide; bits 2, 4, 8, 12, 16, 39 are always written with 0s
#define PL820_NIS0_MASK (~0x00011114L)
#define PL820_NIS1_MASK (~0x00000080L)

//            PL820IS_ADC0                   0x3050             // R        ADC Channel 0 data (3+16LSB valid)
//            PL820IS_ADC1                   0x3054             // R        ADC Channel 1 data (3+16LSB valid)
//            PL820IS_ADC2                   0x3058             // R        ADC Channel 2 data (3+16LSB valid)
//            PL820IS_ADC3                   0x305C             // R        ADC Channel 3 data (3+16LSB valid)
//            PL820IS_ADCTC                                0x3060             // R        ADC Channel Temperature data (3+16LSB valid)
#define PL820IS_ADCCH_V3        0                      // ADC channel 3
#define PL820IS_ADCCH_V2        1                      // ADC channel 2
#define PL820IS_ADCCH_V1        2                      // ADC channel 1
#define PL820IS_ADCCH_V0        3                      // ADC channel 0
#define PL820IS_ADCCH_TEMP      4                      // Internal ADC channel number for temperature

//            PL820IS_USRDIR0                0x3080             // W    USER IO 31-0 direction (1-output)
//            PL820IS_USRDIR1                0x3084             // W    USER IO 63-32 direction (1-output)
//            PL820IS_USRDIR2                0x3088             // W    USER IO 95-64 direction (1-output)
//            PL820IS_USRDIR3                0x308C             // W    USER IO 104-96 direction (1-output)
//            PL820IS_USROUT0                0x3090             // R/W  USER IO 31-0 value
//            PL820IS_USROUT1                0x3094             // R/W  USER IO 63-32 value
//            PL820IS_USROUT2                0x3098             // R/W  USER IO 95-64 value
//            PL820IS_USROUT3                0x309C             // R/W  USER IO 104-96 value
//            PL820IS_USRIN0                 0x30A0             // R    USER IO 31-0 current state
//            PL820IS_USRIN1                 0x30A4             // R    USER IO 63-32 current state
//            PL820IS_USRIN2                 0x30A8             // R    USER IO 95-64 current state
//            PL820IS_USRIN3                 0x30AC            // R     USER IO 104-96 current state
// All registers above are 32-bit wide however only bits 8:0  are utilized for xx_USRxx3 registers
#define PL820IS_USR_IO_REG3_E  104      // Register 3 - I/O 104-83  (Lower connector)
#define PL820IS_USR_IO_REG3_S   83
#define PL820IS_USR_IO_REG2_E   82      // Register 2 - I/O 82-51  (Lower connector)
#define PL820IS_USR_IO_REG2_S   51
#define PL820IS_USR_IO_REG1_E   50      // Register 3 - I/O 50-32  (Upper connector)
#define PL820IS_USR_IO_REG1_S   32
#define PL820IS_USR_IO_REG0_E   31      // Register 1 - I/O 0-32  (Upper connector)
#define PL820IS_USR_IO_REG0_S    0

//            PL820IS_SPI0_CFG               0x3100             // W     SPI0 configuration register
//            PL820IS_SPI0_STS               0x3104             // R     SPI0 status register
//            PL820IS_SPI0_ODT0              0x3108             // W     SPI0 output data register bits 31-0
//            PL820IS_SPI0_ODT1              0x310C             // W     SPI0 output data register bits 63-32
//            PL820IS_SPI0_IDT0              0x3110             // R     SPI0 input bits 31-0 data register bits 31-0
//            PL820IS_SPI0_IDT1              0x3114             // R     SPI0 input bits 63-32 data register bits 63-32
//            PL820IS_SPI0_IADDR             0x3118             // R     SPI0 input address bits register

//            PL820IS_SPI1_CFG               0x3180             // W     SPI1 configuration register
//            PL820IS_SPI1_STS               0x3184             // R     SPI1 status register
//            PL820IS_SPI1_ODT0              0x3188             // W     SPI1 output data register bits 31-0
//            PL820IS_SPI1_ODT1              0x318C             // W     SPI1 output data register bits 63-32
//            PL820IS_SPI1_IDT0              0x3190             // R     SPI1 input bits 31-0 data register bits 31-0
//            PL820IS_SPI1_IDT1              0x3194             // R     SPI1 input bits 63-32 data register bits 63-32
//            PL820IS_SPI0_IADDR             0x3198             // R     SPI1 input address bits register

#define PL820IS_SPI_CFG_CSI            (1L<<31)     // Invert SCS if 1
#define PL820IS_SPI_CFG_ABE_E          29           // Address bit MSB set to "PL820IS_SPI_CFG_DBE"
#define PL820IS_SPI_CFG_ABE(D)         ((D)<<24)    // if address is unused
#define PL820IS_SPI_CFG_PSR            (1L<<23)     // If==1 - receive data is valid on rising edge of the clock
#define PL820IS_SPI_CFG_ABS_E          21           // Address bit LSB set to 0 if address is unused
#define PL820IS_SPI_CFG_ABS(D)         ((D)<<16)    //
#define PL820IS_SPI_CFG_PSW            (1L<<15      // If==1 - transmit data is valid on rising edge of the clock
#define PL820IS_SPI_CFG_DBE_E          13           // Data bit MSB
#define PL820IS_SPI_CFG_DBE(D)         ((D)<<8)     //
#define PL820IS_SPI_CFG_MWE            (1L<<7)      // 1 auto-increment address once RX SPI data is latched
#define PL820IS_SPI_CFG_DBS_E          5            // Data bit LSB
#define PL820IS_SPI_CFG_DBS(D)         ((D)&0x3f)   //

#define PL820IS_SPI_ACFG_REN           (1L<<31)     // register pool read enabled
#define PL820IS_SPI_ACFG_WEN           (1L<<23)     // register pool write enabled
#define PL820IS_SPI_ACFG_RAD(N)        (((N)&0xff)<<8)     // read address
#define PL820IS_SPI_ACFG_WAD(N)        ((N)&0xff)          // write address



#define PL820IS_E                                     0x33FC             // Last address in CPLD address space


// setparam_820 commands
#define DQL_IOCTL820_SETCHNL_CFG    1

#define PL608_PRMFPGA_SPI1       (1L<<8)     // configure SPI1 (FPGA)
#define PL608_PRMFPGA_SPI0       (1L<<7)     // configure SPI0 (FPGA)

#define PL608_PRMCPLD_SPI1       (1L<<6)     // configure SPI1 (CPLD)
#define PL608_PRMCPLD_SPI0       (1L<<5)     // configure SPI0 (CPLD)

#define PL608_PRMFPGA_PLL1       (1L<<4)     // configure PLL1 (FPGA)
#define PL608_PRMFPGA_PLL0       (1L<<3)     // configure PLL0 (CyclonIII required)

#define PL608_PRMCPLD_PORT       (1L<<2)     // configure port side
#define PL608_PRMCPLD_NIS        (1L<<1)     // configure NIS side
#define PL608_PRMFPGA_NIS        (1L<<0)     // configure NIS side


typedef struct {
    uint32 prm_flags;   // flags to validate following parameters

    // Control external pins
    uint32 port_dir[DQ_PL820_PORTS];   // direction of the user pins on DB62 connectors (input or output)
    uint32 port_out[DQ_PL820_PORTS];   // output values

    // PLL section
    uint32 pll_freq[DQ_PL820_NIS_PORTS]; // requested PLL frequency in Hz, or M/N/C/Post
    uint32 pll_div[DQ_PL820_NIS_PORTS];  // post-divider

    // SPI configuration
    uint32 spi_cfg_fpga[DQ_PL820_NIS_PORTS];    // SPIx configuration
    uint32 spi_wm[DQ_PL820_NIS_PORTS];     // SPIx watermark register
    uint32 spi_acfg[DQ_PL820_NIS_PORTS];   // SPIx address configuration register
    uint32 spi_div[DQ_PL820_NIS_PORTS];    // SPIx clock divider from PLL0 (24MHz default)
    uint32 spi_cfg_cpld[DQ_PL820_NIS_PORTS];    // SPIx configuration

    // NIS connects FPGA and CPLD. There are 64 pins total for the exception of pins 2,4,8,12,16 and 39
    // When direction is set to input on FPGA a command is sent mirror FPGA configuration
    // <nis_dir> and <nis_out> is from FPGA side.
    uint32 nis_dir[DQ_PL820_NIS_PORTS];   // direction of NIS pins (input or output)
    uint32 nis_out[DQ_PL820_NIS_PORTS];   // output values for FPGA
    uint32 nis_out_cpld[DQ_PL820_NIS_PORTS];   // output values for CPLD

} PL820CFG, *pPL820CFG;


#define DQ_PL820_NAMELEN             32          // maximum length of the channel name (trailing 0 isn't included)
#define DQ_PL820_MAXINITSPI          32          // maximum number of words to output to SPI upon initialization

// channel names
typedef struct {
    char cname[DQ_PL820_CHAN][DQ_PL820_NAMELEN];
} DQCNAMES_820_, *pDQCNAMES_820_;

//
// Parameters to set in initialization and shutdown modes:
// Driver automatically configures the following parameters upon entering initialization
// and shutdown mode. If 0 == valid_prm nothing is configured
//
#define PL820_VALIDPRM_SPI1      (1L<<5)    // SPI1
#define PL820_VALIDPRM_SPI0      (1L<<4)    // SPP0
#define PL820_VALIDPRM_PLL1      (1L<<3)    // PLL1
#define PL820_VALIDPRM_PLL0      (1L<<2)    // PLL0
#define PL820_VALIDPRM_PORT      (1L<<1)    // User pins - direction and output value
#define PL820_VALIDPRM_NIS       (1L<<0)    // NIS pins - direction and output values


typedef struct {
    uint32 valid_prm;               // which parameters are valid for init mode

    // how to set up NIS interface between FPGA and CPLD
    uint32 nis_dir[DQ_PL820_NIS_PORTS];   // direction of NIS pins (input or output)
    uint32 nis_out[DQ_PL820_NIS_PORTS];   // output values
    uint32 nis_out_cpld[DQ_PL820_NIS_PORTS];   // output values for CPLD

    uint32 lcfg;                    // layer configuration
    uint32 icfg;                    // CPLD layer configuration

    // PLL section
    uint32 pll_freq[DQ_PL820_NIS_PORTS]; // requested PLL frequency in Hz, or M/N/C/Post
    uint32 pll_div[DQ_PL820_NIS_PORTS];  // post-divider

    // SPI configuration
    uint32 spi_cfg_fpga[DQ_PL820_NIS_PORTS];    // SPIx configuration
    uint32 spi_wm[DQ_PL820_NIS_PORTS];     // SPIx watermark register
    uint32 spi_acfg[DQ_PL820_NIS_PORTS];   // SPIx address configuration register
    uint32 spi_div[DQ_PL820_NIS_PORTS];    // SPIx clock divider from PLL0 (24MHz default)
    uint32 spi_cfg_cpld[DQ_PL820_NIS_PORTS];    // SPIx configuration

    // how to set up output lines (CPLD side, optional)
    uint32 port_dir[DQ_PL820_PORTS];     // I/O mask: 0 means input
    uint32 port_out[DQ_PL820_PORTS];     // line states in ops mode for the line if I/O mask==1b

    uint32 spiN[DQ_PL820_NIS_PORTS];       // number of initialization words
    uint32 spi0upon[DQ_PL820_MAXINITSPI];    // output for SPI0 interface upon entering initialization mode
    uint32 spi1upon[DQ_PL820_MAXINITSPI];    // output for SPI1 interface upon entering initialization mode
} DQINITPRM_820_, *pDQINITPRM_820_;

typedef struct {
    uint32 valid_prm;               // which parameters are valid for operation mode

    uint32 port_dir[DQ_PL820_PORTS]; // I/O mask
    uint32 port_out[DQ_PL820_PORTS]; // line states in init mode
    uint32 lcfg;                    // layer configuration
    uint32 icfg;                    // CPLD layer configuration
} DQOPMODEPRM_820_, *pDQOPMODEPRM_820_;

typedef struct {

    uint32 valid_prm;               // which parameters are valid for shutdown mode

    // how to set up NIS interface between FPGA and CPLD
    uint32 nis_dir[DQ_PL820_NIS_PORTS];   // direction of NIS pins (input or output)
    uint32 nis_out[DQ_PL820_NIS_PORTS];   // output values
    uint32 nis_out_cpld[DQ_PL820_NIS_PORTS];   // output values for CPLD

    uint32 lcfg;                    // layer configuration
    uint32 icfg;                    // CPLD layer configuration

    // PLL section
    uint32 pll_freq[DQ_PL820_NIS_PORTS]; // requested PLL frequency in Hz, or M/N/C/Post
    uint32 pll_div[DQ_PL820_NIS_PORTS];  // post-divider

    // SPI configuration
    uint32 spi_cfg_fpga[DQ_PL820_NIS_PORTS];    // SPIx configuration
    uint32 spi_wm[DQ_PL820_NIS_PORTS];     // SPIx watermark register
    uint32 spi_acfg[DQ_PL820_NIS_PORTS];   // SPIx address configuration register
    uint32 spi_div[DQ_PL820_NIS_PORTS];    // SPIx clock divider from PLL0 (24MHz default)
    uint32 spi_cfg_cpld[DQ_PL820_NIS_PORTS];    // SPIx configuration

    // how to set up output lines (CPLD side, optional)
    uint32 port_dir[DQ_PL820_PORTS];     // I/O mask: 0 means input
    uint32 port_out[DQ_PL820_PORTS];     // line states in ops mode for the line if I/O mask==1b

    uint32 spiN[DQ_PL820_NIS_PORTS];       // number of initialization words
    uint32 spi0upon[DQ_PL820_MAXINITSPI];    // output for SPI0 interface upon entering initialization mode
    uint32 spi1upon[DQ_PL820_MAXINITSPI];    // output for SPI1 interface upon entering initialization mode
} DQSDOWNPRM_820_, *pDQSDOWNPRM_820_;

/* specific device structure - calibration values */
typedef struct {
    uint8 valid_prm;                // which parameters are valid
    uint32 param[DQ_PL820_MAXINITSPI]; //
} DQCALSET_820_, *pDQCALSET_820_;


// combined structure to be allocated after CMNDEVS
typedef struct {
    DQEECMNDEVS ee;
    DQCALSET_820_ calset;
    DQOPMODEPRM_820_ opmodeprm;
    DQINITPRM_820_ initprm;
    DQSDOWNPRM_820_ sdownprm;
    DQCNAMES_820_ cname;
    DQPRMFLAGS eeflags;
} DEVEEPROM_820_, *pDEVEEPROM_820_;


#define DQ_L90x_CHAN                2
#define DQ_L90x_INFOSZ              DQ_MAX_INFO_SIZE      // maximum size of information structure
#define DQ_L90x_BASE                66000000    // 66MHz base frequency


#define DQ_L90x_NAMELEN             32          // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cname[DQ_L90x_CHAN][DQ_L90x_NAMELEN];
} DQCNAMES_90x_, *pDQCNAMES_90x_;

typedef struct {
    uint32 mask;                    // change-of-state mask
} DQOPMODEPRM_90x_, *pDQOPMODEPRM_90x_;

typedef struct {
    uint32 val;                     // line states in init mode
} DQINITPRM_90x_, *pDQINITPRM_90x_;

typedef struct {
    uint32 val;                     // line states in shutdown mode
} DQSDOWNPRM_90x_, *pDQSDOWNPRM_90x_;


#define DQ_DIO_440_DATA_WORDS       (4)
#define DQ_DIO_470_CHAN             (1)     // number of channels for different boards
#define DQ_PC_91x_OCHAN             (2)
#define DQ_PC_91x_ICHAN             (5)
#define DQ_PC_921_ICHAN             (5)
#define DQ_PC_925_ICHAN             (4)
#define DQ_PC_926_ICHAN             (4)
#define DQ_PC_927_ICHAN             (4)
#define DQ_PC_91x_CL_MASK           (0x7)
#define DQ_PC_91x_INFOSZ            (DQ_MAX_INFO_SIZE)  // maximum size of information structure
#define DQ_PC_91x_BASE              (66000000)  // 66MHz base frequency

// PC-91X, PC-921 and PC-926 Read ADC conversion factors
#define DQ_PC91X_AI_SPAN            (2.5)       // ADC reference voltage
#define DQ_PC91X_OFFSET             (DQ_PC91X_AI_SPAN/2.0)
#define DQ_PC91X_STEP               (DQ_PC91X_AI_SPAN/(double)0xffff)
#define DQ_PC91X_V_SCALER           (42.667)    //  voltage scaling factor, ADC0,ADC2,ADC3
#define DQ_PC91X_I_SCALER_TH        (166.5)     //  current scaling factor, rev1 pcb
#define DQ_PC91X_I_SCALER_INT       (61.5)      //  current scaling factor, revA pcb
#define DQ_PC91X_I_SCALER_EXT       (83.5)      //  current scaling factor, revA pcb
                                                // temperature scaling is dependent upon reference voltage
#define DQ_PC91X_T_SLOPE            (0.0000935 / (DQ_PC91X_AI_SPAN / (double)0xffff))  // ADC counts per deg C, ADC4
#define DQ_PC91X_T_OFFSET           (273.0)     // kelvin to deg C
#define DQ_PC91X_DEF_OFFSET_CAL     (0)
#define DQ_PC91X_MAX_OFFSET_CAL_DEV (0x1000)    //
#define DQ_PC91X_DEF_GAIN_CAL       (0x8000)
#define DQ_PC91X_MAX_GAIN_CAL_DEV   (3277)
#define DQ_PC91X_MIN_ADC_WAIT       (160)       // minimum # of milliseconds between ADC reads
#define DQ_PC91X_ADC_EOC            (1L<<18)
#define DQ_PC91X_ADC_SIG            (1L<<16)
#define DQ_PC91X_ADC_MSB            (1L<<15)

#define DQ_PC921_V_SCALER_02        (42.667)    //  voltage scaling factor, ADC0,ADC2
#define DQ_PC921_V_SCALER_3         (5.167)     //  voltage scaling factor, ADC3
#define DQ_PC921_I_SCALER_1         (-235.0)    //  current scaling factor

#define DQ_PC926_V_SCALER_02        (42.667)    //  voltage scaling factor, ADC0,1,ADC2
#define DQ_PC926_V_SCALER_3         (106.24)    //  voltage scaling factor, ADC3

// PC-91X ADC channel assignments, used by DqAdv91xRead() for bdata[] and fdata[]
#define DQ_PC91X_CH_EXT_V           (0)         // volts   external JIO connector
#define DQ_PC91X_CH_INPUT_I         (1)         // amps    current used by DC/DC converters
#define DQ_PC91X_CH_INT_V           (2)         // volts   internal DNx system power
#define DQ_PC91X_CH_DCDC_INPUT_V    (3)         // volts   voltage at input to DC/DC
#define DQ_PC91X_CH_THERM           (4)         // degrees C    temperature in the ADC IC

// PC-921 ADC channel assignments, used by DqAdv921Read() for bdata[] and fdata[]
#define DQ_PC921_CH_HOLD_V          (0)         // volts   external JIO connector
#define DQ_PC921_CH_INPUT_I         (1)         // amps    current used by DC/DC converters
#define DQ_PC921_CH_INT_V           (2)         // volts   internal DNx system power
#define DQ_PC921_CH_3_3_V           (3)         // volts   voltage at input to DC/DC
#define DQ_PC921_CH_THERM           (4)         // degrees C    temperature inside the ADC IC

// PC-926 ADC channel assignments, used by DqAdv926Read() for bdata[] and fdata[]
#define DQ_PC926_CH_V24             (0)         // volts   input DNx system power
#define DQ_PC926_CH_24V             (1)         // volts   24V bus DNx system power
#define DQ_PC926_CH_100V            (2)         // volts   voltage at fan
#define DQ_PC926_CH_THERM           (3)         // degrees C    temperature inside the ADC IC

// PC-927 ADC channel assignments, used by DqAdv926Read() for bdata[] and fdata[]
#define DQ_PC927_CH_VIN2            (0)         // volts   ADC Channel 0 data (3+16LSB valid), VIN2
#define DQ_PC927_CH_VPOE            (1)         // volts   ADC Channel 1 data (3+16LSB valid), VPOE
#define DQ_PC927_CH_VIN1            (2)         // volts   ADC Channel 2 data (3+16LSB valid),    VIN1
#define DQ_PC927_CH_VDNA            (3)         // volts   ADC Channel 3 data (3+16LSB valid),  VDNA

// PC-925 Read ADC conversion factors
#define DQ_PC925_AI_SPAN            (2.5)       // ADC reference voltage
#define DQ_PC925_OFFSET             (DQ_PC91X_AI_SPAN/2.0)
#define DQ_PC925_STEP               (DQ_PC91X_AI_SPAN/(double)0xffff)
#define DQ_PC925_I_SCALER           (1.2195)    //  current scaling factor, ADC0
#define DQ_PC925_V_SCALER_I         (42.667)    //  voltage scaling factor, ADC1
#define DQ_PC925_V_SCALER_F         (14.75)     //  voltage scaling factor, ADC2
#define DQ_PC925_T_SLOPE            (0.0000935 / (DQ_PC925_AI_SPAN / (double)0xffff))//  ADC counts per deg C, ADC4
#define DQ_PC925_T_OFFSET           (273.0)     //  kelvin to deg C
#define DQ_PC925_DEF_OFFSET_CAL     (0)
#define DQ_PC925_MAX_OFFSET_CAL_DEV (0x1000)    //
#define DQ_PC925_DEF_GAIN_CAL       (0x8000)
#define DQ_PC925_MAX_GAIN_CAL_DEV   (3277)
#define DQ_PC925_MIN_ADC_WAIT       (160)       // minimum # of milliseconds between ADC reads
#define DQ_PC925_ADC_EOC            (1L<<18)
#define DQ_PC925_ADC_SIG            (1L<<16)
#define DQ_PC925_ADC_MSB            (1L<<15)
#define DQ_PC925_RPM_FACTOR         (46.875)

// PC-926 Read ADC conversion factors
#define DQ_PC926_AI_SPAN            (2.5)
#define DQ_PC926_OFFSET             (DQ_PC91X_AI_SPAN/2.0)
#define DQ_PC926_STEP               (DQ_PC91X_AI_SPAN/(double)0xffff)
#define DQ_PC926_GND_SCALER         (42.667)    // current scaling factor, ADC0 -  ground
#define DQ_PC926_V24_SCALER         (42.667)    // voltage scaling factor, ADC1 -  V24
#define DQ_PC926_24V_SCALER         (42.667)    // voltage scaling factor, ADC2 -  24V
#define DQ_PC926_100V_SCALER        (204.5)     // voltage scaling factor, ADC3 - 100V
#define DQ_PC926_T_SLOPE            (0.0000935 / (DQ_PC926_AI_SPAN / (double)0xffff))      //  ADC counts per deg C, ADC4
#define DQ_PC926_T_OFFSET           (273.0)     //  kelvin to deg C
#define DQ_PC926_DEF_OFFSET_CAL     (0)
#define DQ_PC926_MAX_OFFSET_CAL_DEV (0x1000)    //
#define DQ_PC926_DEF_GAIN_CAL       (0x8000)
#define DQ_PC926_MAX_GAIN_CAL_DEV   (3277)
#define DQ_PC926_MIN_ADC_WAIT       (160)       // minimum # of milliseconds between ADC reads
#define DQ_PC926_ADC_EOC            (1L<<18)
#define DQ_PC926_ADC_SIG            (1L<<16)
#define DQ_PC926_ADC_MSB            (1L<<15)


#define DQ_PC925_FAN_OFF_TEMP       (15.0)      // when fans are turned off
#define DQ_PC925_FAN_ON_TEMP        (45.0)      // when fans are turned on

#define DQ_PC926_FAN_OFF_TEMP       (35.0)      // when fans are turned off
#define DQ_PC926_FAN_ON_TEMP        (45.0)      // when fans are turned on

// DIO-440 ADC constants
#define DQ_DIO440_V_SCALER          (201.4)     // voltage scaling factor

// MUX-461 ADC constants
#define DQ_MUX461_V_SCALER          (23.1)     // voltage scaling factor

// PC-925 ADC channel assignments, used by DqAdv925Read() for bdata[] and fdata[]
#define DQ_PC925_CH_FAN_I           (0)         // amps    current used by fan
#define DQ_PC925_CH_INPUT_V         (1)         // volts   internal DNx system power
#define DQ_PC925_CH_FAN_V           (2)         // volts   voltage at input to fan
#define DQ_PC925_CH_THERM           (3)         // degrees C    temperature in the ADC IC

// bit defines for status returned by DqAdv91xRead()
#define DQ_91X_STS_JMAIN_ON         (1L<<2)     // = 1 if JMAIN (DNA) internal is used as a power source
#define DQ_91X_STS_JIO_ON           (1L<<1)     // = 1 if JIO (Front connector) is used as a power source

                                                // See if input power is connected via the DB-37 connector.
#define DQ_91X_STS_JIO              (1L<<0)     // JIO Input Power status, 0=no power detected, 1= power ON

// bit defines for status returned by DqAdv921Read()
#define DQ_PC921_STS_PFAIL          (1L<<6)     // = 0 - power failure is detected
#define DQ_PC921_STS_IN3            (1L<<5)     // Current value of NIS-IN3 pin  (db37 pin 12)
#define DQ_PC921_STS_IN2            (1L<<4)     // Current value of NIS-IN2 pin  (db37 pin 13)
#define DQ_PC921_STS_IN1            (1L<<3)     // Current value of NIS-IN1 pin  (db37 pin 14)
#define DQ_PC921_STS_IN0            (1L<<2)     // Current value of NIS-IN0 pin  (db37 pin 15)
#define DQ_PC921_STS_CCHRG          (1L<<1)     // =0 - hold-up capacitor is charged
#define DQ_PC921_STS_CDCHRG         (1L<<0)     // =0 - hold-up capacitor is discharged

// bit defines for status returned by DqAdv925Read()
#define DQ_925_STS_FAN_ROTATING     (1L<<1)     // = 1 if fan is rotating
#define DQ_925_STS_FAN_PWR_ON       (1L<<0)     // = 1 if fan power is turned ON

// PC-921  subcommand for DQIOCTL_SETPARAM used by DAQLib DqAdv921SetConfig() function
#define DQ_PC921_CONFIG_SETTINGS    (0x11)
// PC-91x  subcommand for DQIOCTL_SETPARAM
#define DQ_PC91x_CONFIG_SETTINGS    (0x12)      //
// DIO-470 subcommand for DQIOCTL_SETPARAM used by DAQLib function DqAdv470Settings();
#define DQ_DIO470_SETPARAM_SETTINGS (0x10)      // set delay in mSec, 16-bit value, used to protect relays from switching too fast.
                                                // Can also set dynamic control on or off
#define DQ_DIO470_SETPARAM_MIN_DELAY (5)        // minimum settable delay value.
#define DQ_DIO470_DEFAULT_DELAY      (7)        // default delay in milliseconds
#define DQ_DIO470_SETPARAM_MAX_DELAY (65540)    // maximum settable delay value.

#define DQ_PC92x_CHECK_us           (100*1000)  // how often to check for temperature and control fans

// DIO-440 subcommand for DQIOCTL_SETPARAM used by DAQLib function DqAdv440Write();
#define DQ_DIO440_SETPARAM_WRITE    (0x12)      //
#define DQ_PC921_CFG_POFF_EN        (1L<<31)    // 921 =1 Turn off main power
#define DQ_PC921_CFG_DCDC_EN        (1L<<30)    // 921 =1 Enable IS/SYNC DC/DC
#define DQ_PC921_CFG_IN_PWR_EN      (1L<<29)    // =1 Input selected by INSELn will turn OFF main power when input is 0V
#define DQ_PC921_CFG_INSEL1         (1L<<28)    // Select input for power control, msbit
#define DQ_PC921_CFG_INSEL0         (1L<<27)    // Select input for power control, lsbit
#define DQ_PC921_CFG_IN_0_PWR_OFF   (DQ_PC921_CFG_IN_PWR_EN                                        )
#define DQ_PC921_CFG_IN_1_PWR_OFF   (DQ_PC921_CFG_IN_PWR_EN|DQ_PC921_CFG_INSEL0                    )
#define DQ_PC921_CFG_IN_2_PWR_OFF   (DQ_PC921_CFG_IN_PWR_EN|                    DQ_PC921_CFG_INSEL1)
#define DQ_PC921_CFG_IN_3_PWR_OFF   (DQ_PC921_CFG_IN_PWR_EN|DQ_PC921_CFG_INSEL0|DQ_PC921_CFG_INSEL1)
#define DQ_PC921_CFG_PWR_ON         (0)
#define DQ_PC921_CFG_MASK           (DQ_PC921_CFG_IN_PWR_EN|DQ_PC921_CFG_INSEL0|DQ_PC921_CFG_INSEL1|DQ_PC921_CFG_POFF_MASK|DQ_PC921_CFG_POFF_EN)
#define DQ_PC921_CFG_POFF_CODE      (0xB0FF)    // magic number to enable power off
#define DQ_PC921_CFG_POFF_MASK      (0xFFFF)    // mask for magic number

#define DQ_PC927_CFG_POFF_MASK      (DQ_91X_CFG_DCEN1|DQ_91X_CFG_DCEN2|DQ_91X_CFG_DCEN3)

// for mapped modes, the user must combine the delay and the port values.
// A register setting of zero will give DQ_DIO470_SETPARAM_MIN_DELAY
#define DIO470_DIOCFG_DLY15         (1L<<31)    // Minimum delay between updates to the relay output, 0-65535 corresponds
#define DIO470_DIOCFG_DLY0          (1L<<16)    //  to 5-65540mS, used to protect relays from switching too fast
#define DIO470_DIOCFG_DLY_SHIFT     (16)
#define DIO470_DIOCFG_DLY_MASK      (0xffff0000)
#define DIO470_DIOCFG_DATA_MASK     (0x000003FF)

#define DIO_470_DIOCFG_OUT9         (1L<<9)     // 10-bit output port msb ( relay 9 )
#define DIO_470_DIOCFG_OUT0         (1L<<0)     // 10-bit output port lsb ( relay 0 )


#define DQ_PC921_SYNCCFG_OV3_HI     (1L<<11)    // high for the OUT3 pin when SRC3 = 0
#define DQ_PC921_SYNCCFG_OV2_HI     (1L<<10)    //                 2             2
#define DQ_PC921_SYNCCFG_OV1_HI     (1L<<9)     //                 1             1
#define DQ_PC921_SYNCCFG_OV0_HI     (1L<<8)     //                 0             0
#define DQ_PC921_SYNCCFG_OV3_LO     (0)         // low for the OUT3 pin when SRC3 = 0
#define DQ_PC921_SYNCCFG_OV2_LO     (0)         //                2             2
#define DQ_PC921_SYNCCFG_OV1_LO     (0)         //                1             1
#define DQ_PC921_SYNCCFG_OV0_LO     (0)         //                0             0
#define DQ_PC921_SYNCCFG_SRC3       (1L<<7)     // Select source for the OUT3 pin 16, 1 = SYNC3, 0 = OV3
#define DQ_PC921_SYNCCFG_SRC2       (1L<<6)     //                          2     17          2        2
#define DQ_PC921_SYNCCFG_SRC1       (1L<<5)     //                          1     18          1        1
#define DQ_PC921_SYNCCFG_SRC0       (1L<<4)     //                          0     19          0        0
#define DQ_PC921_SYNCCFG_S3EN       (1L<<3)     // =1 - enable output onto SYNC3 bus, driven by IN3 pin 12
#define DQ_PC921_SYNCCFG_S2EN       (1L<<2)     //                             2                  2     13
#define DQ_PC921_SYNCCFG_S1EN       (1L<<1)     //                             1                  1     14
#define DQ_PC921_SYNCCFG_S0EN       (1L<<0)     //                             0                  0     15

#define DQ_PC921_SYNCCFG_PWR_MASK   (DQ_PC921_SYNCCFG_OV3_HI|DQ_PC921_SYNCCFG_SRC3)

#define DQ_PC_91X_CFG_EJIO          (1L<<31)
#define DQ_91X_CFG_DCEN3            (1L<<30)     // =1 Enable DC/DC 3
#define DQ_91X_CFG_DCEN2            (1L<<29)     // =1 Enable DC/DC 2
#define DQ_91X_CFG_DCEN1            (1L<<28)     // =1 Enable DC/DC 1
#define DQ_PC_91X_CFG_AUTO          (1L<<27)


// defines for user control of PC-925 or PC-91x output voltages using vsel parameter of DqAdv91xSetConfig()
#define DQ_925_FAN_OFF              (0)                                 // PC-925 fan off
#define DQ_925_FAN_ON               (DQ_91X_CFG_DCEN1)                  // =1 Enable fan on 925

#define DQ_91X_POWER_OFF            (0)                                 // power off,  PC-910, PC-911, PC-912, PC-913

#define DQ_910_P10_15W              (DQ_91X_CFG_DCEN1)                  // + 10V 15Watts  PC-910
#define DQ_910_P10_N10_30W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN3) // +-10V 30Watts
#define DQ_910_N10_15W              (DQ_91X_CFG_DCEN3)                  //  -10V 15Watts


// PC-911 voltages  FOR PCB REVISION 100
#define DQ_911_P5_N5_12W            (DQ_91X_CFG_DCEN2)                  // +-4.33V 12Watts   PC-911
#define DQ_911_P10_N10_24W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN3) // +-9.66V 24Watts
#define DQ_911_P15_N15_36W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN2+DQ_91X_CFG_DCEN3) // +-15V 36Watts
#define DQ_911_P15_N5_24W           (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN2) // +15V,-4.33V 24Watts
#define DQ_911_P5_N15_24W           (DQ_91X_CFG_DCEN2+DQ_91X_CFG_DCEN3) // +4.33V,-15V 24Watts

// PC-911 voltages  FOR PCB REVISION 200
#define DQ_911_P15_20W              (DQ_91X_CFG_DCEN1)                  // + 15V 20Watts
#define DQ_911_P15_N15_40W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN2+DQ_91X_CFG_DCEN3) // +-15V 40Watts
#define DQ_911_N15_20W              (DQ_91X_CFG_DCEN3)                  //  -15V 20Watts


#define DQ_912_P12_20W              (DQ_91X_CFG_DCEN1)                  // +11.66V 20Watts   PC-912
#define DQ_912_P24_40W              (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN3) // +24V 40Watts

#define DQ_913_P15_N15_12W          (DQ_91X_CFG_DCEN2)                  // +-14.33V 12Watts  PC-913
#define DQ_913_P30_N30_24W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN3) // +-29.66V 24Watts
#define DQ_913_P45_N45_36W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN2+DQ_91X_CFG_DCEN3) // +-45V 36Watts
#define DQ_913_P45_N15_24W          (DQ_91X_CFG_DCEN1+DQ_91X_CFG_DCEN2) // +45V,-14.33V 24Watts
#define DQ_913_P15_N45_24W          (DQ_91X_CFG_DCEN2+DQ_91X_CFG_DCEN3) // +14.33V,-45V 24Watts

// defines for user control of PC-91x input power source using src parameter of DqAdv91xSetConfig()
#define DQ_91X_INTERNAL_POWER       (0)
#define DQ_91X_EXT_JIO_POWER        (DQ_PC_91X_CFG_EJIO)
#define DQ_91X_EXT_JIO_AUTOSWITCH   (DQ_PC_91X_CFG_EJIO+DQ_PC_91X_CFG_AUTO)

#define DQ_L91x_NAMELEN             (32)  // maximum length of the channel name (trailing 0 isn't included)

// channel names
typedef struct {
    char cnames[DQ_PC_91x_OCHAN][DQ_L91x_NAMELEN];
} DQCNAMES_91x_, *pDQCNAMES_91x_;
typedef struct {
    char cnames[10][DQ_L91x_NAMELEN];
} DQCNAMES_470_, *pDQCNAMES_470_;

/* specific device structure - calibration values */
typedef struct {
    uint16 gain[DQ_PC_91x_ICHAN];   // gain calibration for ADC channels
    int16 offs[DQ_PC_91x_ICHAN];    // offset calibration for ADC channels
    int16 iscaler_int;              // internal current scaler x100
    int16 iscaler_ext;              // external current scaler x100
    int16 tslope;                   // temperature slope x100
    double fiscaler_int;            // for use by daqlib only
    double fiscaler_ext;            // for use by daqlib only
    double ftslope;                 // for use by daqlib only
} DQCALSET_91x_, *pDQCALSET_91x_;


typedef struct {
    uint32 val;                     // DC/DC states (cfg register) in init mode
} DQINITPRM_91x_, *pDQINITPRM_91x_;

typedef struct {                    // DC/DC states (cfg register) in config and ops mode
     uint32 val;
} DQOPMODEPRM_91x_, *pDQOPMODEPRM_91x_;

typedef struct {
    uint32 val;                     // DC/DC states (cfg register) in shutdown mode
} DQSDOWNPRM_91x_, *pDQSDOWNPRM_91x_;

typedef struct {
    uint32  flag_ver;
} DQPRMFLAGS_91x_, *pDQPRMFLAGS_91x_;


#define DQ_LAYER_CHAN      4
#define DQ_LAYER_CALDACS   4
#define DQ_LAYER_NAMELEN   20  // maximum length of the channel name (trailing 0 isn't included)

/* channel names */
typedef struct {
    char cname[DQ_LAYER_CHAN][DQ_LAYER_NAMELEN];
} DQCNAMES_LAYER_, *pDQCNAMES_LAYER_;

/* specific device structure - calibration values */
typedef struct {
    uint8 cal[DQ_LAYER_CALDACS];     /* four calibration DAQs */
} DQCALSET_LAYER_, *pDQCALSET_LAYER_;

/* channel list for this device operation mode is stored here */
/* only this device driver knows about this data - nobody else should */
typedef struct {
    uint32 chlst[DQ_LAYER_CHAN*2]; // channel list - full
    int clperint;   // number of channel lists per interrupt; ignored if <1 or invalid
} DQOPMODEPRM_LAYER_, *pDQOPMODEPRM_LAYER_;


//
#define EVTMOD_CFG         0x00  // R/W    Event configuration register
#define EVTMOD_EMP0        0x04  // W    Event mode parameters register 0
                                 // R    Software reset for period counter
#define EVTMOD_EMP1        0x08  // W    Event mode parameters register 1
                                 // R    Software event source
#define EVTMOD_DLY0        0x0C  // W    Subevent 0 time delay register
#define EVTMOD_DLY1        0x10  // W    Subevent 1 time delay register
#define EVTMOD_STS         0x14  // R    Event status register
#define EVTMOD_SDNADC      0x18  // R    DNA data/timestamp capture register
#define EVTMOD_SDNAAC      0x1C  // R    DNA address capture register


//    #define EVTMOD0_BASE    =    16'h2140,    // Base address for the event 0
//    #define EVTMOD1_BASE    =    16'h2180,    // Base address for the event 1
//    #define EVTMOD2_BASE    =    16'h21A0,    // Base address for the event 2
//    #define EVTMOD3_BASE    =    16'h21C0,    // Base address for the event 3
//    #define EVTMODD_BASE    =    16'h21E0,    // Base address for the event detector
// CT-650 uses event generation module that is shared with CPU layers, see EVT_xx registers
// Events 0-3 are general purpose events that can cause interrupts or drive output
// I/O lines. Event "D" is event detector that is used to detect when timestamp should be
// latched and saved to the output channel list.


// EVT_CFG        =    16'h00,        // R/W    Event configuration register
// Select source for the event, year/day/hour/minute/seconds/microseconds inclusion/
// exclusion, clock source, event pulse length, one-shot/repeat mode and other
// settings
#define EVTMOD_CFG_EN          (1L<<31)   // Enable event. Once enabled event can be triggered
                                             // by the event source; if STE bit is set event should be
                                             // pre-armed by the global start trigger; note that stop
                                             // trigger that follows start trigger can disarm event
                                             // if EVT_CFG_SPTE bit is set
                                             // Single (RPT=0) event will auto-clear this bit upon
                                             // finishing generating event pulse(es)
#define EVTMOD_CFG_RSV30       (1L<<30)   // Reserved
#define EVTMOD_CFG_RSV29       (1L<<29)   // Reserved
#define EVTMOD_CFG_SPTE        (1L<<28)   // Use global (layer) stop trigger to "disarm" event
#define EVTMOD_CFG_EV1IRQ      (1L<<27)   // Generate IRQ based on sub-event 1
#define EVTMOD_CFG_EV0IRQ      (1L<<26)   // Generate IRQ based on sub-event 0
#define EVTMOD_CFG_DBL         (1L<<25)   // Number of sub-events) 0-single) 1-dual
#define EVTMOD_CFG_RPT         (1L<<24)   // Set repeat mode (0-one-time) 1-retriggerable)
//#define EVTMOD_CFG_EVTPLE      (1L<<23)   // Specify event pulse length (set to 0 or 1 for events
//#define EVTMOD_CFG_EVTPLS      (1L<<20)   // that generate interrupts and nothing else)
//#define EVTMOD_CFG_ISRCE       (1L<<19)   // Specify clock source for the event period counter
//#define EVTMOD_CFG_ISRCS       (1L<<18)   // 00-layer's 66/100MHz) 10-1MHz) 11-1KHz
#define EVTMOD_CFG_STTE        (1L<<17)   // Use global (layer) start trigger to "arm" event
//#define EVTMOD_CFG_IRSRCE      (1L<<16)   // Reset source for the internal event period counter
//#define EVTMOD_CFG_IRSRCS      (1L<<12)   // same codes as for ESRCx field
#define EVTMOD_CFG_YM          (1L<<11)   // For date/time events - enable year compare
#define EVTMOD_CFG_DM          (1L<<10)   // For date/time events - enable day compare
#define EVTMOD_CFG_HM          (1L<<9)    // For date/time events - enable hour compare
                                             // Note - bit 8 may be used differently depending on the event source
#define EVTMOD_CFG_MM          (1L<<8)    // For date/time events - enable minute compare
#define EVTMOD_CFG_ISRCM       (1L<<8)    // For internal counter event - modifier for ISRCE:ISRCS
#define EVTMOD_CFG_SM          (1L<<7)    // For date/time events - enable second compare
#define EVTMOD_CFG_UM          (1L<<6)    // For date/time events - enable microsecond compare
#define EVTMOD_CFG_EDGE        (1L<<5)    // Specify active edge of the event source (8-31)
//#define EVTMOD_CFG_ESRCE       (1L<<4)    // Event source (specify type of the event)
//#define EVTMOD_CFG_ESRCS       (1L<<0)    // events 8-31 are edge-triggered


    // Clock source for the internal counter, used in EVT_CFG_ESRC_IPC mode
    // values for EVT_CFG_ISRCE:EVT_CFG_ISRCS When EVT_CFG_ISRCM = 0
//#define EVTMOD_CFG_ISRC_1KHZ      2'b11,  // 1KHz always derived from layer's local clock
//#define EVTMOD_CFG_ISRC_1MHZ      2'b10,  // 1MHz always derived from layer's local clock
//#define EVTMOD_CFG_ISRC_100I      2'b00,  // Layer locally generated 100MHz clock, on the layers
                                    // where local clock is not present - same as DNA bus 66MHz

    // values for EVT_CFG_ISRCE:EVT_CFG_ISRCS When EVT_CFG_ISRCM = 1
//#define EVTMOD_CFG_ISRC_CLKIN     2'b10   // "clkin" pin (CT-602 only)
//#define EVTMOD_CFG_ISRC_1MHZE     2'b10   // 1MHz from time keeper (IRIG-650 only)
//#define EVTMOD_CFG_ISRC_PLL       2'b00   // PLL post-divider output (IRIG-650), PLL output (CT-602)

// Event pulse length is measured in layer local clocks and for the codes
// 0-13 corresponds to 1-14 clocks, with two special cases listed below (1uS and 1mS)
#define EVTMOD_CFG_EVTPL_1MS    (15<<20)      // Use 1mS event pulse length
#define EVTMOD_CFG_EVTPL_1US    (14<<20)      // Reserved for 1uS event pulse length
#define EVTMOD_CFG_EVTPL(N)     (((N)&0xf)<<20) // Reserved for 2^{2..13}*10nsec event pulse length
#define EVTMOD_CFG_ISRC(N)      (((N)&0x3)<<18)
#define EVTMOD_CFG_IRSRC(N)     (((N)&0x1f)<<12)
#define EVTMOD_CFG_ESRC(N)      (((N)&0x1f)<<0)

// Clock source for the internal counter, used in #define EVTMOD_CFG_ESRC_IPC mode
#define EVTMOD_CFG_ISRC_1KHZ    (3<<18)    // 1KHz always derived from layer's local clock
#define EVTMOD_CFG_ISRC_1MHZ    (2<<18)    // 1MHz always derived from layer's local clock
#define EVTMOD_CFG_ISRC_100I    (0<<18)    // Layer locally generated 100MHz clock, on the layers
                                              // where local clock is not present - same as DNA bus 66MHz

// Event sources and internal counter reset sources
#define EVTMOD_CFG_ESRC_DEVT23  (31<<0)    // Digital event source 23
//..
#define EVTMOD_CFG_ESRC_DEVT0   (8<<0)   // Digital event source 0
#define EVTMOD_CFG_ESRC_RES7    (7<<0)   // Reserved
#define EVTMOD_CFG_ESRC_DPLL    (6<<0)   // DPLL - Digital PLL
#define EVTMOD_CFG_ESRC_DNAB    (5<<0)   // DNA bus condition
#define EVTMOD_CFG_ESRC_IPC     (4<<0)   // Internal period counter
#define EVTMOD_CFG_ESRC_SBT     (3<<0)   // BCD time mode, event condition is
                                            // "Straight Binary Input time" >= "SB set time"
                                            // BCD time mode allows creation of the events
                                            // that will repeat every month, day, minute or
                                            // second - by masking unused parameters in CFG0
                                            // register
#define EVTMOD_CFG_ESRC_BCDT    (2<<0)   // BCD time mode, event condition is
                                            // "BCD Input time" >= "BCD set time"
                                            // NOTE:
                                            // #define EVTMOD_CFG_ESRC_DNAB,  #define EVTMOD_CFG_ESRC_IPC
                                            // #define EVTMOD_CFG_ESRC_SBT and #define EVTMOD_CFG_ESRC_BCDT
                                            // are mutually exclusive in ESRC/IRSRC fields
#define EVTMOD_CFG_ESRC_SWF     (1<<0)   // Software only, note that event sources
                                            // 2-31 are ORed with software.
                                            // For the ESRC field software clock is read
                                            // from EVT_EMP1 register.
                                            // For the IRSRC field software clock is read
                                            // from EVT_EMP0 register.
#define EVTMOD_CFG_ESRC_DIS    (0<<0)    // No active source - event is in disabled state

// Internal counter reset sources
#define EVTMOD_CFG_ICRS_DEVT23  (31<<12)  // Digital event source 23
//..
#define EVTMOD_CFG_ICRS_DEVT0   (8<<12)   // Digital event source 0
#define EVTMOD_CFG_ICRS_RES7    (7<<12)   // Reserved
#define EVTMOD_CFG_ICRS_RES6    (6<<12)   // Reserved
#define EVTMOD_CFG_ICRS_DNAB    (5<<12)   // DNA bus condition
#define EVTMOD_CFG_ICRS_IPC     (4<<12)   // Internal period counter
#define EVTMOD_CFG_ICRS_SBT     (3<<12)   // BCD time mode, event condition is
                                             // "Straight Binary Input time" >= "SB set time"
                                             // BCD time mode allows creation of the events
                                             // that will repeat every month, day, minute or
                                             // second - by masking unused parameters in CFG0
                                             // register
#define EVTMOD_CFG_ICRS_BCDT    (2<<12)   // BCD time mode, event condition is
                                             // "BCD Input time" >= "BCD set time"
                                             // NOTE:
                                             // #define EVTMOD_CFG_ICRS_DNAB,  #define EVTMOD_CFG_ICRS_IPC
                                             // #define EVTMOD_CFG_ICRS_SBT and #define EVTMOD_CFG_ICRS_BCDT
                                             // are mutually exclusive in ESRC/IRSRC fields
#define EVTMOD_CFG_ICRS_SWF     (1<<12)   // Software only, note that event sources
                                             // 2-31 are ORed with software.
                                             // For the ESRC field software clock is read
                                             // from EVT_EMP1 register.
                                             // For the IRSRC field software clock is read
                                             // from EVT_EMP0 register.
#define EVTMOD_CFG_ICRS_DIS    (0<<12)    // No active source - event is in disabled state


//    EVT_EMP0    =    16'h04,        // W    Event mode parameters register 0
//                                // R    Software reset for period counter
// This register is used to set one of the following:
// - when ESRC=EVT_CFG_ESRC_DNAB - DNA bus address and additional trigger parameters
// - when ESRC=EVT_CFG_ESRC_IPC - event period counter (divider that selects event period)
// - when ESRC=EVT_CFG_ESRC_SBT - straight binary seconds and years
// - when ESRC=EVT_CFG_ESRC_BCDT - BCD seconds, minutes, hours and day of the year
// - when ESRC=EVTMOD_CFG_ESRC_DPLL - number of pulses to generate on the DPLL and the resync adjustment limit
//#define EVTMOD_EMP0_LSAE        =    31,        // Layer select address portion(dna_addr[19:16]) when
#define EVTMOD_EMP0_LSAS(N)     (((N)&0xf)<<28)   // monitored address/data combination
#define EVTMOD_EMP0_DRD         (1L<<27)          // =1 - monitor /rd (reads) on the DNA bus
#define EVTMOD_EMP0_DWR         (1L<<26)          // =1 - monitor /wr (writes) on the DNA bus
//#define EVTMOD_EMP0_DCSE        =    25,        // DNA chip select line (0-3) that should be associated
#define EVTMOD_EMP0_DCSS(N)     (((N)&3)<<24)     // with monitored address/data combination
//#define EVTMOD_EMP0_DDLYE        =    23,       // Number of clocks after /rd or /wr strobe start to
#define EVTMOD_EMP0_DDLYS(N)    (((N)&0xf)<<20)   // comparing address and data (0-15)
//#define EVTMOD_EMP0_DNAAVE        =    19,      // Number of valid MSBs in the DNAA field. 1-14 - select#
#define EVTMOD_EMP0_DNAAVS(N)   (((N)&0xf)<<16)   // of bits, 0 - ignore DNA address and compare data only
//#define EVTMOD_EMP0_DNAAE        =    15,       // bits [15:2] of the DNA bus address that covers address
#define EVTMOD_EMP0_DNAAS(N)    (((N)&0x3fff)<<2) // space of every individual layer
#define EVTMOD_EMP0_DLAC        (1L<<1)           // Use layer address portion (dna_addr[19:16]) when
                                                     // comparing DNA/DNR address, available only on the
                                                     // DNA versions of the layers with event capability except
                                                     // for the CPU where it is always available
#define EVTMOD_EMP0_DDC         (1L<<0)           // 1-compare DNA data. If DNA data is compare feature is
                                                     // used, data should be pre-loaded into #define EVTMOD_EMP1 and layer
                                                     // timestamp of the event will be stored in #define EVTMOD_SDNADC

//#define EVTMOD_EMP0_SBSE         28,        // Straight binary seconds of the day (0x0h to 0x15180h)
#define EVTMOD_EMP0_SBSS(N)     (((N)&0x1ffff)<<12)     //
//#define EVTMOD_EMP0_SBYE         11,        // Straight binary year
#define EVTMOD_EMP0_SBYS(N)     (((N)&0xfff)<<0)     //
//
//#define EVTMOD_EMP0_SECE         27,        // BCD seconds of the day
#define EVTMOD_EMP0_SECS(N)     (((N)&0x3f)<<22)
//#define EVTMOD_EMP0_MINE         21,        // BCD minute of the hour
#define EVTMOD_EMP0_MINS(N)     (((N)&0x3f)<<16)     //
//#define EVTMOD_EMP0_HRE         15,         // BCD hour of the day
#define EVTMOD_EMP0_HRS(N)      (((N)&0x3f)<<10)     //
//#define EVTMOD_EMP0_DOYE         9,         // BCD day of the year
#define EVTMOD_EMP0_DOYS(N)     (((N)&0x3ff)<<0)     //
//
//#define EVTMOD_EMP0_ICNTDIVE    =    31,        // 32-bit counter, reset source is selected in
#define EVTMOD_EMP0_ICNTDIVS(N)  (N)        // #define EVTMOD_CFG_IRSRC, clock source - in #define EVTMOD_CFG_ISRC

//
#define EVTMOD_EMP0_NPULSES(N)   ((N)&0x3FFFFF)     // number of pulses to produce in EVTMOD_CFG_ESRC_DPLL
#define EMTMOD_EMP0_ADJ_MAX      (0x3ff)
#define EVTMOD_EMP0_ADJ(N)       (((N)&0x3ff)<<22) // (DPLL_ADJ) adjust factor to keep the clocks synchronized to the DPLL
#define EVTMOD_EMP0_TICKS_TO_OFFS(N) ((((N) & 0x3FFFFFFF) - 5) >> 2)

//    #define EVTMOD_EMP1    =    16'h08,        // W    Event mode parameters register 1; R    Software event source
// This register is used to set one of the following:
// - when ESRC=#define EVTMOD_CFG_ESRC_DNAB - DNA bus data
// - when ESRC=#define EVTMOD_CFG_ESRC_SBT - straight binary day of the year (and SB microseconds)
// - when ESRC=#define EVTMOD_CFG_ESRC_BCDT - microseconds
//#define EVTMOD_EMP1_SBDE        =    30,       // Straight binary day of the year
#define EVTMOD_EMP1_SBDS(N)  (((N)&0x3ff)<<20)   //
//#define EVTMOD_EMP1_USE        =    19,        // Number of microseconds for the SB and BCD time mode
#define EVTMOD_EMP1_USS(N)   (((N)&0xfffff)<<0)    //  (uS are always binary, 0-999999) that used in event generation
//
//#define EVTMOD_EMP1_DNADE        =    31,        // 32-bit DNA data to compare with actual data on the
#define EVTMOD_EMP1_DNADS(N)      (N)              // DNA bus (used only if #define EVTMOD_EMP0_DDC=1)

//    #define EVTMOD_DLY0    =    16'h0C,        // W    Subevent 0 time delay register
//    #define EVTMOD_DLY1    =    16'h10,        // W    Subevent 1 time delay register
// Event source selected in the CFG_ESRC acts as a trigger that initiates DLY0/DLY1 counters,
// these counters provide programmable delay prior to the generating output pulse and/or
// interrupt. This behavior may be used to create sequence of events that are triggered by the
// same source but should be separated in time by the pre-defined intervals. Two sub-events are
// provided thus allowing more flexible handling of the timing. Putting 0 into these registers
// will result in the event pulse/interrupt delayed by 4-5 clocks from the time of the event
// source
//#define EVTMOD_DLY_EVTDLE        =    31,        // Event delay
#define EVTMOD_DLY_EVTDLS(N)      (N)        //

#define EVTMOD_EMP1_DIV(N)        ((N)<<3)  // 8 bit per divider

#define EVTMOD_DLY0_EVTMERR_MAX   (0xFF)    // In DPLL mode: DLY0 bits 0,7 set maximum allowable output error in pulses.
                                            // Logics 14.B0 or later.

//    #define EVTMOD_STS        =    16'h14,        // R    Event status register
// Event status register provide information about current condition of the event module
// including number of processed events
#define EVTMOD_STS_SEARM        (1L<<31)  // =1-if event is armed by the start trigger
#define EVTMOD_STS_SEVT1        (1L<<30)  // =1-if subevent 1 counter is active
#define EVTMOD_STS_SEVT0        (1L<<29)  // =1-if subevent 0 counter is active
#define EVTMOD_STS_DPLLS        (1L<<28)  // =1- if DPLL generated the correct number of clocks
#define EVTMOD_STS_RSV27        (1L<<27)  // Reserved
#define EVTMOD_STS_RSV26        (1L<<26)  // Reserved
#define EVTMOD_STS_SEVT1D       (1L<<25)  // =1-if subevent 1 was issued
                                             // (auto-cleared after read)
#define EVTMOD_STS_SEVT0D       (1L<<24)  // =1-if subevent 0 was issued
                                             // (auto-cleared after read)
//#define EVTMOD_STS_ECTE         (1L<<23)  // Event counter. Counter is incremented when
#define EVTMOD_STS_ECTS         (1L<<0)   // event start condition is detected and cleared when event is disabled

#define EVTMOD_STS_ECT(N)     ((N)&(0x00ffffff))

//    #define EVTMOD_SDNADC    =    16'h18,        // R    DNA data/timestamp capture register
// Data of the DNA transaction that does not require data compare (#define EVTMOD_EMP1_DNADE=0)
// will be stored in this register. If data compare is enabled (#define EVTMOD_EMP1_DNADE=1) this
// register will contain timestamp of the DNA transaction that triggered #define EVTMOD_CFG_ESRC_DNAB
// event. For all other event sources this register is unused
//#define EVTMOD_SDNADC_DE        =    31,        // 32-bit DNA data or layer timestamp
#define EVTMOD_SDNADC_DS(N)       (N)        //

//    #define EVTMOD_SDNAAC    =    16'h1C,        // R    DNA address capture register
// Address of the DNA transaction that triggered triggered #define EVTMOD_CFG_ESRC_DNAB
// event. For all other event sources this register is unused
//#define EVTMOD_SDNAAC_LACE        =    19,        // DNA layer address capture
#define EVTMOD_SDNAAC_LACS(N)      (((N)>>16)&0xf)  // read
//#define EVTMOD_SDNAAC_ACE        =    15,         // DNA address capture
#define EVTMOD_SDNAAC_ACS(N)       (((N)>>2)&0x3fff)  // read


#pragma pack()

#endif

